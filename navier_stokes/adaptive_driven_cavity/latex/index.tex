In a \href{../../driven_cavity/html/index.html}{\tt previous example} we demonstrated the solution of the 2D driven cavity problem using {\ttfamily oomph-\/lib\textquotesingle{}s} 2D Taylor-\/\+Hood and Crouzeix-\/\+Raviart Navier-\/\+Stokes elements on a uniform mesh. The computed solution was clearly under-\/resolved near the corners of the domain where the discontinuity in the velocity boundary conditions creates pressure singularities.

In this example we shall re-\/solve the driven cavity problem with the refineable versions of {\ttfamily oomph-\/lib\textquotesingle{}s} quadrilateral Navier-\/\+Stokes elements -- the {\ttfamily Refineable\+Q\+Taylor\+Hood\+Element$<$2$>$} and the {\ttfamily Refineable\+Q\+Crouzeix\+Raviart\+Element$<$2$>$}. Enabling spatial adaptivity for this problem involves the same straightforward steps as for a scalar problem\+:
\begin{DoxyItemize}
\item The domain must be discretised with a refineable mesh, i.\+e. a mesh that is derived from the {\ttfamily Refineable\+Mesh} class.
\item An {\ttfamily Error\+Estimator} object must be specified.
\end{DoxyItemize}Two additional steps tend to be required during the adaptive solution of Navier-\/\+Stokes problems\+:
\begin{DoxyItemize}
\item Recall that in Navier-\/\+Stokes problems in which the velocity is prescribed along the entire domain boundary, the pressure is only determined up an arbitrary constant, making it necessary to \char`\"{}pin\char`\"{} one pressure value. If the \char`\"{}pinned\char`\"{} pressure degree of freedom is associated with an element that is unrefined during the mesh adaptation, the \char`\"{}pinned \char`\"{} degree of freedom may no longer exist in the adapted problem. To ensure that exactly one pressure degree of freedom is pinned when re-\/solving the adapted problem, we recommend using the function {\ttfamily Problem\+::actions\+\_\+after\+\_\+adapt()} to
\begin{DoxyEnumerate}
\item unpin all pressure values, e.\+g. using the function 
\begin{DoxyCode}
NavierStokesEquations<DIM>::unpin\_all\_pressure\_dofs(...)
\end{DoxyCode}

\item pin a pressure degree of freedom that is known to exist (e.\+g. the first pressure degree of freedom in the first element of the mesh -- whichever element this may be), e.\+g. using the function 
\begin{DoxyCode}
NavierStokesEquations<DIM>::fix\_pressure(...)
\end{DoxyCode}

\end{DoxyEnumerate}
\item The possible presence of hanging nodes in an adapted mesh requires special treatment for elements (e.\+g. Taylor-\/\+Hood elements) in which the pressure is represented by a low-\/order interpolation between a subset of the element\textquotesingle{}s nodal values. The required tasks are performed by the function 
\begin{DoxyCode}
NavierStokesEquations<DIM>::pin\_redundant\_nodal\_pressures(...)
\end{DoxyCode}
 which should be called
\begin{DoxyEnumerate}
\item before assigning the equation numbers for the first time, and
\item after every mesh adaptation.
\end{DoxyEnumerate}\mbox{[}If the user \char`\"{}forgets\char`\"{} to call this function, a warning is issued if the library is compiled with the P\+A\+R\+A\+N\+O\+ID flag.\mbox{]}
\end{DoxyItemize}The driver code discussed below illustrates the use of these functions. The section \hyperlink{index_comments}{Comments and Exercises} provides a more detailed discussion of the technical details involved in their implementation.



 

\hypertarget{index_example}{}\section{The example problem}\label{index_example}
We shall illustrate the spatially adaptive solution of the steady 2D Navier-\/\+Stokes equations by re-\/considering the 2D steady driven cavity problem\+:

\begin{center} \tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*{1}{|X[-1]}|}
\hline
\begin{center} {\bfseries The 2D steady driven cavity problem in a square domain.} \end{center}  Solve \[ Re\phantom{i}u_j\frac{\partial u_i}{\partial x_j} = - \frac{\partial p}{\partial x_i} + \frac{\partial }{\partial x_j} \left( \frac{\partial u_i}{\partial x_j} + \frac{\partial u_j}{\partial x_i} \right), \ \ \ \ \ \ \ \ \ \ (1) \] and \[ \frac{\partial u_i}{\partial x_i} = 0, \] in the square domain $ D = \left\{x_i \in [0,1]; i=1,2 \right\} $, subject to the Dirichlet boundary conditions \[ \left. \mathbf{u}\right|_{\partial D}=(0,0), \ \ \ \ \ \ \ \ \ \ (2) \] on right, top and left boundaries and \[ \left. \mathbf{u}\right|_{\partial D}=(1,0), \ \ \ \ \ \ \ \ \ \ (3) \] on the bottom boundary, $ x_2 = 0 $ .   \\\cline{1-1}
\end{longtabu}
\end{center} 



\hypertarget{index_CR}{}\subsection{Solution with Crouzeix-\/\+Raviart elements}\label{index_CR}
The figure below shows \char`\"{}carpet plots\char`\"{} of the velocity and pressure fields as well as a contour plot of the pressure distribution with superimposed streamlines for a Reynolds number of $ Re=100$. The velocity vanishes along the entire domain boundary, apart from the bottom boundary $ (x_2 = 0) $ where the moving \char`\"{}lid\char`\"{} imposes a unit tangential velocity which drives a large vortex, centred at $ (x_1,x_2) \approx (0.62,0.26)$. The pressure singularities created by the velocity discontinuities at $ (x_1,x_2)=(0,0) $ and $ (x_1,x_2)=(1,0) $ are now much better resolved.

 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{adaptive_driven_cavity_CR}
\doxyfigcaption{Plot of the velocity and pressure fields computed with adaptive Crouzeix-\/\+Raviart elements for Re=100. }
\end{DoxyImage}




\hypertarget{index_TH}{}\subsection{Solution with Taylor-\/\+Hood elements}\label{index_TH}
The next figure shows the corresponding results obtained from a computation with adaptive Taylor-\/\+Hood elements.

 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{adaptive_driven_cavity_TH}
\doxyfigcaption{Plot of the velocity and pressure fields computed with adaptive Taylor-\/\+Hood elements for Re=100. }
\end{DoxyImage}




 

\hypertarget{index_namespace}{}\section{Global parameters and functions}\label{index_namespace}
The global namespace used to define the problem parameters is identical to the one in the \href{../../driven_cavity/html/index.html#namespace}{\tt non-\/adaptive version}.

 
\begin{DoxyCodeInclude}
\textcolor{comment}{//==start\_of\_namespace===================================================}
\textcolor{comment}{/// Namespace for physical parameters}
\textcolor{comment}{}\textcolor{comment}{//=======================================================================}
\textcolor{keyword}{namespace }\hyperlink{namespaceGlobal__Physical__Variables}{Global\_Physical\_Variables}
\{\textcolor{comment}{}
\textcolor{comment}{ /// Reynolds number}
\textcolor{comment}{} \textcolor{keywordtype}{double} \hyperlink{namespaceGlobal__Physical__Variables_ab814e627d2eb5bc50318879d19ab16b9}{Re}=100;
\} \textcolor{comment}{// end\_of\_namespace}

\end{DoxyCodeInclude}




 

\hypertarget{index_main}{}\section{The driver code}\label{index_main}
The main driver code is virtually identical to that in the \href{../../driven_cavity/html/index.html#main}{\tt non-\/adaptive version}. We specify the appropriate refineable element types and use the black-\/box adaptive Newton solver, allowing for up to three levels of spatial adaptivity.


\begin{DoxyCodeInclude}
\textcolor{comment}{//==start\_of\_main======================================================}
\textcolor{comment}{/// Driver for RefineableDrivenCavity test problem }
\textcolor{comment}{}\textcolor{comment}{//=====================================================================}
\textcolor{keywordtype}{int} \hyperlink{adaptive__driven__cavity_8cc_ae66f6b31b5ad750f1fe042a706a4e3d4}{main}()
\{

 \textcolor{comment}{// Set output directory}
 DocInfo doc\_info;
 doc\_info.set\_directory(\textcolor{stringliteral}{"RESLT"});


 \textcolor{comment}{// Set max. number of black-box adaptation}
 \textcolor{keywordtype}{unsigned} max\_adapt=3;

 \textcolor{comment}{// Solve problem with Taylor Hood elements}
 \textcolor{comment}{//---------------------------------------}
 \{
  \textcolor{comment}{//Build problem}
  \hyperlink{classRefineableDrivenCavityProblem}{RefineableDrivenCavityProblem<RefineableQTaylorHoodElement<2>}
       > problem;
  
  \textcolor{comment}{// Solve the problem with automatic adaptation}
  problem.newton\_solve(max\_adapt);
  
  \textcolor{comment}{// Step number}
  doc\_info.number()=0;
   
  \textcolor{comment}{//Output solution}
  problem.\hyperlink{classRefineableDrivenCavityProblem_a0baa1e8f1d1f6f73ef921b06a9b20836}{doc\_solution}(doc\_info);
 \} \textcolor{comment}{// end of Taylor Hood elements}
 

 \textcolor{comment}{// Solve problem with Crouzeix Raviart elements}
 \textcolor{comment}{//--------------------------------------------}
 \{
  \textcolor{comment}{// Build problem}
  \hyperlink{classRefineableDrivenCavityProblem}{RefineableDrivenCavityProblem<RefineableQCrouzeixRaviartElement<2>}
       > problem;
  
  \textcolor{comment}{// Solve the problem with automatic adaptation}
  problem.newton\_solve(max\_adapt);
  
  \textcolor{comment}{// Step number}
  doc\_info.number()=1;

  \textcolor{comment}{//Output solution}
  problem.\hyperlink{classRefineableDrivenCavityProblem_a0baa1e8f1d1f6f73ef921b06a9b20836}{doc\_solution}(doc\_info);
 \} \textcolor{comment}{// end of Crouzeix Raviart elements}


\} \textcolor{comment}{// end\_of\_main}

\end{DoxyCodeInclude}




 

\hypertarget{index_problem}{}\section{The problem class}\label{index_problem}
Most of the problem class is identical to that in the \href{../../driven_cavity/html/index.html#problem}{\tt non-\/adaptive version of the code }\+: We provide a constructor and destructor and use the function {\ttfamily Problem\+::actions\+\_\+before\+\_\+newton\+\_\+solve()} to (re-\/)assign the boundary conditions.

 
\begin{DoxyCodeInclude}
\textcolor{comment}{//==start\_of\_problem\_class============================================}
\textcolor{comment}{/// Driven cavity problem in rectangular domain, templated}
\textcolor{comment}{}\textcolor{comment}{/// by element type. }
\textcolor{comment}{}\textcolor{comment}{//====================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT>
\textcolor{keyword}{class }\hyperlink{classRefineableDrivenCavityProblem}{RefineableDrivenCavityProblem} : \textcolor{keyword}{public} Problem
\{

\textcolor{keyword}{public}:
\textcolor{comment}{}
\textcolor{comment}{ /// Constructor}
\textcolor{comment}{} \hyperlink{classRefineableDrivenCavityProblem_aef71ddbff081a1f9c7f5484a6c80598a}{RefineableDrivenCavityProblem}();
\textcolor{comment}{}
\textcolor{comment}{ /// Destructor: Empty}
\textcolor{comment}{} \hyperlink{classRefineableDrivenCavityProblem_a7d90594e973d54ee79a11fff828e124b}{~RefineableDrivenCavityProblem}() \{\}
\textcolor{comment}{}
\textcolor{comment}{ /// Update the after solve (empty)}
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{classRefineableDrivenCavityProblem_a168df1ad7b08cf8b760b6d56e9920479}{actions\_after\_newton\_solve}() \{\}
\textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Update the problem specs before solve. }
\textcolor{comment}{ /// (Re-)set velocity boundary conditions just to be on the safe side...}
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{classRefineableDrivenCavityProblem_af83cad4653c7ac633538ebf46657659a}{actions\_before\_newton\_solve}()
  \{ 
  \textcolor{comment}{// Setup tangential flow along boundary 0:}
  \textcolor{keywordtype}{unsigned} ibound=0; 
  \textcolor{keywordtype}{unsigned} num\_nod= mesh\_pt()->nboundary\_node(ibound);
  \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} inod=0;inod<num\_nod;inod++)
   \{
    \textcolor{comment}{// Tangential flow}
    \textcolor{keywordtype}{unsigned} i=0;
    mesh\_pt()->boundary\_node\_pt(ibound,inod)->set\_value(i,1.0);
    \textcolor{comment}{// No penetration}
    i=1;
    mesh\_pt()->boundary\_node\_pt(ibound,inod)->set\_value(i,0.0);
   \}
  
  \textcolor{comment}{// Overwrite with no flow along all other boundaries}
  \textcolor{keywordtype}{unsigned} num\_bound = mesh\_pt()->nboundary();
  \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} ibound=1;ibound<num\_bound;ibound++)
   \{
    \textcolor{keywordtype}{unsigned} num\_nod= mesh\_pt()->nboundary\_node(ibound);
    \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} inod=0;inod<num\_nod;inod++)
     \{
      \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} i=0;i<2;i++)
       \{
        mesh\_pt()->boundary\_node\_pt(ibound,inod)->set\_value(i,0.0);
       \}
     \}
   \}
  \} \textcolor{comment}{// end\_of\_actions\_before\_newton\_solve}

\end{DoxyCodeInclude}


As discussed in the introduction, we use the function {\ttfamily Problem\+::actions\+\_\+after\+\_\+adapt()} to ensure that, regardless of the mesh adaptation pattern, exactly one pressure degree of freedom is pinned. We start by unpinning all pressure degrees of freedom\+:


\begin{DoxyCodeInclude}
 \textcolor{comment}{/// After adaptation: Unpin pressure and pin redudant pressure dofs.}
 \textcolor{keywordtype}{void} actions\_after\_adapt()
  \{
   \textcolor{comment}{// Unpin all pressure dofs}
   RefineableNavierStokesEquations<2>::
    unpin\_all\_pressure\_dofs(mesh\_pt()->element\_pt());

\end{DoxyCodeInclude}


\mbox{[}Note that this function (implemented as a static member function of the {\ttfamily Navier\+Stokes\+Equations$<$\+D\+I\+M$>$} class) unpins the pressure degrees of freedom in all elements that are specified by the input argument (a vector of pointers to the these elements). This implementation allows certain elements in a mesh to be excluded from the procedure; this is required in problems where a mesh contains multiple element types. In the present problem, the mesh contains only Navier-\/\+Stokes elements, so we pass a vector of pointers to all elements in the mesh (returned by the function {\ttfamily Mesh\+::element\+\_\+pt()}\mbox{]} to the function.\mbox{]}

Following the mesh adaptation any redundant nodal pressures must be pinned, so that hanging pressure degrees of freedom are treated correctly. We note that calling this function is essential for Taylor-\/\+Hood elements. The function may be executed without any adverse effect for all other Navier-\/\+Stokes elements; see \hyperlink{index_comments}{Comments and Exercises} for more details on the implementation.


\begin{DoxyCodeInclude}
    
    \textcolor{comment}{// Pin redundant pressure dofs}
   RefineableNavierStokesEquations<2>::
    pin\_redundant\_nodal\_pressures(mesh\_pt()->element\_pt());

\end{DoxyCodeInclude}


Finally, we pin a single pressure degree of freedom (the first pressure value in the first element in the mesh) and set its value to zero.


\begin{DoxyCodeInclude}
   
   \textcolor{comment}{// Now set the first pressure dof in the first element to 0.0}
   fix\_pressure(0,0,0.0);
  \} \textcolor{comment}{// end\_of\_actions\_after\_adapt}

\end{DoxyCodeInclude}


The remainder of the problem class remains as \href{../../driven_cavity/html/index.html#problem}{\tt before}.


\begin{DoxyCodeInclude}
 \textcolor{comment}{}
\textcolor{comment}{ /// Doc the solution}
\textcolor{comment}{} \textcolor{keywordtype}{void} doc\_solution(DocInfo& doc\_info);
 
 
\textcolor{keyword}{private}:
\textcolor{comment}{}
\textcolor{comment}{ ///Fix pressure in element e at pressure dof pdof and set to pvalue}
\textcolor{comment}{} \textcolor{keywordtype}{void} fix\_pressure(\textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} &e, \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} &pdof, 
                   \textcolor{keyword}{const} \textcolor{keywordtype}{double} &pvalue)
  \{
   \textcolor{comment}{//Cast to proper element and fix pressure}
   \textcolor{keyword}{dynamic\_cast<}ELEMENT*\textcolor{keyword}{>}(mesh\_pt()->element\_pt(e))->
                          fix\_pressure(pdof,pvalue);
  \} \textcolor{comment}{// end\_of\_fix\_pressure}

\}; \textcolor{comment}{// end\_of\_problem\_class}

\end{DoxyCodeInclude}




 

\hypertarget{index_constructor}{}\section{The problem constructor}\label{index_constructor}
The constructor remains largely as \href{../../driven_cavity/html/index.html#constructor}{\tt before}. We create an adaptive mesh, build and assign an error estimator and pin the redundant nodal pressure degrees of freedom.


\begin{DoxyCodeInclude}
\textcolor{comment}{//==start\_of\_constructor==================================================}
\textcolor{comment}{/// Constructor for RefineableDrivenCavity problem }
\textcolor{comment}{}\textcolor{comment}{///}
\textcolor{comment}{}\textcolor{comment}{//========================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT>
\hyperlink{classRefineableDrivenCavityProblem_aef71ddbff081a1f9c7f5484a6c80598a}{RefineableDrivenCavityProblem<ELEMENT>::RefineableDrivenCavityProblem}
      ()
\{ 

 \textcolor{comment}{// Setup mesh}

 \textcolor{comment}{// # of elements in x-direction}
 \textcolor{keywordtype}{unsigned} n\_x=10;

 \textcolor{comment}{// # of elements in y-direction}
 \textcolor{keywordtype}{unsigned} n\_y=10;

 \textcolor{comment}{// Domain length in x-direction}
 \textcolor{keywordtype}{double} l\_x=1.0;

 \textcolor{comment}{// Domain length in y-direction}
 \textcolor{keywordtype}{double} l\_y=1.0;

 \textcolor{comment}{// Build and assign mesh}
 Problem::mesh\_pt() = 
  \textcolor{keyword}{new} RefineableRectangularQuadMesh<ELEMENT>(n\_x,n\_y,l\_x,l\_y);

 \textcolor{comment}{// Set error estimator}
 Z2ErrorEstimator* error\_estimator\_pt=\textcolor{keyword}{new} Z2ErrorEstimator;
 \textcolor{keyword}{dynamic\_cast<}RefineableRectangularQuadMesh<ELEMENT>*\textcolor{keyword}{>}(mesh\_pt())->
  spatial\_error\_estimator\_pt()=error\_estimator\_pt;
 
 \textcolor{comment}{// Set the boundary conditions for this problem: All nodes are}
 \textcolor{comment}{// free by default -- just pin the ones that have Dirichlet conditions}
 \textcolor{comment}{// here: All boundaries are Dirichlet boundaries.}
 \textcolor{keywordtype}{unsigned} num\_bound = mesh\_pt()->nboundary();
 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} ibound=0;ibound<num\_bound;ibound++)
  \{
   \textcolor{keywordtype}{unsigned} num\_nod= mesh\_pt()->nboundary\_node(ibound);
   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} inod=0;inod<num\_nod;inod++)
    \{
     \textcolor{comment}{// Loop over values (u and v velocities)}
     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} i=0;i<2;i++)
      \{
       mesh\_pt()->boundary\_node\_pt(ibound,inod)->pin(i); 
      \}
    \}
  \} \textcolor{comment}{// end loop over boundaries}

 \textcolor{comment}{//Find number of elements in mesh}
 \textcolor{keywordtype}{unsigned} n\_element = mesh\_pt()->nelement();

 \textcolor{comment}{// Loop over the elements to set up element-specific }
 \textcolor{comment}{// things that cannot be handled by constructor: Pass pointer to Reynolds}
 \textcolor{comment}{// number}
 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} e=0;e<n\_element;e++)
  \{
   \textcolor{comment}{// Upcast from GeneralisedElement to the present element}
   ELEMENT* el\_pt = \textcolor{keyword}{dynamic\_cast<}ELEMENT*\textcolor{keyword}{>}(mesh\_pt()->element\_pt(e));
   \textcolor{comment}{//Set the Reynolds number, etc}
   el\_pt->re\_pt() = &\hyperlink{namespaceGlobal__Physical__Variables_ab814e627d2eb5bc50318879d19ab16b9}{Global\_Physical\_Variables::Re};
  \} \textcolor{comment}{// end loop over elements}
 
 \textcolor{comment}{// Pin redudant pressure dofs}
 RefineableNavierStokesEquations<2>::
  pin\_redundant\_nodal\_pressures(mesh\_pt()->element\_pt());
 
  \textcolor{comment}{// Now set the first pressure dof in the first element to 0.0}
 fix\_pressure(0,0,0.0);
 
 \textcolor{comment}{// Setup equation numbering scheme}
 cout <<\textcolor{stringliteral}{"Number of equations: "} << assign\_eqn\_numbers() << std::endl; 
 
\} \textcolor{comment}{// end\_of\_constructor}

\end{DoxyCodeInclude}




 

\hypertarget{index_doc}{}\section{Post-\/processing}\label{index_doc}
The post-\/processing function is identical to that in the \href{../../driven_cavity/html/index.html#doc}{\tt non-\/adaptive version of the code}.


\begin{DoxyCodeInclude}
\textcolor{comment}{//==start\_of\_doc\_solution=================================================}
\textcolor{comment}{/// Doc the solution}
\textcolor{comment}{}\textcolor{comment}{//========================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT>
\textcolor{keywordtype}{void} \hyperlink{classRefineableDrivenCavityProblem_a0baa1e8f1d1f6f73ef921b06a9b20836}{RefineableDrivenCavityProblem<ELEMENT>::doc\_solution}
      (DocInfo& doc\_info)
\{ 

 ofstream some\_file;
 \textcolor{keywordtype}{char} filename[100];

 \textcolor{comment}{// Number of plot points}
 \textcolor{keywordtype}{unsigned} npts=5; 


 \textcolor{comment}{// Output solution }
 sprintf(filename,\textcolor{stringliteral}{"%s/soln%i.dat"},doc\_info.directory().c\_str(),
         doc\_info.number());
 some\_file.open(filename);
 mesh\_pt()->output(some\_file,npts);
 some\_file.close();
 
\} \textcolor{comment}{// end\_of\_doc\_solution}

\end{DoxyCodeInclude}




 

\hypertarget{index_comments}{}\section{Comments and Exercises}\label{index_comments}
\hypertarget{index_hang_vector}{}\subsection{Hanging nodes in problems with vector-\/valued unknowns}\label{index_hang_vector}
We discussed in an earlier example for a scalar (\href{../../../poisson/two_d_poisson_adapt/html/index.html}{\tt Poisson}) problem how {\ttfamily oomph-\/lib\textquotesingle{}s} mesh adaptation routines create hanging nodes and how the values that are stored at such nodes are automatically constrained to ensure the inter-\/element continuity of the solution. The methodology employed for scalar problems is easily generalised to problems with vector-\/valued unknowns, provided that all unknowns are represented by the same isoparametric interpolation between the elements\textquotesingle{} nodal values. In such problems, the unknown nodal values at the hanging nodes are constrained to be linear combination of the corresponding values at their \char`\"{}master nodes\char`\"{}. The list of \char`\"{}master nodes\char`\"{} and the corresponding \char`\"{}hanging weights\char`\"{} (contained in a {\ttfamily Hang\+Info} object) are the same for all unknowns.

To allow the use spatial adaptivity for elements in which different unknowns are represented by different interpolation schemes (e.\+g. in 2D quadrilateral Taylor-\/\+Hood elements where the two velocity components are represented by bi-\/quadratic interpolation between the values stored at the element\textquotesingle{}s 3x3 nodes, whereas the pressure is represented by bi-\/linear interpolation between the pressure values stored at the element\textquotesingle{}s 2x2 corner nodes) {\ttfamily oomph-\/lib} allows the different nodal values to have their own list of \char`\"{}master nodes\char`\"{} and \char`\"{}hanging weights\char`\"{}. This is achieved as follows;
\begin{DoxyItemize}
\item By default, all nodes are assumed to be non-\/hanging. This status is indicated by the fact that a {\ttfamily Node\textquotesingle{}s} pointer to its {\ttfamily Hang\+Info} object, accessible via its member function {\ttfamily Node\+::hanging\+\_\+pt()}, is {\ttfamily N\+U\+LL}.
\item Mesh adaptation may turn a node into a hanging node. A node\textquotesingle{}s \char`\"{}hanging status\char`\"{} is primarily a geometrical/topological property. If a {\ttfamily Node} is found to be hanging, {\ttfamily oomph-\/lib\textquotesingle{}s} mesh adaptation procedures create a {\ttfamily Hang\+Info} object that stores the list of the hanging node\textquotesingle{}s \char`\"{}master nodes\char`\"{} and their respective weights. A pointer to the {\ttfamily Hang\+Info} object is then passed to the {\ttfamily Node}. The list of master nodes and weights, stored in this {\ttfamily Hang\+Info} object is then used by the function {\ttfamily Node\+::position()} to determine the {\ttfamily Node\textquotesingle{}s} (constrained) position.
\item Nodes also provide storage for separate pointers to {\ttfamily Hang\+Info} objects for each of their nodal values. These are accessible via the member function {\ttfamily Node\+::hanging\+\_\+pt(i)} which returns the pointer to the {\ttfamily Hang\+Info} object associated with the node\textquotesingle{}s i-\/th nodal value. By default, these pointers point to the \char`\"{}geometric\char`\"{} {\ttfamily Hang\+Info} object, accessible via the argument-\/free version of this function. This default behaviour is appropriate for isoparametric elements in which all unknowns are represented by interpolation between the elements\textquotesingle{} nodes, using its geometric shape functions as basis functions.
\item For elements that use different interpolation schemes for different nodal values (e.\+g. in Taylor-\/\+Hood elements), the default assignment for the pointers to the {\ttfamily Hang\+Info} objects may be over-\/written. This is task is typically performed by re-\/implementing (and thus over-\/writing) the empty virtual function 
\begin{DoxyCode}
RefineableElement::further\_setup\_hanging\_nodes()
\end{DoxyCode}
 for such elements. This function is called automatically during at the end of {\ttfamily oomph-\/lib\textquotesingle{}s} mesh adaptation procedures.
\end{DoxyItemize}\hypertarget{index_refining_TH}{}\subsection{Adaptivity for Taylor-\/\+Hood elements}\label{index_refining_TH}
\hypertarget{index_issues}{}\subsubsection{The issues}\label{index_issues}
In non-\/adaptive 2D \mbox{[}3D\mbox{]} Taylor-\/\+Hood elements, every node stores (at least) two \mbox{[}three\mbox{]} nodal values which represent the two \mbox{[}three\mbox{]} velocity components. The four corner \mbox{[}eight vertex\mbox{]} nodes store an additional third \mbox{[}fourth\mbox{]} value which represents the pressure. If the mesh is subjected to non-\/uniform refinement, some of the mid-\/side nodes in large elements also act as corner nodes for adjacent smaller elements, as illustrated in the figure below.

 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{pressure_hang}
\doxyfigcaption{An adapted mesh, with nodes storing a pressure value denoted by circles, and velocity nodes by squares. }
\end{DoxyImage}


The figure illustrates that the \char`\"{}hanging status\char`\"{} of the various degrees of freedom can be become fairly involved. For instance
\begin{DoxyItemize}
\item Node 7 is geometrically hanging, with master nodes 6, 8 and 12. It is not a pressure node.
\item Node 8 is geometrically non-\/hanging, but it is a hanging node for the pressure interpolation. Its pressure master nodes are 6 and 12.
\item Node 10 is geometrically hanging, and its geometric master nodes are 6, 8 and 12, while its pressure master nodes are 6 and 12.
\end{DoxyItemize}To illustrate that {\ttfamily oomph-\/lib\textquotesingle{}s} automatic mesh adaptation procedures are able to deal with these cases, the figure below shows a \char`\"{}carpet plot\char`\"{} of the pressure distribution, $ p(x_1,x_2) $, obtained from a (strongly under-\/resolved) driven-\/cavity computation on the mesh shown above. The figure illustrates that the hanging node constraints ensure the inter-\/element continuity of the pressure throughout the domain, and, in particular, along the \char`\"{}right\char`\"{} boundary of the largest element.

 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{hanging_pressure}
\doxyfigcaption{The under-\/resolved pressure distribution for the driven cavity problem, using the above mesh and computed with Taylor-\/\+Hood elements. }
\end{DoxyImage}
\hypertarget{index_implementation}{}\subsubsection{Details of the implementation}\label{index_implementation}
To facilitate the book-\/keeping for such problems, {\itshape all} nodes in the refineable Taylor-\/\+Hood elements store three \mbox{[}four\mbox{]} nodal values, even though, depending on the mesh\textquotesingle{}s refinement pattern some of the pressure values will not be used. To eliminate the \char`\"{}redundant\char`\"{} pressure degrees of freedom from the problem, we provide the function


\begin{DoxyCode}
NavierStokesEquations<DIM>::pin\_redundant\_nodal\_pressures(...)
\end{DoxyCode}


which pins the \char`\"{}redundant\char`\"{} pressure degrees of freedom in all elements specified by the input argument (a vector of pointers to the Navier-\/\+Stokes elements). This function must be called after the initial mesh has been created, and after each mesh adaptation. The function first pins {\itshape all} nodal pressure values, using the function


\begin{DoxyCode}
NavierStokesEquations<DIM>::pin\_all\_nodal\_pressure\_dofs()
\end{DoxyCode}


and then unpins the nodal pressure values at the elements\textquotesingle{} corner \mbox{[}vertex\mbox{]} nodes, using the function


\begin{DoxyCode}
NavierStokesEquations<DIM>::unpin\_proper\_nodal\_pressure\_dofs()
\end{DoxyCode}


These functions are implemented as empty virtual functions in the {\ttfamily Navier\+Stokes\+Equations$<$\+D\+I\+M$>$} class which provides a base class for all Navier-\/\+Stokes elements. The empty functions are overwritten for {\ttfamily Q\+Taylor\+Hood\+Element$<$\+D\+I\+M$>$} and remain empty for all other Navier-\/\+Stokes elements, therefore they can be called for any element type.\hypertarget{index_refining_CR}{}\subsection{Adaptivity for Crouzeix-\/\+Raviart elements}\label{index_refining_CR}
As discussed in the \href{../../driven_cavity/html/index.html#CR}{\tt previous example}, {\ttfamily oomph-\/lib\textquotesingle{}s} isoparametric 2D \mbox{[}3D\mbox{]} Crouzeix-\/\+Raviart elements employ a piecewise bi-\/ \mbox{[}tri-\/\mbox{]}linear, globally discontinuous pressure representation. In each element, the pressure is represented by bi-\/\mbox{[}tri-\/\mbox{]}linear basis functions, multiplied by 3 \mbox{[}4\mbox{]} pressure values which are stored in the element\textquotesingle{}s internal {\ttfamily Data}. Since the pressure representation is discontinuous, the pressure values do not have to be subjected to any constraints to ensure inter-\/element continuity. Each {\ttfamily Node} stores two \mbox{[}three\mbox{]} velocity degrees of freedom. Since the velocity representation is isoparametric, the default assignment for the nodal values\textquotesingle{} {\ttfamily Hang\+Info} pointer is appropriate and no further action is required.\hypertarget{index_exercises}{}\subsection{Exercises}\label{index_exercises}

\begin{DoxyEnumerate}
\item Confirm that a warning message is issued if the function {\ttfamily Navier\+Stokes\+Equations$<$\+D\+I\+M$>$\+::pin\+\_\+all\+\_\+nodal\+\_\+pressure\+\_\+dofs()} is not called following the mesh adaptation.
\item Investigate how the pressure distribution changes with each adaptation. \mbox{[}Hint\+: You can call {\ttfamily doc\+\_\+solution}(...) from {\ttfamily actions\+\_\+after\+\_\+newton\+\_\+solve()} to document the progress of the mesh adaptation.\mbox{]}
\end{DoxyEnumerate}



 

\hypertarget{index_sources}{}\section{Source files for this tutorial}\label{index_sources}

\begin{DoxyItemize}
\item The source files for this tutorial are located in the directory\+: \begin{center} \href{../../../../demo_drivers/navier_stokes/adaptive_driven_cavity/}{\tt demo\+\_\+drivers/navier\+\_\+stokes/adaptive\+\_\+driven\+\_\+cavity/ } \end{center} 
\item The driver code is\+: \begin{center} \href{../../../../demo_drivers/navier_stokes/adaptive_driven_cavity/adaptive_driven_cavity.cc}{\tt demo\+\_\+drivers/navier\+\_\+stokes/adaptive\+\_\+driven\+\_\+cavity/adaptive\+\_\+driven\+\_\+cavity.\+cc } \end{center} 
\end{DoxyItemize}



 

 \hypertarget{index_pdf}{}\section{P\+D\+F file}\label{index_pdf}
A \href{../latex/refman.pdf}{\tt pdf version} of this document is available. \end{document}
