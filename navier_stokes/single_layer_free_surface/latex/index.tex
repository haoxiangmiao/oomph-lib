This is our first free surface example problem. We discuss the non-\/dimensionalisation of the free surface boundary conditions and their implementation in {\ttfamily oomph-\/lib}, and demonstrate the solution of a single layer relaxation problem.



 

\hypertarget{index_free_surface_eqns}{}\section{Boundary conditions at a free surface}\label{index_free_surface_eqns}
Free surfaces occur at the interface between two fluids. Such interfaces require two boundary conditions to be applied\+:
\begin{DoxyEnumerate}
\item a kinematic condition which relates the motion of the free surface to the fluid velocities at the surface, and
\item a dynamic condition which is concerned with the force balance at the free surface.
\end{DoxyEnumerate}\hypertarget{index_kinematic_condition_theory}{}\subsection{The kinematic condition}\label{index_kinematic_condition_theory}
The kinematic condition states that the fluid particles at the surface remain on the surface for all times. If the surface is parametrised by intrinsic coordinates $ \zeta_1 $ and $ \zeta_2 $, then the Eulerian position vector which describes the surface at a given time $ t $ can be written as $ \mathbf{R}^* = \mathbf{R}^*(\zeta_1,\zeta_2,t) $. The kinematic condition is then given by \[ \left(u_i^*-\frac{\partial R_i^*}{\partial t^*}\right) n_i = 0, \] where $ \mathbf{u}^* $ is the (dimensional) velocity of the fluid and $ \mathbf{n} $ is the outer unit normal to the free surface. Using the same problem-\/specific reference quantities for the velocity, $ {\cal U} $, length, $ {\cal L} $, and time, ${\cal T} $, that were used to \href{../../driven_cavity/html/index.html#equation}{\tt non-\/dimensionalise the Navier--Stokes equations}, we scale the dimensional quantities such that \[ u_i^* = {\cal U} \, u_i, \qquad R_i^* = {\cal L} \, R_i, \qquad t^* = {\cal T} \, t. \] The non-\/dimensional form of the kinematic boundary condition is then given by \[ \left(u_i - St\, \frac{\partial R_i}{\partial t}\right) n_i = 0, \ \ \ \ \ \ \ \ \ \ (1) \] where the Strouhal number is \[ St = \frac{{\cal L}}{{\cal U}{\cal T}}. \]\hypertarget{index_dynamic_condition_theory}{}\subsection{The dynamic condition}\label{index_dynamic_condition_theory}
 
\begin{DoxyImage}
\includegraphics[width=0.6\textwidth]{free_surface_sketch}
\doxyfigcaption{Sketch of the interface between two fluids. }
\end{DoxyImage}


The dynamic boundary condition requires the stress to be continuous across a flat interface between two fluids. Referring to the sketch above, we define the lower fluid to be fluid 1 and the upper fluid to be fluid 2. The traction exerted by fluid 1 onto fluid 2, $ \mathbf{t}^{[1]*} $, is equal and opposite to that exerted by fluid 2 onto fluid 1, $ \mathbf{t}^{[2]*} $, and therefore $ \mathbf{t}^{[1]*} = - \mathbf{t}^{[2]*} $. The traction in fluid $ \beta $ ( $ \beta = 1,2 $) is given by \[ t_i^{[\beta]*} = \tau_{ij}^{[\beta]*} \, n_j^{[\beta]}, \] where $ \mathbf{\tau}^{[\beta]*} $ is the stress tensor in fluid $ \beta $ and $ \mathbf{n}^{[\beta]} $ is the outer unit normal to fluid $ \beta $. Since $ \mathbf{n}^{[2]} $ must equal $ -\mathbf{n}^{[1]} $, we have \[ \tau_{ij}^{[1]*} \, n_j^{[1]} = \tau_{ij}^{[2]*} \, n_j^{[1]}, \] where we have arbitrarily chosen to use $ \mathbf{n}^{[1]} $ as the unit normal.

On curved surfaces, surface tension creates a pressure jump $ \Delta p^* = \sigma \kappa^* $ across the interface, where $ \sigma $ is the surface tension and $ \kappa^* $ is equal to twice the mean curvature of the surface. Therefore the dynamic boundary condition is given by \[ \tau_{ij}^{[2]*} \, n_j^{[1]} = \tau_{ij}^{[1]*} \, n_j^{[1]} + \sigma \, \kappa^* \, n_i^{[1]}, \] where $ \kappa > 0 $ if the centre of curvature lies inside fluid
\begin{DoxyEnumerate}
\item Using the same problem-\/specific reference quantities as in the \href{#kinematic_condition_theory}{\tt section above}, the dimensional quantities are scaled such that \[ \tau_{ij}^* = \frac{\mu_{ref} \, {\cal U}}{{\cal L}} \, \tau_{ij}, \qquad \kappa^* = \frac{1}{{\cal L}} \, \kappa. \] The non-\/dimensional form of the dynamic boundary condition is then given by \[ \tau_{ij}^{[2]} \, n_j^{[1]} = \tau_{ij}^{[1]} \, n_j^{[1]} + \frac{1}{Ca} \, \kappa \, n_i^{[1]}, \] where the Capillary number is \[ Ca = \frac{\mu_{ref} \, {\cal U}}{\sigma}. \]
\end{DoxyEnumerate}

In certain cases, such as the example problem below, we wish to model the fluid above the interface as totally inviscid. In this case, the stress tensor in fluid 2 reduces to $ \tau_{ij}^{[2]} = - \delta_{ij} p_{ext} $, where $ p_{ext} $ is the (non-\/dimensional) constant pressure above the free surface. The dynamic boundary condition therefore becomes \[ \tau_{ij} \, n_j = - \left( \frac{1}{Ca} \, \kappa + p_{ext} \right) n_i, \] where we have dropped the explicit references to fluid 1 since it is understood that the stress tensor and unit normals refer to those of the (one and only) viscous fluid in the problem.

We shall now discuss how the free surface boundary conditions are implemented in {\ttfamily oomph-\/lib}.



 

\hypertarget{index_implementation}{}\section{Implementation}\label{index_implementation}
\hypertarget{index_kinematic_condition_implementation}{}\subsection{The kinematic condition and the pseudo-\/solid node-\/update procedure}\label{index_kinematic_condition_implementation}
In addition to solving for the fluid velocity and pressure (as in all Navier--Stokes examples), we have additional degrees of freedom in our problem due to the fact that the position of the free surface $ \mathbf{R} $ is unknown. The Navier--Stokes elements in {\ttfamily oomph-\/lib} are based on the Arbitrary Lagrangian Eulerian (A\+LE) form of the Navier-\/\+Stokes equations, and so can be used to solve problems in moving domains. This allows us to discretise our domain using a boundary fitted mesh, which will need to deform in response to the motion of the free surface. This is achieved by treating the interior of the mesh as a fictitious elastic solid, and solving a solid mechanics problem for the (unknown) nodal positions. This technique, which will subsequently be referred to as a `pseudo-\/solid node-\/update strategy\textquotesingle{}, employs wrapper elements to existing fluid and solid equation classes. The specific element used in this example is a {\ttfamily Pseudo\+Solid\+Node\+Update\+Element$<$Q\+Crouzeix\+Raviart\+Element$<$2$>$}, {\ttfamily Q\+P\+V\+D\+Element$<$2,3$>$} {\ttfamily $>$} element, which takes two template arguments. The first is the standard element type used to solve the fluid problem, and the second is the element type which solves the equations that are used to control the mesh deformation.

The deformation of the free surface boundary is imposed by introducing a field of Lagrange multipliers at the free surface, following the method outlined in Cairncross et al., `A finite element method for free surface flows of incompressible fluids in three dimensions. Part I. Boundary fitted mesh motion\textquotesingle{} (2000). These new unknowns are stored as nodal values, and so the vector of values at each node is resized accordingly. Since this introduces further degrees of freedom into the problem, we require an additional equation\+: the kinematic boundary condition (1).

We discretise this equation by attaching {\ttfamily Face\+Elements} to the boundaries of the \char`\"{}bulk\char`\"{} elements that are adjacent to the free surface. The specific {\ttfamily Face\+Element} used in this example is an {\ttfamily Elastic\+Line\+Fluid\+Interface\+Element$<$\+E\+L\+E\+M\+E\+N\+T$>$}, which takes the bulk element type as a template argument. This allows the user of the driver code to easily change the bulk element type, since the appropriate {\ttfamily Face\+Element} type is automatically used. These {\ttfamily Face\+Elements} are applied in the same way as all other surface elements (e.\+g. {\ttfamily Navier\+Stokes\+Traction\+Elements}, {\ttfamily Unsteady\+Heat\+Flux\+Elements}, etc.), and a general introduction can be found in \href{../../../poisson/two_d_poisson_flux_bc/html/index.html#create_flux}{\tt another tutorial}.\hypertarget{index_dynamic_condition_implementation}{}\subsection{The dynamic condition}\label{index_dynamic_condition_implementation}
Within a finite element framework, the dynamic boundary condition is incorporated as contributions to each of the momentum equations at the free surface. We refer to Ruschak, `A method for incorporating free boundaries with surface tension in finite element fluid-\/flow simulators\textquotesingle{} (1980), for details on the formulation, which can also be found in our \href{../../surface_theory/html/index.html#boundary_conditions}{\tt free surface theory } document. Since both Taylor--Hood and Crouzeix--Raviart elements are implemented such that the normal stresses between elements are balanced, applying the dynamic boundary condition in cases in which we are solving the Navier--Stokes equations on both sides of the interface is as straightforward as adding the appropriate surface tension contributions to the relevant momentum equations at the interface. In cases such as the example below, where we have an inviscid fluid above the free surface, we need to add the appropriate external pressure contributions (if any) as well. Both of these contributions are automatically added to the appropriate momentum equations using the same {\ttfamily Face\+Elements} which are used to discretise the kinematic boundary condition (see \href{#kinematic_condition_implementation}{\tt above}).

The Capillary number defaults to 1.\+0 and other values may be set using the function\+:


\begin{DoxyCode}
\textcolor{keywordtype}{double}* FluidInterfaceElement::ca\_pt().
\end{DoxyCode}


The Strouhal number defaults to 1.\+0 and other values may be set using the function\+:


\begin{DoxyCode}
\textcolor{keywordtype}{double}* FluidInterfaceElement::st\_pt().
\end{DoxyCode}


The external pressure defaults to zero and other values may be set using the function\+:


\begin{DoxyCode}
\textcolor{keywordtype}{void} FluidInterfaceElement::set\_external\_pressure\_data(Data* p\_ext\_data\_pt),
\end{DoxyCode}


where {\ttfamily p\+\_\+ext\+\_\+data\+\_\+pt} is (a pointer to) the {\ttfamily Data} in which the value of the external pressure is stored. We note that the external pressure is represented by {\ttfamily Data} because it may be an unknown in certain problems, although it is simply a constant parameter in the example below. It can be accessed using the function\+:


\begin{DoxyCode}
\textcolor{keywordtype}{double} FluidInterfaceElement::pext().
\end{DoxyCode}


The way in which the dynamic condition is incorporated within our finite element structure is discussed in more detail in the \href{#application_of_dbc}{\tt comments} at the end of this tutorial.



 

\hypertarget{index_example_problem}{}\section{The example problem}\label{index_example_problem}
We will illustrate the solution of the unsteady two-\/dimensional Navier--Stokes equations using the example of a distorted free surface which is allowed to relax. The domain is periodic in the $ x_1 $ direction.

\begin{center} \tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*{1}{|X[-1]}|}
\hline
\begin{center} {\bfseries  The 2D unsteady Navier--Stokes equations under a distorted free surface.} \end{center}  Solve \[ Re\left(St\frac{\partial u_i}{\partial t} + \ u_j\frac{\partial u_i}{\partial x_j}\right) = - \frac{\partial p}{\partial x_i} + \frac{Re}{Fr}G_i + \frac{\partial }{\partial x_j} \left( \frac{\partial u_i}{\partial x_j} + \frac{\partial u_j}{\partial x_i} \right) \ \ \ \ \ \ \ \ \ \ (2) \] and \[ \frac{\partial u_i}{\partial x_i} = 0, \ \ \ \ \ \ \ \ \ \ (3) \] with gravity acting in the negative $ x_2 $ direction, in the unit square, where the free surface is located at $ \mathbf{R} $, subject to the Dirichlet boundary conditions\+: \[ u_1=0 \ \ \ \ \ \ \ \ \ \ (4) \] on the bottom, left and right boundaries and \[ u_2=0 \ \ \ \ \ \ \ \ \ \ (5) \] on the bottom boundary.

The free surface is defined by $ \mathbf{R} $, which is subject to the kinematic condition\+: \[ \left(u_i - St\, \frac{\partial R_i}{\partial t}\right) n_i = 0, \ \ \ \ \ \ \ \ \ \ (6) \] and the dynamic condition\+: \[ \tau_{ij}n_j = - \left(\frac{1}{Ca}\kappa + p_{ext}\right) n_i, \ \ \ \ \ \ \ \ \ \ (7) \] where the stress tensor is defined as\+: \[ \tau_{ij} = -p \, \delta_{ij} + \left(\frac{\partial u_i}{\partial x_j} + \frac{\partial u_j}{\partial x_i}\right). \ \ \ \ \ \ \ \ \ \ (8) \]

The initial deformation of the free surface is defined by\+: \[ \mathbf{R} = x_1 \, \mathbf{i} + \left[ 1.0 + \epsilon\cos\left( 2 n \pi x_1 \right)\right] \, \mathbf{j} \ \ \ \ \ \ \ \ \ \ (9) \] where $ \epsilon $ is a small parameter and $ n $ is an integer.   \\\cline{1-1}
\end{longtabu}
\end{center} 



 

\hypertarget{index_results}{}\section{Results}\label{index_results}
The figure below shows a contour plot of the pressure distribution with superimposed streamlines, taken from \href{../figures/single_layer.avi}{\tt an animation of the flow field}, for the parameters $ Re = Re \, St = Re/Fr = 5.0 $ and $ Ca = 0.01 $.

 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{single_layer}
\doxyfigcaption{Pressure contour plot for the relaxing interface problem. }
\end{DoxyImage}


At time $ t \leq 0 $ the free surface is fixed in its deformed shape, but as the simulation begins the restoring forces of surface tension and gravitational acceleration act to revert it to its undeformed flat state. The surface oscillates up and down, but the motion is damped as the energy in the system is dissipated through viscous forces. Eventually the interface settles down to its equilibrium position. This viscous damping effect can be seen in the following time-\/trace of the height of the fluid layer at the edge of the domain.

 
\begin{DoxyImage}
\includegraphics[width=0.95\textwidth]{single_layer_trace}
\doxyfigcaption{Time-\/trace of the height of the fluid layer at the edge of the domain. }
\end{DoxyImage}




 

\hypertarget{index_validation}{}\section{Validation}\label{index_validation}
The free surface boundary conditions for the Cartesian Navier--Stokes equations have been validated against an analytical test case, and we present the results in the figure below. For sufficiently small amplitudes, $ \epsilon \ll 1 $, we can linearise the governing equations by proposing that we can write the fluid velocities and pressure, $ u(x,y,t) $, $ v(x,y,t) $ and $ p(x,y,t) $, as well as the `height\textquotesingle{} of the interface, $ h(x,t) $, in the form $ x = \bar{x} + \epsilon \hat{x} $, where the barred quantities correspond to the `base\textquotesingle{} state, chosen here to be the trivial solution $ \bar{h} = \bar{u} = \bar{v} = \bar{p} = 0 $. Once the linearised forms of the governing equations and boundary conditions have been determined we propose a separable solution of the form \[ \hat{h}(x,t) = H e^{\lambda t + ikx}, \] \[ \hat{u}(x,y,t) = U(y) e^{\lambda t + ikx}, \] \[ \hat{v}(x,y,t) = V(y) e^{\lambda t + ikx}, \] and \[ \hat{p}(x,y,t) = P(y) e^{\lambda t + ikx}. \] Substituting the above ansatz into the governing equations results in a system of coupled ordinary differential equations for $ U(y) $, $ V(y) $ and $ P(y) $ which we solve to find their general solutions up to a set of unknown constants $ A $, $ B $, $ C $ and $ D $. By substituting these general forms into the set of (linearised and separated) boundary conditions we obtain a linear system of five equations in the five unknowns $ A $, $ B $, $ C $, $ D $ and $ H $, from which we can assemble a homogeneous linear system of the form \[ \mathbf{M} \left[ \begin{array}{c} A \\ B \\ C \\ D \\ H \end{array} \right] = \left[ \begin{array}{c} 0 \\ 0 \\ 0 \\ 0 \\ 0 \end{array} \right], \] where $ \mathbf{M} $ is a $ 5 \times 5 $ matrix whose entries are the coefficients of the unknowns in our five conditions. This system only has a non-\/trivial solution if $ \left| \mathbf{M} \right| = 0 $, and solving this equation gives us $ \lambda $ as a function of $ k $. This is a dispersion relation and describes how wave propagation varies as a function of its wavenumber. More specifically, the real part of $ \lambda $ is the growth rate of the wave and the imaginary part is its frequency. This analytical result can now be compared to numerical results computed for given values of the wavenumber $ k $. We choose an initial deflection amplitude of $ \epsilon = 0.01 $ and determine the growth rate and frequency of the oscillation from a time-\/trace of the left-\/hand edge of the interface.

 
\begin{DoxyImage}
\includegraphics[width=0.95\textwidth]{single_layer_code_validation}
\doxyfigcaption{Validation of the code (points) by comparison with an analytical dispersion relation (lines). }
\end{DoxyImage}




 

\hypertarget{index_namespace}{}\section{Global parameters and functions}\label{index_namespace}
As usual, we use a namespace to define the dimensionless parameters $ Re $, $ St $, $ Re/Fr $ and $ Ca $, and we create a vector $ G $ which will define the direction in which gravity acts. We will need to pass the Strouhal number to the interface elements, but the product of the Strouhal number and the Reynolds number to the bulk elements. To avoid potentially inconsistent parameters, we compute $ Re \, St $ rather than defining it explicitly. Because the mesh is to be updated using a pseudo-\/solid node-\/update strategy, we also require the Poisson ratio for the generalised Hookean constitutive law.

 
\begin{DoxyCodeInclude}
\textcolor{comment}{//==start\_of\_namespace====================================================}
\textcolor{comment}{/// Namespace for physical parameters}
\textcolor{comment}{}\textcolor{comment}{//========================================================================}
\textcolor{keyword}{namespace }\hyperlink{namespaceGlobal__Physical__Variables}{Global\_Physical\_Variables}
\{
\textcolor{comment}{}
\textcolor{comment}{ /// Reynolds number}
\textcolor{comment}{} \textcolor{keywordtype}{double} \hyperlink{namespaceGlobal__Physical__Variables_ab814e627d2eb5bc50318879d19ab16b9}{Re} = 5.0;
\textcolor{comment}{}
\textcolor{comment}{ /// Strouhal number}
\textcolor{comment}{} \textcolor{keywordtype}{double} \hyperlink{namespaceGlobal__Physical__Variables_a4b6ef72bd221361c37f5b9a4a6899afc}{St} = 1.0;
\textcolor{comment}{}
\textcolor{comment}{ /// Womersley number (Reynolds x Strouhal, computed automatically)}
\textcolor{comment}{} \textcolor{keywordtype}{double} \hyperlink{namespaceGlobal__Physical__Variables_a085ee4bf968ffdd01a41b8c41864f907}{ReSt};
 \textcolor{comment}{}
\textcolor{comment}{ /// Product of Reynolds number and inverse of Froude number}
\textcolor{comment}{} \textcolor{keywordtype}{double} \hyperlink{namespaceGlobal__Physical__Variables_aa6286f02b476912dd7550eced538331a}{ReInvFr} = 5.0; \textcolor{comment}{// (Fr = 1)}
\textcolor{comment}{}
\textcolor{comment}{ /// Capillary number}
\textcolor{comment}{} \textcolor{keywordtype}{double} \hyperlink{namespaceGlobal__Physical__Variables_a8b32b93d2e546f9375ec418474107838}{Ca} = 0.01;
\textcolor{comment}{}
\textcolor{comment}{ /// Direction of gravity}
\textcolor{comment}{} Vector<double> \hyperlink{namespaceGlobal__Physical__Variables_a37a6f46efcb35b4bd12c73f19d741020}{G}(2);
\textcolor{comment}{}
\textcolor{comment}{ /// Pseudo-solid Poisson ratio}
\textcolor{comment}{} \textcolor{keywordtype}{double} \hyperlink{namespaceGlobal__Physical__Variables_a3962c36313826b19f216f6bbbdd6a477}{Nu} = 0.1;

\} \textcolor{comment}{// End of namespace}

\end{DoxyCodeInclude}




 

\hypertarget{index_main}{}\section{The driver code}\label{index_main}
We start by computing the product of the Reynolds and Strouhal numbers before specifying the (non-\/dimensional) length of time for which we want the simulation to run and the size of the timestep. Because all driver codes are run as part of {\ttfamily oomph-\/lib\textquotesingle{}s} self-\/testing routines we allow the user to pass a command line argument to the executable which sets the maximum time to some lower value.


\begin{DoxyCodeInclude}
\textcolor{comment}{//==start\_of\_main=========================================================}
\textcolor{comment}{/// Driver code for two-dimensional single fluid free surface problem}
\textcolor{comment}{}\textcolor{comment}{//========================================================================}
\textcolor{keywordtype}{int} \hyperlink{elastic__single__layer_8cc_a0ddf1224851353fc92bfbff6f499fa97}{main}(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char}* argv[]) 
\{
 \textcolor{comment}{// Store command line arguments}
 CommandLineArgs::setup(argc,argv);

 \textcolor{comment}{// Compute the Womersley number}
 \hyperlink{namespaceGlobal__Physical__Variables_a085ee4bf968ffdd01a41b8c41864f907}{Global\_Physical\_Variables::ReSt} =
  \hyperlink{namespaceGlobal__Physical__Variables_ab814e627d2eb5bc50318879d19ab16b9}{Global\_Physical\_Variables::Re}*
      \hyperlink{namespaceGlobal__Physical__Variables_a4b6ef72bd221361c37f5b9a4a6899afc}{Global\_Physical\_Variables::St};
\textcolor{comment}{}
\textcolor{comment}{ /// Maximum time}
\textcolor{comment}{} \textcolor{keywordtype}{double} t\_max = 0.6;
\textcolor{comment}{}
\textcolor{comment}{ /// Duration of timestep}
\textcolor{comment}{} \textcolor{keyword}{const} \textcolor{keywordtype}{double} dt = 0.0025;

 \textcolor{comment}{// If we are doing validation run, use smaller number of timesteps}
 \textcolor{keywordflow}{if}(CommandLineArgs::Argc>1) \{ t\_max = 0.005; \}

\end{DoxyCodeInclude}


Next we specify the dimensions of the mesh and the number of elements in the $ x_1 $ and $ x_2 $ directions. To remain consistent with the example code we shall from now on refer to $ x_1 $ as $ x $ and $ x_2 $ as $ y $.


\begin{DoxyCodeInclude}
 \textcolor{comment}{// Number of elements in x direction}
 \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} n\_x = 12;
   
 \textcolor{comment}{// Number of elements in y direction}
 \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} n\_y = 12;

 \textcolor{comment}{// Width of domain}
 \textcolor{keyword}{const} \textcolor{keywordtype}{double} l\_x = 1.0;

 \textcolor{comment}{// Height of fluid layer}
 \textcolor{keyword}{const} \textcolor{keywordtype}{double} h = 1.0;

\end{DoxyCodeInclude}


At this point we define the direction in which gravity acts\+: vertically downwards.


\begin{DoxyCodeInclude}
 \textcolor{comment}{// Set direction of gravity (vertically downwards)}
 \hyperlink{namespaceGlobal__Physical__Variables_a37a6f46efcb35b4bd12c73f19d741020}{Global\_Physical\_Variables::G}[0] = 0.0;
 \hyperlink{namespaceGlobal__Physical__Variables_a37a6f46efcb35b4bd12c73f19d741020}{Global\_Physical\_Variables::G}[1] = -1.0;

\end{DoxyCodeInclude}


Finally, we build the problem using the `pseudo-\/solid\textquotesingle{} version of {\ttfamily Q\+Crouzeix\+Raviart\+Elements} and the {\ttfamily B\+D\+F$<$2$>$} timestepper, before calling {\ttfamily unsteady\+\_\+run}(...). This function solves the system at each timestep using the {\ttfamily Problem\+::unsteady\+\_\+newton\+\_\+solve}(...) function before documenting the result.


\begin{DoxyCodeInclude}
 \textcolor{comment}{// Set up the elastic test problem with QCrouzeixRaviartElements,}
 \textcolor{comment}{// using the BDF<2> timestepper}
 \hyperlink{classInterfaceProblem}{InterfaceProblem<PseudoSolidNodeUpdateElement< QCrouzeixRaviartElement<2>}
      ,
  QPVDElement<2,3> > , BDF<2> >
  problem(n\_x,n\_y,l\_x,h);
 
 \textcolor{comment}{// Run the unsteady simulation}
 problem.unsteady\_run(t\_max,dt);
 
\} \textcolor{comment}{// End of main}

\end{DoxyCodeInclude}




 

\hypertarget{index_problem_class}{}\section{The problem class}\label{index_problem_class}
Since we are solving the unsteady Navier--Stokes equations, the {\ttfamily Problem} class is very similar to that used in the \href{../../rayleigh_channel/html/index.html}{\tt Rayleigh channel example}. We specify the type of the element and the type of the timestepper (assumed to be a member of the {\ttfamily B\+DF} family) as template parameters, before passing the number of elements and domain length in both coordinate directions to the problem constructor. We define an empty destructor, functions to set the initial and boundary conditions and a post-\/processing function {\ttfamily doc\+\_\+solution}(...), which will be used by the timestepping function {\ttfamily unsteady\+\_\+run}(...).

 
\begin{DoxyCodeInclude}
\textcolor{comment}{//==start\_of\_problem\_class================================================}
\textcolor{comment}{/// Single fluid free surface problem in a rectangular domain which is}
\textcolor{comment}{}\textcolor{comment}{/// periodic in the x direction}
\textcolor{comment}{}\textcolor{comment}{//========================================================================}
\textcolor{keyword}{template} <\textcolor{keyword}{class} ELEMENT, \textcolor{keyword}{class} TIMESTEPPER>
\textcolor{keyword}{class }\hyperlink{classInterfaceProblem}{InterfaceProblem} : \textcolor{keyword}{public} Problem
\{
 
\textcolor{keyword}{public}:
 \textcolor{comment}{}
\textcolor{comment}{ /// Constructor: Pass the number of elements and the lengths of the}
\textcolor{comment}{ /// domain in the x and y directions (h is the height of the fluid layer}
\textcolor{comment}{ /// i.e. the length of the domain in the y direction)}
\textcolor{comment}{} \hyperlink{classInterfaceProblem_a83023535d663a2a6558959f36bf6e1e7}{InterfaceProblem}(\textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} &n\_x, \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} &n\_y, 
                  \textcolor{keyword}{const} \textcolor{keywordtype}{double} &l\_x, \textcolor{keyword}{const} \textcolor{keywordtype}{double} &h);
 \textcolor{comment}{}
\textcolor{comment}{ /// Destructor (empty)}
\textcolor{comment}{} \hyperlink{classInterfaceProblem_a90c191f8046069099b199743e7ce7111}{~InterfaceProblem}() \{\}
\textcolor{comment}{}
\textcolor{comment}{ /// Set initial conditions}
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{classInterfaceProblem_a0d3af8378c4f0a6e38636be958c300d5}{set\_initial\_condition}();
\textcolor{comment}{}
\textcolor{comment}{ /// Set boundary conditions}
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{classInterfaceProblem_a844445832ad7a32aa9f5d03ffdb40ebb}{set\_boundary\_conditions}();
\textcolor{comment}{}
\textcolor{comment}{ /// Document the solution}
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{classInterfaceProblem_a49714e35e94f7d2af0b6ddd22b851f52}{doc\_solution}(DocInfo &doc\_info);
\textcolor{comment}{}
\textcolor{comment}{ /// Do unsteady run up to maximum time t\_max with given timestep dt}
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{classInterfaceProblem_adf1f4e43d10939e4323e0e315b711085}{unsteady\_run}(\textcolor{keyword}{const} \textcolor{keywordtype}{double} &t\_max, \textcolor{keyword}{const} \textcolor{keywordtype}{double} &dt); 

\end{DoxyCodeInclude}


The nodal positions are unknowns in the problem and hence are updated automatically, so there is no need to update the mesh before performing a Newton solve. However, since the main use of the methodology demonstrated here is in free-\/boundary problems where the solution of the solid problem merely serves to update the nodal positions in response to the motion of the free surface, we reset the nodes\textquotesingle{} Lagrangian coordinates to their Eulerian positions before every solve, by calling {\ttfamily Solid\+Mesh\+::set\+\_\+lagrangian\+\_\+nodal\+\_\+coordinates()}. This makes the deformed configuration stress-\/free and tends to stabilise the computation, allowing larger domain deformations to be computed.


\begin{DoxyCodeInclude}
\textcolor{keyword}{private}:
\textcolor{comment}{}
\textcolor{comment}{ /// No actions required before solve step}
\textcolor{comment}{} \textcolor{keywordtype}{void} actions\_before\_newton\_solve() \{\}
\textcolor{comment}{}
\textcolor{comment}{ /// No actions required after solve step}
\textcolor{comment}{} \textcolor{keywordtype}{void} actions\_after\_newton\_solve() \{\}
\textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Actions before the timestep: For maximum stability, reset}
\textcolor{comment}{ /// the current nodal positions to be the "stress-free" ones.}
\textcolor{comment}{} \textcolor{keywordtype}{void} actions\_before\_implicit\_timestep()
  \{
   Bulk\_mesh\_pt->set\_lagrangian\_nodal\_coordinates();
  \}
\textcolor{comment}{}
\textcolor{comment}{ /// Deform the mesh/free surface to a prescribed function}
\textcolor{comment}{} \textcolor{keywordtype}{void} deform\_free\_surface(\textcolor{keyword}{const} \textcolor{keywordtype}{double} &epsilon, \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} &n\_periods);

\end{DoxyCodeInclude}


The problem class stores pointers to the specific bulk mesh and the surface mesh, which will contain the interface elements, as well as a pointer to a constitutive law for the pseudo-\/solid mesh. The width of the domain is also stored since it is used by the function {\ttfamily deform\+\_\+free\+\_\+surface}(...) when setting up the initial mesh deformation. Finally we store an output stream in which we record the height of the interface at the domain edge.


\begin{DoxyCodeInclude}
 \textcolor{comment}{/// Pointer to the (specific) "bulk" mesh}
 ElasticRectangularQuadMesh<ELEMENT>* Bulk\_mesh\_pt;
\textcolor{comment}{}
\textcolor{comment}{ /// Pointer to the "surface" mesh}
\textcolor{comment}{} Mesh* Surface\_mesh\_pt;

 \textcolor{comment}{// Pointer to the constitutive law used to determine the mesh deformation}
 ConstitutiveLaw* Constitutive\_law\_pt;
\textcolor{comment}{}
\textcolor{comment}{ /// Width of domain}
\textcolor{comment}{} \textcolor{keywordtype}{double} Lx;
\textcolor{comment}{}
\textcolor{comment}{ /// Trace file}
\textcolor{comment}{} ofstream Trace\_file;

\}; \textcolor{comment}{// End of problem class}

\end{DoxyCodeInclude}




 

\hypertarget{index_constructor}{}\section{The problem constructor}\label{index_constructor}
The constructor starts by copying the width of the domain into the private member data of the problem class, before building the timestepper.


\begin{DoxyCodeInclude}
\textcolor{comment}{//==start\_of\_constructor==================================================}
\textcolor{comment}{/// Constructor for single fluid free surface problem}
\textcolor{comment}{}\textcolor{comment}{//========================================================================}
\textcolor{keyword}{template} <\textcolor{keyword}{class} ELEMENT, \textcolor{keyword}{class} TIMESTEPPER>
\hyperlink{classInterfaceProblem_a83023535d663a2a6558959f36bf6e1e7}{InterfaceProblem<ELEMENT,TIMESTEPPER>::}
\hyperlink{classInterfaceProblem_a83023535d663a2a6558959f36bf6e1e7}{InterfaceProblem}(\textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} &n\_x, \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} &n\_y,
                 \textcolor{keyword}{const} \textcolor{keywordtype}{double} &l\_x, \textcolor{keyword}{const} \textcolor{keywordtype}{double}& h) : Lx(l\_x)
\{

 \textcolor{comment}{// Allocate the timestepper (this constructs the time object as well)}
 add\_time\_stepper\_pt(\textcolor{keyword}{new} TIMESTEPPER);

\end{DoxyCodeInclude}


Next we build the bulk mesh. The mesh we are using is the {\ttfamily Elastic\+Rectangular\+Quad\+Mesh$<$\+E\+L\+E\+M\+E\+N\+T$>$}, which takes the bulk element as a template argument. The boolean argument in the mesh constructor, which is set to `true\textquotesingle{} here, indicates whether or not the domain is to be periodic in $ x $. The surface mesh is also built, although it is empty at this point.


\begin{DoxyCodeInclude}
 \textcolor{comment}{// Build and assign the "bulk" mesh (the "true" boolean flag tells}
 \textcolor{comment}{// the mesh constructor that the domain is periodic in x)}
 Bulk\_mesh\_pt = \textcolor{keyword}{new} ElasticRectangularQuadMesh<ELEMENT>
  (n\_x,n\_y,l\_x,h,\textcolor{keyword}{true},time\_stepper\_pt());

 \textcolor{comment}{// Create the "surface mesh" that will contain only the interface}
 \textcolor{comment}{// elements. The constructor just creates the mesh without giving}
 \textcolor{comment}{// it any elements, nodes, etc.}
 Surface\_mesh\_pt = \textcolor{keyword}{new} Mesh;

\end{DoxyCodeInclude}


Having created the bulk elements, we now create the interface elements. We first build an empty mesh in which to store them, before looping over the bulk elements adjacent to the free surface and `attaching\textquotesingle{} interface elements to their upper faces. These newly-\/created elements are then stored in the surface mesh.


\begin{DoxyCodeInclude}
 \textcolor{comment}{// Create the interface elements}
 \textcolor{comment}{// -----------------------------}

 \textcolor{comment}{// Loop over those elements adjacent to the free surface}
 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} e=0;e<n\_x;e++)
  \{
   \textcolor{comment}{// Set a pointer to the bulk element we wish to our interface}
   \textcolor{comment}{// element to}
   FiniteElement* bulk\_element\_pt =
    Bulk\_mesh\_pt->finite\_element\_pt(n\_x*(n\_y-1)+e);

   \textcolor{comment}{// Create the interface element (on face 2 of the bulk element)}
   FiniteElement* interface\_element\_pt =
    \textcolor{keyword}{new} ElasticLineFluidInterfaceElement<ELEMENT>(bulk\_element\_pt,2);

   \textcolor{comment}{// Add the interface element to the surface mesh}
   this->Surface\_mesh\_pt->add\_element\_pt(interface\_element\_pt);
  \}

\end{DoxyCodeInclude}


Now that the interface elements have been created, we combine the bulk and surface meshes into a single mesh.


\begin{DoxyCodeInclude}
 \textcolor{comment}{// Add the two sub-meshes to the problem}
 add\_sub\_mesh(Bulk\_mesh\_pt);
 add\_sub\_mesh(Surface\_mesh\_pt);

 \textcolor{comment}{// Combine all sub-meshes into a single mesh}
 build\_global\_mesh();

\end{DoxyCodeInclude}


On the solid bottom boundary ( $ y = 0 $) we pin both velocity components so that there is no penetration of the wall by the fluid or flow along it. On the left and right symmetry boundaries ( $ x = 0.0 $ and $ x = 1.0 $) we pin the $ x $ component of the velocity but leave the $ y $ component unconstrained. We do not apply any velocity boundary conditions to the free surface (the top boundary). We pin the vertical displacement of the nodes on the bottom boundary (since these must remain stationary) and pin the horizontal displacement of all nodes in the mesh.


\begin{DoxyCodeInclude}
 \textcolor{comment}{// Set the boundary conditions for this problem}
 \textcolor{comment}{// --------------------------------------------}

 \textcolor{comment}{// All nodes are free by default -- just pin the ones that have}
 \textcolor{comment}{// Dirichlet conditions here}

 \textcolor{comment}{// Determine number of mesh boundaries}
 \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} n\_boundary = Bulk\_mesh\_pt->nboundary();
 
 \textcolor{comment}{// Loop over mesh boundaries}
 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} b=0;b<n\_boundary;b++)
  \{
   \textcolor{comment}{// Determine number of nodes on boundary b}
   \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} n\_node = Bulk\_mesh\_pt->nboundary\_node(b);

   \textcolor{comment}{// Loop over nodes on boundary b}
   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} n=0;n<n\_node;n++)
    \{
     \textcolor{comment}{// Fluid boundary conditions:}
     \textcolor{comment}{// --------------------------}

     \textcolor{comment}{// On lower boundary (solid wall), pin x and y components of}
     \textcolor{comment}{// the velocity (no slip/penetration)}
     \textcolor{keywordflow}{if}(b==0)
      \{
       Bulk\_mesh\_pt->boundary\_node\_pt(b,n)->pin(0);
       Bulk\_mesh\_pt->boundary\_node\_pt(b,n)->pin(1);
      \}

     \textcolor{comment}{// On left and right boundaries, pin x-component of the velocity}
     \textcolor{comment}{// (no penetration of the periodic boundaries)}
     \textcolor{keywordflow}{if}(b==1 || b==3)
      \{
       Bulk\_mesh\_pt->boundary\_node\_pt(b,n)->pin(0);
      \}

     \textcolor{comment}{// Solid boundary conditions:}
     \textcolor{comment}{// --------------------------}

     \textcolor{comment}{// On lower boundary (solid wall), pin vertical displacement}
     \textcolor{comment}{// (no penetration)}
     \textcolor{keywordflow}{if}(b==0)
      \{
       Bulk\_mesh\_pt->boundary\_node\_pt(b,n)->pin\_position(1);
      \}
    \} \textcolor{comment}{// End of loop over nodes on boundary b}
  \} \textcolor{comment}{// End of loop over mesh boundaries}

 \textcolor{comment}{// Pin horizontal displacement of all nodes}
 \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} n\_node = Bulk\_mesh\_pt->nnode();
 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} n=0;n<n\_node;n++) \{ Bulk\_mesh\_pt->node\_pt(n)->pin\_position(0); \}

\end{DoxyCodeInclude}


Next we create a generalised Hookean constitutive equation for the pseudo-\/solid mesh. This constitutive equation is discussed in \href{../../../solid/disk_compression/html/index.html#hooke}{\tt another tutorial}.


\begin{DoxyCodeInclude}
 \textcolor{comment}{// Define a constitutive law for the solid equations: generalised Hookean}
 Constitutive\_law\_pt = \textcolor{keyword}{new} GeneralisedHookean(&\hyperlink{namespaceGlobal__Physical__Variables_a3962c36313826b19f216f6bbbdd6a477}{Global\_Physical\_Variables::Nu});

\end{DoxyCodeInclude}


We loop over the bulk elements and pass them pointers to the Reynolds and Womersley numbers, $ Re $ and $ Re\, St $, the product of the Reynolds number and the inverse of the Froude number, $ Re/Fr $, the direction of gravity, $ G $, and the constitutive law. In addition we pass a pointer to the global time object, created when we called {\ttfamily Problem\+::add\+\_\+time\+\_\+stepper\+\_\+pt}(...) above.


\begin{DoxyCodeInclude}
 \textcolor{comment}{// Complete the problem setup to make the elements fully functional}
 \textcolor{comment}{// ----------------------------------------------------------------}
 
 \textcolor{comment}{// Determine number of bulk elements in mesh}
 \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} n\_element\_bulk = Bulk\_mesh\_pt->nelement();

 \textcolor{comment}{// Loop over the bulk elements}
 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} e=0;e<n\_element\_bulk;e++)
  \{
   \textcolor{comment}{// Upcast from GeneralisedElement to the present element}
   ELEMENT *el\_pt = \textcolor{keyword}{dynamic\_cast<}ELEMENT*\textcolor{keyword}{>}(Bulk\_mesh\_pt->element\_pt(e));

   \textcolor{comment}{// Set the Reynolds number}
   el\_pt->re\_pt() = &\hyperlink{namespaceGlobal__Physical__Variables_ab814e627d2eb5bc50318879d19ab16b9}{Global\_Physical\_Variables::Re};

   \textcolor{comment}{// Set the Womersley number}
   el\_pt->re\_st\_pt() = &\hyperlink{namespaceGlobal__Physical__Variables_a085ee4bf968ffdd01a41b8c41864f907}{Global\_Physical\_Variables::ReSt};

   \textcolor{comment}{// Set the product of the Reynolds number and the inverse of the}
   \textcolor{comment}{// Froude number}
   el\_pt->re\_invfr\_pt() = &\hyperlink{namespaceGlobal__Physical__Variables_aa6286f02b476912dd7550eced538331a}{Global\_Physical\_Variables::ReInvFr};

   \textcolor{comment}{// Set the direction of gravity}
   el\_pt->g\_pt() = &\hyperlink{namespaceGlobal__Physical__Variables_a37a6f46efcb35b4bd12c73f19d741020}{Global\_Physical\_Variables::G};

   \textcolor{comment}{// Set the constitutive law}
   el\_pt->constitutive\_law\_pt() = Constitutive\_law\_pt;

  \} \textcolor{comment}{// End of loop over bulk elements}

\end{DoxyCodeInclude}


Next we create a pointer to a {\ttfamily Data} value for the external pressure $ p_{ext} $, before pinning it and assigning an arbitrary value.


\begin{DoxyCodeInclude}
 \textcolor{comment}{// Create a Data object whose single value stores the external pressure}
 Data* external\_pressure\_data\_pt = \textcolor{keyword}{new} Data(1);
 
 \textcolor{comment}{// Pin and set the external pressure to some arbitrary value}
 external\_pressure\_data\_pt->pin(0);
 external\_pressure\_data\_pt->set\_value(0,1.31);

\end{DoxyCodeInclude}


We then loop over the interface elements and pass them a pointer to this external pressure value as well as pointers to the Strouhal and Capillary numbers.


\begin{DoxyCodeInclude}
 \textcolor{comment}{// Determine number of 1D interface elements in mesh}
 \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} n\_interface\_element = Surface\_mesh\_pt->nelement();

 \textcolor{comment}{// Loop over the interface elements}
 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} e=0;e<n\_interface\_element;e++)
  \{
   \textcolor{comment}{// Upcast from GeneralisedElement to the present element}
   ElasticLineFluidInterfaceElement<ELEMENT>* el\_pt = 
    \textcolor{keyword}{dynamic\_cast<}ElasticLineFluidInterfaceElement<ELEMENT>*\textcolor{keyword}{>}
    (Surface\_mesh\_pt->element\_pt(e));

   \textcolor{comment}{// Set the Strouhal number}
   el\_pt->st\_pt() = &\hyperlink{namespaceGlobal__Physical__Variables_a4b6ef72bd221361c37f5b9a4a6899afc}{Global\_Physical\_Variables::St};

   \textcolor{comment}{// Set the Capillary number}
   el\_pt->ca\_pt() = &\hyperlink{namespaceGlobal__Physical__Variables_a8b32b93d2e546f9375ec418474107838}{Global\_Physical\_Variables::Ca};

   \textcolor{comment}{// Pass the Data item that contains the single external pressure value}
   el\_pt->set\_external\_pressure\_data(external\_pressure\_data\_pt);

  \} \textcolor{comment}{// End of loop over interface elements}

\end{DoxyCodeInclude}


Finally, we apply the problem\textquotesingle{}s boundary conditions (discussed \href{#set_boundary_conditions}{\tt later on}) before setting up the equation numbering scheme using the function {\ttfamily Problem\+::assign\+\_\+eqn\+\_\+numbers()}.


\begin{DoxyCodeInclude}
 \textcolor{comment}{// Apply the boundary conditions}
 set\_boundary\_conditions();

 \textcolor{comment}{// Setup equation numbering scheme}
 cout << \textcolor{stringliteral}{"Number of equations: "} << assign\_eqn\_numbers() << std::endl;

\} \textcolor{comment}{// End of constructor}

\end{DoxyCodeInclude}




 

\hypertarget{index_set_initial_condition}{}\section{Initial conditions}\label{index_set_initial_condition}
This function sets the initial conditions for the problem. We loop over all nodes in the mesh and set both velocity components to zero. No initial conditions are required for the pressure. We then call the function {\ttfamily Problem\+::assign\+\_\+initial\+\_\+values\+\_\+impulsive()} which copies the current values at each of the nodes, as well as the current nodal positions, into the required number of history values for the timestepper in question. This corresponds to an impulsive start, as for all time $ t \leq 0 $ none of the fluid is moving and the shape of the interface is constant.


\begin{DoxyCodeInclude}
\textcolor{comment}{//==start\_of\_set\_initial\_condition========================================}
\textcolor{comment}{/// \(\backslash\)short Set initial conditions: Set all nodal velocities to zero and}
\textcolor{comment}{}\textcolor{comment}{/// initialise the previous velocities and nodal positions to correspond}
\textcolor{comment}{}\textcolor{comment}{/// to an impulsive start}
\textcolor{comment}{}\textcolor{comment}{//========================================================================}
\textcolor{keyword}{template} <\textcolor{keyword}{class} ELEMENT, \textcolor{keyword}{class} TIMESTEPPER>
\textcolor{keywordtype}{void} \hyperlink{classInterfaceProblem_a0d3af8378c4f0a6e38636be958c300d5}{InterfaceProblem<ELEMENT,TIMESTEPPER>::set\_initial\_condition}
      ()
\{
 \textcolor{comment}{// Determine number of nodes in mesh}
 \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} n\_node = mesh\_pt()->nnode();
 
 \textcolor{comment}{// Loop over all nodes in mesh}
 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} n=0;n<n\_node;n++)
  \{
   \textcolor{comment}{// Loop over the two velocity components}
   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} i=0;i<2;i++)
    \{
     \textcolor{comment}{// Set velocity component i of node n to zero}
     mesh\_pt()->node\_pt(n)->set\_value(i,0.0);
    \}
  \}
 
 \textcolor{comment}{// Initialise the previous velocity values and nodal positions}
 \textcolor{comment}{// for timestepping corresponding to an impulsive start}
 assign\_initial\_values\_impulsive();
 
\} \textcolor{comment}{// End of set\_initial\_condition}

\end{DoxyCodeInclude}




 

\hypertarget{index_set_boundary_conditions}{}\section{Boundary conditions}\label{index_set_boundary_conditions}
This function sets the boundary conditions for the problem. Since the Dirichlet conditions are homogeneous this function is not strictly necessary as all values are initialised to zero by default.


\begin{DoxyCodeInclude}
\textcolor{comment}{//==start\_of\_set\_boundary\_conditions======================================}
\textcolor{comment}{/// \(\backslash\)short Set boundary conditions: Set both velocity components to zero}
\textcolor{comment}{}\textcolor{comment}{/// on the bottom (solid) wall and the horizontal component only to zero}
\textcolor{comment}{}\textcolor{comment}{/// on the side (periodic) boundaries}
\textcolor{comment}{}\textcolor{comment}{//========================================================================}
\textcolor{keyword}{template} <\textcolor{keyword}{class} ELEMENT, \textcolor{keyword}{class} TIMESTEPPER>
\textcolor{keywordtype}{void} \hyperlink{classInterfaceProblem_a844445832ad7a32aa9f5d03ffdb40ebb}{InterfaceProblem<ELEMENT,TIMESTEPPER>::set\_boundary\_conditions}
      ()
\{
 \textcolor{comment}{// Determine number of mesh boundaries}
 \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} n\_boundary = Bulk\_mesh\_pt->nboundary();
 
 \textcolor{comment}{// Loop over mesh boundaries}
 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} b=0;b<n\_boundary;b++)
  \{
   \textcolor{comment}{// Determine number of nodes on boundary b}
   \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} n\_node = Bulk\_mesh\_pt->nboundary\_node(b);
   
   \textcolor{comment}{// Loop over nodes on boundary b}
   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} n=0;n<n\_node;n++)
    \{
     \textcolor{comment}{// Set x-component of the velocity to zero on all boundaries}
     \textcolor{comment}{// other than the free surface}
     \textcolor{keywordflow}{if}(b!=2)
      \{
       Bulk\_mesh\_pt->boundary\_node\_pt(b,n)->set\_value(0,0.0);
      \}
     
     \textcolor{comment}{// Set y-component of the velocity to zero on the bottom wall}
     \textcolor{keywordflow}{if}(b==0)
      \{
       Bulk\_mesh\_pt->boundary\_node\_pt(b,n)->set\_value(1,0.0);
      \}
    \} \textcolor{comment}{// End of loop over nodes on boundary b}
  \} \textcolor{comment}{// End of loop over mesh boundaries}
 
\} \textcolor{comment}{// End of set\_boundary\_conditions}

\end{DoxyCodeInclude}




 

\hypertarget{index_deform_free_surface}{}\section{Prescribing the initial free surface position}\label{index_deform_free_surface}
At the beginning of the simulation the free surface is deformed by a prescribed function (9). To do this we define a function, {\ttfamily deform\+\_\+free\+\_\+surface}(...), which cycles through the bulk mesh\textquotesingle{}s {\ttfamily Nodes} and modifies their positions accordingly, such that the nodes on the free surface follow the prescribed interface shape (9) and the bulk nodes retain their fractional position between the lower and the (now deformed) upper boundary.


\begin{DoxyCodeInclude}
\textcolor{comment}{//==start\_of\_deform\_free\_surface==========================================}
\textcolor{comment}{/// Deform the mesh/free surface to a prescribed function}
\textcolor{comment}{}\textcolor{comment}{//========================================================================}
\textcolor{keyword}{template} <\textcolor{keyword}{class} ELEMENT, \textcolor{keyword}{class} TIMESTEPPER>
\textcolor{keywordtype}{void} \hyperlink{classInterfaceProblem_a2319232b08d9df1ab473f6cbd40939d5}{InterfaceProblem<ELEMENT,TIMESTEPPER>::}
\hyperlink{classInterfaceProblem_a2319232b08d9df1ab473f6cbd40939d5}{deform\_free\_surface}(\textcolor{keyword}{const} \textcolor{keywordtype}{double} &epsilon,\textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} &n\_periods)
\{
 \textcolor{comment}{// Determine number of nodes in the "bulk" mesh}
 \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} n\_node = Bulk\_mesh\_pt->nnode();
 
 \textcolor{comment}{// Loop over all nodes in mesh}
 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} n=0;n<n\_node;n++)
  \{
   \textcolor{comment}{// Determine eulerian position of node}
   \textcolor{keyword}{const} \textcolor{keywordtype}{double} current\_x\_pos = Bulk\_mesh\_pt->node\_pt(n)->x(0);
   \textcolor{keyword}{const} \textcolor{keywordtype}{double} current\_y\_pos = Bulk\_mesh\_pt->node\_pt(n)->x(1);
   
   \textcolor{comment}{// Determine new vertical position of node}
   \textcolor{keyword}{const} \textcolor{keywordtype}{double} new\_y\_pos = current\_y\_pos
    + (1.0-fabs(1.0-current\_y\_pos))*epsilon
    *(cos(2.0*n\_periods*MathematicalConstants::Pi*current\_x\_pos/Lx));
   
   \textcolor{comment}{// Set new position}
   Bulk\_mesh\_pt->node\_pt(n)->x(1) = new\_y\_pos;
  \}
\} \textcolor{comment}{// End of deform\_free\_surface}

\end{DoxyCodeInclude}




 

\hypertarget{index_doc}{}\section{Post-\/processing}\label{index_doc}
As expected, this member function documents the computed solution. We first output the value of the current time to the screen, before recording the continuous time and the height of the free surface at the domain boundary in the trace file. We note that as the domain is periodic the height of the free surface must be the same at both the left and right boundaries.


\begin{DoxyCodeInclude}
\textcolor{comment}{//==start\_of\_doc\_solution=================================================}
\textcolor{comment}{/// Document the solution}
\textcolor{comment}{}\textcolor{comment}{//========================================================================}
\textcolor{keyword}{template} <\textcolor{keyword}{class} ELEMENT, \textcolor{keyword}{class} TIMESTEPPER>
\textcolor{keywordtype}{void} \hyperlink{classInterfaceProblem_a49714e35e94f7d2af0b6ddd22b851f52}{InterfaceProblem<ELEMENT,TIMESTEPPER>::doc\_solution}
      (DocInfo &doc\_info)
\{ 

 \textcolor{comment}{// Output the time}
 cout << \textcolor{stringliteral}{"Time is now "} << time\_pt()->time() << std::endl;

 \textcolor{comment}{// Upcast from GeneralisedElement to the present element}
 ElasticLineFluidInterfaceElement<ELEMENT>* el\_pt = 
  \textcolor{keyword}{dynamic\_cast<}ElasticLineFluidInterfaceElement<ELEMENT>*\textcolor{keyword}{>}
  (Surface\_mesh\_pt->element\_pt(0));

 \textcolor{comment}{// Document time and vertical position of left hand side of interface}
 \textcolor{comment}{// in trace file}
 Trace\_file << time\_pt()->time() << \textcolor{stringliteral}{" "}
            << el\_pt->node\_pt(0)->x(1) << std::endl;

\end{DoxyCodeInclude}


We then output the computed solution.


\begin{DoxyCodeInclude}
 ofstream some\_file;
 \textcolor{keywordtype}{char} filename[100];
 
 \textcolor{comment}{// Set number of plot points (in each coordinate direction)}
 \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} npts = 5;
 
 \textcolor{comment}{// Open solution output file}
 sprintf(filename,\textcolor{stringliteral}{"%s/soln%i.dat"},
         doc\_info.directory().c\_str(),doc\_info.number());
 some\_file.open(filename);

 \textcolor{comment}{// Output solution to file}
 Bulk\_mesh\_pt->output(some\_file,npts);

 \textcolor{comment}{// Close solution output file}
 some\_file.close();

\end{DoxyCodeInclude}


Finally, we output the shape of the interface.


\begin{DoxyCodeInclude}
 \textcolor{comment}{// Open interface solution output file}
 sprintf(filename,\textcolor{stringliteral}{"%s/interface\_soln%i.dat"},
         doc\_info.directory().c\_str(),doc\_info.number());
 some\_file.open(filename);
 
 \textcolor{comment}{// Output solution to file}
 Surface\_mesh\_pt->output(some\_file,npts);
 
 \textcolor{comment}{// Close solution output file}
 some\_file.close();
 
\} \textcolor{comment}{// End of doc\_solution}

\end{DoxyCodeInclude}




 

\hypertarget{index_unsteady_run}{}\section{The timestepping loop}\label{index_unsteady_run}
The function {\ttfamily unsteady\+\_\+run}(...) is used to perform the timestepping procedure. We start by deforming the free surface in the manner specified by equation (9).


\begin{DoxyCodeInclude}
\textcolor{comment}{//==start\_of\_unsteady\_run=================================================}
\textcolor{comment}{/// Perform run up to specified time t\_max with given timestep dt}
\textcolor{comment}{}\textcolor{comment}{//========================================================================}
\textcolor{keyword}{template} <\textcolor{keyword}{class} ELEMENT, \textcolor{keyword}{class} TIMESTEPPER>
\textcolor{keywordtype}{void} \hyperlink{classInterfaceProblem_adf1f4e43d10939e4323e0e315b711085}{InterfaceProblem<ELEMENT,TIMESTEPPER>::}
\hyperlink{classInterfaceProblem_adf1f4e43d10939e4323e0e315b711085}{unsteady\_run}(\textcolor{keyword}{const} \textcolor{keywordtype}{double} &t\_max, \textcolor{keyword}{const} \textcolor{keywordtype}{double} &dt)
\{

 \textcolor{comment}{// Set value of epsilon}
 \textcolor{keyword}{const} \textcolor{keywordtype}{double} epsilon = 0.1;

 \textcolor{comment}{// Set number of periods for cosine term}
 \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} n\_periods = 1;

 \textcolor{comment}{// Deform the mesh/free surface}
 deform\_free\_surface(epsilon,n\_periods);

\end{DoxyCodeInclude}


We then create a {\ttfamily Doc\+Info} object to store the output directory and the label for the output files.


\begin{DoxyCodeInclude}
 \textcolor{comment}{// Initialise DocInfo object}
 DocInfo doc\_info;

 \textcolor{comment}{// Set output directory}
 doc\_info.set\_directory(\textcolor{stringliteral}{"RESLT"});

 \textcolor{comment}{// Initialise counter for solutions}
 doc\_info.number()=0;

\end{DoxyCodeInclude}


Next we open and initialise the trace file.


\begin{DoxyCodeInclude}
 \textcolor{comment}{// Open trace file}
 \textcolor{keywordtype}{char} filename[100];   
 sprintf(filename,\textcolor{stringliteral}{"%s/trace.dat"},doc\_info.directory().c\_str());
 Trace\_file.open(filename);

 \textcolor{comment}{// Initialise trace file}
 Trace\_file << \textcolor{stringliteral}{"time, free surface height"} << std::endl;

\end{DoxyCodeInclude}


Before using any of {\ttfamily oomph-\/lib\textquotesingle{}s} timestepping functions, the timestep $ dt $ must be passed to the problem\textquotesingle{}s timestepping routines by calling the function {\ttfamily Problem\+::initialise\+\_\+dt}(...) which sets the weights for all timesteppers in the problem. Next we assign the initial conditions by calling {\ttfamily Problem\+::set\+\_\+initial\+\_\+condition()}, which was discussed \href{#set_initial_condition}{\tt above}.


\begin{DoxyCodeInclude}
 \textcolor{comment}{// Initialise timestep}
 initialise\_dt(dt);

 \textcolor{comment}{// Set initial conditions}
 set\_initial\_condition();

\end{DoxyCodeInclude}


We determine the number of timesteps to be performed and document the initial conditions, and then perform the actual timestepping loop. For each timestep the function {\ttfamily unsteady\+\_\+newton\+\_\+solve(dt)} is called and the solution documented.


\begin{DoxyCodeInclude}
 \textcolor{comment}{// Determine number of timesteps}
 \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} n\_timestep = unsigned(t\_max/dt);

 \textcolor{comment}{// Doc initial solution}
 doc\_solution(doc\_info);

 \textcolor{comment}{// Increment counter for solutions}
 doc\_info.number()++;

 \textcolor{comment}{// Timestepping loop}
 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} t=1;t<=n\_timestep;t++)
  \{
   \textcolor{comment}{// Output current timestep to screen}
   cout << \textcolor{stringliteral}{"\(\backslash\)nTimestep "} << t << \textcolor{stringliteral}{" of "} << n\_timestep << std::endl;
   
   \textcolor{comment}{// Take one fixed timestep}
   unsteady\_newton\_solve(dt);

   \textcolor{comment}{// Doc solution}
   doc\_solution(doc\_info);

   \textcolor{comment}{// Increment counter for solutions }
   doc\_info.number()++;

  \} \textcolor{comment}{// End of timestepping loop}

\} \textcolor{comment}{// End of unsteady\_run}

\end{DoxyCodeInclude}




 

\hypertarget{index_comments}{}\section{Comments}\label{index_comments}
\hypertarget{index_application_of_dbc}{}\subsection{The application of the dynamic boundary condition within the F\+EM}\label{index_application_of_dbc}
As discussed in an \href{../../rayleigh_traction_channel/html/index.html#traction_theory}{\tt earlier tutorial}, the finite element solution of the Navier--Stokes equations is based on their weak form, which is obtained by weighting the stress-\/divergence form of the momentum equations with the global test functions $ \psi_l $, and integrating by parts to obtain the discrete residuals \[ f_{il} = \int_D \left[ Re\left(St\frac{\partial u_i}{\partial t} + u_j\frac{\partial u_i}{\partial x_j} - \frac{G_i}{Fr}\right) \ \psi_l + \tau_{ij} \ \frac{\partial \psi_l}{\partial x_j} \right] \, dV - \int_{\partial D} \tau_{ij} \ n_j \ \psi_l \ dS = 0. \ \ \ \ \ \ \ \ \ \ (10) \] Weighting the dynamic condition (7) by the same global test functions $ \psi_l $ and integrating over the domain boundary $ \partial D$ gives \[ \int_{\partial D} \tau_{ij} n_j \ \psi_l \ dS = - \int_{\partial D} p_{ext} n_i \ \psi_l \ dS - \int_{\partial D} \frac{1}{Ca} \kappa \ \psi_l \ dS. \ \ \ \ \ \ \ \ \ \ (11) \] In a two-\/dimensional problem, such as the one considered in this tutorial, the domain boundary reduces to a one-\/dimensional curve, $ C $. A further integration by parts of (11) therefore gives \[ \int_{\partial D} \tau_{ij} n_j \ \psi_l \ dS = - \int_C p_{ext} n_i \ \psi_l \ dS + \int_C \frac{1}{Ca} t_i \ \frac{\partial\psi_l}{\partial S} \ dS - \frac{1}{Ca} \left[ t_i \ \psi_l \right]^{c_2}_{c_1}, \ \ \ \ \ \ \ \ \ \ (12) \] where $ t_i $, $ (i=1,2) $ is the $ i $-\/th component of a unit vector tangent to $ C $ and pointing in the direction of increasing $ S $, and $ c_1 $ and $ c_2 $ are the two endpoints of $ C $.

In the problem considered in this tutorial, the domain boundary $ C $ can be written as $ C = C_{solid} \ \cup \ C_{surface} $, where $ C_{solid} $ represents the portion of the domain boundary corresponding to a rigid wall and $ C_{surface} $ represents the portion corresponding to the free surface. The velocity along $ C_{solid} $ is prescribed by Dirichlet boundary conditions, and we \href{../../../intro/html/index.html#galerkin}{\tt recall} that the global test functions $ \psi_l $ vanish in this case. On non-\/\+Dirichlet boundaries we must either specify the external pressure $ p_{ext} $, or deliberately neglect this term to obtain the `natural\textquotesingle{} condition $ p_{ext} = 0 $.\hypertarget{index_contact_line}{}\subsection{The contact line}\label{index_contact_line}
In this two-\/dimensional case, the contact `line\textquotesingle{} actually reduces to two contact points, $ c_1 $ and $ c_2 $, which are located at either side of the portion of the domain boundary corresponding to the free surface $ C_{surface} $. The two point contributions are added by specifying the the tangent to the surface $ t_i $ at each of the contact points, which is equivalent to prescribing the contact angle that the free surface makes with the neighbouring domain boundary. We note that in the problem considered here we do not explicitly apply any boundary conditions at either end of the free surface. Neglecting these contributions corresponds to the `natural\textquotesingle{} condition of prescribing a $ 90^o $ contact angle, which happens to be the appropriate condition in this case. Contact angles of arbitrary size can be enforced using {\ttfamily Fluid\+Interface\+Bounding\+Elements}, which are discussed in a \href{../../static_single_layer/html/index.html#contact_angle}{\tt later tutorial}.

Specifying the contact angle is not the only condition that can be applied at the edges of an interface. The alternative boundary condition is to pin the contact line so that its position is fixed for all time. Since this is a Dirichlet condition it causes the integral over the contact line to vanish.



 

\hypertarget{index_sources}{}\section{Source files for this tutorial}\label{index_sources}

\begin{DoxyItemize}
\item The source files for this tutorial are located in the directory\+: \begin{center} \href{../../../../demo_drivers/navier_stokes/single_layer_free_surface/}{\tt demo\+\_\+drivers/navier\+\_\+stokes/single\+\_\+layer\+\_\+free\+\_\+surface/ } \end{center} 
\item The driver code is\+: \begin{center} \href{../../../../demo_drivers/navier_stokes/single_layer_free_surface/elastic_single_layer.cc}{\tt demo\+\_\+drivers/navier\+\_\+stokes/single\+\_\+layer\+\_\+free\+\_\+surface/elastic\+\_\+single\+\_\+layer.\+cc } \end{center} 
\end{DoxyItemize}



 

 \hypertarget{index_pdf}{}\section{P\+D\+F file}\label{index_pdf}
A \href{../latex/refman.pdf}{\tt pdf version} of this document is available. \end{document}
