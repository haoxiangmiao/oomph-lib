In this example we consider our first time-\/dependent Navier-\/\+Stokes problem and demonstrate how to apply periodic boundary conditions.



\hypertarget{index_example}{}\section{The example problem}\label{index_example}
We consider finite-\/\+Reynolds-\/number flow in a 2D channel that is driven by the oscillatory tangential motion of the \char`\"{}upper\char`\"{} wall\+:

\begin{center} \tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*{1}{|X[-1]}|}
\hline
\begin{center} {\bfseries Unsteady flow in a 2D channel with an oscillating wall.} \end{center}  Here is a sketch of the problem\+:

 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{rayleigh_channel}
\doxyfigcaption{Sketch of the problem. }
\end{DoxyImage}


The flow is governed by the 2D unsteady Navier-\/\+Stokes equations, \[ Re\left(St\frac{\partial u_i}{\partial t} + u_j\frac{\partial u_i}{\partial x_j}\right) = - \frac{\partial p}{\partial x_i} + \frac{\partial }{\partial x_j} \left( \frac{\partial u_i}{\partial x_j} + \frac{\partial u_j}{\partial x_i} \right) \ \ \ \ \ \ \ \ \ \ (1) \] and the continuity equation \[ \frac{\partial u_i}{\partial x_i} = 0 \ \ \ \ \ \ \ \ \ \ (2) \] in the domain \[ D = \bigg\{(x_1,x_2) \ | \ x_1 \in [0,1], \ x_2 \in [0,1] \bigg\}. \] We apply the Dirichlet (no-\/slip) boundary condition \[ \left. \mathbf{u}\right|_{\partial D_{lower}}=(0,0), \ \ \ \ \ \ \ \ \ \ (3) \] on the lower, stationary wall, $ \partial D_{lower} = \big\{(x_1,x_2) \ | \ x_2=0 \big\} $ , apply the Dirichlet (no-\/slip) conditions \[ \left. \mathbf{u}\right|_{\partial D{upper}}=(\sin\left(\omega t\right),0), \ \ \ \ \ \ \ \ \ \ (4) \] on the upper, moving wall , $ \partial D_{upper} = \big\{(x_1,x_2) \ | \ x_2=1 \big\} $ , and apply periodic boundary condition on the \char`\"{}left\char`\"{} and \char`\"{}right\char`\"{} boundaries\+: \[ \left.\mathbf{u}\right|_{x_1=0} = \left.\mathbf{u}\right|_{x_1=1}. \ \ \ \ \ \ \ \ \ \ (5) \] Initial conditions for the velocities are given by \[ {\bf u}(x_1,x_2,t=0) = {\bf u}_{IC}(x_1,x_2), \] where $ {\bf u}_{IC}(x_1,x_2)$ is given.   \\\cline{1-1}
\end{longtabu}
\end{center} 



\hypertarget{index_solution}{}\subsection{The exact solution}\label{index_solution}
The above problem has an exact, time-\/periodic parallel flow solution of the form \[ {\bf u}_{exact}(x_1,x_2,t) = U(x_2,t) \ {\bf e}_1 \mbox{ \ \ \ \ \ and \ \ \ \ } p_{exact}(x_1,x_2,t) = 0, \] where $ U(x_2,t) $ is governed by \[ Re\, St\frac{\partial U}{\partial t} = \frac{\partial^2 U}{\partial x_2^2}, \] subject to the boundary conditions $ U(x_2=0,t)=0$ and $ U(x_2=1,t)=\sin(\omega t)$ . The solution is given by \[ U(x_2,t) = Re\left\{\frac{e^{i\omega t}}{e^{i\lambda}-e^{-i\lambda}} \left(e^{i\lambda y}-e^{-i\lambda y}\right)\right\}, \] where \[ \lambda = i\sqrt{i\omega Re\, St}. \]



\hypertarget{index_results}{}\section{Results}\label{index_results}
The two animations below show the computed solutions obtained from a spatial discretisation with Taylor-\/\+Hood and Crouzeix-\/\+Raviart elements, respectively. In both cases we set $ \omega=2\pi, \ Re = ReSt = 10 $ and specified the exact, time-\/periodic solution as the initial condition, i.\+e. $ {\bf u}_{IC}(x_1,x_2) = {\bf u}_{exact}(x_1,x_2,t=0)$ . The computed solutions agree extremely well with the exact solution throughout the simulation.

 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{velocity_vectors_CR}
\doxyfigcaption{Plot of the velocity field computed with 2D Crouzeix-\/\+Raviart elements, starting form the exact, time-\/periodic solution. }
\end{DoxyImage}


 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{velocity_vectors_TH}
\doxyfigcaption{Plot of the velocity field computed with 2D Taylor-\/\+Hood elements, starting form the exact, time-\/periodic solution. }
\end{DoxyImage}


If the simulation is started from other initial conditions, i.\+e. $ {\bf u}_{IC}(x_1,x_2) \ne {\bf u}_{exact}(x_1,x_2,t=0)$ , the velocity field initially differs noticeably from the time-\/periodic solution $ {\bf u}_{exact}(x_1,x_2,t)$ but following the decay of initial transients we have \[ \lim_{t\to \infty} {\bf u}(x_1,x_2,t) = {\bf u}_{exact}(x_1,x_2,t). \] This is illustrated in the following plot which shows the evolution of the L2-\/\char`\"{}error\char`\"{} between the computed and the time-\/periodic solutions for two different initial conditions. The red line was obtained from a simulation in which $ {\bf u}_{IC}(x_1,x_2) = {\bf u}_{exact}(x_1,x_2,t=0)$ ; the blue line was obtained from a computation in which the simulation was started by an \char`\"{}impulsive start\char`\"{}, $ {\bf u}_{IC}(x_1,x_2) = {\bf 0}$ .

 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{error}
\doxyfigcaption{Plot of the L2-\/\textquotesingle{}errors\textquotesingle{} between the computed and time-\/periodic solution for two different initial conditions. }
\end{DoxyImage}


The animations of the simulations for the \char`\"{}impulsive start\char`\"{} (for \href{../figures/velocity_vectors_TH.avi}{\tt Taylor-\/\+Hood} and \href{../figures/velocity_vectors_CR.avi}{\tt Crouzeix-\/\+Raviart elements}) show how the velocity profile approaches the time-\/periodic solution as the simulation progresses.



 

\hypertarget{index_namespace}{}\section{The global parameters}\label{index_namespace}
As usual, we use a namespace to define the problem parameters, the Reynolds number, $ Re$ , and the Womersley number, $ Re\, St$ . We also provide two flags that indicate the length of the run (to allow a short run to be performed when the code is run as a self-\/test), and the initial condition (allowing a start from $ {\bf u}_{exact}$ or an impulsive start in which the fluid is initially at rest).

 
\begin{DoxyCodeInclude}
\textcolor{comment}{//===start\_of\_namespace=================================================}
\textcolor{comment}{/// Namespace for global parameters}
\textcolor{comment}{}\textcolor{comment}{//======================================================================}
\textcolor{keyword}{namespace }\hyperlink{namespaceGlobal__Parameters}{Global\_Parameters}
\{\textcolor{comment}{}
\textcolor{comment}{ /// Reynolds number}
\textcolor{comment}{} \textcolor{keywordtype}{double} \hyperlink{namespaceGlobal__Parameters_a9d72e94a9305c6a310940a6a427ebe06}{Re};
\textcolor{comment}{}
\textcolor{comment}{ /// Womersley = Reynolds times Strouhal}
\textcolor{comment}{} \textcolor{keywordtype}{double} \hyperlink{namespaceGlobal__Parameters_a7a59a32365e87566069e458dc83bd18a}{ReSt};
\textcolor{comment}{}
\textcolor{comment}{ /// Flag for long/short run: Default =  perform long run}
\textcolor{comment}{} \textcolor{keywordtype}{unsigned} \hyperlink{namespaceGlobal__Parameters_a457472b8222bb6bb0d97b2aed78d1ef4}{Long\_run\_flag}=1;
\textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Flag for impulsive start: Default = start from exact}
\textcolor{comment}{ /// time-periodic solution. }
\textcolor{comment}{} \textcolor{keywordtype}{unsigned} \hyperlink{namespaceGlobal__Parameters_aec41eb8da4929003e5d78ef4b43c0ed9}{Impulsive\_start\_flag}=0;

\} \textcolor{comment}{// end of namespace}

\end{DoxyCodeInclude}




 

\hypertarget{index_exact}{}\section{The exact solution}\label{index_exact}
We use another namespace to define the exact, time-\/periodic parallel-\/flow solution\+:

 
\begin{DoxyCodeInclude}
\textcolor{comment}{//==start\_of\_exact\_solution=============================================}
\textcolor{comment}{/// Namespace for exact solution}
\textcolor{comment}{}\textcolor{comment}{//======================================================================}
\textcolor{keyword}{namespace }\hyperlink{namespaceExactSoln}{ExactSoln}
\{
 \textcolor{comment}{}
\textcolor{comment}{ /// Exact solution of the problem as a vector}
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{namespaceExactSoln_a2598550281dd62f4160edb3d0b2e5432}{get\_exact\_u}(\textcolor{keyword}{const} \textcolor{keywordtype}{double}& t, \textcolor{keyword}{const} Vector<double>& x, Vector<double>& u)
 \{
  \textcolor{keywordtype}{double} y=x[1];
  \textcolor{comment}{// I=sqrt(-1)}
  complex<double> I(0.0,1.0);
  \textcolor{comment}{// omega}
  \textcolor{keywordtype}{double} omega=2.0*MathematicalConstants::Pi;
  \textcolor{comment}{// lambda}
  complex<double> lambda(0.0,omega*\hyperlink{namespaceGlobal__Parameters_a7a59a32365e87566069e458dc83bd18a}{Global\_Parameters::ReSt});
  lambda = I*sqrt(lambda);

  \textcolor{comment}{// Solution}
  complex<double> sol(
   exp(complex<double>(0.0,omega*t)) * 
   (exp(lambda*complex<double>(0.0,y))-exp(lambda*complex<double>(0.0,-y)))
   /(exp(I*lambda)-exp(-I*lambda)) );
  
  \textcolor{comment}{// Assign real solution}
  u.resize(2);
  u[0]=real(sol);
  u[1]=0.0;
 \}
\textcolor{comment}{}
\textcolor{comment}{ /// Exact solution of the problem as a scalar}
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{namespaceExactSoln_a2598550281dd62f4160edb3d0b2e5432}{get\_exact\_u}(\textcolor{keyword}{const} \textcolor{keywordtype}{double}& t, \textcolor{keyword}{const} \textcolor{keywordtype}{double}& y,\textcolor{keywordtype}{double}& u)
 \{
  \textcolor{comment}{// I=sqrt(-1)}
  complex<double> I(0.0,1.0);
  \textcolor{comment}{// omega}
  \textcolor{keywordtype}{double} omega=2.0*MathematicalConstants::Pi;
  \textcolor{comment}{// lambda}
  complex<double> lambda(0.0,omega*\hyperlink{namespaceGlobal__Parameters_a7a59a32365e87566069e458dc83bd18a}{Global\_Parameters::ReSt});
  lambda = I*sqrt(lambda);
  \textcolor{comment}{// Solution}
  complex<double> sol(
   exp(complex<double>(0.0,omega*t)) * 
   (exp(lambda*complex<double>(0.0,y))-exp(lambda*complex<double>(0.0,-y)))
   /(exp(I*lambda)-exp(-I*lambda)) );

  \textcolor{comment}{// Assign real solution}
  u=real(sol);

 \}

\} \textcolor{comment}{// end of exact\_solution}

\end{DoxyCodeInclude}




 

\hypertarget{index_main}{}\section{The driver code}\label{index_main}
We use optional command line arguments to specify which mode the code is run in\+: Either as a short or a long run (indicated by the first command line argument being 0 or 1, respectively), and with initial conditions corresponding to an impulsive start or a start from the time-\/periodic exact solution (indicated by the second command line argument being 1 or 0, respectively). If no command line arguments are specified the code is run in the default mode, specified by the parameter values assigned in the namespace {\ttfamily \hyperlink{namespaceGlobal__Parameters}{Global\+\_\+\+Parameters}}.


\begin{DoxyCodeInclude}
\textcolor{comment}{//===start\_of\_main======================================================}
\textcolor{comment}{/// Driver code for Rayleigh channel problem}
\textcolor{comment}{}\textcolor{comment}{//======================================================================}
\textcolor{keywordtype}{int} \hyperlink{rayleigh__channel_8cc_a0ddf1224851353fc92bfbff6f499fa97}{main}(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char}* argv[]) 
\{
\textcolor{comment}{}
\textcolor{comment}{ /// Convert command line arguments (if any) into flags:}
\textcolor{comment}{} \textcolor{keywordflow}{if} (argc==1)
  \{
   cout << \textcolor{stringliteral}{"No command line arguments specified -- using defaults."} 
        << std::endl;
  \}
 \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (argc==3)
  \{
   cout << \textcolor{stringliteral}{"Two command line arguments specified:"} << std::endl;
   \textcolor{comment}{// Flag for long run}
   \hyperlink{namespaceGlobal__Parameters_a457472b8222bb6bb0d97b2aed78d1ef4}{Global\_Parameters::Long\_run\_flag}=atoi(argv[1]);\textcolor{comment}{}
\textcolor{comment}{   /// Flag for impulsive start}
\textcolor{comment}{}   \hyperlink{namespaceGlobal__Parameters_aec41eb8da4929003e5d78ef4b43c0ed9}{Global\_Parameters::Impulsive\_start\_flag}=atoi(argv[2]);
  \}
 \textcolor{keywordflow}{else}
  \{
   std::string error\_message = 
    \textcolor{stringliteral}{"Wrong number of command line arguments. Specify none or two.\(\backslash\)n"};
   error\_message +=
    \textcolor{stringliteral}{"Arg1: Long\_run\_flag [0/1]\(\backslash\)n"};
   error\_message +=
    \textcolor{stringliteral}{"Arg2: Impulsive\_start\_flag [0/1]\(\backslash\)n"};

   \textcolor{keywordflow}{throw} OomphLibError(error\_message,
                       OOMPH\_CURRENT\_FUNCTION,
                       OOMPH\_EXCEPTION\_LOCATION);
  \}
 cout << \textcolor{stringliteral}{"Long run flag: "} 
      <<  \hyperlink{namespaceGlobal__Parameters_a457472b8222bb6bb0d97b2aed78d1ef4}{Global\_Parameters::Long\_run\_flag} << std::endl;
 cout << \textcolor{stringliteral}{"Impulsive start flag: "} 
      <<  \hyperlink{namespaceGlobal__Parameters_aec41eb8da4929003e5d78ef4b43c0ed9}{Global\_Parameters::Impulsive\_start\_flag} << std::endl;

\end{DoxyCodeInclude}


Next we set the physical and mesh parameters.


\begin{DoxyCodeInclude}


 \textcolor{comment}{// Set physical parameters:}

 \textcolor{comment}{// Womersley number = Reynolds number (St = 1)}
 \hyperlink{namespaceGlobal__Parameters_a7a59a32365e87566069e458dc83bd18a}{Global\_Parameters::ReSt} = 10.0;
 \hyperlink{namespaceGlobal__Parameters_a9d72e94a9305c6a310940a6a427ebe06}{Global\_Parameters::Re} = \hyperlink{namespaceGlobal__Parameters_a7a59a32365e87566069e458dc83bd18a}{Global\_Parameters::ReSt};

 \textcolor{comment}{//Horizontal length of domain}
 \textcolor{keywordtype}{double} lx = 1.0;

 \textcolor{comment}{//Vertical length of domain}
 \textcolor{keywordtype}{double} ly = 1.0;

 \textcolor{comment}{// Number of elements in x-direction}
 \textcolor{keywordtype}{unsigned} nx=5;

 \textcolor{comment}{// Number of elements in y-direction}
 \textcolor{keywordtype}{unsigned} ny=10;

\end{DoxyCodeInclude}


Finally we set up {\ttfamily Doc\+Info} objects and solve for both Taylor-\/\+Hood elements and Crouzeix-\/\+Raviart elements.


\begin{DoxyCodeInclude}

 \textcolor{comment}{// Solve with Crouzeix-Raviart elements}
 \{
  \textcolor{comment}{// Set up doc info}
  DocInfo doc\_info;
  doc\_info.number()=0;
  doc\_info.set\_directory(\textcolor{stringliteral}{"RESLT\_CR"});
  
  \textcolor{comment}{//Set up problem}
  \hyperlink{classRayleighProblem}{RayleighProblem<QCrouzeixRaviartElement<2>},BDF<2> > problem(nx,
      ny,lx,ly);
  
  \textcolor{comment}{// Run the unsteady simulation}
  problem.unsteady\_run(doc\_info);
 \}



 \textcolor{comment}{// Solve with Taylor-Hood elements}
 \{
  \textcolor{comment}{// Set up doc info}
  DocInfo doc\_info;
  doc\_info.number()=0;
  doc\_info.set\_directory(\textcolor{stringliteral}{"RESLT\_TH"});

  \textcolor{comment}{//Set up problem}
  \hyperlink{classRayleighProblem}{RayleighProblem<QTaylorHoodElement<2>},BDF<2> > problem(nx,ny,lx,ly);
  
  \textcolor{comment}{// Run the unsteady simulation}
  problem.unsteady\_run(doc\_info);
 \}

\} \textcolor{comment}{// end of main}

\end{DoxyCodeInclude}




 

\hypertarget{index_problem}{}\section{The problem class}\label{index_problem}
The problem class is very similar to that used in the \href{../../driven_cavity/html/index.html}{\tt driven cavity example}. We specify the type of the element and the type of the timestepper (assumed to be a member of the B\+DF family) as template parameters and pass the mesh parameters to the problem constructor.

 
\begin{DoxyCodeInclude}
\textcolor{comment}{//===start\_of\_problem\_class=============================================}
\textcolor{comment}{/// Rayleigh-type problem: 2D channel whose upper}
\textcolor{comment}{}\textcolor{comment}{/// wall oscillates periodically.}
\textcolor{comment}{}\textcolor{comment}{//======================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT, \textcolor{keyword}{class} TIMESTEPPER>
\textcolor{keyword}{class }\hyperlink{classRayleighProblem}{RayleighProblem} : \textcolor{keyword}{public} Problem
\{
\textcolor{keyword}{public}:
\textcolor{comment}{}
\textcolor{comment}{ /// Constructor: Pass number of elements in x and y directions and }
\textcolor{comment}{ /// lengths}
\textcolor{comment}{} \hyperlink{classRayleighProblem_a53aeda7918553889b3fa0dd70cdb30f1}{RayleighProblem}(\textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} &nx, \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} &ny, 
                 \textcolor{keyword}{const} \textcolor{keywordtype}{double} &lx, \textcolor{keyword}{const} \textcolor{keywordtype}{double} &ly);

\end{DoxyCodeInclude}


No action is needed before or after solving, but we update the time-\/dependent boundary conditions at the upper wall before each timestep, using {\ttfamily Problem\+::actions\+\_\+before\+\_\+implicit\+\_\+timestep()}. The boundary values are obtained from the exact solution, defined in the namespace {\ttfamily \hyperlink{namespaceExactSoln}{Exact\+Soln}}.


\begin{DoxyCodeInclude}

 \textcolor{comment}{//Update before solve is empty}
 \textcolor{keywordtype}{void} actions\_before\_newton\_solve() \{\}
\textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Update after solve is empty}
\textcolor{comment}{} \textcolor{keywordtype}{void} actions\_after\_newton\_solve() \{\}

 \textcolor{comment}{//Actions before timestep: Update no slip on upper oscillating wall}
 \textcolor{keywordtype}{void} actions\_before\_implicit\_timestep()
  \{
   \textcolor{comment}{// No slip on upper boundary}
   \textcolor{keywordtype}{unsigned} ibound=2;
   \textcolor{keywordtype}{unsigned} num\_nod=mesh\_pt()->nboundary\_node(ibound);
   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} inod=0;inod<num\_nod;inod++)
    \{
     \textcolor{comment}{// Get exact solution}
     \textcolor{keywordtype}{double} y=mesh\_pt()->boundary\_node\_pt(ibound,inod)->x(1);
     \textcolor{keywordtype}{double} time=time\_pt()->time();
     \textcolor{keywordtype}{double} soln;
     \hyperlink{namespaceExactSoln_a2598550281dd62f4160edb3d0b2e5432}{ExactSoln::get\_exact\_u}(time,y,soln);
     
     \textcolor{comment}{// Assign exact solution to boundary}
     mesh\_pt()->boundary\_node\_pt(ibound,inod)->set\_value(0,soln);
     mesh\_pt()->boundary\_node\_pt(ibound,inod)->set\_value(1,0.0);
    \}

  \} \textcolor{comment}{// end of actions\_before\_implicit\_timestep}

\end{DoxyCodeInclude}


The function {\ttfamily unsteady\+\_\+run}(...), discussed below, performs the timestepping and documents the solution in the directory specified in the {\ttfamily Doc\+Info} object.


\begin{DoxyCodeInclude}
   \textcolor{comment}{}
\textcolor{comment}{ /// Run an unsteady simulation}
\textcolor{comment}{} \textcolor{keywordtype}{void} unsteady\_run(DocInfo& doc\_info); 

\end{DoxyCodeInclude}


We define the function {\ttfamily doc\+\_\+solution}(...) which documents the results, and provide functions to set the initial conditions and to fix a pressure value. The problem\textquotesingle{}s only member data contains an output stream in which we record the time-\/trace of the solution.


\begin{DoxyCodeInclude}
 \textcolor{comment}{}
\textcolor{comment}{ /// Doc the solution}
\textcolor{comment}{} \textcolor{keywordtype}{void} doc\_solution(DocInfo& doc\_info);
\textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Set initial condition (incl previous timesteps) according}
\textcolor{comment}{ /// to specified function. }
\textcolor{comment}{} \textcolor{keywordtype}{void} set\_initial\_condition();

\textcolor{keyword}{private}:
\textcolor{comment}{}
\textcolor{comment}{ ///Fix pressure in element e at pressure dof pdof and set to pvalue}
\textcolor{comment}{} \textcolor{keywordtype}{void} fix\_pressure(\textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} &e, \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} &pdof, 
                   \textcolor{keyword}{const} \textcolor{keywordtype}{double} &pvalue)
  \{
   \textcolor{comment}{//Cast to proper element and fix pressure}
   \textcolor{keyword}{dynamic\_cast<}ELEMENT*\textcolor{keyword}{>}(mesh\_pt()->element\_pt(e))->
                          fix\_pressure(pdof,pvalue);
  \}
\textcolor{comment}{}
\textcolor{comment}{ /// Trace file}
\textcolor{comment}{} ofstream Trace\_file;

\}; \textcolor{comment}{// end of problem\_class}

\end{DoxyCodeInclude}




 

\hypertarget{index_constructor}{}\section{The problem constructor}\label{index_constructor}
We start by building the timestepper, determining its type from the class\textquotesingle{}s second template argument, and pass a pointer to it to the Problem, using the function {\ttfamily Problem\+::add\+\_\+time\+\_\+stepper\+\_\+pt}(...).


\begin{DoxyCodeInclude}
\textcolor{comment}{//===start\_of\_constructor=============================================}
\textcolor{comment}{/// Problem constructor}
\textcolor{comment}{}\textcolor{comment}{//====================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT,\textcolor{keyword}{class} TIMESTEPPER>
\hyperlink{classRayleighProblem_a53aeda7918553889b3fa0dd70cdb30f1}{RayleighProblem<ELEMENT,TIMESTEPPER>::RayleighProblem}
(\textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} &nx, \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} &ny,
 \textcolor{keyword}{const} \textcolor{keywordtype}{double} &lx, \textcolor{keyword}{const} \textcolor{keywordtype}{double}& ly)
\{
 \textcolor{comment}{//Allocate the timestepper}
 add\_time\_stepper\_pt(\textcolor{keyword}{new} TIMESTEPPER); 

\end{DoxyCodeInclude}


Next we build the mesh and pass an additional boolean flag to the constructor to indicate that periodic boundary conditions are to be applied in the $ x_1$ -\/direction. We will discuss the implementation of this feature in more detail in \href{#periodic}{\tt below}.


\begin{DoxyCodeInclude}

 \textcolor{comment}{//Now create the mesh with periodic boundary conditions in x direction}
 \textcolor{keywordtype}{bool} periodic\_in\_x=\textcolor{keyword}{true};
 Problem::mesh\_pt() = 
  \textcolor{keyword}{new} RectangularQuadMesh<ELEMENT>(nx,ny,lx,ly,periodic\_in\_x,
                                   time\_stepper\_pt());

\end{DoxyCodeInclude}


We pin both velocity components on the top and bottom boundaries (i.\+e. at $ x_2=0$ and $ x_2=1$ , respectively), and pin the vertical velocity on the left and right boundaries (i.\+e. at $ x_1=0 $ and $ x_1=1 $ , respectively) to enforce horizontal outflow through the periodic boundaries.


\begin{DoxyCodeInclude}

 \textcolor{comment}{// Set the boundary conditions for this problem: All nodes are}
 \textcolor{comment}{// free by default -- just pin the ones that have Dirichlet conditions}
 \textcolor{comment}{// here}
 \textcolor{keywordtype}{unsigned} num\_bound=mesh\_pt()->nboundary();
 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} ibound=0;ibound<num\_bound;ibound++)
  \{
   \textcolor{keywordtype}{unsigned} num\_nod=mesh\_pt()->nboundary\_node(ibound);
   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} inod=0;inod<num\_nod;inod++)
    \{
     \textcolor{comment}{// No slip on top and bottom}
     \textcolor{keywordflow}{if} ((ibound==0)||(ibound==2))
      \{
       mesh\_pt()->boundary\_node\_pt(ibound,inod)->pin(0);
       mesh\_pt()->boundary\_node\_pt(ibound,inod)->pin(1);
      \}
     \textcolor{comment}{// Horizontal outflow on the left (and right -- right bc not}
     \textcolor{comment}{// strictly necessary because of symmetry)}
     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ((ibound==1)||(ibound==3))
      \{
       mesh\_pt()->boundary\_node\_pt(ibound,inod)->pin(1);
      \}
    \}
  \} \textcolor{comment}{// end loop over boundaries}

\end{DoxyCodeInclude}


Finally we pass the pointers to the Reynolds and Strouhal numbers, $ Re $ and $ Re\, St $ , to the elements. Since no traction boundary conditions are applied anywhere, the pressure is only determined up to an arbitrary constant. To ensure a unique solution we pin a single pressure value before setting up the equation numbering scheme.


\begin{DoxyCodeInclude}

 \textcolor{comment}{//Complete the problem setup to make the elements fully functional}

 \textcolor{comment}{//Loop over the elements}
 \textcolor{keywordtype}{unsigned} n\_el = mesh\_pt()->nelement();
 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} e=0;e<n\_el;e++)
  \{
   \textcolor{comment}{//Cast to a fluid element}
   ELEMENT *el\_pt = \textcolor{keyword}{dynamic\_cast<}ELEMENT*\textcolor{keyword}{>}(mesh\_pt()->element\_pt(e));

   \textcolor{comment}{//Set the Reynolds number, etc}
   el\_pt->re\_pt() = &\hyperlink{namespaceGlobal__Parameters_a9d72e94a9305c6a310940a6a427ebe06}{Global\_Parameters::Re};
   el\_pt->re\_st\_pt() = &\hyperlink{namespaceGlobal__Parameters_a7a59a32365e87566069e458dc83bd18a}{Global\_Parameters::ReSt};
  \}

 \textcolor{comment}{// Now pin the pressure in first element at value 0 to 0.0}
 fix\_pressure(0,0,0.0);

 \textcolor{comment}{//Assgn equation numbers}
 cout << assign\_eqn\_numbers() << std::endl; 
\} \textcolor{comment}{// end of constructor}

\end{DoxyCodeInclude}




 

\hypertarget{index_IC}{}\section{Initial conditions}\label{index_IC}
The application of initial conditions for vector-\/valued problems is performed by the same procedure that we described for \href{../../../unsteady_heat/two_d_unsteady_heat/html/index.html#IC}{\tt scalar problems}, except that we now have to assign \char`\"{}history
values\char`\"{} for multiple nodal values. For timesteppers from the B\+DF family, the \char`\"{}history values\char`\"{} represent the solution at previous timesteps. We check that the timestepper is of the appropriate type, loop over previous time levels, determine the velocity at those times and assign them to the \char`\"{}history values\char`\"{} of the velocities. No initial conditions are required for the pressure. Note that we also have to assign \char`\"{}history values\char`\"{} for the nodal positions since {\ttfamily oomph-\/lib\textquotesingle{}s} Navier-\/\+Stokes elements discretise the momentum equations in their A\+LE form. This aspect was explained in more detail in our discussion of the solution of the \href{../../../unsteady_heat/two_d_unsteady_heat/html/index.html#IC}{\tt unsteady heat equation}.


\begin{DoxyCodeInclude}
\textcolor{comment}{//======================start\_of\_set\_initial\_condition====================}
\textcolor{comment}{/// \(\backslash\)short Set initial condition: Assign previous and current values}
\textcolor{comment}{}\textcolor{comment}{/// from exact solution.}
\textcolor{comment}{}\textcolor{comment}{//========================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT,\textcolor{keyword}{class} TIMESTEPPER>
\textcolor{keywordtype}{void} \hyperlink{classRayleighProblem_a5c54c02c45c656cabbe8f8808e2cfd6b}{RayleighProblem<ELEMENT,TIMESTEPPER>::set\_initial\_condition}
      ()
\{ 

 \textcolor{comment}{// Check that timestepper is from the BDF family}
 \textcolor{keywordflow}{if} (time\_stepper\_pt()->type()!=\textcolor{stringliteral}{"BDF"})
  \{
   std::ostringstream error\_stream;
   error\_stream << \textcolor{stringliteral}{"Timestepper has to be from the BDF family!\(\backslash\)n"}
                << \textcolor{stringliteral}{"You have specified a timestepper from the "}
                << time\_stepper\_pt()->type() << \textcolor{stringliteral}{" family"} << std::endl;

   \textcolor{keywordflow}{throw} OomphLibError(error\_stream.str(),
                       OOMPH\_CURRENT\_FUNCTION,
                       OOMPH\_EXCEPTION\_LOCATION);
  \}

 \textcolor{comment}{// Backup time in global Time object}
 \textcolor{keywordtype}{double} backed\_up\_time=time\_pt()->time();
         
 \textcolor{comment}{// Past history needs to be established for t=time0-deltat, ...}
 \textcolor{comment}{// Then provide current values (at t=time0) which will also form}
 \textcolor{comment}{// the initial guess for the first solve at t=time0+deltat}
 
 \textcolor{comment}{// Vector of exact solution value}
 Vector<double> soln(2);
 Vector<double> x(2);

 \textcolor{comment}{//Find number of nodes in mesh}
 \textcolor{keywordtype}{unsigned} num\_nod = mesh\_pt()->nnode();

 \textcolor{comment}{// Set continuous times at previous timesteps:}
 \textcolor{comment}{// How many previous timesteps does the timestepper use?}
 \textcolor{keywordtype}{int} nprev\_steps=time\_stepper\_pt()->nprev\_values();
 Vector<double> prev\_time(nprev\_steps+1);
 \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} t=nprev\_steps;t>=0;t--)
  \{
   prev\_time[t]=time\_pt()->time(\textcolor{keywordtype}{unsigned}(t));
  \} 

 \textcolor{comment}{// Loop over current & previous timesteps}
 \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} t=nprev\_steps;t>=0;t--)
  \{
   \textcolor{comment}{// Continuous time}
   \textcolor{keywordtype}{double} time=prev\_time[t];
   cout << \textcolor{stringliteral}{"setting IC at time ="} << time << std::endl;
   
   \textcolor{comment}{// Loop over the nodes to set initial guess everywhere}
   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} n=0;n<num\_nod;n++)
    \{
     \textcolor{comment}{// Get nodal coordinates}
     x[0]=mesh\_pt()->node\_pt(n)->x(0);
     x[1]=mesh\_pt()->node\_pt(n)->x(1);

     \textcolor{comment}{// Get exact solution at previous time}
     \hyperlink{namespaceExactSoln_a2598550281dd62f4160edb3d0b2e5432}{ExactSoln::get\_exact\_u}(time,x,soln);
     
     \textcolor{comment}{// Assign solution}
     mesh\_pt()->node\_pt(n)->set\_value(t,0,soln[0]);
     mesh\_pt()->node\_pt(n)->set\_value(t,1,soln[1]);
     
     \textcolor{comment}{// Loop over coordinate directions: Mesh doesn't move, so }
     \textcolor{comment}{// previous position = present position}
     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} i=0;i<2;i++)
      \{
       mesh\_pt()->node\_pt(n)->x(t,i)=x[i];
      \}
    \} 
  \}

 \textcolor{comment}{// Reset backed up time for global timestepper}
 time\_pt()->time()=backed\_up\_time;

\} \textcolor{comment}{// end of set\_initial\_condition}

\end{DoxyCodeInclude}




 

\hypertarget{index_doc}{}\section{Post processing}\label{index_doc}
The function {\ttfamily doc\+\_\+solution}(...) is similar to those used in the \href{../../../unsteady_heat/two_d_unsteady_heat/html/index.html#doc}{\tt unsteady heat examples}. We plot the computed solution, the time-\/periodic exact solution and the difference between the two, and record various parameters in the trace file. The plot of the computed solution contains tecplot instructions that generate a blue line in the top-\/left corner of the plot to indicate how time progresses during the simulation. The trace file contains a record of
\begin{DoxyItemize}
\item the value of the continuous time, $ t $ ,
\item the coordinates of a control node, $ (x_1^{[c]},x_2^{[c]})$ ,
\item the computed velocity at the control node, $( u_1^{[c]},u_2^{[c]})$ ,
\item the time-\/periodic solution, evaluated at the control node, $ (u_1^{[c,exact]},u_2^{[c,exact]})$ ,
\item the difference between the computed velocities and the time-\/periodic solution at the control node,
\item the L2 norm of the \char`\"{}error\char`\"{} between the computed and time-\/periodic solution for the velocity, and
\item the L2 norm of the time-\/periodic solution for the velocity.
\end{DoxyItemize}


\begin{DoxyCodeInclude}
\textcolor{comment}{//==start\_of\_doc\_solution=================================================}
\textcolor{comment}{/// Doc the solution}
\textcolor{comment}{}\textcolor{comment}{//========================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT,\textcolor{keyword}{class} TIMESTEPPER>
\textcolor{keywordtype}{void} \hyperlink{classRayleighProblem_aca1b0f4134bc745c75ae524450e97109}{RayleighProblem<ELEMENT,TIMESTEPPER>::doc\_solution}(
      DocInfo& doc\_info)
\{ 
 ofstream some\_file;
 \textcolor{keywordtype}{char} filename[100];

 \textcolor{comment}{// Number of plot points}
 \textcolor{keywordtype}{unsigned} npts=5; 

 \textcolor{comment}{// Output solution }
 sprintf(filename,\textcolor{stringliteral}{"%s/soln%i.dat"},doc\_info.directory().c\_str(),
         doc\_info.number());
 some\_file.open(filename);
 mesh\_pt()->output(some\_file,npts);

 \textcolor{comment}{// Write file as a tecplot text object}
 some\_file << \textcolor{stringliteral}{"TEXT X=2.5,Y=93.6,F=HELV,HU=POINT,C=BLUE,H=26,T=\(\backslash\)"time = "} 
           << time\_pt()->time() << \textcolor{stringliteral}{"\(\backslash\)""};
 \textcolor{comment}{// ...and draw a horizontal line whose length is proportional}
 \textcolor{comment}{// to the elapsed time}
 some\_file << \textcolor{stringliteral}{"GEOMETRY X=2.5,Y=98,T=LINE,C=BLUE,LT=0.4"} << std::endl;
 some\_file << \textcolor{stringliteral}{"1"} << std::endl;
 some\_file << \textcolor{stringliteral}{"2"} << std::endl;
 some\_file << \textcolor{stringliteral}{" 0 0"} << std::endl;
 some\_file << time\_pt()->time()*20.0 << \textcolor{stringliteral}{" 0"} << std::endl;

 some\_file.close();
 
 \textcolor{comment}{// Output exact solution }
 \textcolor{comment}{//----------------------}
 sprintf(filename,\textcolor{stringliteral}{"%s/exact\_soln%i.dat"},doc\_info.directory().c\_str(),
         doc\_info.number());
 some\_file.open(filename);
 mesh\_pt()->output\_fct(some\_file,npts,time\_pt()->time(),
                       \hyperlink{namespaceExactSoln_a2598550281dd62f4160edb3d0b2e5432}{ExactSoln::get\_exact\_u}); 
 some\_file.close();

 \textcolor{comment}{// Doc error}
 \textcolor{comment}{//----------}
 \textcolor{keywordtype}{double} error,norm;
 sprintf(filename,\textcolor{stringliteral}{"%s/error%i.dat"},doc\_info.directory().c\_str(),
         doc\_info.number());
 some\_file.open(filename);
 mesh\_pt()->compute\_error(some\_file,
                          \hyperlink{namespaceExactSoln_a2598550281dd62f4160edb3d0b2e5432}{ExactSoln::get\_exact\_u},
                          time\_pt()->time(),
                          error,norm); 
 some\_file.close();

 \textcolor{comment}{// Doc solution and error}
 \textcolor{comment}{//-----------------------}
 cout << \textcolor{stringliteral}{"error: "} << error << std::endl; 
 cout << \textcolor{stringliteral}{"norm : "} << norm << std::endl << std::endl;

 \textcolor{comment}{// Get time, position and exact soln at control node }
 \textcolor{keywordtype}{unsigned} n\_control=37;
 Vector<double> x(2), u(2);
 \textcolor{keywordtype}{double} time=time\_pt()->time();
 Node* node\_pt=
  \textcolor{keyword}{dynamic\_cast<}ELEMENT*\textcolor{keyword}{>}(mesh\_pt()->element\_pt(n\_control))->node\_pt(1);
 x[0] = node\_pt->x(0);
 x[1] = node\_pt->x(1);
 \hyperlink{namespaceExactSoln_a2598550281dd62f4160edb3d0b2e5432}{ExactSoln::get\_exact\_u}(time,x,u);

 \textcolor{comment}{// Write trace file}
 Trace\_file << time << \textcolor{stringliteral}{" "} 
            << x[0] << \textcolor{stringliteral}{" "}
            << x[1] << \textcolor{stringliteral}{" "}
            << node\_pt->value(0) << \textcolor{stringliteral}{" "}
            << node\_pt->value(1) << \textcolor{stringliteral}{" "}
            << u[0] << \textcolor{stringliteral}{" "}
            << u[1] << \textcolor{stringliteral}{" "} 
            << abs(u[0]-node\_pt->value(0)) << \textcolor{stringliteral}{" "}
            << abs(u[1]-node\_pt->value(1)) << \textcolor{stringliteral}{" "} 
            << error << \textcolor{stringliteral}{" "}
            << norm << \textcolor{stringliteral}{" "}
            << std::endl;


\} \textcolor{comment}{// end\_of\_doc\_solution   }

\end{DoxyCodeInclude}




 

\hypertarget{index_unsteady_run}{}\section{The timestepping loop}\label{index_unsteady_run}
The function {\ttfamily unsteady\+\_\+run}(...) is used to perform the timestepping procedure. We start by opening the trace file and write a suitable header for the visualisation with tecplot.


\begin{DoxyCodeInclude}
\textcolor{comment}{//===start\_of\_unsteady\_run=====================================================}
\textcolor{comment}{/// Unsteady run...}
\textcolor{comment}{}\textcolor{comment}{//=============================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT,\textcolor{keyword}{class} TIMESTEPPER>
\textcolor{keywordtype}{void} \hyperlink{classRayleighProblem_a7404085b8be8865ffc07fd4133e40151}{RayleighProblem<ELEMENT,TIMESTEPPER>::unsteady\_run}(
      DocInfo& doc\_info)
\{

 \textcolor{comment}{// Open trace file}
 \textcolor{keywordtype}{char} filename[100];   
 sprintf(filename,\textcolor{stringliteral}{"%s/trace.dat"},doc\_info.directory().c\_str());
 Trace\_file.open(filename);

 \textcolor{comment}{// Write tecplot header for trace file}
 Trace\_file << \textcolor{stringliteral}{"time"} << \textcolor{stringliteral}{",      "} 
            << \textcolor{stringliteral}{"x"} << \textcolor{stringliteral}{",         "}
            << \textcolor{stringliteral}{"y"} << \textcolor{stringliteral}{",         "}
            << \textcolor{stringliteral}{"u\_1"} << \textcolor{stringliteral}{",       "}
            << \textcolor{stringliteral}{"u\_2"} << \textcolor{stringliteral}{",       "}
            << \textcolor{stringliteral}{"u\_exact\_1"} << \textcolor{stringliteral}{", "}
            << \textcolor{stringliteral}{"u\_exact\_2"} << \textcolor{stringliteral}{", "}
            << \textcolor{stringliteral}{"error\_1"} << \textcolor{stringliteral}{",   "}
            << \textcolor{stringliteral}{"error\_2"} << \textcolor{stringliteral}{",   "} 
            << \textcolor{stringliteral}{"L2 error"} << \textcolor{stringliteral}{",  "}
            << \textcolor{stringliteral}{"L2 norm"} << \textcolor{stringliteral}{",   "} << std::endl;

\end{DoxyCodeInclude}


Next, we choose a value for the timestep and set up the initial conditions, either for an impulsive start...


\begin{DoxyCodeInclude}

 \textcolor{comment}{//Set value of dt}
 \textcolor{keywordtype}{double} dt = 0.025;

 \textcolor{keywordflow}{if} (\hyperlink{namespaceGlobal__Parameters_aec41eb8da4929003e5d78ef4b43c0ed9}{Global\_Parameters::Impulsive\_start\_flag}==1)
  \{
   \textcolor{comment}{// Initialise all history values for an impulsive start}
   assign\_initial\_values\_impulsive(dt);
   cout << \textcolor{stringliteral}{"IC = impulsive start"} << std::endl;
  \}

\end{DoxyCodeInclude}


...or for a \char`\"{}smooth\char`\"{} start from the time-\/periodic exact solution\+:


\begin{DoxyCodeInclude}
 \textcolor{keywordflow}{else}
  \{
   \textcolor{comment}{// Initialise timestep}
   initialise\_dt(dt);
   \textcolor{comment}{// Set initial conditions.}
   set\_initial\_condition();
   cout << \textcolor{stringliteral}{"IC = exact solution"} << std::endl;
  \} 

\end{DoxyCodeInclude}


We choose the number of timesteps to be computed and document the initial conditions.


\begin{DoxyCodeInclude}

 \textcolor{comment}{//Now do many timesteps}
 \textcolor{keywordtype}{unsigned} ntsteps=80;

 \textcolor{comment}{// If validation run only do 5 timesteps}
 \textcolor{keywordflow}{if} (\hyperlink{namespaceGlobal__Parameters_a457472b8222bb6bb0d97b2aed78d1ef4}{Global\_Parameters::Long\_run\_flag}==0)
  \{ 
   ntsteps=5; 
   cout << \textcolor{stringliteral}{"validation run"} << std::endl;
  \}

 \textcolor{comment}{// Doc initial condition}
 doc\_solution(doc\_info);
 
 \textcolor{comment}{// increment counter}
 doc\_info.number()++;

\end{DoxyCodeInclude}


Finally, perform the actual timestepping and document the solution after every timestep.


\begin{DoxyCodeInclude}

 \textcolor{comment}{//Loop over the timesteps}
 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} t=1;t<=ntsteps;t++)
  \{
   cout << \textcolor{stringliteral}{"TIMESTEP "} << t << std::endl;
   
   \textcolor{comment}{//Take one fixed timestep}
   unsteady\_newton\_solve(dt);

   \textcolor{comment}{//Output the time}
   cout << \textcolor{stringliteral}{"Time is now "} << time\_pt()->time() << std::endl;

   \textcolor{comment}{// Doc solution}
   doc\_solution(doc\_info);

   \textcolor{comment}{// increment counter}
   doc\_info.number()++;
  \}

\} \textcolor{comment}{// end of unsteady run}

\end{DoxyCodeInclude}




 

\hypertarget{index_comments}{}\section{Comments and Exercises}\label{index_comments}
\hypertarget{index_periodic}{}\subsection{Periodic boundaries}\label{index_periodic}
A key feature of the current problem is the presence of periodic boundary conditions. The application of the periodic boundary condition is performed \char`\"{}inside\char`\"{} the mesh constructor and details of the implementation were therefore \char`\"{}hidden\char`\"{}. We will now discuss the steps required to apply periodic boundary conditions and explain why it is easier to apply periodic boundary conditions in the mesh constructor rather than in the \char`\"{}driver code\char`\"{}.

Periodic boundary conditions arise in problems that are periodic in one of their coordinate directions. It is important to realise that, even though the solution at the corresponding nodes on the two periodic domain boundaries (the left and the right boundary in the above example) are the same, one of their nodal coordinates differs. For instance, in the above example, each of the nodes on the left boundary has the same velocity values and the same $ x_2$ -\/coordinate as its corresponding (periodic) node on the right boundary. However, the $ x_1 $ -\/coordinate of the nodes on the left boundary is $ x_1=0$ , whereas that of the (periodic) nodes on the right boundary is $ x_1=1$ . It is therefore not possible to regard the nodes as identical.

In {\ttfamily oomph-\/lib} we create periodic nodes by allowing two (or more) nodes to access some of the same internal data. One of the nodes should be regarded as the original and the other(s) are set to be its \char`\"{}periodic counterpart(s)\char`\"{} and hence access its internal data. The \char`\"{}periodic counterpart(s)\char`\"{} are created by calling the member function 
\begin{DoxyCode}
BoundaryNode::make\_periodic(Node *\textcolor{keyword}{const}& node\_pt)
\end{DoxyCode}
 where the pointer to the original node is passed as the argument. Note that the required functionality imposes a slight storage overhead and so in {\ttfamily oomph-\/lib} we only allow Boundary\+Nodes to be made periodic.

Here is a sketch of a 2D rectangular quad mesh. If this mesh is to be used in a problem with periodic boundary conditions in the horizontal direction (as in the above example), the pointer to node 3 on boundary 3 would have to be used when node 3 on boundary 1 is made periodic, etc. The appropriate commands are 
\begin{DoxyCode}
\textcolor{comment}{//Get pointers to the two nodes that are to be "connected" via}
\textcolor{comment}{//a periodic boundary}
Node* original\_node\_pt = mesh\_pt()->boundary\_node\_pt(3,3);
Node* periodic\_node\_pt = mesh\_pt()->boundary\_node\_pt(1,3);

\textcolor{comment}{//Make the periodic\_node\_pt periodic the data from the original\_node\_pt}
periodic\_node\_pt->make\_periodic(original\_node\_pt);
\end{DoxyCode}


 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{periodic_mesh}
\doxyfigcaption{Figure of a mesh that is periodic in the horizontal direction. }
\end{DoxyImage}


Although it is possible to make nodes periodic at any time, it is usually easier to determine which nodes should be \char`\"{}connected\char`\"{} during mesh construction. We therefore strongly recommend to implement periodic boundary conditions inside the mesh constructor. The \href{../../../../src/meshes/rectangular_quadmesh.template.cc}{\tt source code} for the constructor of the


\begin{DoxyCode}
RectangularQuadMesh<ELEMENT>
\end{DoxyCode}


that we used in the above problem, illustrates a possible implementation.\hypertarget{index_periodic_adapt}{}\subsection{Periodic boundaries in spatially adaptive computations}\label{index_periodic_adapt}
We note that the application of periodic boundary conditions in spatially adaptive computations is slightly more complicated because of the possible presence of hanging nodes on the periodic boundaries. We refer to \href{../../../linear_elasticity/refineable_periodic_load/html/index.html}{\tt another tutorial} for a discussion of this aspect.



\hypertarget{index_ex}{}\subsection{Exercises}\label{index_ex}

\begin{DoxyEnumerate}
\item Show that in the present problem the time-\/periodic solution can also be obtained without applying periodic boundary conditions. Show this mathematically and \char`\"{}by trial and error\char`\"{} (i.\+e. by changing the boolean flag that is passed to the mesh constructor). Explain why the number of unknowns increases when no periodic boundary conditions are applied.
\item Confirm that the assignment of \char`\"{}history values\char`\"{} for the nodal positions in {\ttfamily set\+\_\+initial\+\_\+conditions()} is essential.
\end{DoxyEnumerate}



 

\hypertarget{index_sources}{}\section{Source files for this tutorial}\label{index_sources}

\begin{DoxyItemize}
\item The source files for this tutorial are located in the directory\+: \begin{center} \href{../../../../demo_drivers/navier_stokes/rayleigh_channel/}{\tt demo\+\_\+drivers/navier\+\_\+stokes/rayleigh\+\_\+channel/ } \end{center} 
\item The driver code is\+: \begin{center} \href{../../../../demo_drivers/navier_stokes/rayleigh_channel/rayleigh_channel.cc}{\tt demo\+\_\+drivers/navier\+\_\+stokes/rayleigh\+\_\+channel/rayleigh\+\_\+channel.\+cc } \end{center} 
\end{DoxyItemize}



 

 \hypertarget{index_pdf}{}\section{P\+D\+F file}\label{index_pdf}
A \href{../latex/refman.pdf}{\tt pdf version} of this document is available. \end{document}
