In the \href{../../single_layer_free_surface/html/index.html}{\tt previous example} we considered a two-\/dimensional free surface Navier--Stokes problem. The free surface was deformed to a prescribed shape and then allowed to relax. In this example we consider the relaxation of an interface between two viscous fluids.



 

\hypertarget{index_implementation}{}\section{Implementation}\label{index_implementation}
The extension from a single fluid problem to one involving two fluids separated by an interface is very straightforward. As {\ttfamily oomph-\/lib\textquotesingle{}s} Navier--Stokes elements are based on the Arbitrary Lagrangian Eulerian form of the equations, and can therefore be used to solve problems in moving domains, we can discretise the domain using a rectangular mesh containing an additional boundary corresponding to the position of the interface. The construction of such a mesh is described \href{#mesh}{\tt below}. We also require a method of distinguishing between (and assigning) the physical properties of the two fluid layers.\hypertarget{index_interface_eqns}{}\subsection{Boundary conditions at the interface}\label{index_interface_eqns}
A discussion of the theory and implementation of the boundary conditions at a free surface is given in the \href{../../single_layer_free_surface/html/index.html#free_surface_eqns}{\tt previous example}, where we showed that the dynamic boundary condition is given by \[ \tau_{ij}^{[2]} \, n_j^{[1]} = \tau_{ij}^{[1]} \, n_j^{[1]} + \frac{1}{Ca} \, \kappa \, n_i^{[1]}. \] Here $ \tau_{ij}^{[1]} $ and $ \tau_{ij}^{[2]} $ are the stress tensors in the `lower\textquotesingle{} and `upper\textquotesingle{} fluids respectively, $ n_j^{[1]} $ is the unit normal pointing out of the `lower\textquotesingle{} fluid and $ Ca $ is the Capillary number.

The interface conditions in this two-\/fluid example are implemented in an almost identical way to the \href{../../single_layer_free_surface/html/index.html#implementation}{\tt single layer case}. We employ the same pseudo-\/solid node-\/update strategy, where the interior mesh is treated as a fictitious elastic solid and thus the (unknown) nodal positions can be determined by solving a solid mechanics problem. The deformation of the free surface boundary itself is imposed by introducing a a field of Lagrange multipliers at the interface, and the equation associated with these additional unknowns is the kinematic condition. In the \href{../../single_layer_free_surface/html/index.html#implementation}{\tt single layer case} this equation is discretised by attaching {\ttfamily Face\+Elements} to the boundaries of the `bulk\textquotesingle{} elements that are adjacent to the free surface. In this two-\/layer example we attach the same {\ttfamily Face\+Elements} to only those `bulk\textquotesingle{} elements which are in the `lower\textquotesingle{} fluid (and have boundaries adjacent to the interface). These same {\ttfamily Face\+Elements} are also responsible for adding the surface tension contributions to the momentum equations that arise through the application of the dynamic boundary condition. We note that since we are solving the Navier--Stokes equations on either side of the interface we do not specify an external pressure, a step that was necessary in the \href{../../single_layer_free_surface/html/index.html#implementation}{\tt single layer case}.

The other difference between this problem and the \href{../../single_layer_free_surface/html/index.html}{\tt previous example} is that we shall be solving this one using spatial adaptivity. We refer to \href{../../../poisson/two_d_poisson_flux_bc_adapt/html/index.html}{\tt another tutorial} for a discussion of how to apply boundary conditions in such problems.\hypertarget{index_dens_visc_ratios}{}\subsection{Distinguishing between the two fluids}\label{index_dens_visc_ratios}
In a problem containing a single fluid, the definitions of the Reynolds number, Strouhal number, Capillary number and so on are based on the physical properties of that fluid, as well as the geometry of the problem and typical timescales. In our \href{../../driven_cavity/html/index.html}{\tt discussion of the non-\/dimensionalisation of the Navier--Stokes equations} we describe how the various dimensionless parameters are defined in terms of a reference density, $ \rho_{ext} $, and a reference viscosity, $ \mu_{ext} $. We can then define two dimensionless ratios, $ R_\rho $ and $ R_\mu $, which describe a particular fluid\textquotesingle{}s density $ \rho $ and kinematic viscosity $ \mu $ relative to these reference quantities\+: \[ R_\rho = \frac{\rho}{\rho_{ref}} \qquad ; \qquad R_\mu = \frac{\mu}{\mu_{ref}}. \] {\ttfamily oomph-\/lib\textquotesingle{}s} implementation of the Navier--Stokes equations contains these ratios in the appropriate terms. They default to one but can be set to other values via the member functions {\ttfamily density\+\_\+ratio\+\_\+pt()} and {\ttfamily viscosity\+\_\+ratio\+\_\+pt()} in each element.

It is convenient to choose one of the fluids in this problem to be the `reference fluid\textquotesingle{} on which the dimensionless parameters are based. We choose the lower fluid (fluid 1), and hence the density $ \rho^{[1]} $ and viscosity $ \mu^{[1]} $ of this fluid are identically equal to $ \rho_{ref} $ and $ \mu_{ref} $ (and thus $ R_\rho^{[1]} = R_\mu^{[1]} = 1 $). We can now control the relative density and viscosity of the upper fluid to the lower fluid using the ratios $ R_\rho^{[2]} = \rho^{[2]}/\rho_{ref} $ and $ R_\mu^{[2]} = \mu^{[2]}/\mu_{ref} $ respectively. For simplicity we will from now on refer to $ R_\rho^{[2]} $ simply as $ R_\rho $ and to $ R_\mu^{[2]} $ as $ R_\mu $.



 

\hypertarget{index_example_problem}{}\section{The example problem}\label{index_example_problem}
We will illustrate the solution of the unsteady two-\/dimensional Navier--Stokes equations using the example of a distorted interface between two viscous fluids which is allowed to relax. The domain is periodic in the $ x_1 $ direction.

\begin{center} \tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*{1}{|X[-1]}|}
\hline
\begin{center} {\bfseries  The 2D unsteady Navier--Stokes equations either side of a distorted interface.} \end{center}  Solve \[ Re\left(St\frac{\partial u_i}{\partial t} + \ u_j\frac{\partial u_i}{\partial x_j}\right) = - \frac{\partial p}{\partial x_i} + \frac{Re}{Fr}G_i + \frac{\partial }{\partial x_j} \left[ \frac{\partial u_i}{\partial x_j} + \frac{\partial u_j}{\partial x_i} \right] \ \ \ \ \ \ \ \ \ \ (1) \] and \[ \frac{\partial u_i}{\partial x_i} = 0 \ \ \ \ \ \ \ \ \ \ (2) \] in the `lower\textquotesingle{} fluid, and \[ R_\rho Re\left(St\frac{\partial u_i}{\partial t} + \ u_j\frac{\partial u_i}{\partial x_j}\right) = - \frac{\partial p}{\partial x_i} + R_\rho \frac{Re}{Fr}G_i + \frac{\partial }{\partial x_j} \left[R_\mu \left( \frac{\partial u_i}{\partial x_j} + \frac{\partial u_j}{\partial x_i} \right) \right] \ \ \ \ \ \ \ \ \ \ (3) \] and \[ \frac{\partial u_i}{\partial x_i} = 0 \ \ \ \ \ \ \ \ \ \ (4) \] in the `upper\textquotesingle{} fluid. Gravity acts in the negative $ x_2 $ direction and so $ G_1 = 0 $ and $ G_2 = 1 $. The governing equations are subject to the no slip boundary conditions \[ u_1 = u_2 = 0 \ \ \ \ \ \ \ \ \ \ (5) \] on the top ( $ x_2 = 2.0 $) and bottom ( $ x_2 = 0.0 $) solid boundaries and the symmetry boundary conditions \[ u_1 = 0 \ \ \ \ \ \ \ \ \ \ (6) \] on the left ( $ x_1 = 0.0 $) and right ( $ x_1 = 1.0 $) boundaries.

We denote the position vector to the interface between the two fluids by $ \mathbf{R} $, which is subject to the kinematic condition \[ \left(u_i - St\, \frac{\partial R_i}{\partial t}\right) n_i = 0, \ \ \ \ \ \ \ \ \ \ (7) \] and the dynamic condition \[ \tau_{ij}^{[2]} \, n_j^{[1]} = \tau_{ij}^{[1]} \, n_j^{[1]} + \frac{1}{Ca} \, \kappa \, n_i^{[1]}. \ \ \ \ \ \ \ \ \ \ (8) \] The stress tensor in the `lower\textquotesingle{} fluid is defined as \[ \tau_{ij}^{[1]} = -p^{[1]} \, \delta_{ij} + \left(\frac{\partial u^{[1]}_i}{\partial x_j} + \frac{\partial u^{[1]}_j}{\partial x_i}\right), \ \ \ \ \ \ \ \ \ \ (9) \] and that in the `upper\textquotesingle{} fluid is defined as \[ \tau_{ij}^{[2]} = -p^{[2]} \, \delta_{ij} + R_\mu \left(\frac{\partial u^{[2]}_i}{\partial x_j} + \frac{\partial u^{[2]}_j}{\partial x_i}\right). \ \ \ \ \ \ \ \ \ \ (10) \]

The initial shape of the interface is defined by \[ \mathbf{R} = x_1 \, \mathbf{i} + \left[ 1.0 + \epsilon\cos\left( 2 n \pi x_1 \right)\right] \, \mathbf{j}, \ \ \ \ \ \ \ \ \ \ (11) \] where $ \epsilon $ is the amplitude of the initial deflection and $ n $ is an integer.   \\\cline{1-1}
\end{longtabu}
\end{center} 



 

\hypertarget{index_results}{}\section{Results}\label{index_results}
The figure below shows a contour plot of the pressure distribution taken from \href{../figures/two_layer_interface.avi}{\tt an animation of the flow field}, for the parameters $ Re = Re \, St = Re/Fr = 5.0 $, $ R_\rho = 0.5 $, $ R_\mu = 0.1 $ and $ Ca = 0.01 $.

 
\begin{DoxyImage}
\includegraphics[width=0.6\textwidth]{two_layer_interface}
\doxyfigcaption{Pressure contour plot for the relaxing interface problem. }
\end{DoxyImage}


The restoring forces of surface tension and gravitational acceleration act to revert the interface to its undeformed flat state. The interface oscillates up and down, but the motion is damped as the energy in the system is dissipated through viscous forces. Eventually the interface settles down to its equilibrium position, as can be seen in the following time-\/trace of the height of the interface at the left-\/hand edge of the domain ( $ x_1 = 0 $).

 
\begin{DoxyImage}
\includegraphics[width=0.95\textwidth]{two_layer_interface_trace}
\doxyfigcaption{Time-\/trace of the height of the interface at the point x\+\_\+1 = 0. }
\end{DoxyImage}




 

\hypertarget{index_validation}{}\section{Validation}\label{index_validation}
The free surface boundary conditions for the Cartesian Navier--Stokes equations have been validated against an analytical test case, and we present the results in the figure below. For sufficiently small amplitudes, $ \epsilon \ll 1 $, we can linearise the governing equations and obtain a dispersion relation $ \lambda(k) $, the derivation of which is discussed in the \href{../../single_layer_free_surface/html/index.html#validation}{\tt previous tutorial}. The only difference in this two layer case is that the linear system which needs to be solved contains nine unknowns rather than five, since the two fluids have different properties. The real and imaginary parts of $ \lambda $ correspond to the growth rate and the frequency of the oscillating interface respectively, and can be compared to numerical results computed for given values of the wavenumber $ k $. We choose an initial deflection amplitude of $ \epsilon = 0.01 $ and determine the growth rate and frequency of the oscillation from a time-\/trace of the left-\/hand edge of the interface.

 
\begin{DoxyImage}
\includegraphics[width=0.95\textwidth]{two_layer_interface_code_validation}
\doxyfigcaption{Validation of the code (points) by comparison with an analytical dispersion relation (lines). }
\end{DoxyImage}




 

\hypertarget{index_namespace}{}\section{Global parameters and functions}\label{index_namespace}
As in the \href{../../single_layer_free_surface/html/index.html#namespace}{\tt previous example}, we use a namespace to define the dimensionless parameters $ Re $, $ St $, $ Re/Fr $ and $ Ca $. The pseudo-\/solid mesh is governed by a generalised Hookean constitutive law which requires the definition of the Poisson ratio, $ \nu $, and we create a vector $ G $ which will define the direction in which gravity acts. Because this is a two-\/fluid problem, we also need to define the density ratio $ R_{\rho} = \rho^{[2]}/\rho^{[1]} $ and viscosity ratio $ R_{\mu} = \mu^{[2]}/\mu^{[1]} $ of the two fluids.

 
\begin{DoxyCodeInclude}
\textcolor{comment}{//==start\_of\_namespace====================================================}
\textcolor{comment}{/// Namespace for physical parameters}
\textcolor{comment}{}\textcolor{comment}{//========================================================================}
\textcolor{keyword}{namespace }\hyperlink{namespaceGlobal__Physical__Variables}{Global\_Physical\_Variables}
\{
\textcolor{comment}{}
\textcolor{comment}{ /// Reynolds number}
\textcolor{comment}{} \textcolor{keywordtype}{double} \hyperlink{namespaceGlobal__Physical__Variables_ab814e627d2eb5bc50318879d19ab16b9}{Re} = 5.0;
\textcolor{comment}{}
\textcolor{comment}{ /// Strouhal number}
\textcolor{comment}{} \textcolor{keywordtype}{double} \hyperlink{namespaceGlobal__Physical__Variables_a4b6ef72bd221361c37f5b9a4a6899afc}{St} = 1.0;
\textcolor{comment}{}
\textcolor{comment}{ /// Womersley number (Reynolds x Strouhal)}
\textcolor{comment}{} \textcolor{keywordtype}{double} \hyperlink{namespaceGlobal__Physical__Variables_a085ee4bf968ffdd01a41b8c41864f907}{ReSt} = 5.0;
 \textcolor{comment}{}
\textcolor{comment}{ /// Product of Reynolds number and inverse of Froude number}
\textcolor{comment}{} \textcolor{keywordtype}{double} \hyperlink{namespaceGlobal__Physical__Variables_aa6286f02b476912dd7550eced538331a}{ReInvFr} = 5.0;
\textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Ratio of viscosity in upper fluid to viscosity in lower}
\textcolor{comment}{ /// fluid. Reynolds number etc. is based on viscosity in lower fluid.}
\textcolor{comment}{} \textcolor{keywordtype}{double} \hyperlink{namespaceGlobal__Physical__Variables_adb51428300a01b19395c43c0d3586d6f}{Viscosity\_Ratio} = 0.1;
\textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Ratio of density in upper fluid to density in lower}
\textcolor{comment}{ /// fluid. Reynolds number etc. is based on density in lower fluid.}
\textcolor{comment}{} \textcolor{keywordtype}{double} \hyperlink{namespaceGlobal__Physical__Variables_a80a34b6dfb7e1501966b8d6c7501e718}{Density\_Ratio} = 0.5;
\textcolor{comment}{}
\textcolor{comment}{ /// Capillary number}
\textcolor{comment}{} \textcolor{keywordtype}{double} \hyperlink{namespaceGlobal__Physical__Variables_a8b32b93d2e546f9375ec418474107838}{Ca} = 0.01;
\textcolor{comment}{}
\textcolor{comment}{ /// Direction of gravity}
\textcolor{comment}{} Vector<double> \hyperlink{namespaceGlobal__Physical__Variables_a37a6f46efcb35b4bd12c73f19d741020}{G}(2);
\textcolor{comment}{}
\textcolor{comment}{ /// Pseudo-solid Poisson ratio}
\textcolor{comment}{} \textcolor{keywordtype}{double} \hyperlink{namespaceGlobal__Physical__Variables_a3962c36313826b19f216f6bbbdd6a477}{Nu} = 0.1;

\} \textcolor{comment}{// End of namespace}

\end{DoxyCodeInclude}




 

\hypertarget{index_main}{}\section{The driver code}\label{index_main}
The driver code is very similar to the \href{../../single_layer_free_surface/html/index.html#main}{\tt previous example}. We define a command line flag which allows us to run a `validation\textquotesingle{} version of the code (for {\ttfamily oomph-\/lib\textquotesingle{}s} self-\/testing routines) and check that the non-\/dimensional quantities provided in the {\ttfamily \hyperlink{namespaceGlobal__Physical__Variables}{Global\+\_\+\+Physical\+\_\+\+Variables}} namespace are self-\/consistent.


\begin{DoxyCodeInclude}
\textcolor{comment}{//==start\_of\_main=========================================================}
\textcolor{comment}{/// Driver code for two-dimensional two fluid interface problem}
\textcolor{comment}{}\textcolor{comment}{//========================================================================}
\textcolor{keywordtype}{int} \hyperlink{elastic__two__layer__interface_8cc_a0ddf1224851353fc92bfbff6f499fa97}{main}(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char}* argv[]) 
\{
 \textcolor{comment}{// Store command line arguments}
 CommandLineArgs::setup(argc,argv);

 \textcolor{comment}{// -----------------------------------------------------------------}
 \textcolor{comment}{// Define possible command line arguments and parse the ones that}
 \textcolor{comment}{// were actually specified}
 \textcolor{comment}{// -----------------------------------------------------------------}

 \textcolor{comment}{// Are we performing a validation run?}
 CommandLineArgs::specify\_command\_line\_flag(\textcolor{stringliteral}{"--validation"});

 \textcolor{comment}{// Parse command line}
 CommandLineArgs::parse\_and\_assign();

 \textcolor{comment}{// Doc what has actually been specified on the command line}
 CommandLineArgs::doc\_specified\_flags();

 \textcolor{comment}{// Check that definition of Womersley number is consistent with those}
 \textcolor{comment}{// of the Reynolds and Strouhal numbers}
 \textcolor{keywordflow}{if}(\hyperlink{namespaceGlobal__Physical__Variables_a085ee4bf968ffdd01a41b8c41864f907}{Global\_Physical\_Variables::ReSt} !=
    \hyperlink{namespaceGlobal__Physical__Variables_ab814e627d2eb5bc50318879d19ab16b9}{Global\_Physical\_Variables::Re}*Global\_Physical\_Variables::St)
  \{
   std::ostringstream error\_stream;
   error\_stream << \textcolor{stringliteral}{"Definition of Global\_Physical\_Variables::ReSt is "}
                << \textcolor{stringliteral}{"inconsistant with those\(\backslash\)n"}
                << \textcolor{stringliteral}{"of Global\_Physical\_Variables::Re and "}
                << \textcolor{stringliteral}{"Global\_Physical\_Variables::St."} << std::endl;
   \textcolor{keywordflow}{throw} OomphLibError(error\_stream.str(),
                       OOMPH\_CURRENT\_FUNCTION,OOMPH\_EXCEPTION\_LOCATION);
  \}

\end{DoxyCodeInclude}


Next we specify the duration of the simulation and the size of the timestep. If we are running the code as a self-\/test, we set the length of the simulation such that only two timesteps are taken. The direction in which gravity acts is defined to be vertically downwards.


\begin{DoxyCodeInclude}
 \textcolor{comment}{/// Maximum time}
 \textcolor{keywordtype}{double} t\_max = 0.6;
\textcolor{comment}{}
\textcolor{comment}{ /// Duration of timestep}
\textcolor{comment}{} \textcolor{keyword}{const} \textcolor{keywordtype}{double} dt = 0.0025;

 \textcolor{comment}{// If we are doing validation run, use smaller number of timesteps}
 \textcolor{keywordflow}{if}(CommandLineArgs::command\_line\_flag\_has\_been\_set(\textcolor{stringliteral}{"--validation"}))
  \{
   t\_max = 0.005;
  \}

 \textcolor{comment}{// Set direction of gravity (vertically downwards)}
 \hyperlink{namespaceGlobal__Physical__Variables_a37a6f46efcb35b4bd12c73f19d741020}{Global\_Physical\_Variables::G}[0] = 0.0;
 \hyperlink{namespaceGlobal__Physical__Variables_a37a6f46efcb35b4bd12c73f19d741020}{Global\_Physical\_Variables::G}[1] = -1.0;

\end{DoxyCodeInclude}


Finally, we build the problem using the `pseudo-\/solid\textquotesingle{} version of {\ttfamily Refineable\+Q\+Crouzeix\+Raviart\+Elements} and the {\ttfamily B\+D\+F$<$2$>$} timestepper, before calling {\ttfamily unsteady\+\_\+run}(...). This function solves the system at each timestep using the {\ttfamily Problem\+::unsteady\+\_\+newton\+\_\+solve}(...) function before documenting the result.


\begin{DoxyCodeInclude}
 \textcolor{comment}{// Set up the elastic test problem with QCrouzeixRaviartElements,}
 \textcolor{comment}{// using the BDF<2> timestepper}
 \hyperlink{classInterfaceProblem}{InterfaceProblem}<RefineablePseudoSolidNodeUpdateElement<
 RefineableQCrouzeixRaviartElement<2>,RefineableQPVDElement<2,3> >, BDF<2> >
  problem;
 
 \textcolor{comment}{// Run the unsteady simulation}
 problem.\hyperlink{classInterfaceProblem_adf1f4e43d10939e4323e0e315b711085}{unsteady\_run}(t\_max,dt);
 
\} \textcolor{comment}{// End of main}

\end{DoxyCodeInclude}




 

\hypertarget{index_mesh}{}\section{The mesh class}\label{index_mesh}
In the \href{../../single_layer_free_surface/html/index.html#main}{\tt previous example} we employed {\ttfamily oomph-\/lib\textquotesingle{}s} {\ttfamily Elastic\+Rectangular\+Quad\+Mesh}. If we wanted to solve the same single-\/layer problem but with spatial adaptivity we would simply use that mesh\textquotesingle{}s refineable counterpart, the {\ttfamily Elastic\+Refineable\+Rectangular\+Quad\+Mesh}. For this two-\/layer problem, however, it is convenient to define a new mesh class which contains an additional `boundary\textquotesingle{} which corresponds to the interface between the two fluids. We start by defining the new class (which is templated by the element type) and inheriting from {\ttfamily Elastic\+Refineable\+Rectangular\+Quad\+Mesh}.

 
\begin{DoxyCodeInclude}
\textcolor{comment}{//==start\_of\_specific\_mesh\_class==========================================}
\textcolor{comment}{/// Two layer mesh which employs a pseudo-solid node-update strategy.}
\textcolor{comment}{}\textcolor{comment}{/// This class is essentially a wrapper to an }
\textcolor{comment}{}\textcolor{comment}{/// ElasticRefineableRectangularQuadMesh, with an additional boundary}
\textcolor{comment}{}\textcolor{comment}{/// to represent the interface between the two fluid layers.}
\textcolor{comment}{}\textcolor{comment}{//========================================================================}
\textcolor{keyword}{template} <\textcolor{keyword}{class} ELEMENT>
\textcolor{keyword}{class }\hyperlink{classElasticRefineableTwoLayerMesh}{ElasticRefineableTwoLayerMesh} :
 \textcolor{keyword}{public} \textcolor{keyword}{virtual} ElasticRefineableRectangularQuadMesh<ELEMENT>
\{

\end{DoxyCodeInclude}


Next we define the mesh\textquotesingle{}s constructor. We pass it the usual parameters, including a boolean flag which indicates whether or not the mesh is periodic in the $ x $ direction.


\begin{DoxyCodeInclude}
\textcolor{keyword}{public}:
\textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Constructor: Pass number of elements in x-direction, number of}
\textcolor{comment}{ /// elements in y-direction in bottom and top layer, respectively,}
\textcolor{comment}{ /// axial length and height of top and bottom layers, a boolean}
\textcolor{comment}{ /// flag to make the mesh periodic in the x-direction, and pointer }
\textcolor{comment}{ /// to timestepper (defaults to Steady timestepper)}
\textcolor{comment}{} \hyperlink{classElasticRefineableTwoLayerMesh}{ElasticRefineableTwoLayerMesh}(\textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} &nx, 
                               \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} &ny1,
                               \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} &ny2, 
                               \textcolor{keyword}{const} \textcolor{keywordtype}{double} &lx,
                               \textcolor{keyword}{const} \textcolor{keywordtype}{double} &h1,
                               \textcolor{keyword}{const} \textcolor{keywordtype}{double} &h2,
                               \textcolor{keyword}{const} \textcolor{keywordtype}{bool}& periodic\_in\_x,
                               TimeStepper* time\_stepper\_pt=
                               &Mesh::Default\_TimeStepper)
  : RectangularQuadMesh<ELEMENT>(nx,ny1+ny2,lx,h1+h2,
                                 periodic\_in\_x,time\_stepper\_pt),
    ElasticRectangularQuadMesh<ELEMENT>(nx,ny1+ny2,lx,h1+h2,
                                        periodic\_in\_x,time\_stepper\_pt),
    ElasticRefineableRectangularQuadMesh<ELEMENT>(nx,ny1+ny2,lx,h1+h2,
                                                  periodic\_in\_x,
                                                  time\_stepper\_pt)
  \{

\end{DoxyCodeInclude}


We have so far created an {\ttfamily Elastic\+Refineable\+Rectangular\+Quad\+Mesh}, which has four boundaries corresponding to the edges of our problem\textquotesingle{}s domain. We wish to define a fifth boundary which corresponds to the interface position. First we set the number of boundaries to five and then convert all the {\ttfamily Nodes} which lie on the interface into {\ttfamily Boundary\+Nodes}. These are then added to the fifth boundary.


\begin{DoxyCodeInclude}
   \textcolor{comment}{// Set the number of boundaries to 5}
   this->set\_nboundary(5);

   \textcolor{comment}{// Loop over horizontal elements}
   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} e=0;e<nx;e++)
    \{
     \textcolor{comment}{// Get pointer to element in lower fluid adjacent to interface}
     FiniteElement* el\_pt = this->finite\_element\_pt(nx*(ny1-1)+e);

     \textcolor{comment}{// Determine number of nodes in this element}
     \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} n\_node = el\_pt->nnode();

     \textcolor{comment}{// The last three nodes in this element are those on the interface.}
     \textcolor{comment}{// Loop over these nodes and convert them to boundary nodes.}
     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} n=0;n<3;n++)
      \{
       Node* nod\_pt = el\_pt->node\_pt(n\_node-3+n);
       this->convert\_to\_boundary\_node(nod\_pt);
       this->add\_boundary\_node(4,nod\_pt);
      \}
    \} \textcolor{comment}{// End of loop over horizontal elements}

\end{DoxyCodeInclude}


All that remains is to set up the boundary element information. This is required so that we can easily have access to the bulk elements either side of this new boundary.


\begin{DoxyCodeInclude}
   \textcolor{comment}{// Set up the boundary element information}
   this->setup\_boundary\_element\_info();
  \}

\}; \textcolor{comment}{// End of specific mesh class}

\end{DoxyCodeInclude}




 

\hypertarget{index_problem_class}{}\section{The problem class}\label{index_problem_class}
This is very similar to the problem class in the \href{../../single_layer_free_surface/html/index.html#problem_class}{\tt previous example}, with a few modifications. Because we shall use spatial adaptivity when solving this problem, we define the following two functions, which will be called before and after mesh adaptation.


\begin{DoxyCodeInclude}
 \textcolor{comment}{/// Strip off the interface elements before adapting the bulk mesh}
 \textcolor{keywordtype}{void} actions\_before\_adapt();
\textcolor{comment}{}
\textcolor{comment}{ /// Rebuild the mesh of interface elements after adapting the bulk mesh}
\textcolor{comment}{} \textcolor{keywordtype}{void} actions\_after\_adapt();

\end{DoxyCodeInclude}


These two functions will employ two helper functions which are responsible for the creation and deletion of the interface elements.


\begin{DoxyCodeInclude}
 \textcolor{comment}{/// Create the 1d interface elements}
 \textcolor{keywordtype}{void} create\_interface\_elements();
\textcolor{comment}{}
\textcolor{comment}{ /// Delete the 1d interface elements}
\textcolor{comment}{} \textcolor{keywordtype}{void} delete\_interface\_elements();

\end{DoxyCodeInclude}


The final modification to the problem class is the addition of a helper function which pins a pressure value in a specified element and assigns a specific value.


\begin{DoxyCodeInclude}
 \textcolor{comment}{/// Fix pressure in element e at pressure dof pdof and set to pvalue}
 \textcolor{keywordtype}{void} fix\_pressure(\textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} &e,
                   \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} &pdof, 
                   \textcolor{keyword}{const} \textcolor{keywordtype}{double} &pvalue)
  \{
   \textcolor{comment}{// Fix the pressure at that element}
   \textcolor{keyword}{dynamic\_cast<}ELEMENT*\textcolor{keyword}{>}(mesh\_pt()->element\_pt(e))->
                          fix\_pressure(pdof,pvalue);
  \}

\end{DoxyCodeInclude}




 

\hypertarget{index_constructor}{}\section{The problem constructor}\label{index_constructor}
The constructor starts by building the timestepper and setting the dimensions of the mesh. The number of elements in the $ x_1 $ and $ x_2 $ directions in both fluid layers are specified.


\begin{DoxyCodeInclude}
\textcolor{comment}{//==start\_of\_constructor==================================================}
\textcolor{comment}{/// Constructor for two fluid interface problem}
\textcolor{comment}{}\textcolor{comment}{//========================================================================}
\textcolor{keyword}{template} <\textcolor{keyword}{class} ELEMENT, \textcolor{keyword}{class} TIMESTEPPER>
\hyperlink{classInterfaceProblem_a5889be7fc8eab5d222f1bfb750c845ba}{InterfaceProblem<ELEMENT,TIMESTEPPER>::}
\hyperlink{classInterfaceProblem_a5889be7fc8eab5d222f1bfb750c845ba}{InterfaceProblem}()
\{
 \textcolor{comment}{// Allocate the timestepper (this constructs the time object as well)}
 add\_time\_stepper\_pt(\textcolor{keyword}{new} TIMESTEPPER);

 \textcolor{comment}{// Define number of elements in x direction}
 \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} n\_x = 3;
   
 \textcolor{comment}{// Define number of elements in y direction in lower fluid (fluid 1)}
 \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} n\_y1 = 3;

 \textcolor{comment}{// Define number of elements in y direction in upper fluid (fluid 2)}
 \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} n\_y2 = 3;

 \textcolor{comment}{// Define width of domain and store as class member data}
 \textcolor{keyword}{const} \textcolor{keywordtype}{double} l\_x = 1.0;
 this->Lx = l\_x;

 \textcolor{comment}{// Define height of lower fluid layer}
 \textcolor{keyword}{const} \textcolor{keywordtype}{double} h1 = 1.0;

 \textcolor{comment}{// Define height of upper fluid layer}
 \textcolor{keyword}{const} \textcolor{keywordtype}{double} h2 = 1.0;

\end{DoxyCodeInclude}


Next we build the bulk mesh, create an error estimator for the problem and set the maximum refinement level.


\begin{DoxyCodeInclude}
 \textcolor{comment}{// Build and assign the "bulk" mesh (the "true" boolean flag tells}
 \textcolor{comment}{// the mesh constructor that the domain is periodic in x)}
 Bulk\_mesh\_pt = \textcolor{keyword}{new} \hyperlink{classElasticRefineableTwoLayerMesh}{ElasticRefineableTwoLayerMesh<ELEMENT>}
  (n\_x,n\_y1,n\_y2,l\_x,h1,h2,\textcolor{keyword}{true},time\_stepper\_pt());

 \textcolor{comment}{// Create and set the error estimator for spatial adaptivity}
 Bulk\_mesh\_pt->spatial\_error\_estimator\_pt() = \textcolor{keyword}{new} Z2ErrorEstimator;

 \textcolor{comment}{// Set the maximum refinement level for the mesh to 4}
 Bulk\_mesh\_pt->max\_refinement\_level() = 4;

\end{DoxyCodeInclude}


An empty surface mesh is created and then populated with a call to {\ttfamily create\+\_\+interface\+\_\+elements()}. The bulk and surface meshes are then combined to form the global mesh.


\begin{DoxyCodeInclude}
 \textcolor{comment}{// Create the "surface" mesh that will contain only the interface}
 \textcolor{comment}{// elements. The constructor just creates the mesh without giving}
 \textcolor{comment}{// it any elements, nodes, etc.}
 Surface\_mesh\_pt = \textcolor{keyword}{new} Mesh;
 
 \textcolor{comment}{// Create interface elements at the boundary between the two fluids,}
 \textcolor{comment}{// and add them to the surface mesh}
 create\_interface\_elements();

 \textcolor{comment}{// Add the two sub meshes to the problem}
 add\_sub\_mesh(Bulk\_mesh\_pt);
 add\_sub\_mesh(Surface\_mesh\_pt);

 \textcolor{comment}{// Combine all sub-meshes into a single mesh}
 build\_global\_mesh();

\end{DoxyCodeInclude}


On the top and bottom boundaries ( $ y = 2.0 $ and $ y = 0.0 $) we apply the no-\/slip condition by pinning both velocity components. On the left and right symmetry boundaries ( $ x = 0.0 $ and $ x = 1.0 $) we pin the $ x $ component of the velocity but leave the $ y $ component unconstrained. We pin the vertical displacement of the nodes on the solid boundaries (since these must remain stationary) and pin the horizontal displacement of all nodes in the mesh.


\begin{DoxyCodeInclude}
 \textcolor{comment}{// Set the boundary conditions for this problem}
 \textcolor{comment}{// --------------------------------------------}
 
 \textcolor{comment}{// All values are free by default -- just pin the ones that have}
 \textcolor{comment}{// Dirichlet conditions here}

 \textcolor{comment}{// Determine number of mesh boundaries}
 \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} n\_boundary = Bulk\_mesh\_pt->nboundary();
 
 \textcolor{comment}{// Loop over mesh boundaries}
 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} b=0;b<n\_boundary;b++)
  \{
   \textcolor{comment}{// Determine number of nodes on boundary b}
   \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} n\_node = Bulk\_mesh\_pt->nboundary\_node(b);

   \textcolor{comment}{// Loop over nodes on boundary b}
   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} n=0;n<n\_node;n++)
    \{
     \textcolor{comment}{// Fluid boundary conditions:}
     \textcolor{comment}{// --------------------------}

     \textcolor{comment}{// Pin x-component of velocity (no slip/penetration)}
     \textcolor{comment}{// on all boundaries other than the interface (b=4)}
     \textcolor{keywordflow}{if}(b!=4) \{ Bulk\_mesh\_pt->boundary\_node\_pt(b,n)->pin(0); \}

     \textcolor{comment}{// Pin y-component of velocity on both solid boundaries (no penetration)}
     \textcolor{keywordflow}{if}(b==0 || b==2) \{ Bulk\_mesh\_pt->boundary\_node\_pt(b,n)->pin(1); \}

     \textcolor{comment}{// Solid boundary conditions:}
     \textcolor{comment}{// --------------------------}

     \textcolor{comment}{// Pin vertical mesh position on both solid boundaries (no penetration)}
     \textcolor{keywordflow}{if}(b==0 || b==2) \{ Bulk\_mesh\_pt->boundary\_node\_pt(b,n)->pin\_position(1); \}

    \} \textcolor{comment}{// End of loop over nodes on boundary b}
  \} \textcolor{comment}{// End of loop over mesh boundaries}

 \textcolor{comment}{// Pin horizontal position of all nodes}
 \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} n\_node = Bulk\_mesh\_pt->nnode();
 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} n=0;n<n\_node;n++) \{ Bulk\_mesh\_pt->node\_pt(n)->pin\_position(0); \}

\end{DoxyCodeInclude}


Next we create a generalised Hookean constitutive equation for the pseudo-\/solid mesh. This constitutive equation is discussed in \href{../../../solid/disk_compression/html/index.html#hooke}{\tt another tutorial}.


\begin{DoxyCodeInclude}
 \textcolor{comment}{// Define a constitutive law for the solid equations: generalised Hookean}
 Constitutive\_law\_pt = \textcolor{keyword}{new} GeneralisedHookean(&\hyperlink{namespaceGlobal__Physical__Variables_a3962c36313826b19f216f6bbbdd6a477}{Global\_Physical\_Variables::Nu});

\end{DoxyCodeInclude}


We loop over the bulk elements in the lower fluid and pass them pointers to the Reynolds and Womersley numbers, $ Re $ and $ Re\, St $, the product of the Reynolds number and the inverse of the Froude number, $ Re/Fr $, the direction of gravity, $ G $, the constitutive law and the global time object, created when we called {\ttfamily Problem\+::add\+\_\+time\+\_\+stepper\+\_\+pt}(...) above. Note that we do not assign pointers for the viscosity and density ratios, $ R_\mu $ and $ R_\rho $, since these take the default value in the lower fluid.


\begin{DoxyCodeInclude}
 \textcolor{comment}{// Complete the problem setup to make the elements fully functional}
 \textcolor{comment}{// ----------------------------------------------------------------}
 
 \textcolor{comment}{// Compute number of bulk elements in lower/upper fluids}
 \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} n\_lower = n\_x*n\_y1;
 \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} n\_upper = n\_x*n\_y2;

 \textcolor{comment}{// Loop over bulk elements in lower fluid}
 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} e=0;e<n\_lower;e++)
  \{
   \textcolor{comment}{// Upcast from GeneralisedElement to the present element}
   ELEMENT *el\_pt = \textcolor{keyword}{dynamic\_cast<}ELEMENT*\textcolor{keyword}{>}(Bulk\_mesh\_pt->element\_pt(e));

   \textcolor{comment}{// Set the Reynolds number}
   el\_pt->re\_pt() = &\hyperlink{namespaceGlobal__Physical__Variables_ab814e627d2eb5bc50318879d19ab16b9}{Global\_Physical\_Variables::Re};

   \textcolor{comment}{// Set the Womersley number}
   el\_pt->re\_st\_pt() = &\hyperlink{namespaceGlobal__Physical__Variables_a085ee4bf968ffdd01a41b8c41864f907}{Global\_Physical\_Variables::ReSt};

   \textcolor{comment}{// Set the product of the Reynolds number and the inverse of the}
   \textcolor{comment}{// Froude number}
   el\_pt->re\_invfr\_pt() = &\hyperlink{namespaceGlobal__Physical__Variables_aa6286f02b476912dd7550eced538331a}{Global\_Physical\_Variables::ReInvFr};

   \textcolor{comment}{// Set the direction of gravity}
   el\_pt->g\_pt() = &\hyperlink{namespaceGlobal__Physical__Variables_a37a6f46efcb35b4bd12c73f19d741020}{Global\_Physical\_Variables::G};

   \textcolor{comment}{// Set the constitutive law}
   el\_pt->constitutive\_law\_pt() = Constitutive\_law\_pt;

  \} \textcolor{comment}{// End of loop over bulk elements in lower fluid}

\end{DoxyCodeInclude}


We then do the same for the bulk elements in the upper fluid, and this time we do assign pointers for the viscosity and density ratios.


\begin{DoxyCodeInclude}
 \textcolor{comment}{// Loop over bulk elements in upper fluid}
 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} e=n\_lower;e<(n\_lower+n\_upper);e++)
  \{
   \textcolor{comment}{// Upcast from GeneralisedElement to the present element}
   ELEMENT *el\_pt = \textcolor{keyword}{dynamic\_cast<}ELEMENT*\textcolor{keyword}{>}(Bulk\_mesh\_pt->element\_pt(e));

   \textcolor{comment}{// Set the Reynolds number}
   el\_pt->re\_pt() = &\hyperlink{namespaceGlobal__Physical__Variables_ab814e627d2eb5bc50318879d19ab16b9}{Global\_Physical\_Variables::Re};

   \textcolor{comment}{// Set the Womersley number}
   el\_pt->re\_st\_pt() = &\hyperlink{namespaceGlobal__Physical__Variables_a085ee4bf968ffdd01a41b8c41864f907}{Global\_Physical\_Variables::ReSt};

   \textcolor{comment}{// Set the product of the Reynolds number and the inverse of the}
   \textcolor{comment}{// Froude number}
   el\_pt->re\_invfr\_pt() = &\hyperlink{namespaceGlobal__Physical__Variables_aa6286f02b476912dd7550eced538331a}{Global\_Physical\_Variables::ReInvFr};

   \textcolor{comment}{// Set the viscosity ratio}
   el\_pt->viscosity\_ratio\_pt() = &\hyperlink{namespaceGlobal__Physical__Variables_adb51428300a01b19395c43c0d3586d6f}{Global\_Physical\_Variables::Viscosity\_Ratio}
      ;

   \textcolor{comment}{// Set the density ratio}
   el\_pt->density\_ratio\_pt() = &\hyperlink{namespaceGlobal__Physical__Variables_a80a34b6dfb7e1501966b8d6c7501e718}{Global\_Physical\_Variables::Density\_Ratio}
      ;

   \textcolor{comment}{// Set the direction of gravity}
   el\_pt->g\_pt() = &\hyperlink{namespaceGlobal__Physical__Variables_a37a6f46efcb35b4bd12c73f19d741020}{Global\_Physical\_Variables::G};

   \textcolor{comment}{// Set the constitutive law}
   el\_pt->constitutive\_law\_pt() = Constitutive\_law\_pt;

  \} \textcolor{comment}{// End of loop over bulk elements in upper fluid}

\end{DoxyCodeInclude}


We then pin one pressure degree of freedom.


\begin{DoxyCodeInclude}
 \textcolor{comment}{// Set the pressure in the first element at 'node' 0 to 0.0}
 fix\_pressure(0,0,0.0);

\end{DoxyCodeInclude}


At this point we set up the boundary conditions.


\begin{DoxyCodeInclude}
 \textcolor{comment}{// Apply the boundary conditions}
 set\_boundary\_conditions();

\end{DoxyCodeInclude}


Finally, we set up the equation numbering scheme.


\begin{DoxyCodeInclude}
 \textcolor{comment}{// Set up equation numbering scheme}
 cout << \textcolor{stringliteral}{"Number of equations: "} << assign\_eqn\_numbers() << std::endl;

\} \textcolor{comment}{// End of constructor}

\end{DoxyCodeInclude}




 

\hypertarget{index_set_initial_condition}{}\section{Initial conditions}\label{index_set_initial_condition}
The {\ttfamily set\+\_\+initial\+\_\+conditions()} function is identical to that in the \href{../../single_layer_free_surface/html/index.html#set_initial_condition}{\tt previous example}.



 

\hypertarget{index_set_boundary_conditions}{}\section{Boundary conditions}\label{index_set_boundary_conditions}
The {\ttfamily set\+\_\+boundary\+\_\+conditions()} function is very similar to that in the \href{../../single_layer_free_surface/html/index.html#set_boundary_conditions}{\tt previous example}.



 

\hypertarget{index_before_adapt}{}\section{Actions before adaptation}\label{index_before_adapt}
The mesh adaptation is driven by the error estimates in the bulk elements and only performed for that mesh. The interface elements must therefore be removed before adaptation. We do this by calling the function {\ttfamily delete\+\_\+interface\+\_\+elements()}, and then rebuilding the {\ttfamily Problem\textquotesingle{}s} global mesh.


\begin{DoxyCodeInclude}
\textcolor{comment}{//==start\_of\_actions\_before\_adapt=========================================}
\textcolor{comment}{/// Strip off the interface elements before adapting the bulk mesh}
\textcolor{comment}{}\textcolor{comment}{//========================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT, \textcolor{keyword}{class} TIMESTEPPER>
\textcolor{keywordtype}{void} \hyperlink{classInterfaceProblem_a944e5754e9b3f3394211b6c62f705abe}{InterfaceProblem<ELEMENT,TIMESTEPPER>::actions\_before\_adapt}
      ()
\{
 \textcolor{comment}{// Delete the interface elements and wipe the surface mesh}
 delete\_interface\_elements();
 
 \textcolor{comment}{// Rebuild the Problem's global mesh from its various sub-meshes}
 rebuild\_global\_mesh();

\} \textcolor{comment}{// End of actions\_before\_adapt}

\end{DoxyCodeInclude}




 

\hypertarget{index_after_adapt}{}\section{Actions after adapt}\label{index_after_adapt}
After the bulk mesh has been adapted we must create new interface elements and rebuild the problem\textquotesingle{}s global mesh. Any newly-\/created boundary nodes will automatically have the appropriate boundary conditions applied; however, we must remember to pin the horizontal displacement of all nodes throughout the bulk of the domain.


\begin{DoxyCodeInclude}
\textcolor{comment}{//==start\_of\_actions\_after\_adapt==========================================}
\textcolor{comment}{/// Rebuild the mesh of interface elements after adapting the bulk mesh}
\textcolor{comment}{}\textcolor{comment}{//========================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT, \textcolor{keyword}{class} TIMESTEPPER>
\textcolor{keywordtype}{void} \hyperlink{classInterfaceProblem_a1c8a5dee970dccc3f1da993cf531872d}{InterfaceProblem<ELEMENT,TIMESTEPPER>::actions\_after\_adapt}
      ()
\{
 \textcolor{comment}{// Create the interface elements}
 this->create\_interface\_elements();
 
 \textcolor{comment}{// Rebuild the Problem's global mesh from its various sub-meshes}
 rebuild\_global\_mesh();
 
 \textcolor{comment}{// Pin horizontal displacement of all nodes}
 \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} n\_node = Bulk\_mesh\_pt->nnode();
 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} n=0;n<n\_node;n++) \{ Bulk\_mesh\_pt->node\_pt(n)->pin\_position(0); \}

\end{DoxyCodeInclude}


To ensure that precisely one fluid pressure degree of freedom is pinned, we unpin all pressure degrees of freedom, pin any redundant nodal pressures which have arisen following mesh adaptation and call {\ttfamily fix\+\_\+pressure}(...). We also pin any redundant solid pressures before re-\/setting the boundary conditions.


\begin{DoxyCodeInclude}
 \textcolor{comment}{// Unpin all fluid pressure dofs}
 RefineableNavierStokesEquations<2>::
  unpin\_all\_pressure\_dofs(Bulk\_mesh\_pt->element\_pt());
 
 \textcolor{comment}{// Pin redudant fluid pressure dofs}
 RefineableNavierStokesEquations<2>::
  pin\_redundant\_nodal\_pressures(Bulk\_mesh\_pt->element\_pt());
 
 \textcolor{comment}{// Now set the pressure in the first element at 'node' 0 to 0.0}
 fix\_pressure(0,0,0.0);
 
 \textcolor{comment}{// Pin the redundant solid pressures (if any)}
 PVDEquationsBase<2>::pin\_redundant\_nodal\_solid\_pressures(
  Bulk\_mesh\_pt->element\_pt());

 \textcolor{comment}{// Reset the boundary conditions}
 set\_boundary\_conditions();

\} \textcolor{comment}{// End of actions\_after\_adapt}

\end{DoxyCodeInclude}




 

\hypertarget{index_create_interface_elements}{}\section{Create interface elements}\label{index_create_interface_elements}
This function is used to `attach\textquotesingle{} interface elements to the upper face of those bulk elements in the lower fluid which are adjacent to the interface. Firstly, we loop over all bulk elements (in either fluid) which are adjacent to the interface.


\begin{DoxyCodeInclude}
\textcolor{comment}{//==start\_of\_create\_interface\_elements====================================}
\textcolor{comment}{/// \(\backslash\)short Create interface elements between the two fluids in the mesh}
\textcolor{comment}{}\textcolor{comment}{/// pointed to by Bulk\_mesh\_pt and add the elements to the Mesh object}
\textcolor{comment}{}\textcolor{comment}{/// pointed to by Surface\_mesh\_pt.}
\textcolor{comment}{}\textcolor{comment}{//========================================================================}
\textcolor{keyword}{template} <\textcolor{keyword}{class} ELEMENT, \textcolor{keyword}{class} TIMESTEPPER>
\textcolor{keywordtype}{void} \hyperlink{classInterfaceProblem_a94e2cc71fe27c0c329030874e05734b8}{InterfaceProblem<ELEMENT,TIMESTEPPER>::create\_interface\_elements}
      ()
\{
 \textcolor{comment}{// Determine number of bulk elements adjacent to interface (boundary 4)}
 \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} n\_element = this->Bulk\_mesh\_pt->nboundary\_element(4);
 
 \textcolor{comment}{// Loop over those elements adjacent to the interface}
 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} e=0;e<n\_element;e++)
  \{
   \textcolor{comment}{// Get pointer to the bulk element that is adjacent to the interface}
   ELEMENT* bulk\_elem\_pt = \textcolor{keyword}{dynamic\_cast<}ELEMENT*\textcolor{keyword}{>}(
    this->Bulk\_mesh\_pt->boundary\_element\_pt(4,e));

\end{DoxyCodeInclude}


In order to determine whether the bulk element we are currently looking at is in the upper or lower fluid, we check to see whether that element\textquotesingle{}s {\ttfamily viscosity\+\_\+ratio\+\_\+pt} is pointing to the address of {\ttfamily \hyperlink{namespaceGlobal__Physical__Variables_adb51428300a01b19395c43c0d3586d6f}{Global\+\_\+\+Physical\+\_\+\+Variables\+::\+Viscosity\+\_\+\+Ratio}}. If it is, then that bulk element is in the upper fluid, and we ignore it. Otherwise, we determine the face of the bulk element that corresponds to the interface and create an interface element on that face. The newly-\/created element is then added to the surface mesh.


\begin{DoxyCodeInclude}
   \textcolor{comment}{// We only want to attach interface elements to the bulk elements}
   \textcolor{comment}{// which are BELOW the interface, and so we filter out those above by}
   \textcolor{comment}{// referring to the viscosity\_ratio\_pt}
   \textcolor{keywordflow}{if}(bulk\_elem\_pt->viscosity\_ratio\_pt()
      !=&\hyperlink{namespaceGlobal__Physical__Variables_adb51428300a01b19395c43c0d3586d6f}{Global\_Physical\_Variables::Viscosity\_Ratio})
    \{
     \textcolor{comment}{// Find index of the face of element e that corresponds to the interface}
     \textcolor{keyword}{const} \textcolor{keywordtype}{int} face\_index = this->Bulk\_mesh\_pt->face\_index\_at\_boundary(4,e);
     
     \textcolor{comment}{// Create the interface element}
     FiniteElement* interface\_element\_element\_pt =
      \textcolor{keyword}{new} ElasticLineFluidInterfaceElement<ELEMENT>(bulk\_elem\_pt,face\_index);

     \textcolor{comment}{// Add the interface element to the surface mesh}
     this->Surface\_mesh\_pt->add\_element\_pt(interface\_element\_element\_pt);
    \}

\end{DoxyCodeInclude}


Finally, we pass the Strouhal and Capillary numbers to the interface elements.


\begin{DoxyCodeInclude}
 \textcolor{comment}{// Complete the setup to make the elements fully functional}
 \textcolor{comment}{// --------------------------------------------------------}

 \textcolor{comment}{// Determine number of 1D interface elements in mesh}
 \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} n\_interface\_element = this->Surface\_mesh\_pt->nelement();

 \textcolor{comment}{// Loop over the interface elements}
 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} e=0;e<n\_interface\_element;e++)
  \{
   \textcolor{comment}{// Upcast from GeneralisedElement to the present element}
   ElasticLineFluidInterfaceElement<ELEMENT>* el\_pt = 
    \textcolor{keyword}{dynamic\_cast<}ElasticLineFluidInterfaceElement<ELEMENT>*\textcolor{keyword}{>}
    (Surface\_mesh\_pt->element\_pt(e));

   \textcolor{comment}{// Set the Strouhal number}
   el\_pt->st\_pt() = &\hyperlink{namespaceGlobal__Physical__Variables_a4b6ef72bd221361c37f5b9a4a6899afc}{Global\_Physical\_Variables::St};

   \textcolor{comment}{// Set the Capillary number}
   el\_pt->ca\_pt() = &\hyperlink{namespaceGlobal__Physical__Variables_a8b32b93d2e546f9375ec418474107838}{Global\_Physical\_Variables::Ca};

  \} \textcolor{comment}{// End of loop over interface elements}

\} \textcolor{comment}{// End of create\_interface\_elements}

\end{DoxyCodeInclude}




 

\hypertarget{index_delete_interface_elements}{}\section{Delete interface elements}\label{index_delete_interface_elements}
This function loops over all the interface elements (i.\+e. those in the surface mesh) and deletes them and their storage.


\begin{DoxyCodeInclude}
\textcolor{comment}{//==start\_of\_delete\_interface\_elements====================================}
\textcolor{comment}{/// Delete the interface elements and wipe the surface mesh}
\textcolor{comment}{}\textcolor{comment}{//========================================================================}
\textcolor{keyword}{template} <\textcolor{keyword}{class} ELEMENT, \textcolor{keyword}{class} TIMESTEPPER>
\textcolor{keywordtype}{void} \hyperlink{classInterfaceProblem_ac2aaab086d9bbd3913ce8bc0d244413d}{InterfaceProblem<ELEMENT,TIMESTEPPER>::delete\_interface\_elements}
      ()
\{
 \textcolor{comment}{// Determine number of interface elements}
 \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} n\_interface\_element = Surface\_mesh\_pt->nelement();
 
 \textcolor{comment}{// Loop over interface elements and delete}
 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} e=0;e<n\_interface\_element;e++)
  \{
   \textcolor{keyword}{delete} Surface\_mesh\_pt->element\_pt(e);
  \}
 
 \textcolor{comment}{// Wipe the mesh}
 Surface\_mesh\_pt->flush\_element\_and\_node\_storage();
 
\} \textcolor{comment}{// End of delete\_interface\_elements}

\end{DoxyCodeInclude}




 

\hypertarget{index_deform_free_surface}{}\section{Prescribing the initial free surface position}\label{index_deform_free_surface}
At the beginning of the simulation the interface is deformed by a prescribed function (11), implemented in the function {\ttfamily deform\+\_\+free\+\_\+surface}(...), which cycles through the bulk mesh\textquotesingle{}s {\ttfamily Nodes} and modifies their positions such that the nodes on the free surface follow the prescribed interface shape and the bulk nodes retain their fractional position between the solid boundaries and the (now deformed) interface.


\begin{DoxyCodeInclude}
\textcolor{comment}{//==start\_of\_deform\_free\_surface==========================================}
\textcolor{comment}{/// Deform the mesh/free surface to a prescribed function}
\textcolor{comment}{}\textcolor{comment}{//========================================================================}
\textcolor{keyword}{template} <\textcolor{keyword}{class} ELEMENT, \textcolor{keyword}{class} TIMESTEPPER>
\textcolor{keywordtype}{void} \hyperlink{classInterfaceProblem_a2319232b08d9df1ab473f6cbd40939d5}{InterfaceProblem<ELEMENT,TIMESTEPPER>::}
\hyperlink{classInterfaceProblem_a2319232b08d9df1ab473f6cbd40939d5}{deform\_free\_surface}(\textcolor{keyword}{const} \textcolor{keywordtype}{double} &epsilon,\textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} &n\_periods)
\{
 \textcolor{comment}{// Determine number of nodes in the "bulk" mesh}
 \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} n\_node = Bulk\_mesh\_pt->nnode();
 
 \textcolor{comment}{// Loop over all nodes in mesh}
 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} n=0;n<n\_node;n++)
  \{
   \textcolor{comment}{// Determine eulerian position of node}
   \textcolor{keyword}{const} \textcolor{keywordtype}{double} current\_x\_pos = Bulk\_mesh\_pt->node\_pt(n)->x(0);
   \textcolor{keyword}{const} \textcolor{keywordtype}{double} current\_y\_pos = Bulk\_mesh\_pt->node\_pt(n)->x(1);
   
   \textcolor{comment}{// Determine new vertical position of node}
   \textcolor{keyword}{const} \textcolor{keywordtype}{double} new\_y\_pos = current\_y\_pos
    + (1.0-fabs(1.0-current\_y\_pos))*epsilon
    *(cos(2.0*n\_periods*MathematicalConstants::Pi*current\_x\_pos/Lx));
   
   \textcolor{comment}{// Set new position}
   Bulk\_mesh\_pt->node\_pt(n)->x(1) = new\_y\_pos;
  \}
\} \textcolor{comment}{// End of deform\_free\_surface}

\end{DoxyCodeInclude}




 

\hypertarget{index_doc}{}\section{Post-\/processing}\label{index_doc}
This function is identical to that in the \href{../../single_layer_free_surface/html/index.html#doc}{\tt previous example}.



 

\hypertarget{index_unsteady_run}{}\section{The timestepping loop}\label{index_unsteady_run}
The function {\ttfamily unsteady\+\_\+run}(...) is used to perform the timestepping procedure, and is very similar to that in the \href{../../single_layer_free_surface/html/index.html#unsteady_run}{\tt previous example}. The only changes arise due to this problem being solved with spatial adaptivity. We start by deforming the interface in the manner specified by equation (11).


\begin{DoxyCodeInclude}
\textcolor{comment}{//==start\_of\_unsteady\_run=================================================}
\textcolor{comment}{/// Perform run up to specified time t\_max with given timestep dt}
\textcolor{comment}{}\textcolor{comment}{//========================================================================}
\textcolor{keyword}{template} <\textcolor{keyword}{class} ELEMENT, \textcolor{keyword}{class} TIMESTEPPER>
\textcolor{keywordtype}{void} \hyperlink{classInterfaceProblem_adf1f4e43d10939e4323e0e315b711085}{InterfaceProblem<ELEMENT,TIMESTEPPER>::}
\hyperlink{classInterfaceProblem_adf1f4e43d10939e4323e0e315b711085}{unsteady\_run}(\textcolor{keyword}{const} \textcolor{keywordtype}{double} &t\_max, \textcolor{keyword}{const} \textcolor{keywordtype}{double} &dt)
\{

 \textcolor{comment}{// Set value of epsilon}
 \textcolor{keyword}{const} \textcolor{keywordtype}{double} epsilon = 0.1;

 \textcolor{comment}{// Set number of periods for cosine term}
 \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} n\_periods = 1;

 \textcolor{comment}{// Deform the mesh/free surface}
 deform\_free\_surface(epsilon,n\_periods);

\end{DoxyCodeInclude}


We then create a {\ttfamily Doc\+Info} object to store the output directory and the label for the output files.


\begin{DoxyCodeInclude}
 \textcolor{comment}{// Initialise DocInfo object}
 DocInfo doc\_info;

 \textcolor{comment}{// Set output directory}
 doc\_info.set\_directory(\textcolor{stringliteral}{"RESLT"});

 \textcolor{comment}{// Initialise counter for solutions}
 doc\_info.number()=0;

\end{DoxyCodeInclude}


Next we open and initialise the trace file.


\begin{DoxyCodeInclude}
 \textcolor{comment}{// Open trace file}
 \textcolor{keywordtype}{char} filename[100];   
 sprintf(filename,\textcolor{stringliteral}{"%s/trace.dat"},doc\_info.directory().c\_str());
 Trace\_file.open(filename);

 \textcolor{comment}{// Initialise trace file}
 Trace\_file << \textcolor{stringliteral}{"time, interface height"} << std::endl;

\end{DoxyCodeInclude}


Before using any of {\ttfamily oomph-\/lib\textquotesingle{}s} timestepping functions, the timestep $ dt $ must be passed to the problem\textquotesingle{}s timestepping routines by calling the function {\ttfamily Problem\+::initialise\+\_\+dt}(...) which sets the weights for all timesteppers in the problem. Next we assign the initial conditions by calling {\ttfamily Problem\+::set\+\_\+initial\+\_\+condition()}, which was discussed \href{#set_initial_condition}{\tt above}.


\begin{DoxyCodeInclude}
 \textcolor{comment}{// Initialise timestep}
 initialise\_dt(dt);

 \textcolor{comment}{// Set initial condition}
 set\_initial\_condition();

\end{DoxyCodeInclude}


We limit number of spatial adaptations per timestep to two and refine the problem uniformly twice, before documenting the initial conditions.


\begin{DoxyCodeInclude}
 \textcolor{comment}{// Maximum number of spatial adaptations per timestep}
 \textcolor{keywordtype}{unsigned} max\_adapt = 2;

 \textcolor{comment}{// Call refine\_uniformly twice}
 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} i=0;i<2;i++) \{ refine\_uniformly(); \}

 \textcolor{comment}{// Doc initial solution}
 doc\_solution(doc\_info);

 \textcolor{comment}{// Increment counter for solutions}
 doc\_info.number()++;

\end{DoxyCodeInclude}


Finally, we determine the number of timesteps to be performed and perform the actual timestepping loop. For each timestep the function {\ttfamily unsteady\+\_\+newton\+\_\+solve(dt,max\+\_\+adapt,first\+\_\+timestep)} is called and the solution documented. The boolean flag {\ttfamily first\+\_\+timestep} is used to instruct the code to re-\/assign the initial conditions after every mesh adaptation. After the first timestep, the maximum number of adaptations for all timesteps is reset to one. We refer to \href{../../../unsteady_heat/two_d_unsteady_heat_adapt/html/index.html#spatial_adapt}{\tt another example} for a discussion of why this is recommended.


\begin{DoxyCodeInclude}
 \textcolor{comment}{// Determine number of timesteps}
 \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} n\_timestep = unsigned(t\_max/dt);

 \textcolor{comment}{// Are we on the first timestep? At this point, yes!}
 \textcolor{keywordtype}{bool} first\_timestep = \textcolor{keyword}{true};

 \textcolor{comment}{// Timestepping loop}
 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} t=1;t<=n\_timestep;t++)
  \{
   \textcolor{comment}{// Output current timestep to screen}
   cout << \textcolor{stringliteral}{"\(\backslash\)nTimestep "} << t << \textcolor{stringliteral}{" of "} << n\_timestep << std::endl;
   
   \textcolor{comment}{// Take one fixed timestep with spatial adaptivity}
   unsteady\_newton\_solve(dt,max\_adapt,first\_timestep);

   \textcolor{comment}{// No longer on first timestep, so set first\_timestep flag to false}
   first\_timestep = \textcolor{keyword}{false}; 

   \textcolor{comment}{// Reset maximum number of adaptations for all future timesteps}
   max\_adapt = 1;

   \textcolor{comment}{// Doc solution}
   doc\_solution(doc\_info);

   \textcolor{comment}{// Increment counter for solutions }
   doc\_info.number()++;

  \} \textcolor{comment}{// End of timestepping loop}

\} \textcolor{comment}{// End of unsteady\_run}

\end{DoxyCodeInclude}




 

\hypertarget{index_comments}{}\section{Comments}\label{index_comments}

\begin{DoxyItemize}
\item Since the problem discussed in this example has the fluid velocity prescribed along the entire domain boundary, the fluid pressure is only determined up to an arbitrary constant and hence we fix the pressure at a single point in the domain. However, it is worth noting that in the case of Crouzeix--Raviart elements being used in a problem with spatial adaptivity the notion of a fixed pressure is slightly subtle. In this example we fix the first pressure value of the first element in the mesh to zero, which in the case of Crouzeix--Raviart elements means that we fix the average value of the pressure to zero in this element. Were this element to be refined, however, we would then be imposing a zero pressure elsewhere in the domain, causing the entire pressure field to `jump\textquotesingle{} from one timestep to the next. Since the problem is incompressible this would not affect the computed velocity fields, but could lead to some confusion when studying the time evolution of the pressure field.
\end{DoxyItemize}



 

\hypertarget{index_exercises}{}\section{Exercises}\label{index_exercises}

\begin{DoxyItemize}
\item In the \href{../../single_layer_free_surface/html/index.html}{\tt single-\/layer example} we chose to discretise the problem using Crouzeix--Raviart elements, but we could also have chosen to use Taylor--Hood elements. Why can we not use Taylor--Hood elements to solve this two-\/layer problem?
\item What happens if we do not call {\ttfamily setup\+\_\+boundary\+\_\+element\+\_\+info()} in the \href{#mesh}{\tt mesh constructor}? Why is this?
\end{DoxyItemize}



 

\hypertarget{index_sources}{}\section{Source files for this tutorial}\label{index_sources}

\begin{DoxyItemize}
\item The source files for this tutorial are located in the directory\+: \begin{center} \href{../../../../demo_drivers/navier_stokes/two_layer_interface/}{\tt demo\+\_\+drivers/navier\+\_\+stokes/two\+\_\+layer\+\_\+interface/ } \end{center} 
\item The driver code is\+: \begin{center} \href{../../../../demo_drivers/navier_stokes/two_layer_interface/elastic_two_layer_interface.cc}{\tt demo\+\_\+drivers/navier\+\_\+stokes/two\+\_\+layer\+\_\+interface/elastic\+\_\+two\+\_\+layer\+\_\+interface.\+cc } \end{center} 
\end{DoxyItemize}



 

 \hypertarget{index_pdf}{}\section{P\+D\+F file}\label{index_pdf}
A \href{../latex/refman.pdf}{\tt pdf version} of this document is available. \end{document}
