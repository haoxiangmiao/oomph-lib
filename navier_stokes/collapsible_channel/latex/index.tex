The moving-\/boundary Navier-\/\+Stokes problem discussed in this document is a \char`\"{}warm-\/up\char`\"{} problem for the classical fluid-\/structure interaction problem of flow in a 2D collapsible channel. Here we compute the flow through a 2D channel in which part of one wall is replaced by a moving \char`\"{}membrane\char`\"{} whose motion is prescribed. In \href{../../../interaction/fsi_collapsible_channel/html/index.html}{\tt another example}, we will demonstrate how easy it is to extend the driver code for the current problem to a fluid-\/structure interaction problem in which the \char`\"{}membrane\char`\"{} is represented by an elastic beam that deforms in response to the fluid traction.

We note that the (F\+SI version of the) problem considered here was analysed in much more detail in


\begin{DoxyItemize}
\item Jensen, O.\+E. \& Heil, M. (2003) High-\/frequency self-\/excited oscillations in a collapsible-\/channel flow. {\itshape Journal of Fluid Mechanics} {\bfseries 481} 235-\/268. \href{http://www.maths.man.ac.uk/~mheil/MATTHIAS/PDF/JensenHeil2003.pdf}{\tt (pdf preprint)} \href{http://www.maths.man.ac.uk/~mheil/MATTHIAS/ABSTRACTS/JensenHeil02.html}{\tt (abstract)} 
\end{DoxyItemize}where a detailed discussion (and an asymptotic analysis) of the flow-\/structures described below may be found.



 

\hypertarget{index_problem}{}\section{The problem}\label{index_problem}
\begin{center} \tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*{1}{|X[-1]}|}
\hline
\begin{center} {\bfseries Finite-\/\+Reynolds-\/number flow in a 2D channel with an oscillating wall .} \end{center} 

The figure below shows a sketch of the problem\+: Flow is driven by a prescribed pressure drop through a 2D channel of width $ H^* $ and total length $ L^*_{total} = L^*_{up} + L^*_{collapsible} + L^*_{down}. $ The upstream and downstream lengths of the channel are rigid, whereas the upper wall in the central section performs a prescribed oscillation. The shape of the moving segment is parametrised by a Lagrangian coordinate, $ \zeta^* $ , so that the position vector to the moving wall is given by $ {\bf R}_w^*(\zeta^*,t^*)$ .

 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{collapsible_channel_sketch}
\doxyfigcaption{Sketch of the problem. }
\end{DoxyImage}


We scale all lengths on the channel width, $ H^* $ , use the average velocity through the undeformed channel, $ U =P^*_{up} H^{*2}/(12 \mu L^*_{total}) $ , to scale the velocities, and use $ H^{*}/U $ to non-\/dimensionalise time. (As usual, we employ asterisks distinguish dimensional parameters from their non-\/dimensional equivalents.)

The flow is then governed by the unsteady Navier-\/\+Stokes equations \[ Re\left(St\frac{\partial u_i}{\partial t} + u_j\frac{\partial u_i}{\partial x_j}\right) = - \frac{\partial p}{\partial x_i} + \frac{\partial }{\partial x_j} \left( \frac{\partial u_i}{\partial x_j} + \frac{\partial u_j}{\partial x_i} \right) \ \ \ \ \ \ \ \ \ \ (1) \] and the continuity equation \[ \frac{\partial u_i}{\partial x_i} = 0 \ \ \ \ \ \ \ \ \ \ (2) \] with $ St=1 $ , subject to the following boundary and initial conditions\+:
\begin{DoxyItemize}
\item Initial condition\+: Poiseuille flow, i.\+e. \[ {\bf u}(x_1,x_2,t=0) = {\bf u}_{Poiseuille}(x_1,x_2) = 6 \ x_2 \ (1-x_2) \ {\bf e}_1. \ \ \ \ \ \ \ \ \ \ (3) \]
\item Parallel inflow, $ {\bf u} \cdot {\bf e}_2 = {\bf 0}, $ and an applied axial traction of $ {\bf t} \cdot {\bf e}_1 = p_{up} = 12 \ L_{total} $ at the upstream end, $ x_1=0 $ .
\item Parallel, axially traction-\/free outflow at the downstream end, i.\+e. $ {\bf u} \cdot {\bf e}_2 = {\bf 0} $ and $ {\bf t} \cdot {\bf e}_1 = p_{down} = 0 $ at $ x_1=L_{total} $ .
\item No slip on all channel walls, i.\+e. $ {\bf u} = {\bf 0} $ on the rigid walls and \[ {\bf u} = \frac{\partial {\bf R}_w}{\partial t} \mbox{\ \ \ \ on the moving wall.} \ \ \ \ \ \ \ \ \ \ (4) \]
\end{DoxyItemize}

\\\cline{1-1}
\end{longtabu}
\end{center} 

We consider a wall motion that deforms the initially \char`\"{}flush\char`\"{} wall into a parabolic shape. We denote the non-\/dimensional amplitude of the oscillation by $ A $ and its period by $ T $ , and parametrise the position vector to a point on the wall by the Lagrangian coordinate $ \zeta \in [0,L_{collapsible}] $ as \[ {\bf R}_w(\zeta,t) = \left( \begin{array}{l} L_{up} + \zeta \\ 1 + A \left(\frac{2}{L_{collapsible}}\right)^2 \zeta \ (L-\zeta) \ \sin(2\pi t / T) \ {\cal R}(t) \end{array} \right), \ \ \ \ \ \ \ \ \ \ (5) \] where the \char`\"{}ramp\char`\"{} function \[ {\cal R}(t) = \left\{ \begin{array}{ll} \frac{1}{2}(1-\cos(\pi t/T)) & \mbox{for $t<T$} \\ 1 & \mbox{for $t \ge T$} \end{array} \right. \] is used to facilitate the start-\/up of the simulation from the initial condition of steady Poiseuille flow. $ {\cal R}(t) $ provides a \char`\"{}smooth\char`\"{} startup of the wall motion during the first period of the oscillation.



 

\hypertarget{index_reslt}{}\section{The results}\label{index_reslt}
The figure below shows a snapshot, taken from \href{../figures/flow.avi}{\tt the animation of the computational results}. The first four figures show (from top left to bottom right) \char`\"{}carpet plots\char`\"{} of the axial and transverse velocities, the axial component of the perturbation velocity $ {\bf u} - {\bf u}_{Poiseuille} $ , and the pressure distribution. The 2D contour plot at the bottom of the figure shows a contour plot of the pressure and a few instantaneous streamlines.

 
\begin{DoxyImage}
\includegraphics[width=0.20\textwidth]{flow}
\doxyfigcaption{Snapshot from the animation of the flow field for Re = Re St = 50, T=0.45, A=0.01. }
\end{DoxyImage}


The figures illustrate the flow structures identified in \href{http://www.maths.man.ac.uk/~mheil/MATTHIAS/PDF/JensenHeil2003.pdf}{\tt Jensen \& Heil\textquotesingle{}s (2003)} asymptotic analysis of 2D channel flows that are driven by high-\/frequency, small-\/amplitude oscillations of a finite section of one of their walls\+: The flow consists of oscillatory axial \char`\"{}sloshing flows\char`\"{}, superimposed on the mean Poiseuille flow that is driven by the applied pressure drop. During phases when the wall moves inwards (outwards) the flow generated by the moving wall decelerates (accelerates) the flow in the upstream region as the wall \char`\"{}injects\char`\"{} fluid into (\char`\"{}sucks\char`\"{} fluid out of) the domain. Conversely, in the downstream region the flow generated by the wall adds to the pressure-\/driven mean flow during phases when the wall moves inwards. This is shown most clearly in the plot of the axial velocity perturbation. In the plots shown above, the wall moves outwards and the axial perturbation velocity is positive (i.\+e. in the direction of the pressure-\/driven mean flow) in the upstream region, and negative in the downstream region. This is also shown in the time-\/traces of the velocities at two control points in the in-\/ and outflow cross-\/sections, shown in the figure below\+:

 
\begin{DoxyImage}
\includegraphics[width=0.20\textwidth]{trace}
\doxyfigcaption{Time-\/trace of the axial velocities at two control points in the upstream and downstream cross-\/sections, and the vertical position of a control point on the wall. (Re = Re St = 50, T=0.45, A=0.01.) }
\end{DoxyImage}


Finally, we comment that the plot of the perturbation velocities confirms the two-\/layer structure of the sloshing flows predicted in the asymptotic analysis. The sloshing flow comprises a blunt core flow region in which the flow is dominated by inertial effects while thin Stokes layers develop near the wall. Within these layers, the fluid viscosity reduces the axial velocity to zero. The carpet plot of the pressure shows that the pressure distribution is dominated by the variations induced by the oscillatory sloshing flows. For a detailed discussion of the flow structure we refer to \href{http://www.maths.man.ac.uk/~mheil/MATTHIAS/PDF/JensenHeil2003.pdf}{\tt Jensen \& Heil (2003).}



 

\hypertarget{index_overview}{}\section{Overview of the driver code}\label{index_overview}
Overall, the driver code is very similar to codes developed for other moving-\/boundary Navier-\/\+Stokes problems, such as the driver code used to simulate the \href{../../osc_ellipse/html/index.html}{\tt flow inside an oscillating ellipse.} The present code is slightly lengthier because of the traction boundary conditions which we impose by attaching traction elements to the upstream end of the mesh. (Refer to the \href{../../../navier_stokes/rayleigh_traction_channel/html/index.html}{\tt traction-\/driven Rayleigh problem} for a more detailed discussion of this technique.) Also, as discussed in \href{../../../poisson/two_d_poisson_flux_bc_adapt/html/index.html}{\tt another example}, the traction elements must be removed/re-\/attached before/after every mesh adaptation.

The domain is discretised by the \href{../../../meshes/mesh_list/html/index.html#collapsible_channel}{\tt {\ttfamily Collapsible\+Channel\+Mesh}} which employs the {\ttfamily Collapsible\+Channel\+Domain} to provide a {\ttfamily Macro\+Element} -\/ based representation of the deforming domain in terms of the {\ttfamily Geom\+Object} that describes the motion of the \char`\"{}collapsible\char`\"{} section of the wall (boundary 3). The sketch below illustrates the topology and the mesh deformation\+: As the wall deforms, the boundaries of the {\ttfamily Macro\+Elements} in the \char`\"{}collapsible\char`\"{} part of the {\ttfamily Domain} follow the wall motion.

 
\begin{DoxyImage}
\includegraphics[width=0.20\textwidth]{mesh}
\doxyfigcaption{Sketch of the Collapsible\+Channel\+Domain/\+Mesh. }
\end{DoxyImage}


The no-\/slip boundary conditions on the moving wall are applied as in the \href{../../osc_ellipse/html/index.html}{\tt oscillating ellipse problem,} by executing the function {\ttfamily F\+S\+I\+\_\+functions\+::apply\+\_\+no\+\_\+slip\+\_\+on\+\_\+moving\+\_\+wall}(...) in {\ttfamily Problem\+::actions\+\_\+before\+\_\+implicit\+\_\+timestep()} for all nodes that are located on boundary 3.

The following sections provide a complete annotated listing of the driver code. Most functions should already be familiar from previous examples and you may want to skip straight to the \hyperlink{index_comments}{Comments and Exercises}.



 

\hypertarget{index_wall}{}\section{The moving wall}\label{index_wall}
As usual, we represent the moving wall as a {\ttfamily Geom\+Object} and define its shape by implementing the pure virtual function {\ttfamily Geom\+Object\+::position}(...). The arguments to the constructor specify the Eulerian coordinates of wall\textquotesingle{}s left end, its undeformed length, the amplitude of the oscillations, $ A $ , and the period of the oscillations $ T $ . We also pass the pointer to a {\ttfamily Time} object to the constructor and store it in a private data member, to allow the {\ttfamily position}(...) functions to access the current value of the continuous time. The amplitude of the wall motion, and the period of its oscillations are stored as private data members, accessible via suitable member functions.

 
\begin{DoxyCodeInclude}
\textcolor{comment}{//===============start\_of\_oscillating\_wall=================================}
\textcolor{comment}{/// Straight, horizontal channel wall at \(\backslash\)f$ y=H \(\backslash\)f$ deforms into an }
\textcolor{comment}{}\textcolor{comment}{/// oscillating parabola. The amplitude of the oscillation }
\textcolor{comment}{}\textcolor{comment}{/// \(\backslash\)f$ A \(\backslash\)f$ and its period is \(\backslash\)f$ T \(\backslash\)f$.}
\textcolor{comment}{}\textcolor{comment}{/// The position vector to a point on the wall, parametrised by}
\textcolor{comment}{}\textcolor{comment}{/// the Lagrangian coordinate \(\backslash\)f$ \(\backslash\)zeta \(\backslash\)in [0,L]\(\backslash\)f$, is therefore given by}
\textcolor{comment}{}\textcolor{comment}{/// \(\backslash\)f[ \{\(\backslash\)bf R\}(\(\backslash\)zeta,t) = }
\textcolor{comment}{}\textcolor{comment}{///   \(\backslash\)left(}
\textcolor{comment}{}\textcolor{comment}{///   \(\backslash\)begin\{array\}\{c\}}
\textcolor{comment}{}\textcolor{comment}{///   L\_\{up\} + \(\backslash\)zeta  \(\backslash\)\(\backslash\)   1 }
\textcolor{comment}{}\textcolor{comment}{///   \(\backslash\)end\{array\}}
\textcolor{comment}{}\textcolor{comment}{///   \(\backslash\)right)}
\textcolor{comment}{}\textcolor{comment}{///   + A}
\textcolor{comment}{}\textcolor{comment}{///   \(\backslash\)left(}
\textcolor{comment}{}\textcolor{comment}{///   \(\backslash\)begin\{array\}\{l\}}
\textcolor{comment}{}\textcolor{comment}{///   - B \(\backslash\)sin\(\backslash\)left(\(\backslash\)frac\{2\(\backslash\)pi\}\{L\_\{collapsible\}\}\(\backslash\)zeta\(\backslash\)right) \(\backslash\)\(\backslash\) \(\backslash\)left(}
\textcolor{comment}{}\textcolor{comment}{///   \(\backslash\)frac\{2\}\{L\_\{collapsible\}\}\(\backslash\)right)^2 \(\backslash\)zeta \(\backslash\) (L-\(\backslash\)zeta)}
\textcolor{comment}{}\textcolor{comment}{///   \(\backslash\)end\{array\}}
\textcolor{comment}{}\textcolor{comment}{///   \(\backslash\)right)   }
\textcolor{comment}{}\textcolor{comment}{///   \(\backslash\) \(\backslash\)sin\(\backslash\)left(\(\backslash\)frac\{2\(\backslash\)pi t\}\{T\}\(\backslash\)right)}
\textcolor{comment}{}\textcolor{comment}{///   \(\backslash\) \{\(\backslash\)cal R\}(t)}
\textcolor{comment}{}\textcolor{comment}{///  \(\backslash\)f]}
\textcolor{comment}{}\textcolor{comment}{/// The parameter \(\backslash\)f$ B \(\backslash\)f$ is zero by default. If it is set to a nonzero}
\textcolor{comment}{}\textcolor{comment}{/// value, the material particles on the wall also perform some }
\textcolor{comment}{}\textcolor{comment}{/// horizontal motion. The "ramp" function }
\textcolor{comment}{}\textcolor{comment}{/// \(\backslash\)f[ }
\textcolor{comment}{}\textcolor{comment}{/// \{\(\backslash\)cal R\}(t) =  \(\backslash\)left\(\backslash\)\{ }
\textcolor{comment}{}\textcolor{comment}{/// \(\backslash\)begin\{array\}\{ll\}  }
\textcolor{comment}{}\textcolor{comment}{/// \(\backslash\)frac\{1\}\{2\}(1-\(\backslash\)cos(\(\backslash\)pi t/T)) & \(\backslash\)mbox\{for $t<T$\} \(\backslash\)\(\backslash\) 1 & \(\backslash\)mbox\{for $t \(\backslash\)ge T$\}}
\textcolor{comment}{}\textcolor{comment}{/// \(\backslash\)end\{array\} }
\textcolor{comment}{}\textcolor{comment}{/// \(\backslash\)right.}
\textcolor{comment}{}\textcolor{comment}{/// \(\backslash\)f]}
\textcolor{comment}{}\textcolor{comment}{/// provides a "smooth" startup of the oscillation. }
\textcolor{comment}{}\textcolor{comment}{//=========================================================================}
\textcolor{keyword}{class }\hyperlink{classOscillatingWall}{OscillatingWall} : \textcolor{keyword}{public} GeomObject
\{

\textcolor{keyword}{public}:
\textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Constructor : It's a 2D object, parametrised by }
\textcolor{comment}{ /// one Lagrangian coordinate. Arguments: height at ends, x-coordinate of }
\textcolor{comment}{ /// left end, length, amplitude of deflection, period of oscillation, and}
\textcolor{comment}{ /// pointer to time object}
\textcolor{comment}{} \hyperlink{classOscillatingWall_a5ededc3d27eef5c4ef7e82ac5cdf6ff9}{OscillatingWall}(\textcolor{keyword}{const} \textcolor{keywordtype}{double}& h, \textcolor{keyword}{const} \textcolor{keywordtype}{double}& x\_left, \textcolor{keyword}{const} \textcolor{keywordtype}{double}& l, 
                 \textcolor{keyword}{const} \textcolor{keywordtype}{double}& a, \textcolor{keyword}{const} \textcolor{keywordtype}{double}& period, Time* time\_pt) : 
  GeomObject(1,2), \hyperlink{classOscillatingWall_aa587e944cac9e501e6d3323731145b95}{H}(h), \hyperlink{classOscillatingWall_ac5e2ad6d5ef2992ba9295118787190e6}{Length}(l), \hyperlink{classOscillatingWall_a71a60ee3294746875a24aeeffb38f7ec}{X\_left}(x\_left), \hyperlink{classOscillatingWall_ac22b6ac70a42850ddbe2e9c4c16f4664}{A}(a), \hyperlink{classOscillatingWall_a9db810649987a2011c7fe14d10b98b9a}{B}(0.0), 
      \hyperlink{classOscillatingWall_af33b31988c823d33a3b147281ec94599}{T}(period), 
  \hyperlink{classOscillatingWall_a9c4bea6ec6e80ba23139cd5a1d4d25d5}{Time\_pt}(time\_pt) 
  \{\}
 \textcolor{comment}{}
\textcolor{comment}{ /// Destructor:  Empty}
\textcolor{comment}{} \hyperlink{classOscillatingWall_adc35b40bdd733a244d6399d91fa20ade}{~OscillatingWall}()\{\}
\textcolor{comment}{}
\textcolor{comment}{///Access function to the amplitude}
\textcolor{comment}{} \textcolor{keywordtype}{double}& \hyperlink{classOscillatingWall_ae923c6a7abefe33efaf47a4b69d1b621}{amplitude}()\{\textcolor{keywordflow}{return} \hyperlink{classOscillatingWall_ac22b6ac70a42850ddbe2e9c4c16f4664}{A};\}
\textcolor{comment}{}
\textcolor{comment}{///Access function to the period}
\textcolor{comment}{} \textcolor{keywordtype}{double}& \hyperlink{classOscillatingWall_ac3e0098c026e23dd8be8ea29f6a9c101}{period}()\{\textcolor{keywordflow}{return} \hyperlink{classOscillatingWall_af33b31988c823d33a3b147281ec94599}{T};\}

\end{DoxyCodeInclude}


Since the {\ttfamily Geom\+Object} represents a moving (i.\+e. time-\/dependent) boundary, we implement both versions of the {\ttfamily Geom\+Object\+::position}(...) function\+: The \char`\"{}unsteady\char`\"{} version computes the position vector at the {\ttfamily t} -\/th previous timestep.


\begin{DoxyCodeInclude}
\textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Position vector at Lagrangian coordinate zeta }
\textcolor{comment}{ /// at time level t.}
\textcolor{comment}{} \textcolor{keywordtype}{void} position(\textcolor{keyword}{const} \textcolor{keywordtype}{unsigned}& t, \textcolor{keyword}{const} Vector<double>&zeta, 
               Vector<double>& r)\textcolor{keyword}{ const}
\textcolor{keyword}{  }\{
   \textcolor{keyword}{using namespace }MathematicalConstants;

   \textcolor{comment}{// Smoothly ramp up the oscillation during the first period}
   \textcolor{keywordtype}{double} ramp=1.0;
   \textcolor{keywordflow}{if} (Time\_pt->time(t)<T)
    \{
     ramp=0.5*(1.0-cos(Pi*Time\_pt->time(t)/T));
    \}
   
   \textcolor{comment}{// Position vector}
   r[0] = zeta[0]+X\_left 
    -B*A*sin(2.0*3.14159*zeta[0]/Length)*
    sin(2.0*Pi*(Time\_pt->time(t))/T)*ramp;

   r[1] = H+A*((Length-zeta[0])*zeta[0])/pow(0.5*Length,2)*
    sin(2.0*Pi*(Time\_pt->time(t))/T)*ramp;

  \} \textcolor{comment}{// end of "unsteady" version}

\end{DoxyCodeInclude}


The version without additional argument computes the position vector at the present time\+:


\begin{DoxyCodeInclude}

\textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short "Current" position vector at Lagrangian coordinate zeta }
\textcolor{comment}{} \textcolor{keywordtype}{void} position(\textcolor{keyword}{const} Vector<double>&zeta, Vector<double>& r)\textcolor{keyword}{ const}
\textcolor{keyword}{  }\{
   position (0, zeta, r);
  \}

\end{DoxyCodeInclude}


Finally, here are the various private data members\+:


\begin{DoxyCodeInclude}
 \textcolor{comment}{}
\textcolor{comment}{ /// Number of geometric Data in GeomObject: None.}
\textcolor{comment}{} \textcolor{keywordtype}{unsigned} ngeom\_data()\textcolor{keyword}{ const }\{\textcolor{keywordflow}{return} 0;\}              

\textcolor{keyword}{private}:
 \textcolor{comment}{}
\textcolor{comment}{ /// Height at ends}
\textcolor{comment}{} \textcolor{keywordtype}{double} H;
\textcolor{comment}{}
\textcolor{comment}{ /// Length}
\textcolor{comment}{} \textcolor{keywordtype}{double} Length;
\textcolor{comment}{}
\textcolor{comment}{ /// x-coordinate of left end}
\textcolor{comment}{} \textcolor{keywordtype}{double} X\_left;
\textcolor{comment}{}
\textcolor{comment}{ /// Amplitude of oscillation}
\textcolor{comment}{} \textcolor{keywordtype}{double} A;
\textcolor{comment}{}
\textcolor{comment}{ /// Relative amplitude of horizontal wall motion}
\textcolor{comment}{} \textcolor{keywordtype}{double} B;
\textcolor{comment}{}
\textcolor{comment}{ ///Period of the oscillations}
\textcolor{comment}{} \textcolor{keywordtype}{double} T;
\textcolor{comment}{}
\textcolor{comment}{ ///Pointer to the global time object}
\textcolor{comment}{} Time* Time\_pt;

\}; \textcolor{comment}{// end of oscillating wall}

\end{DoxyCodeInclude}


\mbox{[}{\bfseries Note\+:} We note that the {\ttfamily \hyperlink{classOscillatingWall}{Oscillating\+Wall}} class allows the wall shape to be slightly more complicated than required by (5). If the parameter {\ttfamily B} is set to a non-\/zero value, the material points on the wall also undergo some horizontal displacement. We will use this capability in one of the exercises in section \hyperlink{index_comments}{Comments and Exercises}.\mbox{]}



 

 \hypertarget{index_variables}{}\section{Namespace for the \char`\"{}global\char`\"{} physical variables}\label{index_variables}
As usual, we define the problem parameters in a namespace and assign default values that can be overwritten if required.

 
\begin{DoxyCodeInclude}
\textcolor{comment}{//====start\_of\_Global\_Physical\_Variables================}
\textcolor{comment}{/// Namespace for phyical parameters}
\textcolor{comment}{}\textcolor{comment}{//======================================================}
\textcolor{keyword}{namespace }\hyperlink{namespaceGlobal__Physical__Variables}{Global\_Physical\_Variables}
\{\textcolor{comment}{}
\textcolor{comment}{ /// Reynolds number}
\textcolor{comment}{} \textcolor{keywordtype}{double} Re=50.0;
\textcolor{comment}{}
\textcolor{comment}{ /// Womersley = Reynolds times Strouhal}
\textcolor{comment}{} \textcolor{keywordtype}{double} ReSt=50.0;
 \textcolor{comment}{}
\textcolor{comment}{ /// Default pressure on the left boundary}
\textcolor{comment}{} \textcolor{keywordtype}{double} P\_up=0.0;

\end{DoxyCodeInclude}


We also implement the function that defines the prescribed (axial) traction at the inflow boundary.


\begin{DoxyCodeInclude}
\textcolor{comment}{}
\textcolor{comment}{ /// Traction required at the left boundary}
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{namespaceGlobal__Physical__Variables_a0de42ee6d39e85c77c16a04c3a05f7a2}{prescribed\_traction}(\textcolor{keyword}{const} \textcolor{keywordtype}{double}& t,
                          \textcolor{keyword}{const} Vector<double>& x,
                          \textcolor{keyword}{const} Vector<double>& n,
                          Vector<double>& traction)
 \{
  traction.resize(2);
  traction[0]=\hyperlink{namespaceGlobal__Physical__Variables_ae1a493695b7f4619af32f405b0b28861}{P\_up};
  traction[1]=0.0;
 \} 

\} \textcolor{comment}{// end of Global\_Physical\_Variables}

\end{DoxyCodeInclude}




 

\hypertarget{index_main}{}\section{The driver code}\label{index_main}
 As with most previous time-\/dependent codes, we use command line arguments to indicate if the code is run during {\ttfamily oomph-\/lib\textquotesingle{}s} self-\/test. If any command line arguments are specified, we use a coarser discretisation and perform fewer timesteps.

After storing the command line arguments, we choose the number of elements in the mesh, set the lengths of the domain and choose the amplitude and period of the oscillation. The parameter values are chosen such that the wall motion resembles that in the F\+SI simulations shown in Fig. 5 of \href{http://www.maths.man.ac.uk/~mheil/MATTHIAS/PDF/JensenHeil2003.pdf}{\tt Jensen \& Heil (2003).}


\begin{DoxyCodeInclude}
\textcolor{comment}{//=======start\_of\_driver\_code==================================================}
\textcolor{comment}{/// Driver code for an unsteady adaptive collapsible channel problem}
\textcolor{comment}{}\textcolor{comment}{/// with prescribed wall motion. Presence of command line arguments}
\textcolor{comment}{}\textcolor{comment}{/// indicates validation run with coarse resolution and small number of}
\textcolor{comment}{}\textcolor{comment}{/// timesteps.}
\textcolor{comment}{}\textcolor{comment}{//=============================================================================}
\textcolor{keywordtype}{int} \hyperlink{collapsible__channel_8cc_a0ddf1224851353fc92bfbff6f499fa97}{main}(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char}* argv[])
\{

 \textcolor{comment}{// Store command line arguments}
 CommandLineArgs::setup(argc,argv);
  
 \textcolor{comment}{// Reduction in resolution for validation run?}
 \textcolor{keywordtype}{unsigned} coarsening\_factor=1;
 \textcolor{keywordflow}{if} (CommandLineArgs::Argc>1)
  \{
   coarsening\_factor=4;
  \}

 \textcolor{comment}{// Number of elements in the domain}
 \textcolor{keywordtype}{unsigned} nup=20/coarsening\_factor;
 \textcolor{keywordtype}{unsigned} ncollapsible=40/coarsening\_factor;
 \textcolor{keywordtype}{unsigned} ndown=40/coarsening\_factor;
 \textcolor{keywordtype}{unsigned} ny=16/coarsening\_factor;

 \textcolor{comment}{// Length of the domain}
 \textcolor{keywordtype}{double} lup=5.0;
 \textcolor{keywordtype}{double} lcollapsible=10.0;
 \textcolor{keywordtype}{double} ldown=10.0;
 \textcolor{keywordtype}{double} ly=1.0;

 \textcolor{comment}{// Initial amplitude of the wall deformation}
 \textcolor{keywordtype}{double} amplitude=1.0e-2; \textcolor{comment}{// ADJUST }
  
 \textcolor{comment}{// Period of oscillation}
 \textcolor{keywordtype}{double} period=0.45;

\end{DoxyCodeInclude}


We set the (non-\/dimensional) upstream pressure to $ p_{up} = 12 L_{total }$ , so that in the absence of any wall oscillation, the steady flow through the channel is Poiseuille flow, $ {\bf u} = {\bf u}_{Poiseuille} = 6 \ x_2 \ (1-x_2) \ {\bf e}_1 $ ; see \hyperlink{index_comments}{Comments and Exercises}. 
\begin{DoxyCodeInclude}

 \textcolor{comment}{// Pressure/applied traction on the left boundary: This is consistent with }
 \textcolor{comment}{// steady Poiseuille flow}
 \hyperlink{namespaceGlobal__Physical__Variables_ae1a493695b7f4619af32f405b0b28861}{Global\_Physical\_Variables::P\_up}=12.0*(lup+lcollapsible+ldown);

\end{DoxyCodeInclude}


Next, we specify the output directory and build the problem with refineable 2D Crouzeix Raviart Elements.


\begin{DoxyCodeInclude}
 

 \textcolor{comment}{//Set output directory}
 DocInfo doc\_info;
 doc\_info.set\_directory(\textcolor{stringliteral}{"RESLT"});
 
 \textcolor{comment}{// Open a trace file }
 ofstream trace\_file;
 \textcolor{keywordtype}{char} filename[100];   
 sprintf(filename,\textcolor{stringliteral}{"%s/trace.dat"},doc\_info.directory().c\_str());
 trace\_file.open(filename);

 \textcolor{comment}{// Build the problem with Crouzeix Raviart Elements}
 \hyperlink{classCollapsibleChannelProblem}{CollapsibleChannelProblem<RefineableQCrouzeixRaviartElement<2>}
       > 
  problem(nup, ncollapsible, ndown, ny, 
          lup, lcollapsible, ldown, ly, 
          amplitude,period);

\end{DoxyCodeInclude}


Next we set up the time-\/stepping parameters for a simulation of three periods of the oscillation, performed with 40 timesteps per period. Fewer timesteps are performed if the code is run in self-\/test mode.


\begin{DoxyCodeInclude}
 

 \textcolor{comment}{// Number of timesteps per period}
 \textcolor{keywordtype}{unsigned} nsteps\_per\_period=40;

 \textcolor{comment}{// Number of periods}
 \textcolor{keywordtype}{unsigned} nperiod=3; 

 \textcolor{comment}{// Number of timesteps (reduced for validation)}
 \textcolor{keywordtype}{unsigned} nstep=nsteps\_per\_period*nperiod;
 \textcolor{keywordflow}{if} (CommandLineArgs::Argc>1)
  \{
   nstep=3;
  \}
 
 \textcolor{comment}{//Timestep: }
 \textcolor{keywordtype}{double} dt=period/double(nsteps\_per\_period);

 \textcolor{comment}{// Start time}
 \textcolor{keywordtype}{double} t\_min=0.0;

\end{DoxyCodeInclude}


We initialise the timestepper and set the initial conditions before documenting the initial condition.


\begin{DoxyCodeInclude}

 \textcolor{comment}{// Initialise timestep and set initial conditions}
 problem.time\_pt()->time()=t\_min;
 problem.initialise\_dt(dt);
 problem.set\_initial\_condition();
 
  \textcolor{comment}{// Output the initial solution}
 problem.doc\_solution(doc\_info, trace\_file);
 
 \textcolor{comment}{// Step number}
 doc\_info.number()++;

\end{DoxyCodeInclude}


Next we set the error targets for the adaptive mesh refinement; a smaller target error is used when the code is run in self-\/test mode to ensure that some mesh refinement is performed during the first few timesteps.


\begin{DoxyCodeInclude}


 \textcolor{comment}{// Set targets for spatial adaptivity}
 problem.bulk\_mesh\_pt()->max\_permitted\_error()=1.0e-3;
 problem.bulk\_mesh\_pt()->min\_permitted\_error()=1.0e-5;

 \textcolor{comment}{// Overwrite with reduced targets for validation run to force}
 \textcolor{comment}{// some refinement during the first few timesteps}
 \textcolor{keywordflow}{if} (CommandLineArgs::Argc>1)
  \{
   problem.bulk\_mesh\_pt()->max\_permitted\_error()=1.0e-4;
   problem.bulk\_mesh\_pt()->min\_permitted\_error()=1.0e-6;
  \}

\end{DoxyCodeInclude}


The timestepping loop itself is identical to that used in \href{../../../unsteady_heat/two_d_unsteady_heat_adapt/html/index.html}{\tt other time-\/dependent driver codes with adaptive mesh refinement}. During the first timestep, an arbitrary number of spatial adaptations may be performed, as the initial condition can be re-\/assigned on the refined mesh. (This is indicated by setting the boolean flag {\ttfamily first} to {\ttfamily true} when calling the spatially adaptive, unsteady Newton solver.) During subsequent timesteps the need to interpolate the history values onto the refined mesh limits the benefits of repeated mesh adaptations and we limit the number of spatial adaptations per timestep to 1.


\begin{DoxyCodeInclude}


 \textcolor{comment}{// First timestep: We may re-assign the initial condition}
 \textcolor{comment}{// following any mesh adaptation.}
 \textcolor{keywordtype}{bool} first=\textcolor{keyword}{true};

 \textcolor{comment}{// Max. number of adaptations during first timestep}
 \textcolor{keywordtype}{unsigned} max\_adapt=10;

 \textcolor{comment}{// Timestepping loop}
 \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} istep=0;istep<nstep;istep++)
  \{
   \textcolor{comment}{// Solve the problem}
   problem.unsteady\_newton\_solve(dt, max\_adapt, first);
    

   \textcolor{comment}{// Outpt the solution}
   problem.doc\_solution(doc\_info, trace\_file);
   
   \textcolor{comment}{// Step number}
   doc\_info.number()++;

   \textcolor{comment}{// We've done one step: Don't re-assign the initial conditions}
   \textcolor{comment}{// and limit the number of adaptive mesh refinements to one}
   \textcolor{comment}{// per timestep.}
   first=\textcolor{keyword}{false};
   max\_adapt=1;
  \}

 trace\_file.close();
 
\} \textcolor{comment}{//end of driver code}

\end{DoxyCodeInclude}




 

\hypertarget{index_problemclass}{}\section{The problem class}\label{index_problemclass}
As usual, we template the problem class by the element type and provide an access functions to the \char`\"{}bulk\char`\"{} Navier-\/\+Stokes mesh.

 
\begin{DoxyCodeInclude}
\textcolor{comment}{//=======start\_of\_problem\_class=======================================}
\textcolor{comment}{///Problem class}
\textcolor{comment}{}\textcolor{comment}{//====================================================================}
\textcolor{keyword}{template} <\textcolor{keyword}{class} ELEMENT>
\textcolor{keyword}{class }\hyperlink{classCollapsibleChannelProblem}{CollapsibleChannelProblem} : \textcolor{keyword}{public} Problem
\{

 public :
\textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Constructor : the arguments are the number of elements,}
\textcolor{comment}{ /// the length of the domain and the amplitude and period of }
\textcolor{comment}{ ///the oscillations}
\textcolor{comment}{} \hyperlink{classCollapsibleChannelProblem_ab43fa30667f57e8019c8b30fd93156f8}{CollapsibleChannelProblem}(\textcolor{keyword}{const} \textcolor{keywordtype}{unsigned}& nup, 
                           \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned}& ncollapsible,
                           \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned}& ndown,
                           \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned}& ny,
                           \textcolor{keyword}{const} \textcolor{keywordtype}{double}& lup,
                           \textcolor{keyword}{const} \textcolor{keywordtype}{double}& lcollapsible, 
                           \textcolor{keyword}{const} \textcolor{keywordtype}{double}& ldown,
                           \textcolor{keyword}{const} \textcolor{keywordtype}{double}& ly,
                           \textcolor{keyword}{const} \textcolor{keywordtype}{double}& amplitude,
                           \textcolor{keyword}{const} \textcolor{keywordtype}{double}& period);
 \textcolor{comment}{}
\textcolor{comment}{ /// Empty destructor}
\textcolor{comment}{} \hyperlink{classCollapsibleChannelProblem_a205e3e654d3205d1d55ac46e7b63ca9d}{~CollapsibleChannelProblem}() \{\} 
 \textcolor{comment}{}
\textcolor{comment}{ /// Access function for the specific mesh}
\textcolor{comment}{} RefineableCollapsibleChannelMesh<ELEMENT>* \hyperlink{classCollapsibleChannelProblem_a49a428b5f489d11b3fb92199b72f6dd7}{bulk\_mesh\_pt}() 
  \{

   \textcolor{comment}{// Upcast from pointer to the Mesh base class to the specific }
   \textcolor{comment}{// element type that we're using here.}
   \textcolor{keywordflow}{return} \textcolor{keyword}{dynamic\_cast<}RefineableCollapsibleChannelMesh<ELEMENT>*\textcolor{keyword}{>}
    (\hyperlink{classCollapsibleChannelProblem_acd96e5a1d72cc3a1aad196c97dcb3883}{Bulk\_mesh\_pt});

  \} \textcolor{comment}{// end of access to bulk mesh}

\end{DoxyCodeInclude}


No action is needed before or after solving, so the pure virtual functions {\ttfamily Problem\+::actions\+\_\+before\+\_\+newton\+\_\+solve()} and {\ttfamily Problem\+::actions\+\_\+after\+\_\+newton\+\_\+solve()} can remain empty.


\begin{DoxyCodeInclude}
 \textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Update the problem specs before solve (empty) }
\textcolor{comment}{} \textcolor{keywordtype}{void} actions\_before\_newton\_solve()\{\}
\textcolor{comment}{}
\textcolor{comment}{ /// Update the problem after solve (empty)}
\textcolor{comment}{} \textcolor{keywordtype}{void} actions\_after\_newton\_solve()\{\}

\end{DoxyCodeInclude}


We will use the function {\ttfamily Problem\+::actions\+\_\+before\+\_\+implicit\+\_\+timestep()} to update the no-\/slip boundary conditions on the moving wall before each timestep and employ {\ttfamily Problem\+::actions\+\_\+before\+\_\+adapt()} and {\ttfamily Problem\+::actions\+\_\+after\+\_\+adapt()} to wipe and rebuild the mesh of prescribed traction elements each time a mesh adaptation is performed. The functions {\ttfamily Problem\+::doc\+\_\+solution}(...) and {\ttfamily Problem\+::set\+\_\+initial\+\_\+condition()} will do what they say...


\begin{DoxyCodeInclude}
 \textcolor{comment}{}
\textcolor{comment}{ /// Update the velocity boundary condition on the moving wall}
\textcolor{comment}{} \textcolor{keywordtype}{void} actions\_before\_implicit\_timestep();
\textcolor{comment}{}
\textcolor{comment}{ /// Actions before adapt: Wipe the mesh of prescribed traction elements}
\textcolor{comment}{} \textcolor{keywordtype}{void} actions\_before\_adapt();
 \textcolor{comment}{}
\textcolor{comment}{ /// Actions after adapt: Rebuild the mesh of prescribed traction elements}
\textcolor{comment}{} \textcolor{keywordtype}{void} actions\_after\_adapt();
\textcolor{comment}{}
\textcolor{comment}{ /// Apply initial conditions}
\textcolor{comment}{} \textcolor{keywordtype}{void} set\_initial\_condition();
\textcolor{comment}{}
\textcolor{comment}{ /// Doc the solution}
\textcolor{comment}{} \textcolor{keywordtype}{void} doc\_solution(DocInfo& doc\_info, ofstream& trace\_file);

\end{DoxyCodeInclude}


The private helper functions {\ttfamily create\+\_\+traction\+\_\+elements}(...) and {\ttfamily delete\+\_\+traction\+\_\+elements()} attach and remove the traction elements from the upstream boundary of the \char`\"{}bulk\char`\"{} Navier-\/\+Stokes mesh. 
\begin{DoxyCodeInclude}
 
private : 
\textcolor{comment}{}
\textcolor{comment}{ /// Create the prescribed traction elements on boundary b}
\textcolor{comment}{ /// of the bulk mesh and stick them into the surface mesh.}
\textcolor{comment}{} \textcolor{keywordtype}{void} create\_traction\_elements(\textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} &b, 
                               Mesh* \textcolor{keyword}{const} &bulk\_mesh\_pt,
                               Mesh* \textcolor{keyword}{const} &surface\_mesh\_pt);
 \textcolor{comment}{}
\textcolor{comment}{ /// Delete prescribed traction elements from the surface mesh}
\textcolor{comment}{} \textcolor{keywordtype}{void} delete\_traction\_elements(Mesh* \textcolor{keyword}{const} &surface\_mesh\_pt);

\end{DoxyCodeInclude}


The private member data contains the geometric parameters as well as the pointer to the {\ttfamily Geom\+Object} that describes the moving wall.


\begin{DoxyCodeInclude}
\textcolor{comment}{}
\textcolor{comment}{ ///Number of elements in the x direction in the upstream part of the channel}
\textcolor{comment}{} \textcolor{keywordtype}{unsigned} Nup;
\textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Number of elements in the x direction in the "collapsible" }
\textcolor{comment}{ /// part of the channel}
\textcolor{comment}{} \textcolor{keywordtype}{unsigned} Ncollapsible;
\textcolor{comment}{}
\textcolor{comment}{ ///Number of elements in the x direction in the downstream part of the channel}
\textcolor{comment}{} \textcolor{keywordtype}{unsigned} Ndown;
\textcolor{comment}{}
\textcolor{comment}{ ///Number of elements across the channel}
\textcolor{comment}{} \textcolor{keywordtype}{unsigned} Ny;
\textcolor{comment}{}
\textcolor{comment}{ ///x-length in the upstream part of the channel}
\textcolor{comment}{} \textcolor{keywordtype}{double} Lup;
\textcolor{comment}{}
\textcolor{comment}{ ///x-length in the "collapsible" part of the channel}
\textcolor{comment}{} \textcolor{keywordtype}{double} Lcollapsible;
\textcolor{comment}{}
\textcolor{comment}{ ///x-length in the downstream part of the channel}
\textcolor{comment}{} \textcolor{keywordtype}{double} Ldown;
\textcolor{comment}{}
\textcolor{comment}{ ///Transverse length}
\textcolor{comment}{} \textcolor{keywordtype}{double} Ly;
\textcolor{comment}{}
\textcolor{comment}{ ///Pointer to the geometric object that parametrises the "collapsible" wall}
\textcolor{comment}{} \hyperlink{classOscillatingWall}{OscillatingWall}* Wall\_pt;

\end{DoxyCodeInclude}


Further private member data includes pointers to the \char`\"{}bulk\char`\"{} mesh and the surface mesh that contains the traction elements, and pointers to control nodes in the in-\/ and outflow cross-\/sections.


\begin{DoxyCodeInclude}
 \textcolor{comment}{}
\textcolor{comment}{ /// Pointer to the "bulk" mesh}
\textcolor{comment}{} RefineableCollapsibleChannelMesh<ELEMENT>* Bulk\_mesh\_pt;
 \textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Pointer to the "surface" mesh that contains the applied traction}
\textcolor{comment}{ /// elements}
\textcolor{comment}{} Mesh* Surface\_mesh\_pt; 
 \textcolor{comment}{}
\textcolor{comment}{ /// Pointer to the left control node}
\textcolor{comment}{} Node* Left\_node\_pt;
 \textcolor{comment}{}
\textcolor{comment}{ /// Pointer to right control node}
\textcolor{comment}{} Node* Right\_node\_pt;
  
\}; \textcolor{comment}{// end of problem class}

\end{DoxyCodeInclude}




 

\hypertarget{index_problemcontr}{}\section{The problem constructor}\label{index_problemcontr}
The arguments passed to the problem constructor specify the number of elements and lengths of the various parts of the channel, as well as the amplitude and period of the wall oscillations.

We store the parameters in the problem\textquotesingle{}s private member data and increase the maximum permitted residual for the Newton iteration.

 
\begin{DoxyCodeInclude}
\textcolor{comment}{//===start\_of\_constructor=======================================}
\textcolor{comment}{/// Constructor for the collapsible channel problem}
\textcolor{comment}{}\textcolor{comment}{//===============================================================}
\textcolor{keyword}{template} <\textcolor{keyword}{class} ELEMENT>
\hyperlink{classCollapsibleChannelProblem_ab43fa30667f57e8019c8b30fd93156f8}{CollapsibleChannelProblem<ELEMENT>::CollapsibleChannelProblem}
      (
 \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned}& nup, 
 \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned}& ncollapsible,
 \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned}& ndown,
 \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned}& ny,
 \textcolor{keyword}{const} \textcolor{keywordtype}{double}& lup,
 \textcolor{keyword}{const} \textcolor{keywordtype}{double}& lcollapsible, 
 \textcolor{keyword}{const} \textcolor{keywordtype}{double}& ldown,
 \textcolor{keyword}{const} \textcolor{keywordtype}{double}& ly,
 \textcolor{keyword}{const} \textcolor{keywordtype}{double}& amplitude,
 \textcolor{keyword}{const} \textcolor{keywordtype}{double}& period)
\{
 \textcolor{comment}{// Number of elements}
 Nup=nup;
 Ncollapsible=ncollapsible;
 Ndown=ndown;
 Ny=ny;

 \textcolor{comment}{// Lengths of domain}
 Lup=lup;
 Lcollapsible=lcollapsible;
 Ldown=ldown;
 Ly=ly;

 \textcolor{comment}{// Overwrite maximum allowed residual to accomodate possibly}
 \textcolor{comment}{// poor initial guess for solution}
 Problem::Max\_residuals=10000;

\end{DoxyCodeInclude}


We continue by building the {\ttfamily B\+D\+F$<$2$>$} timestepper and pass a pointer to it to the {\ttfamily Problem} 


\begin{DoxyCodeInclude}

 \textcolor{comment}{// Allocate the timestepper -- this constructs the Problem's }
 \textcolor{comment}{// time object with a sufficient amount of storage to store the}
 \textcolor{comment}{// previous timsteps. }
 add\_time\_stepper\_pt(\textcolor{keyword}{new} BDF<2>);

\end{DoxyCodeInclude}


Next, we create the {\ttfamily Geom\+Object} that represents the oscillating wall, and pass a pointer to it to the constructor of the \href{../../../meshes/mesh_list/html/index.html#collapsible_channel}{\tt {\ttfamily Collapsible\+Channel\+Mesh}}


\begin{DoxyCodeInclude}
 \textcolor{comment}{//Create the geometric object that represents the wall}
 Wall\_pt=\textcolor{keyword}{new} \hyperlink{classOscillatingWall}{OscillatingWall}(height, x\_left, length, amplitude, period,
                             time\_pt());

 \textcolor{comment}{//Build mesh}
 Bulk\_mesh\_pt = \textcolor{keyword}{new} RefineableCollapsibleChannelMesh<ELEMENT>(
  nup, ncollapsible, ndown, ny,
  lup, lcollapsible, ldown, ly,
  Wall\_pt,
  time\_stepper\_pt());

\end{DoxyCodeInclude}


We create a second mesh to store the applied traction elements and attach them to the inflow boundary (boundary 5) of the \char`\"{}bulk\char`\"{} fluid mesh, using the function {\ttfamily create\+\_\+traction\+\_\+elements}(...). Both submeshes are then combined into a global mesh.


\begin{DoxyCodeInclude}
 \textcolor{comment}{// Create "surface mesh" that will contain only the prescribed-traction }
 \textcolor{comment}{// elements at the inflow. The default constructor just creates the mesh }
 \textcolor{comment}{// without giving it any elements, nodes, etc.}
 Surface\_mesh\_pt = \textcolor{keyword}{new} Mesh;
 
 \textcolor{comment}{// Create prescribed-traction elements from all elements that are }
 \textcolor{comment}{// adjacent to boundary 5 (inflow boundary), and add them to the surface mesh.}
 create\_traction\_elements(5,Bulk\_mesh\_pt,Surface\_mesh\_pt);

 \textcolor{comment}{// Add the two sub meshes to the problem}
 add\_sub\_mesh(Bulk\_mesh\_pt);
 add\_sub\_mesh(Surface\_mesh\_pt);

 \textcolor{comment}{// Combine all submeshes added so far into a single Mesh}
 build\_global\_mesh();

\end{DoxyCodeInclude}


We create the spatial error estimator for the fluid mesh and loop over the various elements to set the pointers to the relevant physical parameters, first for the Navier-\/\+Stokes elements in the bulk mesh,


\begin{DoxyCodeInclude}
   
 \textcolor{comment}{//Set errror estimator  for bulk mesh}
 Z2ErrorEstimator* error\_estimator\_pt=\textcolor{keyword}{new} Z2ErrorEstimator;
 \textcolor{keyword}{dynamic\_cast<}RefineableCollapsibleChannelMesh<ELEMENT>*\textcolor{keyword}{>}
  (Bulk\_mesh\_pt)->spatial\_error\_estimator\_pt()=error\_estimator\_pt;
 
 
 \textcolor{comment}{// Loop over the elements to set up element-specific }
 \textcolor{comment}{// things that cannot be handled by constructor}
 \textcolor{keywordtype}{unsigned} n\_element=Bulk\_mesh\_pt->nelement();
 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} e=0;e<n\_element;e++)
  \{
   \textcolor{comment}{// Upcast from GeneralisedElement to the present element}
   ELEMENT* el\_pt = \textcolor{keyword}{dynamic\_cast<}ELEMENT*\textcolor{keyword}{>}(Bulk\_mesh\_pt->element\_pt(e));
   
   \textcolor{comment}{//Set the Reynolds number}
   el\_pt->re\_pt() = &\hyperlink{namespaceGlobal__Physical__Variables_ab814e627d2eb5bc50318879d19ab16b9}{Global\_Physical\_Variables::Re};

   \textcolor{comment}{// Set the Womersley number}
   el\_pt->re\_st\_pt() = &\hyperlink{namespaceGlobal__Physical__Variables_a085ee4bf968ffdd01a41b8c41864f907}{Global\_Physical\_Variables::ReSt};
   
  \} \textcolor{comment}{// end loop over bulk elements}

\end{DoxyCodeInclude}


and then for the applied traction elements in the surface mesh\+:


\begin{DoxyCodeInclude}



  \textcolor{comment}{// Loop over the traction elements to pass pointer to prescribed }
  \textcolor{comment}{// traction function }
  \textcolor{keywordtype}{unsigned} n\_el=Surface\_mesh\_pt->nelement();
  \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} e=0;e<n\_el;e++)
   \{
    \textcolor{comment}{// Upcast from GeneralisedElement to NavierStokes traction element}
    NavierStokesTractionElement<ELEMENT> *el\_pt = 
     \textcolor{keyword}{dynamic\_cast<} NavierStokesTractionElement<ELEMENT>*\textcolor{keyword}{>}(
      Surface\_mesh\_pt->element\_pt(e));
    
    \textcolor{comment}{// Set the pointer to the prescribed traction function}
    el\_pt->traction\_fct\_pt() = &\hyperlink{namespaceGlobal__Physical__Variables_a0de42ee6d39e85c77c16a04c3a05f7a2}{Global\_Physical\_Variables::prescribed\_traction}
      ;

   \}  \textcolor{comment}{// end loop over applied traction elements}

\end{DoxyCodeInclude}


We apply the boundary conditions and pin the velocity on the relevant mesh boundaries\+:
\begin{DoxyItemize}
\item both axial and transverse velocities are pinned along the bottom and the top boundaries (boundaries 0, 2, 3 and 4).
\item the transverse velocities are pinned along the in-\/ and outflow boundaries (boundaries 1 and 5).
\end{DoxyItemize}
\begin{DoxyCodeInclude}

  
  

 \textcolor{comment}{//Pin the velocity on the boundaries}
 \textcolor{comment}{//x and y-velocities pinned along boundary 0 (bottom boundary) :}
 \textcolor{keywordtype}{unsigned} ibound=0; 
 \textcolor{keywordtype}{unsigned} num\_nod= bulk\_mesh\_pt()->nboundary\_node(ibound);
 \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} inod=0;inod<num\_nod;inod++)
  \{
   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} i=0;i<2;i++)
    \{
     bulk\_mesh\_pt()->boundary\_node\_pt(ibound, inod)->pin(i);
    \}
  \}
 
 
  \textcolor{comment}{//x and y-velocities pinned along boundary 2, 3, 4 (top boundaries) :}
 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} ib=2;ib<5;ib++)
  \{ 
   num\_nod= bulk\_mesh\_pt()->nboundary\_node(ib);
   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} inod=0;inod<num\_nod;inod++)
    \{
     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} i=0;i<2;i++)
      \{
       bulk\_mesh\_pt()->boundary\_node\_pt(ib, inod)->pin(i);
      \}
    \}
  \}

   \textcolor{comment}{//y-velocity pinned along boundary 1 (right boundary):}
  ibound=1; 
  num\_nod= bulk\_mesh\_pt()->nboundary\_node(ibound);
  \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} inod=0;inod<num\_nod;inod++)
   \{
    bulk\_mesh\_pt()->boundary\_node\_pt(ibound, inod)->pin(1);
   \}


  \textcolor{comment}{//y-velocity pinned along boundary 5 (left boundary):}
  ibound=5; 
  num\_nod= bulk\_mesh\_pt()->nboundary\_node(ibound);
  \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} inod=0;inod<num\_nod;inod++)
   \{
    bulk\_mesh\_pt()->boundary\_node\_pt(ibound, inod)->pin(1);
   \}\textcolor{comment}{// end of pin\_velocity}

\end{DoxyCodeInclude}


We select two control nodes on the inflow and outflow boundaries to document the velocities.


\begin{DoxyCodeInclude}



  \textcolor{comment}{//Select control nodes "half way" up the inflow/outflow cross-sections}
  \textcolor{comment}{//--------------------------------------------------------------------}
  
  \textcolor{comment}{// Left boundary}
  ibound=5; 
  num\_nod= bulk\_mesh\_pt()->nboundary\_node(ibound);
  \textcolor{keywordtype}{unsigned} control\_nod=num\_nod/2;
  Left\_node\_pt= bulk\_mesh\_pt()->boundary\_node\_pt(ibound, control\_nod);
  
  \textcolor{comment}{// Right boundary}
  ibound=1; 
  num\_nod= bulk\_mesh\_pt()->nboundary\_node(ibound);
  control\_nod=num\_nod/2;
  Right\_node\_pt= bulk\_mesh\_pt()->boundary\_node\_pt(ibound, control\_nod);

\end{DoxyCodeInclude}


Finally, we set up the equation numbering scheme.


\begin{DoxyCodeInclude}
  
  \textcolor{comment}{// Setup equation numbering scheme}
  cout <<\textcolor{stringliteral}{"Number of equations: "} << assign\_eqn\_numbers() << std::endl; 
  
\} \textcolor{comment}{//end of constructor}

\end{DoxyCodeInclude}




 

\hypertarget{index_doc}{}\section{Post processing}\label{index_doc}
The function {\ttfamily doc\+\_\+solution}(...) documents the results, and records the time-\/trace of the axial velocities at the two control nodes and the position of the midpoint on the oscillating wall.

 
\begin{DoxyCodeInclude}
\textcolor{comment}{//====start\_of\_doc\_solution===================================================}
\textcolor{comment}{/// Doc the solution}
\textcolor{comment}{}\textcolor{comment}{//============================================================================}
\textcolor{keyword}{template} <\textcolor{keyword}{class} ELEMENT>
\textcolor{keywordtype}{void} \hyperlink{classCollapsibleChannelProblem_afc4af9796c01d904d4074bd5bbfc5b9b}{CollapsibleChannelProblem<ELEMENT>:: doc\_solution}(
      DocInfo& doc\_info, 
                                                       ofstream& trace\_file)
\{ 
 ofstream some\_file;
 \textcolor{keywordtype}{char} filename[100];

 \textcolor{comment}{// Number of plot points}
 \textcolor{keywordtype}{unsigned} npts;
 npts=5; 

 \textcolor{comment}{// Output solution }
 sprintf(filename,\textcolor{stringliteral}{"%s/soln%i.dat"},doc\_info.directory().c\_str(),
         doc\_info.number());
 some\_file.open(filename);
 bulk\_mesh\_pt()->output(some\_file,npts);
 some\_file.close();


 \textcolor{comment}{// Get the position of the midpoint on the geometric object}
 Vector<double> zeta(1);
 zeta[0]=0.5*Lcollapsible;
 Vector<double> wall\_point(2);
 Wall\_pt->position(zeta,wall\_point);
 
 \textcolor{comment}{// Write trace file}
 trace\_file << time\_pt()->time() << \textcolor{stringliteral}{" "} 
            << wall\_point[1]  << \textcolor{stringliteral}{" "}
            << Left\_node\_pt->value(0) << \textcolor{stringliteral}{" "}
            << Right\_node\_pt->value(0) << \textcolor{stringliteral}{" "}
            << std::endl;

 \textcolor{comment}{// Output wall shape}
 sprintf(filename,\textcolor{stringliteral}{"%s/wall%i.dat"},doc\_info.directory().c\_str(),
         doc\_info.number());
 some\_file.open(filename);
 \textcolor{keywordtype}{unsigned} nplot=100; 
 \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} i=0;i<nplot;i++)
  \{
   zeta[0]=double(i)/double(nplot-1)*Lcollapsible;
   Wall\_pt->position(zeta,wall\_point);
   some\_file << wall\_point[0]  << \textcolor{stringliteral}{" "}
             << wall\_point[1]  << std::endl;
  \}
 some\_file.close();

\} \textcolor{comment}{// end\_of\_doc\_solution}

\end{DoxyCodeInclude}




 

\hypertarget{index_tractioncre}{}\section{Creation of the traction elements}\label{index_tractioncre}
The creation of the applied traction elements follows the usual pattern, explained in detail \href{../../../poisson/two_d_poisson_flux_bc_adapt/html/index.html}{\tt elsewhere}\+: We loop over the elements in the fluid mesh that are adjacent to the specified mesh boundary, and build the corresponding traction elements, which are added to the surface mesh.

 
\begin{DoxyCodeInclude}
\textcolor{comment}{//==========start\_of\_create\_traction\_elements==================================}
\textcolor{comment}{/// Create the traction elements}
\textcolor{comment}{}\textcolor{comment}{//============================================================================}
\textcolor{keyword}{template} <\textcolor{keyword}{class} ELEMENT>
\textcolor{keywordtype}{void} \hyperlink{classCollapsibleChannelProblem_a70cfe97c12c0cb6a2a81266cdd4d6088}{CollapsibleChannelProblem<ELEMENT>::create\_traction\_elements}
      (
 \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} &b, Mesh* \textcolor{keyword}{const} &bulk\_mesh\_pt, Mesh* \textcolor{keyword}{const} &surface\_mesh\_pt)
\{
 \textcolor{comment}{// How many bulk elements are adjacent to boundary b?}
 \textcolor{keywordtype}{unsigned} n\_element = bulk\_mesh\_pt->nboundary\_element(b);

 \textcolor{comment}{// Loop over the bulk elements adjacent to boundary b}
 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} e=0;e<n\_element;e++)
  \{
   \textcolor{comment}{// Get pointer to the bulk element that is adjacent to boundary b}
   ELEMENT* bulk\_elem\_pt = \textcolor{keyword}{dynamic\_cast<}ELEMENT*\textcolor{keyword}{>}
    (bulk\_mesh\_pt->boundary\_element\_pt(b,e));
   
   \textcolor{comment}{//What is the index of the face of element e that lies along boundary b}
   \textcolor{keywordtype}{int} face\_index = bulk\_mesh\_pt->face\_index\_at\_boundary(b,e);

   \textcolor{comment}{// Build the corresponding prescribed-traction element}
   NavierStokesTractionElement<ELEMENT>* traction\_element\_pt = 
    \textcolor{keyword}{new}  NavierStokesTractionElement<ELEMENT>(bulk\_elem\_pt,face\_index);
   
   \textcolor{comment}{//Add the prescribed-flux element to the surface mesh}
   surface\_mesh\_pt->add\_element\_pt(traction\_element\_pt);

  \} \textcolor{comment}{//end of loop over bulk elements adjacent to boundary b}

\} \textcolor{comment}{// end of create\_traction\_elements}

\end{DoxyCodeInclude}




 

\hypertarget{index_tractiondel}{}\section{Delete the traction elements}\label{index_tractiondel}
Since the \char`\"{}bulk\char`\"{} elements that the applied traction elements are attached to may disappear during mesh adaptation, we delete all traction elements before the adaptation and re-\/attach them afterwards. The deletion is performed by the following member function. Note that the surface mesh that contains the traction elements is {\itshape not} deleted, as this would also delete the associated nodes which are shared with the corresponding bulk elements.

 
\begin{DoxyCodeInclude}
\textcolor{comment}{//============start\_of\_delete\_traction\_elements==============================}
\textcolor{comment}{/// Delete traction elements and wipe the surface mesh}
\textcolor{comment}{}\textcolor{comment}{//=======================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT>
\textcolor{keywordtype}{void} \hyperlink{classCollapsibleChannelProblem_a6a5324dd1efb8c517a7e4d431b10fca4}{CollapsibleChannelProblem<ELEMENT>::}
\hyperlink{classCollapsibleChannelProblem_a6a5324dd1efb8c517a7e4d431b10fca4}{delete\_traction\_elements}(Mesh* \textcolor{keyword}{const} &surface\_mesh\_pt)
\{
 \textcolor{comment}{// How many surface elements are in the surface mesh}
 \textcolor{keywordtype}{unsigned} n\_element = surface\_mesh\_pt->nelement();

 \textcolor{comment}{// Loop over the surface elements}
 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} e=0;e<n\_element;e++)
  \{
   \textcolor{comment}{// Kill surface element}
   \textcolor{keyword}{delete} surface\_mesh\_pt->element\_pt(e);
  \}

 \textcolor{comment}{// Wipe the mesh}
 surface\_mesh\_pt->flush\_element\_and\_node\_storage();

\} \textcolor{comment}{// end of delete\_traction\_elements}

\end{DoxyCodeInclude}




 

\hypertarget{index_IC}{}\section{Apply the initial conditions}\label{index_IC}
Initial conditions are applied as usual. We start by confirming that the timestepper is a member of the {\ttfamily B\+DF} family and therefore operates on history values that represent the solution at previous timesteps. We assign the previous nodal positions and velocities at all nodes, assuming that for $ t< 0 $ the wall is at rest and the flow field is given by steady Poiseuille flow.

 
\begin{DoxyCodeInclude}
\textcolor{comment}{//=======start\_of\_apply\_initial\_conditions===================================}
\textcolor{comment}{/// Apply initial conditions: Impulsive start from steady Poiseuille flow}
\textcolor{comment}{}\textcolor{comment}{//============================================================================}
\textcolor{keyword}{template} <\textcolor{keyword}{class} ELEMENT>
\textcolor{keywordtype}{void} \hyperlink{classCollapsibleChannelProblem_a646147fb75669cfcc5bb56ee79d9b8da}{CollapsibleChannelProblem<ELEMENT>::set\_initial\_condition}
      ()
\{ 

 \textcolor{comment}{// Check that timestepper is from the BDF family}
 \textcolor{keywordflow}{if} (time\_stepper\_pt()->type()!=\textcolor{stringliteral}{"BDF"})
  \{
   std::ostringstream error\_stream;
   error\_stream 
    << \textcolor{stringliteral}{"Timestepper has to be from the BDF family!\(\backslash\)n"}
    << \textcolor{stringliteral}{"You have specified a timestepper from the "}
    << time\_stepper\_pt()->type() << \textcolor{stringliteral}{" family"} << std::endl;

   \textcolor{keywordflow}{throw} OomphLibError(error\_stream.str(),
                       OOMPH\_CURRENT\_FUNCTION,
                       OOMPH\_EXCEPTION\_LOCATION);
  \}

 \textcolor{comment}{// Update the mesh}
 bulk\_mesh\_pt()->node\_update();
 
 \textcolor{comment}{// Loop over the nodes to set initial guess everywhere}
 \textcolor{keywordtype}{unsigned} num\_nod = bulk\_mesh\_pt()->nnode();
 \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} n=0;n<num\_nod;n++)
  \{
   \textcolor{comment}{// Get nodal coordinates}
   Vector<double> x(2);
   x[0]=bulk\_mesh\_pt()->node\_pt(n)->x(0);
   x[1]=bulk\_mesh\_pt()->node\_pt(n)->x(1);
   
   \textcolor{comment}{// Assign initial condition: Steady Poiseuille flow}
   bulk\_mesh\_pt()->node\_pt(n)->set\_value(0,6.0*(x[1]/Ly)*(1.0-(x[1]/Ly)));
   bulk\_mesh\_pt()->node\_pt(n)->set\_value(1,0.0);
  \} 

 \textcolor{comment}{// Assign initial values for an impulsive start}
 bulk\_mesh\_pt()->assign\_initial\_values\_impulsive();


\} \textcolor{comment}{// end of set\_initial\_condition}

\end{DoxyCodeInclude}




 

\hypertarget{index_beforestep}{}\section{Actions before the timestep}\label{index_beforestep}
Before each timestep, we update the nodal positions in the fluid mesh, and apply the no-\/slip condition to each node on mesh boundary 3.

 
\begin{DoxyCodeInclude}
\textcolor{comment}{//=====start\_of\_actions\_before\_implicit\_timestep==============================}
\textcolor{comment}{/// Execute the actions before timestep: Update the velocity}
\textcolor{comment}{}\textcolor{comment}{/// boundary condition on the moving wall}
\textcolor{comment}{}\textcolor{comment}{//============================================================================}
\textcolor{keyword}{template} <\textcolor{keyword}{class} ELEMENT>
\textcolor{keywordtype}{void} \hyperlink{classCollapsibleChannelProblem_a4c365050b11c184007b8e1cd6079147f}{CollapsibleChannelProblem<ELEMENT>::actions\_before\_implicit\_timestep}
      ()
\{
 \textcolor{comment}{// Update the domain shape}
 bulk\_mesh\_pt()->node\_update();
 
 \textcolor{comment}{// Moving wall: No slip; this implies that the velocity needs}
 \textcolor{comment}{// to be updated in response to wall motion}
 \textcolor{keywordtype}{unsigned} ibound=3;
 \textcolor{keywordtype}{unsigned} num\_nod=bulk\_mesh\_pt()->nboundary\_node(ibound);
  \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} inod=0;inod<num\_nod;inod++)
  \{
   \textcolor{comment}{// Which node are we dealing with?}
   Node* node\_pt=bulk\_mesh\_pt()->boundary\_node\_pt(ibound,inod);
   
   \textcolor{comment}{// Apply no slip}
   FSI\_functions::apply\_no\_slip\_on\_moving\_wall(node\_pt);
  \}
\} \textcolor{comment}{//end of actions\_before\_implicit\_timestep}

\end{DoxyCodeInclude}




 

\hypertarget{index_beforeadapt}{}\section{Actions before the mesh adaptation}\label{index_beforeadapt}
As discussed above, we delete the applied traction elements before performing any mesh adaptation and then rebuild the global mesh.

 
\begin{DoxyCodeInclude}
\textcolor{comment}{//=========start\_of\_actions\_before\_adapt==================================}
\textcolor{comment}{/// Actions before adapt: Wipe the mesh of prescribed traction elements}
\textcolor{comment}{}\textcolor{comment}{//========================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT>
\textcolor{keywordtype}{void} \hyperlink{classCollapsibleChannelProblem_a54abc5259d590154e5dfa458d885c16c}{CollapsibleChannelProblem<ELEMENT>::actions\_before\_adapt}
      ()
\{
 \textcolor{comment}{// Kill the traction elements and wipe surface mesh}
 delete\_traction\_elements(Surface\_mesh\_pt);
 
 \textcolor{comment}{// Rebuild the global mesh. }
 rebuild\_global\_mesh();

\} \textcolor{comment}{// end of actions\_before\_adapt}

\end{DoxyCodeInclude}




 

\hypertarget{index_beforeadapt}{}\section{Actions before the mesh adaptation}\label{index_beforeadapt}
Once the mesh has been adapted, we (re-\/)create the prescribed traction elements and rebuild the global mesh. We also have to pass the pointers to prescribed traction function to the newly created traction elements.


\begin{DoxyCodeInclude}
\textcolor{comment}{//==========start\_of\_actions\_after\_adapt==================================}
\textcolor{comment}{/// Actions after adapt: Rebuild the mesh of prescribed traction elements}
\textcolor{comment}{}\textcolor{comment}{//========================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT>
\textcolor{keywordtype}{void} \hyperlink{classCollapsibleChannelProblem_a3ea01d83f0256c588a652741c6c33e0e}{CollapsibleChannelProblem<ELEMENT>::actions\_after\_adapt}
      ()
\{
 \textcolor{comment}{// Create prescribed-flux elements from all elements that are }
 \textcolor{comment}{// adjacent to boundary 5 and add them to surface mesh}
 create\_traction\_elements(5,Bulk\_mesh\_pt,Surface\_mesh\_pt);

 \textcolor{comment}{// Rebuild the global mesh}
 rebuild\_global\_mesh();
 
 \textcolor{comment}{// Loop over the traction elements to pass pointer to prescribed traction function}
 \textcolor{keywordtype}{unsigned} n\_element=Surface\_mesh\_pt->nelement();
 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} e=0;e<n\_element;e++)
  \{
   \textcolor{comment}{// Upcast from GeneralisedElement to NavierStokesTractionElement element}
   NavierStokesTractionElement<ELEMENT> *el\_pt = 
    \textcolor{keyword}{dynamic\_cast<}NavierStokesTractionElement<ELEMENT>*\textcolor{keyword}{>}(
     Surface\_mesh\_pt->element\_pt(e));
   
   \textcolor{comment}{// Set the pointer to the prescribed traction function}
   el\_pt->traction\_fct\_pt() = &\hyperlink{namespaceGlobal__Physical__Variables_a0de42ee6d39e85c77c16a04c3a05f7a2}{Global\_Physical\_Variables::prescribed\_traction}
      ;
  \}
\} \textcolor{comment}{// end of actions\_after\_adapt}

\end{DoxyCodeInclude}




 

\hypertarget{index_comments}{}\section{Comments and Exercises}\label{index_comments}

\begin{DoxyEnumerate}
\item Check the non-\/dimensionalisation of the governing equations and confirm that a (non-\/dimensional) upstream pressure $ p_{up} = 12 \ L_{total} $ is required to drive the steady Poiseuille flow specified by (3) through the static, undeformed channel. Use this to \char`\"{}validate\char`\"{} (well, \char`\"{}plausibility-\/check\char`\"{}, anyway...) the code by setting the amplitude of the wall oscillation to zero.
\item Double the upstream pressure while keeping the amplitude of the wall oscillation at zero and confirm that the flow accelerates until it (asymptotically) approaches Poiseuille flow with twice the initial flowrate as $ t \to \infty. $
\item The flow field has the largest velocity gradients in the thin Stokes layers near the wall, causing the automatic mesh adaptation procedure to refine the mesh pre-\/dominantly in these regions. To facilitate the resolution of such layers the {\ttfamily Collapsible\+Channel\+Domain} and {\ttfamily Collapsible\+Channel\+Mesh} allow the specification of a mapping \mbox{[}0,1\mbox{]} -\/$>$ \mbox{[}0,1\mbox{]} that redistributes the nodal points in the vertical direction so that the elements near the wall become more squashed. By default the \char`\"{}boundary-\/layer squash function\char`\"{} is the identity but it may be overloaded by specifying a function pointer to an alternative function. The driver code already includes a demonstration of this capability which may be activated by compiling the driver code with {\ttfamily -\/\+D\+U\+S\+E\+\_\+\+B\+L\+\_\+\+S\+Q\+U\+A\+S\+H\+\_\+\+F\+CT}. This activates the code segment  
\begin{DoxyCodeInclude}
\textcolor{preprocessor}{#ifdef USE\_BL\_SQUASH\_FCT}

 \textcolor{comment}{// Set a non-trivial boundary-layer-squash function...}
 Bulk\_mesh\_pt->bl\_squash\_fct\_pt() = &\hyperlink{namespaceBL__Squash_a0fdaf7661591150041b7102dbe578cdc}{BL\_Squash::squash\_fct}; 

 \textcolor{comment}{// ... and update the nodal positions accordingly}
 Bulk\_mesh\_pt->node\_update();

\textcolor{preprocessor}{#endif}

\end{DoxyCodeInclude}
 in the Problem constructor. The \char`\"{}squash function\char`\"{} used for this example is defined in the following namespace\+:  
\begin{DoxyCodeInclude}
\textcolor{comment}{//==========start\_of\_BL\_Squash =========================================}
\textcolor{comment}{/// Namespace to define the mapping [0,1] -> [0,1] that re-distributes}
\textcolor{comment}{}\textcolor{comment}{/// nodal points across the channel width.}
\textcolor{comment}{}\textcolor{comment}{//======================================================================}
\textcolor{keyword}{namespace }\hyperlink{namespaceBL__Squash}{BL\_Squash}
\{
 \textcolor{comment}{}
\textcolor{comment}{ /// Boundary layer width}
\textcolor{comment}{} \textcolor{keywordtype}{double} Delta=0.1;
\textcolor{comment}{}
\textcolor{comment}{ /// Fraction of points in boundary layer}
\textcolor{comment}{} \textcolor{keywordtype}{double} Fract\_in\_BL=0.5;
\textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Mapping [0,1] -> [0,1] that re-distributes}
\textcolor{comment}{ /// nodal points across the channel width}
\textcolor{comment}{} \textcolor{keywordtype}{double} \hyperlink{namespaceBL__Squash_a0fdaf7661591150041b7102dbe578cdc}{squash\_fct}(\textcolor{keyword}{const} \textcolor{keywordtype}{double}& s)
 \{
  \textcolor{comment}{// Default return}
  \textcolor{keywordtype}{double} y=s;
  \textcolor{keywordflow}{if} (s<0.5*Fract\_in\_BL)
   \{
    y=Delta*2.0*s/\hyperlink{namespaceBL__Squash_af84bda39008884cd2b01e630957573df}{Fract\_in\_BL};
   \}
  \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (s>1.0-0.5*Fract\_in\_BL)
   \{
    y=2.0*Delta/Fract\_in\_BL*s+1.0-2.0*Delta/\hyperlink{namespaceBL__Squash_af84bda39008884cd2b01e630957573df}{Fract\_in\_BL};
   \}
  \textcolor{keywordflow}{else}
   \{
    y=(1.0-2.0*\hyperlink{namespaceBL__Squash_a3c4183891049bca81f3a011db24fc579}{Delta})/(1.0-Fract\_in\_BL)*s+
      (Delta-0.5*\hyperlink{namespaceBL__Squash_af84bda39008884cd2b01e630957573df}{Fract\_in\_BL})/(1.0-Fract\_in\_BL);
   \}

  \textcolor{keywordflow}{return} y;
 \}
\}\textcolor{comment}{// end of BL\_Squash}

\end{DoxyCodeInclude}
 With this function 50\% of the nodal points in the vertical direction are located within two boundary-\/layer regions which occupy 2 x 10\% of the channel\textquotesingle{}s width. The figure below shows the element shapes for a (coarse) initial mesh that is used in the validation run, with and without the boundary-\/layer squashing function\+:  
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{bl_squashing}
\doxyfigcaption{Coarse initial meshes with and without the boundary-\/layer squash function. }
\end{DoxyImage}
 Confirm that if this \char`\"{}squashing function\char`\"{} is applied to the mesh that is used during the non-\/self-\/test runs (this mesh has 16 x larger number of elements than the meshes shown above), the quality of the computed solution improves so much that no subsequent mesh adaptation is required.
\item The flow structures observed during the small-\/amplitude oscillations (shown in the animation at the beginning of this document) are in perfect agreement with the structures predicted by \href{http://www.maths.man.ac.uk/~mheil/MATTHIAS/PDF/JensenHeil2003.pdf}{\tt Jensen \& Heil\textquotesingle{}s (2003)} asymptotic analysis. As an exercise, increase the amplitude of the wall oscillation (to $ A=0.5$ , say) to confirm that the flow-\/structure predicted by the theory (which is strictly applicable only for small-\/amplitude oscillations) also provides an excellent description of of the system\textquotesingle{}s behaviour during large-\/amplitude oscillations with more complicated wall motions. ~\newline
 ~\newline
 For instance, the figure below shows a snapshot of the \href{../figures/large_amplitude_flow.avi}{\tt the animation of the computational results} for an oscillation in which the wall undergoes a more complicated motion, described by \[ {\bf R}_w(\zeta,t) = \left( \begin{array}{c} L_{up} + \zeta \\ 1 \end{array} \right) + A \left( \begin{array}{l} - B \sin\left(\frac{2\pi}{L_{collapsible}}\zeta\right) \\ \left(\frac{2}{L_{collapsible}}\right)^2 \zeta \ (L-\zeta) \end{array} \right) \ \sin\left(\frac{2\pi t}{T}\right) \ {\cal R}(t) \ \ \ \ \ \ \ \ \ \ (6) \] for $ A= B = 0.5 $ . For these parameter values, the wall performs a large-\/amplitude oscillation in the course of which material particles are not only displaced vertically but also in the horizontal direction. Nevertheless, the flow generated by the moving wall may be described as arising from the superposition of Poiseuille flow and an axial sloshing motion, the latter obviously having a much larger amplitude than in the previous case. The \href{../figures/large_amplitude_flow.avi}{\tt animation of the flow field} shows that more complex local flow features develop briefly whenever the flow separates from the wall. However, the appearance of these features does not change the macroscopic behaviour of the flow.  
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{large_amplitude_flow}
\doxyfigcaption{Flow field for a large-\/amplitude wall motion. Re=Re\+St=50; A=B=0.5; T=0.45. }
\end{DoxyImage}

\end{DoxyEnumerate}



 

\hypertarget{index_sources}{}\section{Source files for this tutorial}\label{index_sources}

\begin{DoxyItemize}
\item The source files for this tutorial are located in the directory\+: \begin{center} \href{../../../../demo_drivers/navier_stokes/collapsible_channel/}{\tt demo\+\_\+drivers/navier\+\_\+stokes/collapsible\+\_\+channel/ } \end{center} 
\item The driver code is\+: \begin{center} \href{../../../../demo_drivers/navier_stokes/collapsible_channel/collapsible_channel.cc}{\tt demo\+\_\+drivers/navier\+\_\+stokes/collapsible\+\_\+channel/collapsible\+\_\+channel.\+cc } \end{center} 
\end{DoxyItemize}

 

 \hypertarget{index_pdf}{}\section{P\+D\+F file}\label{index_pdf}
A \href{../latex/refman.pdf}{\tt pdf version} of this document is available. \end{document}
