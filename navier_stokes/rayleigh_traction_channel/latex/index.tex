In this example we consider a variation of the unsteady 2D channel flow problem considered elsewhere. In the \href{../../rayleigh_channel/html/index.html}{\tt previous example} the flow was driven by the imposed wall motion. Here we shall consider the case in which the flow is driven by an applied traction $ {\bf t}^{[prescribed]}$ which balances the fluid stress so that \[ t_i^{[prescribed]} = \tau_{ij} \ n_j = \left( -p\ \delta_{ij} + \left(\frac{\partial u_i}{\partial x_j} + \frac{\partial u_j}{\partial x_i}\right)\right) n_j \ \ \ \ \ \ \ \ \ \ (1) \] along the upper, horizontal boundary of the channel. Here $ n_j $ is the outward unit normal, $ \delta_{ij} $ is the Kronecker delta and $ \tau_{ij} $ the stress tensor. {\ttfamily oomph-\/lib} provides traction elements that can be applied along a domain boundary to (weakly) impose the above boundary condition. The traction elements are used in the same way as flux-\/elements in the \href{../../../poisson/two_d_poisson_flux_bc/html/index.html}{\tt Poisson } and \href{../../../unsteady_heat/two_d_unsteady_heat_adapt/html/index.html}{\tt unsteady heat} examples. The section \hyperlink{index_comments}{Comments and Exercises} at the end of this documents provides more detail on the underlying theory and its implementation in {\ttfamily oomph-\/lib}.



 

\hypertarget{index_example}{}\section{The example problem}\label{index_example}
We consider the unsteady finite-\/\+Reynolds-\/number flow in a 2D channel that is driven by an applied traction along its upper boundary.

\begin{center} \tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*{1}{|X[-1]}|}
\hline
\begin{center} {\bfseries Unsteady flow in a 2D channel, driven by an applied traction.} \end{center}  Here is a sketch of the problem\+:

 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{rayleigh_traction_channel}
\doxyfigcaption{Sketch of the problem. }
\end{DoxyImage}


The flow is governed by the 2D unsteady Navier-\/\+Stokes equations,

\[ Re\left(St\frac{\partial u_i}{\partial t} + u_j\frac{\partial u_i}{\partial x_j}\right) = - \frac{\partial p}{\partial x_i} + \frac{\partial }{\partial x_j} \left( \frac{\partial u_i}{\partial x_j} + \frac{\partial u_j}{\partial x_i} \right), \ \ \ \ \ \ \ \ \ \ (2) \] and \[ \frac{\partial u_i}{\partial x_i} = 0, \] in the square domain \[ D = \bigg\{(x_1,x_2) \ | \ x_1 \in [0,1], \ x_2 \in [0,1] \bigg\}. \] We apply the Dirichlet (no-\/slip) boundary condition \[ \left. \mathbf{u}\right|_{\partial D_{lower}}=(0,0), \ \ \ \ \ \ \ \ \ \ (3) \] on the lower, stationary wall, $ \partial D_{lower} = \big\{(x_1,x_2) \ | \ x_2=0 \big\} $ and the traction \[ \mathbf{t}^{[prescribed]}= (\tau(t), 0) \ \ \ \ \ \ \ \ \ \ (4) \] where $ \tau(t)$ is a given function, on the upper boundary, $ \partial D_{upper} = \big\{(x_1,x_2) \ | \ x_2=1 \big\} $ . As in the \href{../../rayleigh_channel/html/index.html}{\tt previous example} we apply periodic boundary conditions on the \char`\"{}left\char`\"{} and \char`\"{}right\char`\"{} boundaries\+: \[ \left.\mathbf{u}\right|_{x_1=0} = \left.\mathbf{u}\right|_{x_1=1}. \ \ \ \ \ \ \ \ \ \ (5) \] Initial conditions for the velocities are given by \[ {\bf u}(x_1,x_2,t=0) = {\bf u}_{IC}(x_1,x_2), \] where $ {\bf u}_{IC}(x_1,x_2)$ is given.   \\\cline{1-1}
\end{longtabu}
\end{center} \hypertarget{index_solution}{}\subsection{An exact, parallel-\/flow solution}\label{index_solution}
We choose the prescribed traction $ {\bf t}^{[prescribed]} = (\tau(t), 0) $ such that the parallel-\/flow solution \[ {\bf u}_{exact}(x_1,x_2,t) = U(x_2,t) \ {\bf e}_1 \mbox{ \ \ \ \ \ and \ \ \ \ } p_{exact}(x_1,x_2,t) = 0, \] derived in the \href{../../rayleigh_channel/html/index.html}{\tt previous example} remains valid. For this purpose we set \[ \tau(t) = \left. \frac{\partial U(x_2,t)}{\partial x_2}\right|_{x_2=1}, \] where \[ U(x_2,t) = Re\left\{\frac{e^{i\omega t}}{e^{i\lambda}-e^{-i\lambda}}\left(e^{i\lambda y}-e^{-i\lambda y} \right)\right\} \] and \[ \lambda = i\sqrt{i\omega Re\, St}. \] 

\hypertarget{index_results}{}\section{Results}\label{index_results}
The two animations below show the computed solutions obtained from a spatial discretisation with Taylor-\/\+Hood and Crouzeix-\/\+Raviart elements, respectively. In both cases we set $ \omega=2\pi, \ Re = ReSt = 10 $ and specified the exact, time-\/periodic solution as the initial condition, i.\+e. $ {\bf u}_{IC}(x_1,x_2) = {\bf u}_{exact}(x_1,x_2,t=0)$ . The computed solutions agree extremely well with the exact solution throughout the simulation.

 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{velocity_vectors_CR}
\doxyfigcaption{Plot of the velocity field computed with 2D Crouzeix-\/\+Raviart elements, starting from the exact, time-\/periodic solution. }
\end{DoxyImage}


 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{velocity_vectors_TH}
\doxyfigcaption{Plot of the velocity field computed with 2D Taylor-\/\+Hood elements, starting from the exact, time-\/periodic solution. }
\end{DoxyImage}




 

\hypertarget{index_namespace}{}\section{The global parameters}\label{index_namespace}
As usual, we use a namespace to define the problem parameters, the Reynolds number, $ Re$, and the Womersley number, $ Re\, St$ . We also provide two flags that indicate the length of the run (to allow a short run to be performed when the code is run as a self-\/test), and the initial condition (allowing a start from $ {\bf u}_{exact}$ or an impulsive start in which the fluid is initially at rest).

 
\begin{DoxyCodeInclude}
\textcolor{comment}{//===start\_of\_namespace=================================================}
\textcolor{comment}{/// Namepspace for global parameters}
\textcolor{comment}{}\textcolor{comment}{//======================================================================}
\textcolor{keyword}{namespace }\hyperlink{namespaceGlobal__Parameters}{Global\_Parameters}
\{\textcolor{comment}{}
\textcolor{comment}{ /// Reynolds number}
\textcolor{comment}{} \textcolor{keywordtype}{double} \hyperlink{namespaceGlobal__Parameters_a9d72e94a9305c6a310940a6a427ebe06}{Re};
\textcolor{comment}{}
\textcolor{comment}{ /// Womersley = Reynolds times Strouhal}
\textcolor{comment}{} \textcolor{keywordtype}{double} \hyperlink{namespaceGlobal__Parameters_a7a59a32365e87566069e458dc83bd18a}{ReSt};
\textcolor{comment}{}
\textcolor{comment}{ /// Flag for long/short run: Default =  perform long run}
\textcolor{comment}{} \textcolor{keywordtype}{unsigned} \hyperlink{namespaceGlobal__Parameters_a457472b8222bb6bb0d97b2aed78d1ef4}{Long\_run\_flag}=1;
\textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Flag for impulsive start: Default = start from exact}
\textcolor{comment}{ /// time-periodic solution. }
\textcolor{comment}{} \textcolor{keywordtype}{unsigned} \hyperlink{namespaceGlobal__Parameters_aec41eb8da4929003e5d78ef4b43c0ed9}{Impulsive\_start\_flag}=0;

\} \textcolor{comment}{// end of namespace}

\end{DoxyCodeInclude}




 

\hypertarget{index_exact}{}\section{The exact solution}\label{index_exact}
We use a second namespace to define the time-\/periodic, parallel flow $ {\bf u}_{exact}$, and the traction $ {\bf t}^{[prescribed]}$ required to make $ {\bf u}_{exact}$ a solution of the problem.

 
\begin{DoxyCodeInclude}
\textcolor{comment}{//==start\_of\_exact\_solution=============================================}
\textcolor{comment}{/// Namespace for exact solution}
\textcolor{comment}{}\textcolor{comment}{//======================================================================}
\textcolor{keyword}{namespace }\hyperlink{namespaceExactSoln}{ExactSoln}
\{
 \textcolor{comment}{}
\textcolor{comment}{ /// Exact solution of the problem as a vector}
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{namespaceExactSoln_a2598550281dd62f4160edb3d0b2e5432}{get\_exact\_u}(\textcolor{keyword}{const} \textcolor{keywordtype}{double}& t, \textcolor{keyword}{const} Vector<double>& x, Vector<double>& u)
 \{
  \textcolor{keywordtype}{double} y=x[1];
  \textcolor{comment}{// I=sqrt(-1)}
  complex<double> I(0.0,1.0);
  \textcolor{comment}{// omega}
  \textcolor{keywordtype}{double} omega=2.0*MathematicalConstants::Pi;
  \textcolor{comment}{// lambda}
  complex<double> lambda(0.0,omega*\hyperlink{namespaceGlobal__Parameters_a7a59a32365e87566069e458dc83bd18a}{Global\_Parameters::ReSt});
  lambda = I*sqrt(lambda);

  \textcolor{comment}{// Solution}
  complex<double> sol(
   exp(complex<double>(0.0,omega*t)) * 
   (exp(lambda*complex<double>(0.0,y))-exp(lambda*complex<double>(0.0,-y)))
   /(exp(I*lambda)-exp(-I*lambda)) );
  
  \textcolor{comment}{// Extract real part and stick into vector}
  u.resize(2);
  u[0]=real(sol);
  u[1]=0.0;

 \}
\textcolor{comment}{}
\textcolor{comment}{ /// Traction required at the top boundary}
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{namespaceExactSoln_a2a77269d59d7cf56364f0c3b5ae13b41}{prescribed\_traction}(\textcolor{keyword}{const} \textcolor{keywordtype}{double}& t,
                          \textcolor{keyword}{const} Vector<double>& x,
                          \textcolor{keyword}{const} Vector<double> &n,
                          Vector<double>& traction)
 \{
  \textcolor{keywordtype}{double} y=x[1];
  \textcolor{comment}{// I=sqrt(-1)}
  complex<double> I(0.0,1.0);
  \textcolor{comment}{// omega}
  \textcolor{keywordtype}{double} omega=2.0*MathematicalConstants::Pi;
  \textcolor{comment}{// lambda}
  complex<double> lambda(0.0,omega*\hyperlink{namespaceGlobal__Parameters_a7a59a32365e87566069e458dc83bd18a}{Global\_Parameters::ReSt});
  lambda = I*sqrt(lambda);

  \textcolor{comment}{// Solution}
  complex<double> sol(
   exp(complex<double>(0.0,omega*t)) * 
   (exp(lambda*complex<double>(0.0,y))+exp(lambda*complex<double>(0.0,-y)))
   *I*lambda/(exp(I*lambda)-exp(-I*lambda)) );
   
  \textcolor{comment}{//Extract real part and stick into vector}
  traction.resize(2);
  traction[0]=real(sol);
  traction[1]=0.0;
 \} 

\}  \textcolor{comment}{// end of exact\_solution}

\end{DoxyCodeInclude}




 

\hypertarget{index_main}{}\section{The driver code}\label{index_main}
As in the \href{../../rayleigh_channel/html/index.html}{\tt previous example} we use optional command line arguments to specify which mode the code is run in\+: Either as a short or a long run (indicated by the first command line argument being 0 or 1, respectively), and with initial conditions corresponding to an impulsive start or a start from the time-\/periodic exact solution (indicated by the second command line argument being 1 or 0, respectively). If no command line arguments are specified the code is run in the default mode, specified by parameter values assigned in the namespace {\ttfamily \hyperlink{namespaceGlobal__Parameters}{Global\+\_\+\+Parameters}}.


\begin{DoxyCodeInclude}
\textcolor{comment}{//===start\_of\_main======================================================}
\textcolor{comment}{/// Driver code for Rayleigh-type problem}
\textcolor{comment}{}\textcolor{comment}{//======================================================================}
\textcolor{keywordtype}{int} \hyperlink{rayleigh__traction__channel_8cc_a0ddf1224851353fc92bfbff6f499fa97}{main}(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char}* argv[]) 
\{

\textcolor{comment}{}
\textcolor{comment}{ /// Convert command line arguments (if any) into flags:}
\textcolor{comment}{} \textcolor{keywordflow}{if} (argc==1)
  \{
   cout << \textcolor{stringliteral}{"No command line arguments specified -- using defaults."} << std::endl;
  \}
 \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (argc==3)
  \{
   cout << \textcolor{stringliteral}{"Two command line arguments specified:"} << std::endl;
   \textcolor{comment}{// Flag for long run}
   \hyperlink{namespaceGlobal__Parameters_a457472b8222bb6bb0d97b2aed78d1ef4}{Global\_Parameters::Long\_run\_flag}=atoi(argv[1]);\textcolor{comment}{}
\textcolor{comment}{   /// Flag for impulsive start}
\textcolor{comment}{}   \hyperlink{namespaceGlobal__Parameters_aec41eb8da4929003e5d78ef4b43c0ed9}{Global\_Parameters::Impulsive\_start\_flag}=atoi(argv[2]);
  \}
 \textcolor{keywordflow}{else}
  \{
   std::string error\_message = 
    \textcolor{stringliteral}{"Wrong number of command line arguments. Specify none or two.\(\backslash\)n"};
   error\_message +=
    \textcolor{stringliteral}{"Arg1: Long\_run\_flag [0/1]\(\backslash\)n"};
   error\_message +=
    \textcolor{stringliteral}{"Arg2: Impulsive\_start\_flag [0/1]\(\backslash\)n"};

   \textcolor{keywordflow}{throw} OomphLibError(error\_message,
                       OOMPH\_CURRENT\_FUNCTION,
                       OOMPH\_EXCEPTION\_LOCATION);
  \}
 cout << \textcolor{stringliteral}{"Long run flag: "} 
      <<  \hyperlink{namespaceGlobal__Parameters_a457472b8222bb6bb0d97b2aed78d1ef4}{Global\_Parameters::Long\_run\_flag} << std::endl;
 cout << \textcolor{stringliteral}{"Impulsive start flag: "} 
      <<  \hyperlink{namespaceGlobal__Parameters_aec41eb8da4929003e5d78ef4b43c0ed9}{Global\_Parameters::Impulsive\_start\_flag} << std::endl;

\end{DoxyCodeInclude}


Next we set the physical and mesh parameters.


\begin{DoxyCodeInclude}


 \textcolor{comment}{// Set physical parameters:}

 \textcolor{comment}{// Womersly number = Reynolds number (St = 1)}
 \hyperlink{namespaceGlobal__Parameters_a7a59a32365e87566069e458dc83bd18a}{Global\_Parameters::ReSt} = 10.0;
 \hyperlink{namespaceGlobal__Parameters_a9d72e94a9305c6a310940a6a427ebe06}{Global\_Parameters::Re} = \hyperlink{namespaceGlobal__Parameters_a7a59a32365e87566069e458dc83bd18a}{Global\_Parameters::ReSt};

 \textcolor{comment}{//Horizontal length of domain}
 \textcolor{keywordtype}{double} lx = 1.0;

 \textcolor{comment}{//Vertical length of domain}
 \textcolor{keywordtype}{double} ly = 1.0;

 \textcolor{comment}{// Number of elements in x-direction}
 \textcolor{keywordtype}{unsigned} nx=5;

 \textcolor{comment}{// Number of elements in y-direction}
 \textcolor{keywordtype}{unsigned} ny=10;

\end{DoxyCodeInclude}


Finally we set up {\ttfamily Doc\+Info} objects and solve for both Taylor-\/\+Hood elements and Crouzeix-\/\+Raviart elements.


\begin{DoxyCodeInclude}

 \textcolor{comment}{// Solve with Crouzeix-Raviart elements}
 \{
  \textcolor{comment}{// Set up doc info}
  DocInfo doc\_info;
  doc\_info.number()=0;
  doc\_info.set\_directory(\textcolor{stringliteral}{"RESLT\_CR"});
  
  \textcolor{comment}{//Set up problem}
  \hyperlink{classRayleighTractionProblem}{RayleighTractionProblem<QCrouzeixRaviartElement<2>},
      BDF<2> > 
   problem(nx,ny,lx,ly);
  
  \textcolor{comment}{// Run the unsteady simulation}
  problem.unsteady\_run(doc\_info);
 \}


 \textcolor{comment}{// Solve with Taylor-Hood elements}
 \{
  \textcolor{comment}{// Set up doc info}
  DocInfo doc\_info;
  doc\_info.number()=0;
  doc\_info.set\_directory(\textcolor{stringliteral}{"RESLT\_TH"});

  \textcolor{comment}{//Set up problem}
  \hyperlink{classRayleighTractionProblem}{RayleighTractionProblem<QTaylorHoodElement<2>},BDF<2> > 
   problem(nx,ny,lx,ly);
  
  \textcolor{comment}{// Run the unsteady simulation}
  problem.unsteady\_run(doc\_info);
 \}

\} \textcolor{comment}{// end of main}

\end{DoxyCodeInclude}




 

\hypertarget{index_problem}{}\section{The problem class}\label{index_problem}
The problem class remains similar to that in the \href{../../rayleigh_channel/html/index.html}{\tt previous example}. Since we are no longer driving the flow by prescribing a time-\/periodic tangential velocity at the upper wall, the function {\ttfamily actions\+\_\+before\+\_\+implicit\+\_\+timestep()} can remain empty.

 
\begin{DoxyCodeInclude}
\textcolor{comment}{//===start\_of\_problem\_class=============================================}
\textcolor{comment}{/// Rayleigh-type problem: 2D channel flow driven by traction bc}
\textcolor{comment}{}\textcolor{comment}{//======================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT, \textcolor{keyword}{class} TIMESTEPPER>
\textcolor{keyword}{class }\hyperlink{classRayleighTractionProblem}{RayleighTractionProblem} : \textcolor{keyword}{public} Problem
\{
\textcolor{keyword}{public}:
\textcolor{comment}{}
\textcolor{comment}{ /// Constructor: Pass number of elements in x and y directions and }
\textcolor{comment}{ /// lengths}
\textcolor{comment}{} \hyperlink{classRayleighTractionProblem_a6be21517d8294957f768184a2d51844a}{RayleighTractionProblem}(\textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} &nx, \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} &ny, 
                 \textcolor{keyword}{const} \textcolor{keywordtype}{double} &lx, \textcolor{keyword}{const} \textcolor{keywordtype}{double} &ly);
\textcolor{comment}{}
\textcolor{comment}{ /// Update before solve is empty}
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{classRayleighTractionProblem_ad8f0e846280b0dd56f90c6d40808d3ea}{actions\_before\_newton\_solve}() \{\}
\textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Update after solve is empty}
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{classRayleighTractionProblem_ad85c20559eec76d54ebf666f62507d2e}{actions\_after\_newton\_solve}() \{\}
\textcolor{comment}{}
\textcolor{comment}{ /// Actions before timestep (empty)}
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{classRayleighTractionProblem_aea3e470265c0e98a8b5bdabedd28eb82}{actions\_before\_implicit\_timestep}() \{\}
   \textcolor{comment}{}
\textcolor{comment}{ /// Run an unsteady simulation}
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{classRayleighTractionProblem_a50871474406082ae1c1a1694e69e094b}{unsteady\_run}(DocInfo& doc\_info); 
 \textcolor{comment}{}
\textcolor{comment}{ /// Doc the solution}
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{classRayleighTractionProblem_a451af703b4a6de97b060884ca71c3ef8}{doc\_solution}(DocInfo& doc\_info);
\textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Set initial condition (incl previous timesteps) according}
\textcolor{comment}{ /// to specified function. }
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{classRayleighTractionProblem_ad6394f146505e00aeba2fc37f2c75488}{set\_initial\_condition}();

\end{DoxyCodeInclude}


The function {\ttfamily create\+\_\+traction\+\_\+elements}(...) (discussed in more detail below) creates the traction elements and \char`\"{}attaches\char`\"{} them to the specified boundary of the \char`\"{}bulk\char`\"{} mesh.


\begin{DoxyCodeInclude}
\textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Create traction elements on boundary b of the Mesh pointed}
\textcolor{comment}{ /// to by bulk\_mesh\_pt and add them to the Mesh object pointed to by }
\textcolor{comment}{ /// surface\_mesh\_pt}
\textcolor{comment}{} \textcolor{keywordtype}{void} create\_traction\_elements(\textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} &b, 
                               Mesh* \textcolor{keyword}{const} &bulk\_mesh\_pt,
                               Mesh* \textcolor{keyword}{const} &surface\_mesh\_pt);

\end{DoxyCodeInclude}


The traction boundary condition sets the pressure so the function {\ttfamily fix\+\_\+pressure}(...) used in the \href{../../rayleigh_channel/html/index.html}{\tt previous example} is no longer required. The problem\textquotesingle{}s private member data contains pointers to the bulk and surface meshes and the output stream that we use to record the time-\/trace of the solution.


\begin{DoxyCodeInclude}

\textcolor{keyword}{private}:
\textcolor{comment}{}
\textcolor{comment}{ /// Pointer to the "bulk" mesh}
\textcolor{comment}{} RectangularQuadMesh<ELEMENT>* Bulk\_mesh\_pt;
 \textcolor{comment}{}
\textcolor{comment}{ /// Pointer to the "surface" mesh}
\textcolor{comment}{} Mesh* Surface\_mesh\_pt;
\textcolor{comment}{}
\textcolor{comment}{ /// Trace file}
\textcolor{comment}{} ofstream Trace\_file;

\}; \textcolor{comment}{// end of problem\_class}

\end{DoxyCodeInclude}




 

\hypertarget{index_constructor}{}\section{The problem constructor}\label{index_constructor}
We start by building the timestepper, determining its type from the class\textquotesingle{}s second template argument, and pass a pointer to it to the Problem, using the function {\ttfamily Problem\+::add\+\_\+time\+\_\+stepper\+\_\+pt}(...).


\begin{DoxyCodeInclude}
\textcolor{comment}{//===start\_of\_constructor=============================================}
\textcolor{comment}{/// Problem constructor}
\textcolor{comment}{}\textcolor{comment}{//====================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT,\textcolor{keyword}{class} TIMESTEPPER>
\hyperlink{classRayleighTractionProblem_a6be21517d8294957f768184a2d51844a}{RayleighTractionProblem<ELEMENT,TIMESTEPPER>::RayleighTractionProblem}
(\textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} &nx, \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} &ny,
 \textcolor{keyword}{const} \textcolor{keywordtype}{double} &lx, \textcolor{keyword}{const} \textcolor{keywordtype}{double}& ly)
\{
 \textcolor{comment}{//Allocate the timestepper}
 add\_time\_stepper\_pt(\textcolor{keyword}{new} TIMESTEPPER); 

\end{DoxyCodeInclude}


Next we build the periodic bulk mesh,


\begin{DoxyCodeInclude}

 \textcolor{comment}{//Now create the mesh with periodic boundary conditions in x direction}
 \textcolor{keywordtype}{bool} periodic\_in\_x=\textcolor{keyword}{true};
 Bulk\_mesh\_pt = 
  \textcolor{keyword}{new} RectangularQuadMesh<ELEMENT>(nx,ny,lx,ly,periodic\_in\_x,
                                   time\_stepper\_pt());

\end{DoxyCodeInclude}


and the surface mesh,


\begin{DoxyCodeInclude}

 \textcolor{comment}{// Create "surface mesh" that will contain only the prescribed-traction }
 \textcolor{comment}{// elements. The constructor just creates the mesh without}
 \textcolor{comment}{// giving it any elements, nodes, etc.}
 Surface\_mesh\_pt = \textcolor{keyword}{new} Mesh;

\end{DoxyCodeInclude}


and use the function {\ttfamily create\+\_\+traction\+\_\+elements}(...) to populate it with traction elements that attach themselves to the specified boundary (2) of the bulk mesh.


\begin{DoxyCodeInclude}

 \textcolor{comment}{// Create prescribed-traction elements from all elements that are }
 \textcolor{comment}{// adjacent to boundary 2, but add them to a separate mesh.}
 create\_traction\_elements(2,Bulk\_mesh\_pt,Surface\_mesh\_pt);

\end{DoxyCodeInclude}


We add both sub-\/meshes to the {\ttfamily Problem}, using the function {\ttfamily Problem\+::add\+\_\+sub\+\_\+mesh}(...) and use the function {\ttfamily Problem\+::build\+\_\+global\+\_\+mesh()} to combine the sub-\/meshes into the {\ttfamily Problem\textquotesingle{}s} single, global mesh.


\begin{DoxyCodeInclude}

 \textcolor{comment}{// Add the two sub meshes to the problem}
 add\_sub\_mesh(Bulk\_mesh\_pt);
 add\_sub\_mesh(Surface\_mesh\_pt);

 \textcolor{comment}{// Combine all submeshes into a single Mesh}
 build\_global\_mesh();

\end{DoxyCodeInclude}


We apply Dirichlet boundary conditions where required\+: No-\/slip on the stationary, lower wall, at $ x_2=0 $, parallel outflow on the left and right boundaries, at $ x_1=0 $ and $ x_1=1 $. No velocity boundary conditions are applied at the \char`\"{}upper\char`\"{} boundary, at $ x_2=1 $, where the traction boundary condition is applied.


\begin{DoxyCodeInclude}

 \textcolor{comment}{// Set the boundary conditions for this problem: All nodes are}
 \textcolor{comment}{// free by default -- just pin the ones that have Dirichlet conditions}
 \textcolor{comment}{// here}
 \textcolor{keywordtype}{unsigned} num\_bound=Bulk\_mesh\_pt->nboundary();
 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} ibound=0;ibound<num\_bound;ibound++)
  \{
   \textcolor{keywordtype}{unsigned} num\_nod=Bulk\_mesh\_pt->nboundary\_node(ibound);
   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} inod=0;inod<num\_nod;inod++)
    \{
     \textcolor{comment}{// No slip on bottom}
     \textcolor{comment}{// (DO NOT PIN TOP BOUNDARY, SINCE TRACTION DEFINES ITS VELOCITY!)}
     \textcolor{keywordflow}{if} (ibound==0)
      \{
       Bulk\_mesh\_pt->boundary\_node\_pt(ibound,inod)->pin(0);
       Bulk\_mesh\_pt->boundary\_node\_pt(ibound,inod)->pin(1);
      \}
     \textcolor{comment}{// Horizontal outflow on the left (and right -- right bc not}
     \textcolor{comment}{// strictly necessary because of symmetry)}
     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ((ibound==1) || (ibound==3))
      \{
       Bulk\_mesh\_pt->boundary\_node\_pt(ibound,inod)->pin(1);
      \}
    \}
  \} \textcolor{comment}{// end loop over boundaries}

\end{DoxyCodeInclude}


Next we pass the pointers to the Reynolds and Strouhal numbers, $ Re $, $ Re\, St $, to the bulk elements.


\begin{DoxyCodeInclude}

 \textcolor{comment}{//Complete the problem setup to make the elements fully functional}
 
 \textcolor{comment}{//Loop over the elements}
 \textcolor{keywordtype}{unsigned} n\_el = Bulk\_mesh\_pt->nelement();
 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} e=0;e<n\_el;e++)
  \{
   \textcolor{comment}{//Cast to a fluid element}
   ELEMENT *el\_pt = \textcolor{keyword}{dynamic\_cast<}ELEMENT*\textcolor{keyword}{>}(Bulk\_mesh\_pt->element\_pt(e));

   \textcolor{comment}{//Set the Reynolds number, etc}
   el\_pt->re\_pt() = &\hyperlink{namespaceGlobal__Parameters_a9d72e94a9305c6a310940a6a427ebe06}{Global\_Parameters::Re};
   el\_pt->re\_st\_pt() = &\hyperlink{namespaceGlobal__Parameters_a7a59a32365e87566069e458dc83bd18a}{Global\_Parameters::ReSt};
  \}

\end{DoxyCodeInclude}


Finally we pass pointers to the applied traction function to the traction elements and assign the equation numbers.


\begin{DoxyCodeInclude}

 \textcolor{comment}{// Loop over the flux elements to pass pointer to prescribed traction function}
 \textcolor{comment}{// and pointer to global time object}
 n\_el=Surface\_mesh\_pt->nelement();
 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} e=0;e<n\_el;e++)
  \{
   \textcolor{comment}{// Upcast from GeneralisedElement to traction element}
   NavierStokesTractionElement<ELEMENT> *el\_pt = 
    \textcolor{keyword}{dynamic\_cast<} NavierStokesTractionElement<ELEMENT>*\textcolor{keyword}{>}(
     Surface\_mesh\_pt->element\_pt(e));

   \textcolor{comment}{// Set the pointer to the prescribed traction function}
   el\_pt->traction\_fct\_pt() = 
    &\hyperlink{namespaceExactSoln_a2a77269d59d7cf56364f0c3b5ae13b41}{ExactSoln::prescribed\_traction};
  \}

 \textcolor{comment}{//Assgn equation numbers}
 cout << assign\_eqn\_numbers() << std::endl; 

\} \textcolor{comment}{// end of constructor}

\end{DoxyCodeInclude}




 

\hypertarget{index_traction}{}\section{Create traction elements}\label{index_traction}
The creation of the traction elements is performed exactly as in the \href{../../../poisson/two_d_poisson_flux_bc2/html/index.html}{\tt Poisson } and \href{../../../unsteady_heat/two_d_unsteady_heat_adapt/html/index.html}{\tt unsteady heat} problems with flux boundary conditions, discussed earlier. We obtain pointers to the \char`\"{}bulk\char`\"{} elements that are adjacent to the specified boundary of the bulk mesh from the function {\ttfamily Mesh\+::boundary\+\_\+element\+\_\+pt}(...), determine which of the elements\textquotesingle{} local coordinate(s) are constant along that boundary, and pass these parameters to the constructors of the traction elements which \char`\"{}attach\char`\"{} themselves to the appropriate face of the \char`\"{}bulk\char`\"{} element. Finally, we store the pointers to the newly created traction elements in the surface mesh.


\begin{DoxyCodeInclude}
\textcolor{comment}{//============start\_of\_create\_traction\_elements==========================}
\textcolor{comment}{/// Create Navier-Stokes traction elements on the b-th boundary of the}
\textcolor{comment}{}\textcolor{comment}{/// Mesh object pointed to by bulk\_mesh\_pt and add the elements to the }
\textcolor{comment}{}\textcolor{comment}{/// Mesh object pointeed to by surface\_mesh\_pt.}
\textcolor{comment}{}\textcolor{comment}{//=======================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT,\textcolor{keyword}{class} TIMESTEPPER>
\textcolor{keywordtype}{void} \hyperlink{classRayleighTractionProblem_a3a94c245abf443c436eb8a94be19a9f9}{RayleighTractionProblem<ELEMENT,TIMESTEPPER>::}
\hyperlink{classRayleighTractionProblem_a3a94c245abf443c436eb8a94be19a9f9}{create\_traction\_elements}(\textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} &b, Mesh* \textcolor{keyword}{const} &bulk\_mesh\_pt,
                         Mesh* \textcolor{keyword}{const} &surface\_mesh\_pt)
\{
 \textcolor{comment}{// How many bulk elements are adjacent to boundary b?}
 \textcolor{keywordtype}{unsigned} n\_element = bulk\_mesh\_pt->nboundary\_element(b);

 \textcolor{comment}{// Loop over the bulk elements adjacent to boundary b?}
 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} e=0;e<n\_element;e++)
  \{
   \textcolor{comment}{// Get pointer to the bulk element that is adjacent to boundary b}
   ELEMENT* bulk\_elem\_pt = \textcolor{keyword}{dynamic\_cast<}ELEMENT*\textcolor{keyword}{>}(
    bulk\_mesh\_pt->boundary\_element\_pt(b,e));
   
   \textcolor{comment}{//What is the index of the face of element e along boundary b}
   \textcolor{keywordtype}{int} face\_index = bulk\_mesh\_pt->face\_index\_at\_boundary(b,e);

   \textcolor{comment}{// Build the corresponding prescribed-flux element}
   NavierStokesTractionElement<ELEMENT>* flux\_element\_pt = \textcolor{keyword}{new} 
    NavierStokesTractionElement<ELEMENT>(bulk\_elem\_pt,face\_index);
   
   \textcolor{comment}{//Add the prescribed-flux element to the surface mesh}
   surface\_mesh\_pt->add\_element\_pt(flux\_element\_pt);

  \} \textcolor{comment}{//end of loop over bulk elements adjacent to boundary b}

\} \textcolor{comment}{// end of create\_traction\_elements}

\end{DoxyCodeInclude}
 \textbackslash{} 

 

\hypertarget{index_IC}{}\section{Initial conditions}\label{index_IC}
The function {\ttfamily set\+\_\+initial\+\_\+conditions}(...) remains the same as in the \href{../../rayleigh_channel/html/index.html#IC}{\tt previous example}.



 

\hypertarget{index_doc}{}\section{Post processing}\label{index_doc}
The function {\ttfamily doc\+\_\+solution}(...) remains the same as in the \href{../../rayleigh_channel/html/index.html#doc}{\tt previous example}.



 

\hypertarget{index_unsteady_run}{}\section{The timestepping loop}\label{index_unsteady_run}
The function {\ttfamily unsteady\+\_\+run}(...) remains the same as in the \href{../../rayleigh_channel/html/index.html#unsteady_run}{\tt previous example}, except that the default number of timesteps is increased to 500.



 

\hypertarget{index_comments}{}\section{Comments and Exercises}\label{index_comments}
\hypertarget{index_traction_theory}{}\subsection{How do the traction elements work?}\label{index_traction_theory}
The finite element solution of the Navier-\/\+Stokes equations is based on their weak form, obtained by weighting the stress-\/divergence form of the momentum equations \[ Re\left(St\frac{\partial u_i}{\partial t} + u_j\frac{\partial u_i}{\partial x_j}\right) = \frac{\partial \tau_{ij}}{\partial x_j}, \ \ \ \ \ \ \ \ \ \ (6) \] with the global test functions $ \psi_l $, and integrating by parts to obtain the discrete residuals \[ f_{il} = \int_D \left[ Re\left(St\frac{\partial u_i}{\partial t} + u_j\frac{\partial u_i}{\partial x_j}\right) \ \psi_l + \tau_{ij} \ \frac{\partial \psi_l}{\partial x_j} \right] \, dV - \int_{\partial D} \tau_{ij} \ n_j \ \psi_l \ dS = 0. \ \ \ \ \ \ \ \ \ \ (7) \] The volume integral in this residual is computed by the \char`\"{}bulk\char`\"{} Navier-\/\+Stokes elements. \href{../../../intro/html/index.html#galerkin}{\tt Recall} that in the residual for the $ i $ -\/th momentum equation, the global test functions $ \psi_l $ vanish on those parts of the domain boundary $ \partial D$ where the $ i $ -\/th velocity component is prescribed by Dirichlet boundary conditions. On such boundaries, the surface integral in (7) vanishes because $ \psi_l=0. $ If the velocity on a certain part of the domain boundary, $ \partial D_{natural} \subset \partial D$, is not prescribed by Dirichlet boundary conditions and the surface integral over $ \partial D_{natural} $ is not added to the discrete residual, the velocity degrees of freedom on those boundaries are regarded as unknowns and the \char`\"{}traction-\/free\char`\"{} (or natural) boundary condition \[ \tau_{ij} \ n_j = 0 \mbox{ \ \ \ on \ \ $\partial D_{natural}$} \] is \char`\"{}implied\char`\"{}. Finally, traction boundary conditions of the form (1) may be applied along a part, $ \partial D_{traction} \subset \partial D$, of the domain boundary. The surface integral along this part of the domain boundary is given by \[ \int_{\partial D_{traction} } \tau_{ij} \ n_j \ \psi_l \ dS = \int_{\partial D_{traction} } t_i^{[prescribed]} \ \psi_l \ dS, \ \ \ \ \ \ \ \ \ \ (8) \] where $ t_i^{[prescribed]} $ is given, and it is this contribution that the traction elements add to the residual of the momentum equations.



\hypertarget{index_ex}{}\subsection{Exercises}\label{index_ex}

\begin{DoxyEnumerate}
\item Pin the vertical velocity along the upper boundary, $ x_2 = 1$, and compare the results against those obtained with the original version of the code. How does the change affect the velocity field? Why is pressure likely to change?
\item Pin the horizontal velocity along the upper boundary, $ x_2 = 1$, and start the simulation with an impulsive start. Compare the results against those obtained with the original version of the code and explain your findings, referring to the theory provided in the section \hyperlink{index_traction_theory}{How do the traction elements work?} .
\item Run the code with an impulsive start and confirm that it takes longer for the solution to approach the time-\/periodic solution than in the \href{../../rayleigh_channel/html/index.html}{\tt previous case} where the flow was driven by the wall motion. \mbox{[}Here are some animations of the velocity fields obtained following an impulsive start, for a discretisation with \href{../figures/velocity_vectors_TH.avi}{\tt Taylor-\/\+Hood elements} and \href{../figures/velocity_vectors_CR.avi}{\tt Crouzeix-\/\+Raviart elements}.\mbox{]}
\item Investigate the effects of applying a non-\/zero value for $ t_2 $ on the top boundary.
\end{DoxyEnumerate}



 

\hypertarget{index_sources}{}\section{Source files for this tutorial}\label{index_sources}

\begin{DoxyItemize}
\item The source files for this tutorial are located in the directory\+: \begin{center} \href{../../../../demo_drivers/navier_stokes/rayleigh_traction_channel/}{\tt demo\+\_\+drivers/navier\+\_\+stokes/rayleigh\+\_\+traction\+\_\+channel/ } \end{center} 
\item The driver code is\+: \begin{center} \href{../../../../demo_drivers/navier_stokes/rayleigh_traction_channel/rayleigh_traction_channel.cc}{\tt demo\+\_\+drivers/navier\+\_\+stokes/rayleigh\+\_\+traction\+\_\+channel/rayleigh\+\_\+traction\+\_\+channel.\+cc } \end{center} 
\end{DoxyItemize}



 

 \hypertarget{index_pdf}{}\section{P\+D\+F file}\label{index_pdf}
A \href{../latex/refman.pdf}{\tt pdf version} of this document is available. \end{document}
