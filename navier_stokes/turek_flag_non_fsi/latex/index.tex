In this example we consider the flow in a 2D channel that contains a cylinder with a waving \char`\"{}flag\char`\"{}. This is a \char`\"{}warm-\/up problem\char`\"{} for the solution of Turek \& Hron\textquotesingle{}s F\+SI benchmark problem discussed in \href{../../../interaction/turek_flag/html/index.html}{\tt another tutorial.}



 

\hypertarget{index_the_problem}{}\section{The Problem}\label{index_the_problem}
The figure below shows a sketch of the problem\+: A 2D channel of height $ H^*$ and length $ L^* $ contains a cylinder of diameter $ d^* $, centred at $ (X^*_c, Y^*_c) $ to which a \char`\"{}flag\char`\"{} of thickness $ H^*_{flag}$ and length $ L^*_{flag} $ is attached. We assume that the flag performs time-\/periodic oscillations with period $ T^*. $ Steady Poiseuille flow with average velocity $ U^* $ is imposed at the left end of the channel while we assume the outflow to be parallel and axially traction-\/free.

 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{turek_flag_non_fsi_dim}
\doxyfigcaption{Sketch of the problem in dimensional variables. }
\end{DoxyImage}


We non-\/dimensionalise all length and coordinates on the diameter of the cylinder, $ d^* $, time on the natural timescale of the flow, $ d^*/U^* $, the velocities on the mean velocity, $ U^* $, and the pressure on the viscous scale. The problem is then governed by the non-\/dimensional Navier-\/\+Stokes equations \[ Re \left( St \frac{\partial u_i}{\partial t} + u_j \frac{\partial u_i}{\partial x_j} \right) = - \frac{\partial p}{\partial x_i} + \frac{\partial }{\partial x_j} \left[ \left( \frac{\partial u_i}{\partial x_j} + \frac{\partial u_j}{\partial x_i} \right) \right], \] where $ Re = \rho U^* H_0^* / \mu $ and $ St = 1 $, and \begin{center} \[ \frac{\partial u_i}{\partial x_i} = 0, \] \end{center}  subject to parabolic inflow \begin{center} \[ {\bf u} = 6 x_2 (1-x_2) {\bf e}_1 \] \end{center}  at the inflow cross-\/section; parallel, axially-\/traction-\/free outflow at the outlet; and no-\/slip on the stationary channel walls and the surface of the cylinder, $ {\bf u} = {\bf 0} $. The no-\/slip condition on the moving flag is \begin{center} \[ {\bf u} = \frac{\partial {\bf R}_w(\xi_{[top,tip,bottom]},t)}{\partial t} \] \end{center}  where $ \xi_{[top,tip,bottom]} $ are Lagrangian coordinates parametrising the three faces of the flag. The flag performs oscillations with non-\/dimensional period $ T = T^* U^* / H^*_{tot} $. Here is a sketch of the non-\/dimensional version of the problem\+:

 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{turek_flag_non_fsi}
\doxyfigcaption{Sketch of the problem in dimensionless variables, showing the Lagrangian coordinates that parametrise the three faces of the flag. }
\end{DoxyImage}




 

\hypertarget{index_results}{}\section{Results}\label{index_results}
The figure below shows a snapshot of the flow field (pressure contours and instantaneous streamlines) for a Reynolds number of $ Re=100 $ and an oscillation period of $ T= 10 $, as well as the corresponding fluid mesh. Note how {\ttfamily oomph-\/lib\textquotesingle{}s} automatic mesh adaptation has refined the mesh in the high-\/shear regions near the front of the cylinder and at the trailing edge of the flag.

 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{flow_cropped}
\doxyfigcaption{Mesh (top) and flow field (bottom). }
\end{DoxyImage}


The corresponding \href{../figures/turek_flag_non_fsi.avi}{\tt animation} illustrates the algebraic node update strategy (implemented with an {\ttfamily Algebraic\+Mesh}, discussed in more detail in \href{../../algebraic_collapsible_channel/html/index.html}{\tt another tutorial}) and the evolution of the flow field. Note that the instantaneous streamlines intersect the (impermeable) flag because the flag is not stationary.



 

\hypertarget{index_parameters}{}\section{The global parameters}\label{index_parameters}
As usual we use a namespace to define the (single) global parameter, the Reynolds number.

 
\begin{DoxyCodeInclude}
\textcolor{comment}{//====start\_of\_global\_parameters==========================================}
\textcolor{comment}{/// Global parameters}
\textcolor{comment}{}\textcolor{comment}{//========================================================================}
\textcolor{keyword}{namespace }\hyperlink{namespaceGlobal__Parameters}{Global\_Parameters}
\{\textcolor{comment}{}
\textcolor{comment}{ /// Reynolds number}
\textcolor{comment}{} \textcolor{keywordtype}{double} Re=100.0;
\}

\end{DoxyCodeInclude}




 

\hypertarget{index_leaflet}{}\section{Specification of the flag geometry}\label{index_leaflet}
We specify the flag geometry and its time-\/dependent motion by representing its three faces by {\ttfamily Geom\+Objects}, each parametrised by its own Lagrangian coordinate, as shown in the sketch above. The geometry of the cylinder is represented by one of {\ttfamily oomph-\/lib\textquotesingle{}s} generic {\ttfamily Geom\+Objects}, the {\ttfamily Circle}.

We enclose the relevant data in its own namespace and start by defining the period of the oscillation, and the geometric parameters controlling the flag\textquotesingle{}s initial shape and its subsequent motion.

 
\begin{DoxyCodeInclude}
\textcolor{comment}{//====start\_of\_flag\_definition===========================================}
\textcolor{comment}{/// Namespace for definition of flag boundaries}
\textcolor{comment}{}\textcolor{comment}{//=======================================================================}
\textcolor{keyword}{namespace }\hyperlink{namespaceFlag__definition}{Flag\_definition}
\{
\textcolor{comment}{}
\textcolor{comment}{ /// Period of prescribed flag oscillation}
\textcolor{comment}{} \textcolor{keywordtype}{double} Period=10.0;
\textcolor{comment}{}
\textcolor{comment}{ /// Height of flag}
\textcolor{comment}{} \textcolor{keywordtype}{double} H=0.2;
\textcolor{comment}{}
\textcolor{comment}{ /// Length of flag}
\textcolor{comment}{} \textcolor{keywordtype}{double} L=3.5;
   \textcolor{comment}{}
\textcolor{comment}{ /// x position of centre of cylinder}
\textcolor{comment}{} \textcolor{keywordtype}{double} Centre\_x=2.0;
\textcolor{comment}{}
\textcolor{comment}{ /// y position of centre of cylinder}
\textcolor{comment}{} \textcolor{keywordtype}{double} Centre\_y=2.0;
\textcolor{comment}{}
\textcolor{comment}{ /// Radius of cylinder}
\textcolor{comment}{} \textcolor{keywordtype}{double} Radius=0.5;
\textcolor{comment}{}
\textcolor{comment}{ /// Amplitude of tip deflection}
\textcolor{comment}{} \textcolor{keywordtype}{double} Amplitude=0.33;
\textcolor{comment}{}
\textcolor{comment}{ ///Pointer to the global time object}
\textcolor{comment}{} Time* Time\_pt=0;

\end{DoxyCodeInclude}


We choose the motion of the flag such that it vaguely resembles that expected in the corresponding F\+SI problem\+: We subject the flag\textquotesingle{}s upper and lower faces to purely vertical displacements that deform them into a fraction of a sine wave, while keeping the face at the tip of the flag straight and vertical. We implement this by prescribing the time-\/dependent motion of the two vertices at the tip of the flag with two functions\+:


\begin{DoxyCodeInclude}
 

\textcolor{comment}{}
\textcolor{comment}{ /// Time-dependent vector to upper tip of the "flag"}
\textcolor{comment}{} Vector<double> \hyperlink{namespaceFlag__definition_a6af3444eee77be503be4aa8c2ef47c13}{upper\_tip}(\textcolor{keyword}{const} \textcolor{keywordtype}{double}& t)
  \{
   \textcolor{keywordtype}{double} tmp\_ampl=\hyperlink{namespaceFlag__definition_ad0eb269ec983b485aa24a6f2c25d2f5b}{Amplitude};
   \textcolor{keywordflow}{if} (t<=0.0) tmp\_ampl=0.0;
   Vector<double> uppertip(2);
   uppertip[0]= Centre\_x+Radius*sqrt(1.0-H*H/(4.0*Radius*Radius))+\hyperlink{namespaceFlag__definition_a94553533bee82260731a466182369a9d}{L};
   uppertip[1]= Centre\_y+0.5*H-
    tmp\_ampl*sin(2.0*MathematicalConstants::Pi*t/Period);
   \textcolor{keywordflow}{return} uppertip;
  \}  
 \textcolor{comment}{}
\textcolor{comment}{ /// Time-dependent vector to bottom tip of the "flag"}
\textcolor{comment}{} Vector<double> \hyperlink{namespaceFlag__definition_a91eabcfac65c509ab3448d82db1eb988}{lower\_tip}(\textcolor{keyword}{const} \textcolor{keywordtype}{double}& t)
  \{
   \textcolor{keywordtype}{double} tmp\_ampl=\hyperlink{namespaceFlag__definition_ad0eb269ec983b485aa24a6f2c25d2f5b}{Amplitude};
   \textcolor{keywordflow}{if} (t<=0.0) tmp\_ampl=0.0;
   Vector<double> lowertip(2);
   lowertip[0]= Centre\_x+Radius*sqrt(1.0-H*H/(4.0*Radius*Radius))+\hyperlink{namespaceFlag__definition_a94553533bee82260731a466182369a9d}{L};
   lowertip[1]= Centre\_y-0.5*H-
    tmp\_ampl*sin(2.0*MathematicalConstants::Pi*t/Period);
   \textcolor{keywordflow}{return} lowertip;
  \} \textcolor{comment}{// end of bottom tip}

\end{DoxyCodeInclude}


This information is then used in three custom-\/written {\ttfamily Geom\+Object} that define the time-\/dependent shape of the three faces. Here is the one describing the shape of the upper face\+:


\begin{DoxyCodeInclude}





\textcolor{comment}{//-----start\_of\_top\_of\_flag--------------------------------------}\textcolor{comment}{}
\textcolor{comment}{/// GeomObject that defines the upper boundary of the flag}
\textcolor{comment}{}\textcolor{comment}{//---------------------------------------------------------------}
 \textcolor{keyword}{class }TopOfFlag : \textcolor{keyword}{public} GeomObject
 \{
  
 \textcolor{keyword}{public}:
  \textcolor{comment}{}
\textcolor{comment}{  ///Constructor: It's a 1D object in 2D space }
\textcolor{comment}{}  TopOfFlag() : GeomObject(1,2) \{\}
\textcolor{comment}{}
\textcolor{comment}{  ///Destructor (empty)}
\textcolor{comment}{}  ~TopOfFlag()\{\}
  \textcolor{comment}{}
\textcolor{comment}{  /// \(\backslash\)short Return the position along the top of the flag (xi[0] varies }
\textcolor{comment}{  /// between 0 and Lx)}
\textcolor{comment}{}  \textcolor{keywordtype}{void} position(\textcolor{keyword}{const} \textcolor{keywordtype}{unsigned}& t,\textcolor{keyword}{const} Vector<double> &xi, Vector<double> &r)\textcolor{keyword}{}
\textcolor{keyword}{   const}
\textcolor{keyword}{   }\{
    \textcolor{comment}{// Compute position of fixed point on the cylinder}
    Vector<double> point\_on\_circle(2);     
    point\_on\_circle[0]=Centre\_x+Radius*sqrt(1.0-H*H/(4.0*Radius*Radius));
    point\_on\_circle[1]=Centre\_y+H/2.0;

    r[0] = point\_on\_circle[0]+xi[0]/L*(\hyperlink{namespaceFlag__definition_a6af3444eee77be503be4aa8c2ef47c13}{upper\_tip}(Time\_pt->time(t))[0]-
                                        point\_on\_circle[0]);
    
    r[1] = point\_on\_circle[1]+xi[0]/L*(\hyperlink{namespaceFlag__definition_a6af3444eee77be503be4aa8c2ef47c13}{upper\_tip}(Time\_pt->time(t))[1]-
                                        point\_on\_circle[1])+
     1.0/3.0*sin((r[0]-point\_on\_circle[0])/
                 (\hyperlink{namespaceFlag__definition_a6af3444eee77be503be4aa8c2ef47c13}{upper\_tip}(Time\_pt->time(t))[0]-
                  point\_on\_circle[0])*MathematicalConstants::Pi)
     *sin(2.0* MathematicalConstants::Pi*Time\_pt->time(t)/\hyperlink{namespaceFlag__definition_a47976a19abd58b9c31671f074ca57285}{Period});
    
   \}
 
  \textcolor{comment}{}
\textcolor{comment}{  /// Current position}
\textcolor{comment}{}  \textcolor{keywordtype}{void} position(\textcolor{keyword}{const} Vector<double> &xi, Vector<double> &r)\textcolor{keyword}{ const}
\textcolor{keyword}{   }\{
    \textcolor{keywordflow}{return} position(0,xi,r);
   \}
\textcolor{comment}{}
\textcolor{comment}{  /// Number of geometric Data in GeomObject: None.}
\textcolor{comment}{}  \textcolor{keywordtype}{unsigned} ngeom\_data()\textcolor{keyword}{ const }\{\textcolor{keywordflow}{return} 0;\} 
  
\};

\end{DoxyCodeInclude}


\mbox{[}We omit the definition of the other two {\ttfamily Geom\+Objects}, {\ttfamily Bottom\+Of\+Flag} and {\ttfamily Tip\+Of\+Flag} in in the interest of brevity. Their definitions can be found in the \href{
../../../../demo_drivers/navier_stokes/turek_flag_non_fsi/turek_flag_non_fsi.cc
}{\tt source code}.\mbox{]} We provide storage for the pointers to the four {\ttfamily Geom\+Objects} required for the representation of the flag,


\begin{DoxyCodeInclude}
 \textcolor{comment}{/// Pointer to GeomObject that bounds the upper edge of the flag}
 TopOfFlag* \hyperlink{namespaceFlag__definition_af602ebeb0c40d05d00961af07bf3e842}{Top\_flag\_pt}=0;
\textcolor{comment}{}
\textcolor{comment}{ /// Pointer to GeomObject that bounds the bottom edge of the flag}
\textcolor{comment}{} BottomOfFlag* \hyperlink{namespaceFlag__definition_adde5e58da47e90ef46e1183188281f2e}{Bottom\_flag\_pt}=0;
\textcolor{comment}{}
\textcolor{comment}{ /// Pointer to GeomObject that bounds the tip edge of the flag}
\textcolor{comment}{} TipOfFlag* \hyperlink{namespaceFlag__definition_a17de6efd8447ee9c2bb5a1767084ecef}{Tip\_flag\_pt}=0;
\textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Pointer to GeomObject of type Circle that defines the}
\textcolor{comment}{ /// central cylinder.}
\textcolor{comment}{} Circle* \hyperlink{namespaceFlag__definition_a87051411606f6aa4518ace9ce66a4189}{Cylinder\_pt}=0;

\end{DoxyCodeInclude}


and provide a setup function that generates the {\ttfamily Geom\+Objects} and stores the pointer to the global {\ttfamily Time} object that will be created by the {\ttfamily Problem\+:} 


\begin{DoxyCodeInclude}
\textcolor{comment}{}
\textcolor{comment}{ /// Create all GeomObjects needed to define the cylinder and the flag}
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{namespaceFlag__definition_a61a03bffd4a34950ef9892be53c49f89}{setup}(Time* time\_pt)
 \{
  \textcolor{comment}{// Assign pointer to global time object}
  Time\_pt=time\_pt;
  
  \textcolor{comment}{// Create GeomObject of type Circle that defines the}
  \textcolor{comment}{// central cylinder.}
  Cylinder\_pt=\textcolor{keyword}{new} Circle(Centre\_x,Centre\_y,Radius);
  \textcolor{comment}{}
\textcolor{comment}{  /// Create GeomObject that bounds the upper edge of the flag}
\textcolor{comment}{}  Top\_flag\_pt=\textcolor{keyword}{new} TopOfFlag;
  \textcolor{comment}{}
\textcolor{comment}{  /// Create GeomObject that bounds the bottom edge of the flag}
\textcolor{comment}{}  Bottom\_flag\_pt=\textcolor{keyword}{new} BottomOfFlag;
  \textcolor{comment}{}
\textcolor{comment}{  /// Create GeomObject that bounds the tip edge of the flag}
\textcolor{comment}{}  Tip\_flag\_pt=\textcolor{keyword}{new} TipOfFlag;
 
 \}

\} \textcolor{comment}{// end of namespace that specifies the flag}

\end{DoxyCodeInclude}




 

\hypertarget{index_mesh}{}\section{The mesh}\label{index_mesh}
The figure below shows a sketch of the (unrefined) mesh and the enumeration of its boundaries. Various different implementations of the mesh exist, allowing the user to perform the node-\/update in response to the motion of the flag by a {\ttfamily Domain/\+Macro\+Element} -\/ based procedure, or by using an algebraic node update. In either case, only the nodes in the elements that are shaded in yellow (or refined elements that are generated from these) participate in the node-\/update.

 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{cylinder_with_flag_mesh}
\doxyfigcaption{The (unrefined) mesh. Only nodes in the yellow regions participate in the node-\/update. }
\end{DoxyImage}


The node update strategy is illustrated in the \href{../figures/turek_flag_non_fsi.avi}{\tt animation} of the flow field and the mesh motion.



 

\hypertarget{index_main}{}\section{The driver code}\label{index_main}
The driver code has the usual structure for a time-\/dependent problem\+: We store the command line arguments, create a {\ttfamily Doc\+Info} object, and assign the parameters that specify the dimensions of the channel.

 
\begin{DoxyCodeInclude}
\textcolor{comment}{//======start\_of\_main==================================================}
\textcolor{comment}{/// Driver code -- pass a command line argument if you want to run}
\textcolor{comment}{}\textcolor{comment}{/// the code in validation mode where it only performs a few steps}
\textcolor{comment}{}\textcolor{comment}{//=====================================================================}
\textcolor{keywordtype}{int} \hyperlink{turek__flag__non__fsi_8cc_a0ddf1224851353fc92bfbff6f499fa97}{main}(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char}* argv[])
\{

 \textcolor{comment}{// Store command line arguments}
 \hyperlink{namespaceFlag__definition_a61a03bffd4a34950ef9892be53c49f89}{CommandLineArgs::setup}(argc,argv);
 
 \textcolor{comment}{// Set up doc info}
 DocInfo doc\_info; 
 doc\_info.set\_directory(\textcolor{stringliteral}{"RESLT"});
 doc\_info.number()=0;
 
 \textcolor{comment}{// Length and height of domain}
 \textcolor{keywordtype}{double} length=25.0;
 \textcolor{keywordtype}{double} height=4.1;

\end{DoxyCodeInclude}


We build the problem using a mesh in which the node update is performed by the {\ttfamily Algebraic\+Mesh} class. (The driver code also provides the option to use a {\ttfamily Domain/\+Macro\+Element} -\/ based node update -- this option is chosen via suitable \#ifdefs; see the \href{
../../../../demo_drivers/navier_stokes/turek_flag_non_fsi/turek_flag_non_fsi.cc
}{\tt source code} for details).


\begin{DoxyCodeInclude}
 \textcolor{comment}{// Create Problem with AlgebraicMesh-based node update}
 \hyperlink{classTurekNonFSIProblem}{TurekNonFSIProblem}
  <AlgebraicElement<RefineableQCrouzeixRaviartElement<2> > > 
  problem(length, height);

\end{DoxyCodeInclude}


Next we set up the time-\/stepping (as usual, fewer timesteps are performed during a validation run which is identified by a non-\/zero number of command line arguments)\+:


\begin{DoxyCodeInclude}
\textcolor{comment}{// Number of timesteps per period}
 \textcolor{keywordtype}{unsigned} nsteps\_per\_period=40;

 \textcolor{comment}{// Number of periods}
 \textcolor{keywordtype}{unsigned} nperiod=3; 

 \textcolor{comment}{// Number of timesteps  (reduced for validation)}
 \textcolor{keywordtype}{unsigned} nstep=nsteps\_per\_period*nperiod;
 \textcolor{keywordflow}{if} (CommandLineArgs::Argc>1)
  \{
   nstep=2;
   \textcolor{comment}{// Also reduce the Reynolds number to reduce the mesh refinement}
   \hyperlink{namespaceGlobal__Parameters_a9d72e94a9305c6a310940a6a427ebe06}{Global\_Parameters::Re}=10.0;
  \}

 \textcolor{comment}{//Timestep: }
 \textcolor{keywordtype}{double} dt=\hyperlink{namespaceFlag__definition_a47976a19abd58b9c31671f074ca57285}{Flag\_definition::Period}/double(nsteps\_per\_period);
 \textcolor{comment}{}
\textcolor{comment}{ /// Initialise timestep }
\textcolor{comment}{} problem.initialise\_dt(dt);

\end{DoxyCodeInclude}


We start the simulation with a steady solve, allowing up to three levels of adaptive refinement (fewer if we are performing a validation run)\+:


\begin{DoxyCodeInclude}

 \textcolor{comment}{// Solve adaptively with up to max\_adapt rounds of refinement (fewer if }
 \textcolor{comment}{// run during self-test)}
 \textcolor{keywordtype}{unsigned} max\_adapt=3;
 \textcolor{keywordflow}{if} (CommandLineArgs::Argc>1)
  \{
   max\_adapt=1;
  \} 
\textcolor{comment}{}
\textcolor{comment}{ /// Output intial guess for steady Newton solve}
\textcolor{comment}{} problem.doc\_solution(doc\_info);
 doc\_info.number()++;

\end{DoxyCodeInclude}


Finally, we enter the proper timestepping loop, allowing one spatial adaptation per timestep and suppressing the re-\/assignment of initial conditions following an adaptation by setting the parameter {\ttfamily first} to false. (See the discussion of timestepping with automatic mesh adaptation in \href{../../../unsteady_heat/two_d_unsteady_heat_adapt/html/index.html}{\tt another tutorial}.)


\begin{DoxyCodeInclude}

 \textcolor{comment}{// Do steady solve first -- this also sets the history values}
 \textcolor{comment}{// to those corresponding to an impulsive start from the}
 \textcolor{comment}{// steady solution}
 problem.steady\_newton\_solve(max\_adapt);
 \textcolor{comment}{}
\textcolor{comment}{ /// Output steady solution = initial condition for subsequent unsteady solve}
\textcolor{comment}{} problem.doc\_solution(doc\_info);
 doc\_info.number()++;
\textcolor{comment}{}
\textcolor{comment}{ /// Reduce the max number of adaptations for time-dependent simulation}
\textcolor{comment}{} max\_adapt=1;

 \textcolor{comment}{// We don't want to re-assign the initial condition after the mesh}
 \textcolor{comment}{// adaptation}
 \textcolor{keywordtype}{bool} first=\textcolor{keyword}{false};
 
\textcolor{comment}{// Timestepping loop}
 \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} istep=0;istep<nstep;istep++)
  \{ 
   \textcolor{comment}{// Solve the problem}
   problem.unsteady\_newton\_solve(dt,max\_adapt,first);
   
   \textcolor{comment}{// Output the solution}
   problem.doc\_solution(doc\_info);
   
   \textcolor{comment}{// Step number}
   doc\_info.number()++;
  \}
 
\}\textcolor{comment}{//end of main}

\end{DoxyCodeInclude}




 

\hypertarget{index_problem}{}\section{The Problem class}\label{index_problem}
The problem class provides an access function to the mesh (note the use of \#ifdefs to choose the correct one), and defines the interfaces for the usual member functions, either empty or explained in more detail below.

 
\begin{DoxyCodeInclude}
\textcolor{comment}{//======= start\_of\_problem\_class=====================================}
\textcolor{comment}{/// Flow around a cylinder with flag}
\textcolor{comment}{}\textcolor{comment}{//===================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT>
\textcolor{keyword}{class }\hyperlink{classTurekNonFSIProblem}{TurekNonFSIProblem} : \textcolor{keyword}{public} Problem
\{

\textcolor{keyword}{public}:
\textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Constructor: Pass length and height of domain.}
\textcolor{comment}{} \hyperlink{classTurekNonFSIProblem_aacb3214544ef81c2f8b49777457e8be6}{TurekNonFSIProblem}(\textcolor{keyword}{const} \textcolor{keywordtype}{double} &length, 
                         \textcolor{keyword}{const} \textcolor{keywordtype}{double} &height);
 \textcolor{comment}{}
\textcolor{comment}{ /// Update the problem specs after solve (empty)}
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{classTurekNonFSIProblem_a161cfe46817a5129dcc33c7ce3a17173}{actions\_after\_newton\_solve}() \{\}
\textcolor{comment}{}
\textcolor{comment}{ /// Update the problem specs before solve (empty)}
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{classTurekNonFSIProblem_ae5881b3424aee1ba7b947fff96493d2f}{actions\_before\_newton\_solve}() \{\}
\textcolor{comment}{}
\textcolor{comment}{ /// After adaptation: Unpin pressures and pin redudant pressure dofs.}
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{classTurekNonFSIProblem_a88ed5ef8b1be34f5176c29ffec20eedd}{actions\_after\_adapt}();
\textcolor{comment}{}
\textcolor{comment}{ /// Update the velocity boundary condition on the flag}
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{classTurekNonFSIProblem_a29725cde9071c3a83792469787ea6c7d}{actions\_before\_implicit\_timestep}();


\textcolor{preprocessor}{#ifdef USE\_MACRO\_ELEMENTS}
\textcolor{comment}{}
\textcolor{comment}{ /// Access function for the specific mesh}
\textcolor{comment}{} RefineableCylinderWithFlagMesh<ELEMENT>* \hyperlink{classTurekNonFSIProblem_a6b9af904a3091d55a61b35c2ce7d7fcb}{mesh\_pt}() 
  \{
   \textcolor{keywordflow}{return} \textcolor{keyword}{dynamic\_cast<}RefineableCylinderWithFlagMesh<ELEMENT>*\textcolor{keyword}{>}
    (Problem::mesh\_pt());
  \}

\textcolor{preprocessor}{#else}
\textcolor{comment}{}
\textcolor{comment}{ /// Access function for the specific mesh}
\textcolor{comment}{} RefineableAlgebraicCylinderWithFlagMesh<ELEMENT>* \hyperlink{classTurekNonFSIProblem_a6b9af904a3091d55a61b35c2ce7d7fcb}{mesh\_pt}() 
  \{
   \textcolor{keywordflow}{return} \textcolor{keyword}{dynamic\_cast<}RefineableAlgebraicCylinderWithFlagMesh<ELEMENT>*\textcolor{keyword}{>}
    (Problem::mesh\_pt());
  \}
 
\textcolor{preprocessor}{#endif}
\textcolor{comment}{}
\textcolor{comment}{ /// Doc the solution}
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{classTurekNonFSIProblem_a2f129e4eba71784a58b27d846fdc2a61}{doc\_solution}(DocInfo& doc\_info);


\textcolor{keyword}{private}:
\textcolor{comment}{}
\textcolor{comment}{ /// Height of channel}
\textcolor{comment}{} \textcolor{keywordtype}{double} \hyperlink{classTurekNonFSIProblem_a7e85e76876a9b1136cc340b0bb25e299}{Height};

\};\textcolor{comment}{//end\_of\_problem\_class}

\end{DoxyCodeInclude}




 

\hypertarget{index_constructor}{}\section{The problem constructor}\label{index_constructor}
The initial assignment of zero velocity and pressure provides a very poor initial guess for the preliminary steady Newton solve. We therefore increase the maximum residuals and iteration counts allowed in the Newton iteration before creating the timestepper and setting up the {\ttfamily Geom\+Objects} required to parametrise the flag\+:


\begin{DoxyCodeInclude}
\textcolor{comment}{//=====start\_of\_constructor===============================================}
\textcolor{comment}{/// Constructor: Pass length and height of domain.}
\textcolor{comment}{}\textcolor{comment}{//========================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT>
\hyperlink{classTurekNonFSIProblem_aacb3214544ef81c2f8b49777457e8be6}{TurekNonFSIProblem<ELEMENT>::TurekNonFSIProblem}(
 \textcolor{keyword}{const} \textcolor{keywordtype}{double} &length, \textcolor{keyword}{const} \textcolor{keywordtype}{double} &height) : Height(height)
\{ 

 \textcolor{comment}{// Bump up Newton solver parameters to allow for crappy initial guesses}
 Max\_residuals=100.0;;
 Max\_newton\_iterations=50;

 \textcolor{comment}{// Allocate the timestepper}
 add\_time\_stepper\_pt(\textcolor{keyword}{new} BDF<2>);

 \textcolor{comment}{// Setup flag/cylinder geometry}
 \hyperlink{namespaceFlag__definition_a61a03bffd4a34950ef9892be53c49f89}{Flag\_definition::setup}(time\_pt());

\end{DoxyCodeInclude}


Next we build the mesh, passing the pointers to the various {\ttfamily Geom\+Objects} and the geometric parameters to its constructor.


\begin{DoxyCodeInclude}
 \textcolor{comment}{// Build mesh (with AlgebraicMesh-based node update)}
 Problem::mesh\_pt()=\textcolor{keyword}{new} RefineableAlgebraicCylinderWithFlagMesh<ELEMENT>
  (\hyperlink{namespaceFlag__definition_a87051411606f6aa4518ace9ce66a4189}{Flag\_definition::Cylinder\_pt},
   \hyperlink{namespaceFlag__definition_af602ebeb0c40d05d00961af07bf3e842}{Flag\_definition::Top\_flag\_pt}, 
   \hyperlink{namespaceFlag__definition_adde5e58da47e90ef46e1183188281f2e}{Flag\_definition::Bottom\_flag\_pt}, 
   \hyperlink{namespaceFlag__definition_a17de6efd8447ee9c2bb5a1767084ecef}{Flag\_definition::Tip\_flag\_pt},
   length, height, 
   \hyperlink{namespaceFlag__definition_a94553533bee82260731a466182369a9d}{Flag\_definition::L},
   \hyperlink{namespaceFlag__definition_a6cdf33de1fe6f94832181664d7769af7}{Flag\_definition::H}, 
   \hyperlink{namespaceFlag__definition_a60f30c718c6c67504b05dca7832be8aa}{Flag\_definition::Centre\_x},
   \hyperlink{namespaceFlag__definition_a0024007edc2ad0ef647939aa6b06bde7}{Flag\_definition::Centre\_y},
   \hyperlink{namespaceFlag__definition_a921d8bd82b7b267651dea625a548dfcb}{Flag\_definition::Radius},
   time\_stepper\_pt());

\end{DoxyCodeInclude}


We perform two rounds of uniform refinement (the Newton solver does not converge on coarser meshes) before creating an error estimator for the subsequent automatic mesh adaptation.


\begin{DoxyCodeInclude}
 \textcolor{comment}{// Refine uniformly}
 mesh\_pt()->refine\_uniformly();
 mesh\_pt()->refine\_uniformly();

 \textcolor{comment}{// Set error estimator}
 Z2ErrorEstimator* error\_estimator\_pt=\textcolor{keyword}{new} Z2ErrorEstimator;
 mesh\_pt()->spatial\_error\_estimator\_pt()=error\_estimator\_pt;

\end{DoxyCodeInclude}


Both velocity components are imposed by Dirichlet conditions (either via a no-\/slip condition or via the imposed inflow profile) on all boundaries, apart from the outflow cross-\/section (mesh boundary 1), where the axial velocity is unknown.


\begin{DoxyCodeInclude}
  
 \textcolor{comment}{// Set the boundary conditions for this problem: All nodes are}
 \textcolor{comment}{// free by default -- just pin the ones that have Dirichlet conditions}
 \textcolor{comment}{// here. }
 
 \textcolor{comment}{//Pin both velocities at all boundaries apart from outflow}
 \textcolor{keywordtype}{unsigned} num\_bound = mesh\_pt()->nboundary();
 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} ibound=0;ibound<num\_bound;ibound++)
  \{
   \textcolor{keywordtype}{unsigned} num\_nod= mesh\_pt()->nboundary\_node(ibound);
   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} inod=0;inod<num\_nod;inod++)
    \{
     \textcolor{comment}{// Parallel, axially traction free outflow at downstream end}
     \textcolor{keywordflow}{if} (ibound != 1)
      \{
       mesh\_pt()->boundary\_node\_pt(ibound,inod)->pin(0);
       mesh\_pt()->boundary\_node\_pt(ibound,inod)->pin(1);
      \}
     \textcolor{keywordflow}{else}
      \{
       mesh\_pt()->boundary\_node\_pt(ibound,inod)->pin(1);
      \}
    \}
  \} \textcolor{comment}{// done bc}

\end{DoxyCodeInclude}


Next we complete the build of the elements, passing the relevant pointers to physical parameters,


\begin{DoxyCodeInclude}
  
  
  \textcolor{comment}{// Pass pointer to Reynolds number to elements}
  \textcolor{keywordtype}{unsigned} nelem=mesh\_pt()->nelement();
  \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} e=0;e<nelem;e++)
   \{
    \textcolor{comment}{// Upcast from GeneralisedElement to the present element}
    ELEMENT* el\_pt = \textcolor{keyword}{dynamic\_cast<}ELEMENT*\textcolor{keyword}{>}(mesh\_pt()->element\_pt(e));
    
    \textcolor{comment}{//Set the Reynolds number}
    el\_pt->re\_pt() = &\hyperlink{namespaceGlobal__Parameters_a9d72e94a9305c6a310940a6a427ebe06}{Global\_Parameters::Re};   
    
    \textcolor{comment}{//Set the Womersley number (assuming St=1)}
    el\_pt->re\_st\_pt() = &\hyperlink{namespaceGlobal__Parameters_a9d72e94a9305c6a310940a6a427ebe06}{Global\_Parameters::Re};
   \}

\end{DoxyCodeInclude}


and impose the steady Poiseuille profile at the inlet (mesh boundary 3).


\begin{DoxyCodeInclude}
  

  \textcolor{comment}{// Setup Poiseuille flow along boundary 3}
  \textcolor{keywordtype}{unsigned} ibound=3;
  \textcolor{keywordtype}{unsigned} num\_nod= mesh\_pt()->nboundary\_node(ibound);
  \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} inod=0;inod<num\_nod;inod++)
   \{
    \textcolor{keywordtype}{double} ycoord = mesh\_pt()->boundary\_node\_pt(ibound,inod)->x(1);

    \textcolor{comment}{// Set Poiseuille velocity}
    \textcolor{keywordtype}{double} uy = 6.0*ycoord/Height*(1.0-ycoord/Height);
    
    mesh\_pt()->boundary\_node\_pt(ibound,inod)->set\_value(0,uy);
    mesh\_pt()->boundary\_node\_pt(ibound,inod)->set\_value(1,0.0);
   \}   

\end{DoxyCodeInclude}


Finally, we pin the redundant pressure degrees of freedom (see \href{../../../navier_stokes/adaptive_driven_cavity/html/index.html}{\tt another tutorial} for details), and assign the equations numbers.


\begin{DoxyCodeInclude}

  
  \textcolor{comment}{// Pin redudant pressure dofs}
  RefineableNavierStokesEquations<2>::
   pin\_redundant\_nodal\_pressures(mesh\_pt()->element\_pt());
  
  \textcolor{comment}{// Assign equations numbers}
  cout <<\textcolor{stringliteral}{"Number of equations: "} << assign\_eqn\_numbers() << endl;  
 
\} \textcolor{comment}{// end of constructor}

\end{DoxyCodeInclude}




 

\hypertarget{index_after_adapt}{}\section{Actions before adapt}\label{index_after_adapt}
After each adaptation, we unpin and re-\/pin all redundant pressures degrees of freedom (see \href{../../../navier_stokes/adaptive_driven_cavity/html/index.html}{\tt another tutorial} for details). Since the inflow profile is parabolic, it is interpolated correctly from \char`\"{}father\char`\"{} to \char`\"{}son\char`\"{} elements during mesh refinement so no further action is required.


\begin{DoxyCodeInclude}
\textcolor{comment}{//=====actions\_after\_adapt================================================}
\textcolor{comment}{/// Actions after adapt}
\textcolor{comment}{}\textcolor{comment}{//========================================================================}
\textcolor{keyword}{template} <\textcolor{keyword}{class} ELEMENT> 
\textcolor{keywordtype}{void} \hyperlink{classTurekNonFSIProblem_a88ed5ef8b1be34f5176c29ffec20eedd}{TurekNonFSIProblem<ELEMENT>::actions\_after\_adapt}()
\{
 \textcolor{comment}{// Unpin all pressure dofs}
 RefineableNavierStokesEquations<2>::
  unpin\_all\_pressure\_dofs(mesh\_pt()->element\_pt());
 
 \textcolor{comment}{// Pin redundant pressure dofs}
 RefineableNavierStokesEquations<2>::
  pin\_redundant\_nodal\_pressures(mesh\_pt()->element\_pt());
 
\} \textcolor{comment}{// end\_of\_actions\_after\_adapt}

\end{DoxyCodeInclude}




 

\hypertarget{index_timestep}{}\section{Actions before the timestep}\label{index_timestep}
Before each timestep we update the nodal positions in the mesh and re-\/apply the no-\/slip condition at the nodes on mesh boundaries 5 -\/ 7.


\begin{DoxyCodeInclude}
\textcolor{comment}{//==== start\_of\_actions\_before\_implicit\_timestep==========================}
\textcolor{comment}{/// Actions before implicit timestep: Update velocity boundary conditions}
\textcolor{comment}{}\textcolor{comment}{//========================================================================}
\textcolor{keyword}{template} <\textcolor{keyword}{class} ELEMENT> 
\textcolor{keywordtype}{void} \hyperlink{classTurekNonFSIProblem_a29725cde9071c3a83792469787ea6c7d}{TurekNonFSIProblem<ELEMENT>::actions\_before\_implicit\_timestep}
      ()
\{

 \textcolor{comment}{// Update the domain shape}
 mesh\_pt()->node\_update();

 \textcolor{comment}{// Moving leaflet: No slip; this implies that the velocity needs}
 \textcolor{comment}{// to be updated in response to flag motion}
 \textcolor{keywordflow}{for}( \textcolor{keywordtype}{unsigned} ibound=5;ibound<8;ibound++)
  \{
   \textcolor{keywordtype}{unsigned} num\_nod=mesh\_pt()->nboundary\_node(ibound);
   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} inod=0;inod<num\_nod;inod++)
    \{
     \textcolor{comment}{// Which node are we dealing with?}
     Node* node\_pt=mesh\_pt()->boundary\_node\_pt(ibound,inod);
     
     \textcolor{comment}{// Apply no slip}
     FSI\_functions::apply\_no\_slip\_on\_moving\_wall(node\_pt);
    \}
  \}
\} \textcolor{comment}{//end\_of\_actions\_before\_implicit\_timestep}

\end{DoxyCodeInclude}




 

\hypertarget{index_doc}{}\section{Post Processing}\label{index_doc}
The function doc\+\_\+solution(...) documents the results.


\begin{DoxyCodeInclude}
\textcolor{comment}{//==start\_of\_doc\_solution=================================================}
\textcolor{comment}{/// Doc the solution}
\textcolor{comment}{}\textcolor{comment}{//========================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT>
\textcolor{keywordtype}{void} \hyperlink{classTurekNonFSIProblem_a2f129e4eba71784a58b27d846fdc2a61}{TurekNonFSIProblem<ELEMENT>::doc\_solution}(DocInfo& doc\_info)
\{ 

 ofstream some\_file;
 \textcolor{keywordtype}{char} filename[100];

 \textcolor{comment}{// Number of plot points}
 \textcolor{keywordtype}{unsigned} npts;
 npts=5; 

 \textcolor{comment}{// Output solution }
 sprintf(filename,\textcolor{stringliteral}{"%s/soln%i.dat"},doc\_info.directory().c\_str(),
         doc\_info.number());
 some\_file.open(filename);
 mesh\_pt()->output(some\_file,npts);
 some\_file.close();

\} \textcolor{comment}{// end\_of\_doc\_solution}

\end{DoxyCodeInclude}




 

\hypertarget{index_ex_com}{}\section{Comments and Exercises}\label{index_ex_com}

\begin{DoxyItemize}
\item Compare the results obtained when the node update is performed with the algebraic or the {\ttfamily Macro\+Element/\+Domain-\/based} node update. ({\ttfamily oomph-\/lib\textquotesingle{}s} build machinery will automatically generate both versions of the code, using the {\ttfamily -\/\+D\+U\+S\+E\+\_\+\+M\+A\+C\+R\+O\+\_\+\+E\+L\+E\+M\+E\+N\+TS} compilation flag).
\end{DoxyItemize}



 

\hypertarget{index_ackn}{}\section{Acknowledgements}\label{index_ackn}

\begin{DoxyItemize}
\item This code was originally developed by Stefan Kollmannsberger and his students Iason Papaioannou and Orkun Oezkan Doenmez. It was completed by Floraine Cordier.
\end{DoxyItemize}



 

\hypertarget{index_sources}{}\section{Source files for this tutorial}\label{index_sources}

\begin{DoxyItemize}
\item The source files for this tutorial are located in the directory\+:~\newline
~\newline
\begin{center} \href{
../../../../
demo_drivers/navier_stokes/turek_flag_non_fsi/
}{\tt demo\+\_\+drivers/navier\+\_\+stokes/turek\+\_\+flag\+\_\+non\+\_\+fsi/ } \end{center} ~\newline

\item The driver code is\+: ~\newline
~\newline
\begin{center} \href{
../../../../
demo_drivers/navier_stokes/turek_flag_non_fsi/turek_flag_non_fsi.cc
}{\tt demo\+\_\+drivers/navier\+\_\+stokes/turek\+\_\+flag\+\_\+non\+\_\+fsi/turek\+\_\+flag\+\_\+non\+\_\+fsi.\+cc } \end{center} 
\end{DoxyItemize}

 

 \hypertarget{index_pdf}{}\section{P\+D\+F file}\label{index_pdf}
A \href{../latex/refman.pdf}{\tt pdf version} of this document is available. \end{document}
