In this example we demonstrate the solution of the 2D linear wave equation -- a hyperbolic P\+DE that involves second time-\/derivatives. Timestepping of such problems may be performed with timesteppers from the {\ttfamily Newmark} family. We demonstrate their use and illustrate how to assign the initial conditions.



 

\hypertarget{index_example_problem}{}\section{The example problem}\label{index_example_problem}
We shall illustrate the timestepping procedures for hyperbolic problems by considering the solution of the 2D linear wave equation in a rectangular domain\+:

\begin{center} \tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*{1}{|X[-1]}|}
\hline
\begin{center} {\bfseries The two-\/dimensional linear wave equation in a rectangular domain.} \end{center}  Solve \[ \sum_{i=1}^2\frac{\partial^2 u}{\partial x_i^2} = \frac{\partial^2 u}{\partial t^2} + f\left(x_1,x_2,t\right), \ \ \ \ \ \ \ \ \ \ (1) \] in the rectangular domain $ D = \left\{ (x_1,x_2) \ \bigg| \ x_1 \in [0,1],\ x_2 \in [0,2] \right\} $, subject to the Dirichlet boundary conditions \[ \left. u\right|_{\partial D}=g_0 \ \ \ \ \ \ \ \ \ \ (2) \] and the initial conditions \[ u(x_1,x_2,t=0)=h_0(x_1,x_2), \ \ \ \ \ \ \ \ \ \ (3) \] and \[ \left. \frac{\partial u}{\partial t}\right|_{t=0}=k_0(x_1,x_2), \ \ \ \ \ \ \ \ \ \ (4) \] where the functions $ g_0, h_0$ and $ k_0 $ are given.   \\\cline{1-1}
\end{longtabu}
\end{center} 

Here we consider the unforced case, $ f=0 $, and choose boundary and initial conditions that are consistent with the exact, travelling-\/wave solution \[ u_0(x_1,x_2,t) = \tanh\left(1-\alpha\left(\zeta-t\right)\right), \ \ \ \ \ \ \ \ \ \ (5) \] where \[ \zeta=\cos\left(\phi\right)x_1+\sin\left(\phi\right)x_2, \ \ \ \ \ \ \ \ \ \ (6) \] is the travelling-\/wave coordinate. The solution represents a tanh step profile that propagates with unit speed through the domain. The parameter $ \alpha $ controls the steepness of the step while $ \phi $ controls the orientation of the step in the $ (x_1,x_2) $ -\/ plane.

The figure below shows a plot of computed and exact solutions at time $ t = 0.25 $, for a steepness parameter $ \alpha=4 $, and an angle $ \phi=\pi/6 $ . The plot is a snapshot, taken from the \href{../figures/wave_sol.avi}{\tt animation of the solution}.

 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{wave_sol}
\doxyfigcaption{Snapshot of the exact and computed solutions. }
\end{DoxyImage}




 

\hypertarget{index_namespace}{}\section{Global parameters and functions}\label{index_namespace}
As usual, we store the problem parameters in a namespace. Note that we define not only the exact solution but also its first and second time-\/derivatives, as both are needed to assign the initial conditions for the Newmark timestepper; see \hyperlink{index_IC}{Setting the initial conditions for Newmark timesteppers} for details.

 
\begin{DoxyCodeInclude}
\textcolor{comment}{//==start\_of\_tanh\_solution============================================}
\textcolor{comment}{/// Namespace for exact solution for LinearWave equation }
\textcolor{comment}{}\textcolor{comment}{/// with sharp step }
\textcolor{comment}{}\textcolor{comment}{//====================================================================}
\textcolor{keyword}{namespace }\hyperlink{namespaceTanhSolnForLinearWave}{TanhSolnForLinearWave}
\{
\textcolor{comment}{}
\textcolor{comment}{ /// Parameter for steepness of step}
\textcolor{comment}{} \textcolor{keywordtype}{double} \hyperlink{namespaceTanhSolnForLinearWave_a48021142056bdea20e6432e360fd0314}{Alpha};
\textcolor{comment}{}
\textcolor{comment}{ /// Orientation of step wave}
\textcolor{comment}{} \textcolor{keywordtype}{double} \hyperlink{namespaceTanhSolnForLinearWave_a5242d421b567b803323bc127081351a6}{Phi};
\textcolor{comment}{}
\textcolor{comment}{ /// Exact solution}
\textcolor{comment}{} \textcolor{keywordtype}{double} \hyperlink{namespaceTanhSolnForLinearWave_aceea2935b2d3815ce72aae8c9de2b468}{exact\_u}(\textcolor{keyword}{const} \textcolor{keywordtype}{double}& time, \textcolor{keyword}{const} Vector<double>& x)
 \{
  \textcolor{keywordtype}{double} zeta=cos(Phi)*x[0]+sin(Phi)*x[1];
  \textcolor{keywordflow}{return} tanh(1.0-Alpha*(zeta-time));
 \}
 \textcolor{comment}{}
\textcolor{comment}{ /// 1st time-deriv of exact solution}
\textcolor{comment}{} \textcolor{keywordtype}{double} \hyperlink{namespaceTanhSolnForLinearWave_aa2081bd3d3d518a38497f664b0e498bc}{exact\_dudt}(\textcolor{keyword}{const} \textcolor{keywordtype}{double}& time, \textcolor{keyword}{const} Vector<double>& x)
 \{
  \textcolor{keywordtype}{double} zeta=cos(Phi)*x[0]+sin(Phi)*x[1];
  \textcolor{keywordflow}{return} Alpha/(cosh(1.0-Alpha*(zeta-time))*
              cosh(1.0-Alpha*(zeta-time)));
 \}
\textcolor{comment}{}
\textcolor{comment}{ /// 2nd time-deriv of exact solution}
\textcolor{comment}{} \textcolor{keywordtype}{double} \hyperlink{namespaceTanhSolnForLinearWave_a63b7a0f5fd5d06cc2c0a43322a81fe43}{exact\_d2udt2}(\textcolor{keyword}{const} \textcolor{keywordtype}{double}& time, \textcolor{keyword}{const} Vector<double>& x)
 \{
  \textcolor{keywordtype}{double} zeta=cos(Phi)*x[0]+sin(Phi)*x[1];
  \textcolor{keywordflow}{return} -2.0*Alpha*Alpha*tanh(1.0-Alpha*(zeta-time))/
   (cosh(1.0-Alpha*(zeta-time))*cosh(1.0-Alpha*(zeta-time)));
 \}

\textcolor{comment}{}
\textcolor{comment}{ /// Exact solution as a vector}
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{namespaceTanhSolnForLinearWave_a7dd7e9f155d19f871ba87d3fe41fd8e9}{get\_exact\_u}(\textcolor{keyword}{const} \textcolor{keywordtype}{double}& time, \textcolor{keyword}{const} Vector<double>& x, 
                  Vector<double>& u)
 \{
  u[0]=\hyperlink{namespaceTanhSolnForLinearWave_aceea2935b2d3815ce72aae8c9de2b468}{exact\_u}(time,x);
  u[1]=\hyperlink{namespaceTanhSolnForLinearWave_aa2081bd3d3d518a38497f664b0e498bc}{exact\_dudt}(time,x);
  u[2]=\hyperlink{namespaceTanhSolnForLinearWave_a63b7a0f5fd5d06cc2c0a43322a81fe43}{exact\_d2udt2}(time,x);
 \}
\textcolor{comment}{}
\textcolor{comment}{ /// Source function to make it an exact solution }
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{namespaceTanhSolnForLinearWave_a3bc9643b40e62283dc09f405ed17c805}{get\_source}(\textcolor{keyword}{const} \textcolor{keywordtype}{double}& time, \textcolor{keyword}{const} Vector<double>& x, \textcolor{keywordtype}{double}& source)
 \{
  source=0.0;
 \}

\} \textcolor{comment}{// end of tanh solution}

\end{DoxyCodeInclude}




 

\hypertarget{index_main}{}\section{The driver code}\label{index_main}
As in most previous time-\/dependent example codes, we use the command line arguments as flags that indicate if the code is run in validation mode -- if command line arguments are specified, the code will only perform a small number of timesteps.


\begin{DoxyCodeInclude}
\textcolor{comment}{//===start\_of\_main========================================================}
\textcolor{comment}{/// Demonstrate how to solve LinearWave problem.}
\textcolor{comment}{}\textcolor{comment}{//========================================================================}
\textcolor{keywordtype}{int} \hyperlink{two__d__linear__wave_8cc_a0ddf1224851353fc92bfbff6f499fa97}{main}(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char}* argv[])
\{

 \textcolor{comment}{// Store command line arguments: If a command line argument is specied}
 \textcolor{comment}{// we regard this as validation run.}
 CommandLineArgs::setup(argc,argv);

\end{DoxyCodeInclude}


We build the problem with 2D bi-\/quadratic {\ttfamily Q\+Linear\+Wave\+Elements} and a {\ttfamily Newmark$<$1$>$} timestepper (see \hyperlink{index_IC}{Setting the initial conditions for Newmark timesteppers} for an explanation of the template argument), passing the number of elements, and the pointer to the source function to the constructor, and run the time time-\/dependent simulation. We solve the problem twice, once with an impulsive start and once a with \char`\"{}smooth\char`\"{} start from the travelling-\/wave solution (5).


\begin{DoxyCodeInclude}
 
 \textcolor{comment}{// Number of elements in x direction}
 \textcolor{keywordtype}{unsigned} n\_x=10;

 \textcolor{comment}{// Number of elements in y direction}
 \textcolor{keywordtype}{unsigned} n\_y=20;

 \textcolor{comment}{// Impulsive start?}
 \textcolor{keywordtype}{bool} impulsive\_start;

 \textcolor{comment}{// Run with impulsive start}
 \textcolor{comment}{// ------------------------}
 \{
  impulsive\_start=\textcolor{keyword}{true};

  \textcolor{comment}{// Build problem}
  \hyperlink{classLinearWaveProblem}{LinearWaveProblem<QLinearWaveElement<2,3>}, Newmark<1> >
   problem(n\_x,n\_y,impulsive\_start,&\hyperlink{namespaceTanhSolnForLinearWave_a3bc9643b40e62283dc09f405ed17c805}{TanhSolnForLinearWave::get\_source});
  
  \textcolor{comment}{// Run it}
  problem.unsteady\_run();
 \}

 \textcolor{comment}{// Run with "smooth" start}
 \textcolor{comment}{// -----------------------}
 \{
  impulsive\_start=\textcolor{keyword}{false};

  \textcolor{comment}{// Build problem}
  \hyperlink{classLinearWaveProblem}{LinearWaveProblem<QLinearWaveElement<2,3>}, Newmark<1> >
   problem(n\_x,n\_y,impulsive\_start,&\hyperlink{namespaceTanhSolnForLinearWave_a3bc9643b40e62283dc09f405ed17c805}{TanhSolnForLinearWave::get\_source});
  
  \textcolor{comment}{// Run it}
  problem.unsteady\_run();
 \}


\}; \textcolor{comment}{// end of main}

\end{DoxyCodeInclude}




 

\hypertarget{index_problem}{}\section{The problem class}\label{index_problem}
The problem class is practically identical to that used for \href{../../../unsteady_heat/two_d_unsteady_heat/html/index.html}{\tt the corresponding unsteady heat problem}. No actions are required before or after the solve but the time-\/dependent boundary conditions must be updated before every timestep.

 
\begin{DoxyCodeInclude}
\textcolor{comment}{//===start\_of\_problem\_class===========================================}
\textcolor{comment}{/// LinearWave problem in rectanglular domain}
\textcolor{comment}{}\textcolor{comment}{//====================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT, \textcolor{keyword}{class} TIMESTEPPER>
\textcolor{keyword}{class }\hyperlink{classLinearWaveProblem}{LinearWaveProblem} : \textcolor{keyword}{public} Problem
\{

\textcolor{keyword}{public}:
\textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Constructor: pass number of elements in x and y directions,}
\textcolor{comment}{ /// bool indicating impulsive or "smooth" start,}
\textcolor{comment}{ /// and pointer to source function}
\textcolor{comment}{} \hyperlink{classLinearWaveProblem_a459a58b7afd588cfa78a5e1e98c3c41e}{LinearWaveProblem}(\textcolor{keyword}{const} \textcolor{keywordtype}{unsigned}& nx, \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned}& ny, 
                   \textcolor{keyword}{const} \textcolor{keywordtype}{bool}& impulsive\_start,
                   LinearWaveEquations<2>::LinearWaveSourceFctPt source\_fct\_pt);
\textcolor{comment}{}
\textcolor{comment}{ /// Destructor (empty) }
\textcolor{comment}{} \hyperlink{classLinearWaveProblem_af1f3879114813b0acdfd2567c5c7b1e9}{~LinearWaveProblem}() \{\}
\textcolor{comment}{}
\textcolor{comment}{ /// Update the problem specs after solve (empty)}
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{classLinearWaveProblem_a5b45c619af141b19162f990a95490e80}{actions\_after\_newton\_solve}() \{\}
\textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Update the problem specs before solve (empty)}
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{classLinearWaveProblem_a66e87510f6fa8af693cede514cb7a62e}{actions\_before\_newton\_solve}() \{\}
\textcolor{comment}{}
\textcolor{comment}{ /// Update the problem specs after solve (empty)}
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{classLinearWaveProblem_a521290f43f9aac37c9604e744fa71075}{actions\_after\_implicit\_timestep}() \{\}
\textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Update the problem specs before next timestep: }
\textcolor{comment}{ /// Set time-dependent Dirchlet boundary from exact solution.}
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{classLinearWaveProblem_a39cfcb8ce06463ace1ac09fa43afa00a}{actions\_before\_implicit\_timestep}()
  \{
   Vector<typename TIMESTEPPER::NodeInitialConditionFctPt> 
    initial\_value\_fct(1);
   Vector<typename TIMESTEPPER::NodeInitialConditionFctPt>
    initial\_veloc\_fct(1);
   Vector<typename TIMESTEPPER::NodeInitialConditionFctPt> 
    initial\_accel\_fct(1);
   
   \textcolor{comment}{// Assign values for analytical value, veloc and accel:}
   initial\_value\_fct[0]=&\hyperlink{namespaceTanhSolnForLinearWave_aceea2935b2d3815ce72aae8c9de2b468}{TanhSolnForLinearWave::exact\_u};
   initial\_veloc\_fct[0]=&\hyperlink{namespaceTanhSolnForLinearWave_aa2081bd3d3d518a38497f664b0e498bc}{TanhSolnForLinearWave::exact\_dudt};
   initial\_accel\_fct[0]=&\hyperlink{namespaceTanhSolnForLinearWave_a63b7a0f5fd5d06cc2c0a43322a81fe43}{TanhSolnForLinearWave::exact\_d2udt2};
   
   \textcolor{comment}{// Loop over boundaries}
   \textcolor{keywordtype}{unsigned} num\_bound=mesh\_pt()->nboundary();
   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} ibound=0;ibound<num\_bound;ibound++)
    \{
     \textcolor{comment}{// Loop over boundary nodes}
     \textcolor{keywordtype}{unsigned} num\_nod=mesh\_pt()->nboundary\_node(ibound);
     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} inod=0;inod<num\_nod;inod++)
      \{
       \textcolor{comment}{// Set the boundary condition from the exact solution}
       Node* nod\_pt=mesh\_pt()->boundary\_node\_pt(ibound,inod);

       \textcolor{keywordtype}{bool} use\_direct\_assignment=\textcolor{keyword}{false};
       \textcolor{keywordflow}{if} (use\_direct\_assignment)
        \{
         \textcolor{comment}{// Set nodal coordinates for evaluation of BC:}
         Vector<double> x(2);
         x[0]=nod\_pt->x(0);
         x[1]=nod\_pt->x(1);
         
         \textcolor{comment}{// Set exact solution at current time}
         nod\_pt->set\_value(0,
                           \hyperlink{namespaceTanhSolnForLinearWave_aceea2935b2d3815ce72aae8c9de2b468}{TanhSolnForLinearWave::exact\_u}(time\_pt()->time(),x
      ));
        \}
       \textcolor{keywordflow}{else}
        \{
         \textcolor{comment}{// Get timestepper}
         TIMESTEPPER* timestepper\_pt=\textcolor{keyword}{dynamic\_cast<}TIMESTEPPER*\textcolor{keyword}{>}
          (time\_stepper\_pt());
         
         \textcolor{comment}{// Assign the history values}
         timestepper\_pt->assign\_initial\_data\_values(nod\_pt, 
                                                    initial\_value\_fct,
                                                    initial\_veloc\_fct,
                                                    initial\_accel\_fct);
        \}
      \}
    \}
  \} \textcolor{comment}{// end of actions before timestep}
\textcolor{comment}{}
\textcolor{comment}{ ///  Set initial condition (incl history values)}
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{classLinearWaveProblem_afb5d327791d8289a8a0a565afc8aee37}{set\_initial\_condition}();
\textcolor{comment}{}
\textcolor{comment}{ /// Doc the solution}
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{classLinearWaveProblem_a6d9396a693be0479ece9ac1f14f9233a}{doc\_solution}(DocInfo& doc\_info);
\textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Do unsteady run }
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{classLinearWaveProblem_a9993365201bfffcc04dd2034f0d3d391}{unsteady\_run}();

\textcolor{keyword}{private}:

 \textcolor{comment}{// Trace file}
 ofstream \hyperlink{classLinearWaveProblem_ac75d13211cfb08c7cfba0ea129711a09}{Trace\_file};

 \textcolor{comment}{// Impulsive start?}
 \textcolor{keywordtype}{bool} \hyperlink{classLinearWaveProblem_a296c67402f065a1a3776064492003670}{Impulsive\_start};

\}; \textcolor{comment}{// end of problem class}

\end{DoxyCodeInclude}




 

\hypertarget{index_constructor}{}\section{The problem constructor}\label{index_constructor}
The problem constructor is also fairly standard\+: We start by creating the timestepper (of the type specified by the template argument), pass it to the Problem\textquotesingle{}s collection of timesteppers, and initialise the parameters for the exact solution.


\begin{DoxyCodeInclude}
\textcolor{comment}{//===start\_of\_constructor=================================================}
\textcolor{comment}{/// Constructor for LinearWave problem }
\textcolor{comment}{}\textcolor{comment}{//========================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT, \textcolor{keyword}{class} TIMESTEPPER>
\hyperlink{classLinearWaveProblem_a459a58b7afd588cfa78a5e1e98c3c41e}{LinearWaveProblem<ELEMENT,TIMESTEPPER>::LinearWaveProblem}
      (
 \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned}& nx, \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned}& ny, \textcolor{keyword}{const} \textcolor{keywordtype}{bool}& impulsive\_start, 
 LinearWaveEquations<2>::LinearWaveSourceFctPt source\_fct\_pt) :
 Impulsive\_start(impulsive\_start)
\{ 

 \textcolor{comment}{//Allocate the timestepper -- this constructs the time object as well}
 add\_time\_stepper\_pt(\textcolor{keyword}{new} TIMESTEPPER());

 \textcolor{comment}{// Set up parameters for exact solution}
 \textcolor{comment}{//-------------------------------------}

 \textcolor{comment}{// Steepness of tanh profile}
 \hyperlink{namespaceTanhSolnForLinearWave_a48021142056bdea20e6432e360fd0314}{TanhSolnForLinearWave::Alpha}=4.0;

 \textcolor{comment}{// Orientation of step wave}
 \hyperlink{namespaceTanhSolnForLinearWave_a5242d421b567b803323bc127081351a6}{TanhSolnForLinearWave::Phi}=MathematicalConstants::Pi/180.0*30.0;

\end{DoxyCodeInclude}


Next, we build the mesh and pin the nodal values on the Dirichlet boundaries (i.\+e. at all boundary nodes). \href{../../../unsteady_heat/two_d_unsteady_heat/html/index.html}{\tt Recall} that the pointer to the timestepper must be passed the mesh constructor to allow the creation of {\ttfamily Nodes} that provide sufficient storage for the \char`\"{}history values\char`\"{} required by the timestepper.


\begin{DoxyCodeInclude}

 \textcolor{comment}{// Set up mesh}
 \textcolor{comment}{//------------}

 \textcolor{comment}{// # of elements in x-direction}
 \textcolor{keywordtype}{unsigned} Nx=nx;

 \textcolor{comment}{// # of elements in y-direction}
 \textcolor{keywordtype}{unsigned} Ny=ny;

 \textcolor{comment}{// Domain length in x-direction}
 \textcolor{keywordtype}{double} Lx=1.0;

 \textcolor{comment}{// Domain length in y-direction}
 \textcolor{keywordtype}{double} Ly=2.0;

 \textcolor{comment}{// Build and assign mesh}
 Problem::mesh\_pt()=\textcolor{keyword}{new} RectangularQuadMesh<ELEMENT>(
  Nx,Ny,Lx,Ly,time\_stepper\_pt());

 \textcolor{comment}{// Set the boundary conditions for this problem: All nodes are}
 \textcolor{comment}{// free by default -- just pin the ones that have Dirichlet conditions}
 \textcolor{comment}{// here. }
 \textcolor{keywordtype}{unsigned} num\_bound = mesh\_pt()->nboundary();
 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} ibound=0;ibound<num\_bound;ibound++)
  \{
   \textcolor{keywordtype}{unsigned} num\_nod= mesh\_pt()->nboundary\_node(ibound);
   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} inod=0;inod<num\_nod;inod++)
    \{
     mesh\_pt()->boundary\_node\_pt(ibound,inod)->pin(0); 
    \}
  \} \textcolor{comment}{//end of boundary conditions}

\end{DoxyCodeInclude}


Finally, we complete the build of the elements by passing the pointer to the source function to the elements, and set up the equation numbering scheme.


\begin{DoxyCodeInclude}

 \textcolor{comment}{// Complete build of elements}
 \textcolor{comment}{// --------------------------}

 \textcolor{comment}{// Loop over the elements to set up element-specific }
 \textcolor{comment}{// things that cannot be handled by constructor }
\textcolor{keywordtype}{unsigned} n\_element = mesh\_pt()->nelement();
\textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} i=0;i<n\_element;i++)
  \{
   \textcolor{comment}{// Upcast from GeneralisedElement to the present element}
   ELEMENT *el\_pt = \textcolor{keyword}{dynamic\_cast<}ELEMENT*\textcolor{keyword}{>}(mesh\_pt()->element\_pt(i));

   \textcolor{comment}{//Set the source function pointer}
   el\_pt->source\_fct\_pt() = source\_fct\_pt;
  \}

 \textcolor{comment}{// Setup equation numbering scheme}
 cout <<\textcolor{stringliteral}{"Number of equations: "} << assign\_eqn\_numbers() << std::endl; 

\} \textcolor{comment}{// end of constructor}

\end{DoxyCodeInclude}




 

\hypertarget{index_IC}{}\section{Setting the initial conditions for Newmark timesteppers}\label{index_IC}
Most of the code discussed so far was (and most of what follows is) practically identical to that in \href{../../../unsteady_heat/two_d_unsteady_heat/html/index.html}{\tt the corresponding unsteady heat example}. The main difference between the two example codes is the way in which the initial conditions are applied. This is closely related to the different role of the \char`\"{}history values\char`\"{} in {\ttfamily B\+DF} and {\ttfamily Newmark} timestepping schemes\+:



\hypertarget{index_BDFvsNewmark}{}\subsection{The interpretation of history values in B\+D\+F and Newmark timesteppers}\label{index_BDFvsNewmark}
In problems in which first time-\/derivatives are discretised by {\ttfamily B\+DF} timesteppers, the \char`\"{}history values\char`\"{} represent the values of the solution at previous timesteps, i.\+e. for a {\ttfamily Data} object that is associated with a timestepper from the {\ttfamily B\+DF} family, {\ttfamily Data\+::value(t,i)} returns the i-\/th value stored in the {\ttfamily Data} object, at the t-\/th previous timestep. We recall that when assigning initial conditions for computations with higher-\/order timesteppers from the {\ttfamily B\+DF} family, the number of (mathematical) initial conditions (the solution at the intial time, $ t=t_0 $ , say) is {\itshape smaller} than the number of \char`\"{}history values\char`\"{} required by the timestepper. For instance, a computation with a {\ttfamily B\+D\+F$<$2$>$} timestepper and a timestep {\ttfamily dt} not only requires the solution at $ t=t_0 $ but also the solution at $ t=t_0- {\tt dt} $ . In most of our examples, this did not cause any problems. We either started the simulation with an \char`\"{}impulsive start\char`\"{} by setting {\itshape all} history values to the solution at $ t=t_0 $ , or we assigned the history values from an explicitly-\/given function (usually an exact solution of the governing equations), in which case the evaluation of the history values at previous timesteps was trivial.

Timesteppers from the {\ttfamily Newmark} family compute second-\/order accurate approximations for the first and second time-\/derivatives of the values stored in an associated {\ttfamily Data} object. {\ttfamily Newmark} timesteppers are implicit, single-\/step schemes since the approximation of the time-\/derivatives only involves quantities evaluated at the current time (where the solution is unknown) and at a single previous timestep. To facilitate their application in multiphysics problems where parts of a {\ttfamily Problem} might be discretised by timesteppers from the {\ttfamily B\+DF} family, say, {\ttfamily Newmark} timesteppers can allocate additional storage for the solution at the previous {\ttfamily N\+S\+T\+E\+PS} timesteps. These history values are stored in the {\ttfamily Data} objects and are updated by the timestepper when the solution is advanced to the next time level, but they are not used in the computation of the time-\/derivatives.

For a {\ttfamily Data} object that is associated with a {\ttfamily Newmark$<$\+N\+S\+T\+E\+P\+S$>$} timestepper, the history value obtained from {\ttfamily Data\+::value(t,i)} may be interpreted as follows\+:
\begin{DoxyItemize}
\item t=0\+: The i-\/th value at at present time, {\ttfamily Time\+\_\+pt-\/$>$time()} 
\item t=1\+: The i-\/th value at the previous timestep, {\ttfamily Time\+\_\+pt-\/$>$time()-\/dt} 
\item ...
\item t=N\+S\+T\+E\+PS\+: The i-\/th value at the N\+S\+T\+E\+P\+S-\/th previous timestep, i.\+e. at {\ttfamily Time\+\_\+pt-\/$>$time()-\/\+N\+S\+T\+E\+P\+S$\ast$dt} if the timestep dt was kept constant.
\item t=N\+S\+T\+E\+P\+S+1\+: The 1st time derivative (= \char`\"{}the velocity\char`\"{}) of the i-\/th value at the previous timestep, {\ttfamily Time\+\_\+pt-\/$>$time()-\/dt} 
\item t=N\+S\+T\+E\+P\+S+2\+: The 2nd time derivative (= \char`\"{}the acceleration\char`\"{}) of the i-\/th value at the previous timestep, {\ttfamily Time\+\_\+pt-\/$>$time()-\/dt}.
\end{DoxyItemize}The {\ttfamily Newmark$<$1$>$} timestepper is equivalent to the classical Newmark scheme.



\hypertarget{index_ic_for_newmark}{}\subsection{Assigning the history values for Newmark timesteppers}\label{index_ic_for_newmark}
The {\ttfamily Newmark} timestepper provides a number of helper functions that facilitate the assignment of \char`\"{}history values\char`\"{}.
\begin{DoxyEnumerate}
\item {\bfseries Impulsive starts\+: } ~\newline
~\newline
 Given a pointer, {\ttfamily data\+\_\+pt}, to a {\ttfamily Data} object, the function {\ttfamily Newmark$<$\+N\+S\+T\+E\+P\+S$>$\+::assign\+\_\+initial\+\_\+values\+\_\+impulsive(data\+\_\+pt)} assigns history values that are consistent with an impulsive start from the {\ttfamily Data} object\textquotesingle{}s current values.
\item {\bfseries \char`\"{}\+Smooth\char`\"{} starts from explicitly given time-\/histories\+: } ~\newline
~\newline
 If the solution $ u $ and its first {\itshape and} second time-\/derivatives are available analytically for $ t \le t_0$, the function {\ttfamily Newmark$<$\+N\+S\+T\+E\+P\+S$>$\+::assign\+\_\+initial\+\_\+data\+\_\+values}(...) may be used to assign history values that are consistent with this time history. Note that, as in the case of the higher-\/order {\ttfamily B\+DF} timesteppers, we require more information than is provided by the (mathematical) initial conditions which only provide the value and the first time-\/derivative of the unknown function at the initial time.
\end{DoxyEnumerate}

\hypertarget{index_implement_ic}{}\subsection{Implementation in the demo code}\label{index_implement_ic}
The function {\ttfamily set\+\_\+initial\+\_\+condition()} demonstrates the use of these functions in our example problem. The assignment of the \char`\"{}history values\char`\"{} for the nodal {\ttfamily Data} is handled by the timestepper, a pointer to which can be obtained from the {\ttfamily Problem\+:} 


\begin{DoxyCodeInclude}
\textcolor{comment}{//===start\_of\_set\_initial\_condition=======================================}
\textcolor{comment}{/// Set initial condition.}
\textcolor{comment}{}\textcolor{comment}{//========================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT, \textcolor{keyword}{class} TIMESTEPPER>
\textcolor{keywordtype}{void} \hyperlink{classLinearWaveProblem_afb5d327791d8289a8a0a565afc8aee37}{LinearWaveProblem<ELEMENT,TIMESTEPPER>::set\_initial\_condition}
      ()
\{ 

 \textcolor{comment}{// Get timestepper}
 TIMESTEPPER* timestepper\_pt=\textcolor{keyword}{dynamic\_cast<}TIMESTEPPER*\textcolor{keyword}{>}(time\_stepper\_pt());

\end{DoxyCodeInclude}


To start the simulation with an impulsive start from the travelling-\/wave solution, defined in the namespace {\ttfamily \hyperlink{namespaceTanhSolnForLinearWave}{Tanh\+Soln\+For\+Linear\+Wave}}, we loop over all nodes and determine their positions. We then compute the value of the exact solution at that point and assign it to the current nodal value. \char`\"{}\+History values\char`\"{} that correspond to an impulsive start from this value are then assigned by calling {\ttfamily Newmark$<$\+N\+S\+T\+E\+P\+S$>$\+::assign\+\_\+initial\+\_\+values\+\_\+impulsive}(...).


\begin{DoxyCodeInclude}


 \textcolor{comment}{// Impulsive start}
 \textcolor{comment}{//----------------}
 \textcolor{keywordflow}{if} (Impulsive\_start)
  \{
   \textcolor{comment}{// Loop over the nodes to set initial conditions everywhere}
   \textcolor{keywordtype}{unsigned} num\_nod=mesh\_pt()->nnode();
   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} jnod=0;jnod<num\_nod;jnod++)
    \{
     \textcolor{comment}{// Pointer to node}
     Node* nod\_pt=mesh\_pt()->node\_pt(jnod);

     \textcolor{comment}{// Get nodal coordinates}
     Vector<double> x(2);
     x[0]=nod\_pt->x(0);
     x[1]=nod\_pt->x(1);

     \textcolor{comment}{// Assign initial value from exact solution}
     nod\_pt->set\_value(0,\hyperlink{namespaceTanhSolnForLinearWave_aceea2935b2d3815ce72aae8c9de2b468}{TanhSolnForLinearWave::exact\_u}(time\_pt()->time(),x))
      ;

     \textcolor{comment}{// Set history values so that they are consistent with an impulsive}
     \textcolor{comment}{// start from this value}
     timestepper\_pt->assign\_initial\_values\_impulsive(nod\_pt);
    \}
  \} \textcolor{comment}{// end impulsive start}

\end{DoxyCodeInclude}


To start the simulation with a \char`\"{}smooth\char`\"{} start from the travelling-\/wave solution we have to pass function pointers to the functions that specify the function and its first and second time-\/derivatives to {\ttfamily Newmark$<$\+N\+S\+T\+E\+P\+S$>$\+::assign\+\_\+initial\+\_\+data\+\_\+values}(...). As usual, the required form of the function pointer is defined as a public {\ttfamily typedef} in the Newmark class. Since {\ttfamily Data} objects can store multiple values, each of which will generally have a different time-\/history, {\ttfamily Newmark$<$\+N\+S\+T\+E\+P\+S$>$\+::assign\+\_\+initial\+\_\+data\+\_\+values}(...) expects a vector of function pointers. In the current example where each node only stores a single value, these vectors only have a single entry.


\begin{DoxyCodeInclude}

 \textcolor{comment}{// "Smooth" start from analytical time history}
 \textcolor{comment}{//--------------------------------------------}
 \textcolor{keywordflow}{else}
  \{

   \textcolor{comment}{// Vector of function pointers to functions that specify the}
   \textcolor{comment}{// value, and the first and second time-derivatives of the}
   \textcolor{comment}{// function used as the initial condition}
   Vector<typename TIMESTEPPER::NodeInitialConditionFctPt> 
    initial\_value\_fct(1);
   Vector<typename TIMESTEPPER::NodeInitialConditionFctPt>
    initial\_veloc\_fct(1);
   Vector<typename TIMESTEPPER::NodeInitialConditionFctPt> 
    initial\_accel\_fct(1);
   
   \textcolor{comment}{// Assign values for analytical value, veloc and accel:}
   initial\_value\_fct[0]=&\hyperlink{namespaceTanhSolnForLinearWave_aceea2935b2d3815ce72aae8c9de2b468}{TanhSolnForLinearWave::exact\_u};
   initial\_veloc\_fct[0]=&\hyperlink{namespaceTanhSolnForLinearWave_aa2081bd3d3d518a38497f664b0e498bc}{TanhSolnForLinearWave::exact\_dudt};
   initial\_accel\_fct[0]=&\hyperlink{namespaceTanhSolnForLinearWave_a63b7a0f5fd5d06cc2c0a43322a81fe43}{TanhSolnForLinearWave::exact\_d2udt2};

\end{DoxyCodeInclude}


Now we loop over all nodes and pass the vectors of function pointers to {\ttfamily Newmark$<$\+N\+S\+T\+E\+P\+S$>$\+::assign\+\_\+initial\+\_\+data\+\_\+values}(...) to assign the required history values.


\begin{DoxyCodeInclude}
   
   \textcolor{comment}{// Assign Newmark history values so that Newmark approximations}
   \textcolor{comment}{// for velocity and accel are correct at initial time:}

   \textcolor{comment}{// Loop over the nodes to set initial conditions everywhere}
   \textcolor{keywordtype}{unsigned} num\_nod=mesh\_pt()->nnode();
   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} jnod=0;jnod<num\_nod;jnod++)
    \{
     \textcolor{comment}{// Pointer to node}
     Node* nod\_pt=mesh\_pt()->node\_pt(jnod);
    
     \textcolor{comment}{// Assign the history values}
     timestepper\_pt->assign\_initial\_data\_values(nod\_pt, 
                                                initial\_value\_fct,
                                                initial\_veloc\_fct,
                                                initial\_accel\_fct);
    \} \textcolor{comment}{// end of smooth start}

\end{DoxyCodeInclude}


To check/demonstrate that the assignment of the initial condition was successful, we compare the Newmark approximation for the zero-\/th, first and second time-\/derivatives of the nodal values against the exact solution and document the maximum discrepancy.


\begin{DoxyCodeInclude}


   \textcolor{comment}{// Paranoia: Check that the initial values were assigned correctly}
   \textcolor{keywordtype}{double} err\_max=0.0;
   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} jnod=0;jnod<num\_nod;jnod++)
    \{
     \textcolor{comment}{// Pointer to node}
     Node* nod\_pt=mesh\_pt()->node\_pt(jnod);

     \textcolor{comment}{// Get nodal coordinates}
     Vector<double> x(2);
     x[0]=nod\_pt->x(0);
     x[1]=nod\_pt->x(1);

     \textcolor{comment}{// Get exact value and first and second time-derivatives}
     \textcolor{keywordtype}{double} u\_exact=
      \hyperlink{namespaceTanhSolnForLinearWave_aceea2935b2d3815ce72aae8c9de2b468}{TanhSolnForLinearWave::exact\_u}(time\_pt()->time(),x);
     \textcolor{keywordtype}{double} dudt\_exact=
      \hyperlink{namespaceTanhSolnForLinearWave_aa2081bd3d3d518a38497f664b0e498bc}{TanhSolnForLinearWave::exact\_dudt}(time\_pt()->time(),x);
     \textcolor{keywordtype}{double} d2udt2\_exact=
      \hyperlink{namespaceTanhSolnForLinearWave_a63b7a0f5fd5d06cc2c0a43322a81fe43}{TanhSolnForLinearWave::exact\_d2udt2}(time\_pt()->time(),x);
    
     \textcolor{comment}{// Get Newmark approximations for zero-th, first and second }
     \textcolor{comment}{// time-derivatives of the nodal values. }
     \textcolor{keywordtype}{double} u\_fe=timestepper\_pt->time\_derivative(0,nod\_pt,0);
     \textcolor{keywordtype}{double} dudt\_fe=timestepper\_pt->time\_derivative(1,nod\_pt,0);
     \textcolor{keywordtype}{double} d2udt2\_fe=timestepper\_pt->time\_derivative(2,nod\_pt,0);
     
     \textcolor{comment}{// Error}
     \textcolor{keywordtype}{double} error=sqrt(pow(u\_exact-u\_fe,2)+
                       pow(dudt\_exact-dudt\_fe,2)+
                       pow(d2udt2\_exact-d2udt2\_fe,2));
     \textcolor{keywordflow}{if} (error>err\_max) err\_max=error;
    \}
   cout << \textcolor{stringliteral}{"Max. error in assignment of initial condition "} 
        << err\_max << std::endl;   
  \}


\} \textcolor{comment}{// end of set initial condition}

\end{DoxyCodeInclude}




 

\hypertarget{index_doc}{}\section{Post processing}\label{index_doc}
The post-\/processing routine is practically identical to that in the \href{../../../unsteady_heat/two_d_unsteady_heat/html/index.html}{\tt corresponding unsteady heat example}. We output the solution, and compare the computed and exact solutions.


\begin{DoxyCodeInclude}



\textcolor{comment}{//===start\_of\_doc\_solution================================================}\textcolor{comment}{}
\textcolor{comment}{/// Doc the solution}
\textcolor{comment}{}\textcolor{comment}{//========================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT, \textcolor{keyword}{class} TIMESTEPPER>
\textcolor{keywordtype}{void} \hyperlink{classLinearWaveProblem_a6d9396a693be0479ece9ac1f14f9233a}{LinearWaveProblem<ELEMENT,TIMESTEPPER>::doc\_solution}
      (DocInfo& doc\_info)
\{ 

 ofstream some\_file;
 \textcolor{keywordtype}{char} filename[100];

 \textcolor{comment}{// Number of plot points}
 \textcolor{keywordtype}{unsigned} npts;
 npts=5; 

 cout << std::endl;
 cout << \textcolor{stringliteral}{"================================================="} << std::endl;
 cout << \textcolor{stringliteral}{"Docing solution for t="} << time\_pt()->time() << std::endl;
 cout << \textcolor{stringliteral}{"================================================="} << std::endl;

 \textcolor{comment}{// Output solution }
 \textcolor{comment}{//-----------------}
 sprintf(filename,\textcolor{stringliteral}{"%s/soln%i.dat"},doc\_info.directory().c\_str(),
         doc\_info.number());
 some\_file.open(filename);
 mesh\_pt()->output(some\_file,npts);
 some\_file << \textcolor{stringliteral}{"TEXT X=2.5,Y=93.6,F=HELV,HU=POINT,C=BLUE,H=26,T=\(\backslash\)"time = "} 
           << time\_pt()->time() << \textcolor{stringliteral}{"\(\backslash\)""};
 some\_file << \textcolor{stringliteral}{"GEOMETRY X=2.5,Y=98,T=LINE,C=BLUE,LT=0.4"} << std::endl;
 some\_file << \textcolor{stringliteral}{"1"} << std::endl;
 some\_file << \textcolor{stringliteral}{"2"} << std::endl;
 some\_file << \textcolor{stringliteral}{" 0 0"} << std::endl;
 some\_file << time\_pt()->time()*20.0 << \textcolor{stringliteral}{" 0"} << std::endl;
 some\_file.close();

 \textcolor{comment}{// Output exact solution }
 \textcolor{comment}{//----------------------}
 sprintf(filename,\textcolor{stringliteral}{"%s/exact\_soln%i.dat"},doc\_info.directory().c\_str(),
         doc\_info.number());
 oomph\_info << \textcolor{stringliteral}{" FILENAME: "} << filename << std::endl;
 some\_file.open(filename);
 mesh\_pt()->output\_fct(some\_file,npts,time\_pt()->time(),
                        \hyperlink{namespaceTanhSolnForLinearWave_a7dd7e9f155d19f871ba87d3fe41fd8e9}{TanhSolnForLinearWave::get\_exact\_u}); 
 some\_file.close();

 \textcolor{comment}{// Doc error}
 \textcolor{comment}{//----------}
 \textcolor{keywordtype}{double} error,norm;
 sprintf(filename,\textcolor{stringliteral}{"%s/error%i.dat"},doc\_info.directory().c\_str(),
         doc\_info.number());
 some\_file.open(filename);
 mesh\_pt()->compute\_error(some\_file,
                          \hyperlink{namespaceTanhSolnForLinearWave_a7dd7e9f155d19f871ba87d3fe41fd8e9}{TanhSolnForLinearWave::get\_exact\_u},
                          time\_pt()->time(),
                          error,norm); 
 some\_file.close();
 cout << \textcolor{stringliteral}{"error: "} << error << std::endl; 
 cout << \textcolor{stringliteral}{"norm : "} << norm << std::endl << std::endl;

 \textcolor{comment}{// Write trace file}
 Trace\_file << time\_pt()->time() << \textcolor{stringliteral}{" "} << time\_pt()->dt()
            << \textcolor{stringliteral}{" "} << mesh\_pt()->nelement() << \textcolor{stringliteral}{" "} 
            << error << \textcolor{stringliteral}{" "} << norm << std::endl;

\} \textcolor{comment}{// end of doc solution}

\end{DoxyCodeInclude}




 

\hypertarget{index_unsteady_run}{}\section{The timestepping loop}\label{index_unsteady_run}
Timestepping the linear wave equation involves exactly the same steps as in the \href{../../../unsteady_heat/two_d_unsteady_heat/html/index.html}{\tt unsteady heat example\+:} We start by creating a {\ttfamily Doc\+Info} object to specify the output directories and open the trace file in which we record the time-\/evolution of the error.


\begin{DoxyCodeInclude}
\textcolor{comment}{//===start\_of\_unsteady\_run================================================}
\textcolor{comment}{/// Unsteady run.}
\textcolor{comment}{}\textcolor{comment}{//========================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT, \textcolor{keyword}{class} TIMESTEPPER>
\textcolor{keywordtype}{void} \hyperlink{classLinearWaveProblem_a9993365201bfffcc04dd2034f0d3d391}{LinearWaveProblem<ELEMENT,TIMESTEPPER>::unsteady\_run}
      ()
\{

 \textcolor{comment}{// Setup labels for output}
 DocInfo doc\_info;
 
 \textcolor{comment}{// Output directory}
 \textcolor{keywordflow}{if} (Impulsive\_start)
  \{
   doc\_info.set\_directory(\textcolor{stringliteral}{"RESLT\_impulsive"}); 
  \}
 \textcolor{keywordflow}{else}
  \{
   doc\_info.set\_directory(\textcolor{stringliteral}{"RESLT\_smooth"}); 
  \}

 \textcolor{comment}{// Open trace file}
 \textcolor{keywordtype}{char} filename[100];   
 sprintf(filename,\textcolor{stringliteral}{"%s/trace.dat"},doc\_info.directory().c\_str());
 Trace\_file.open(filename);

\end{DoxyCodeInclude}


We then initialise the time, set the initial condition and output the initial solution.


\begin{DoxyCodeInclude}

 \textcolor{comment}{// Initialise time}
 \textcolor{keywordtype}{double} time0=0.0;
 time\_pt()->time()=time0;

 \textcolor{comment}{// Set initial timestep}
 \textcolor{keywordtype}{double} dt=0.005;
 time\_pt()->initialise\_dt(dt);

 \textcolor{comment}{// Set IC}
 set\_initial\_condition();

 \textcolor{comment}{//Output initial condition}
 doc\_solution(doc\_info);
 
 \textcolor{comment}{//Increment counter for solutions }
 doc\_info.number()++;

\end{DoxyCodeInclude}


Next we set up the number of timesteps to be performed. If the code is run in validation mode, indicated by a non-\/zero number of command line arguments, we only perform two timesteps.


\begin{DoxyCodeInclude}

 \textcolor{comment}{// Maximum time}
 \textcolor{keywordtype}{double} t\_max=4.0;

 \textcolor{comment}{// Number of steps}
 \textcolor{keywordtype}{unsigned} nstep=unsigned(t\_max/dt);

 \textcolor{comment}{// If validation run only do 2 timesteps}
 \textcolor{keywordflow}{if} (CommandLineArgs::Argc>1)
  \{ 
   nstep=2; 
   cout << \textcolor{stringliteral}{"Validation run -- only doing two timesteps."} << std::endl;
  \}

\end{DoxyCodeInclude}


Finally, we loop over the timesteps, solve the equations at each time level and document the results.


\begin{DoxyCodeInclude}
 
 \textcolor{comment}{// Timestepping loop}
 \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} istep=0;istep<nstep;istep++)
  \{
   \textcolor{comment}{//Take fixed timestep without spatial adaptivity}
   unsteady\_newton\_solve(dt);
      
   \textcolor{comment}{//Output solution}
   doc\_solution(doc\_info);
     
   \textcolor{comment}{//Increment counter for solutions }
   doc\_info.number()++;
  \}

 \textcolor{comment}{// Close trace file}
 Trace\_file.close();

\} \textcolor{comment}{// end of unsteady run}

\end{DoxyCodeInclude}




 

\hypertarget{index_comments}{}\section{Comments and Exercises}\label{index_comments}
\hypertarget{index_default}{}\subsection{Default parameters for the linear wave equations}\label{index_default}
The linear wave equation does not contain any parameters, therefore the {\ttfamily Problem} constructor only passed the pointer to the pointer to the source function to the elements. Passing the pointer to the source function is optional -- if no source function pointer is specified, the linear-\/wave elements will use the default $ f(x_1,x_2,t)=0 $ , so that the unforced linear wave equation is solved. You should confirm this by commenting out the assignment of the source function pointer in the Problem constructor -- the code should (and does!) still compute the correct results. This is because the travelling-\/wave solution (5) is in fact a solution of the {\itshape unforced} wave equation -- the source function defined in the namespace {\ttfamily \hyperlink{namespaceTanhSolnForLinearWave}{Tanh\+Soln\+For\+Linear\+Wave}} implements $ f(x_1,x_2,t)=0 $ .\hypertarget{index_imp_soln}{}\subsection{The errors induced by an impulsive start}\label{index_imp_soln}

\begin{DoxyEnumerate}
\item View \href{../figures/impulsive_wave_solution.avi}{\tt the animation of the results obtained from the simulation that was started impulsively } and explain how the differences to the exact solution arise.
\item Does the error induced by the impulsive start decay with time? Contrast this with the behaviour in the \href{../../../unsteady_heat/two_d_unsteady_heat/html/index.html}{\tt unsteady heat example. }
\end{DoxyEnumerate}\hypertarget{index_flux}{}\subsection{The use of Neumann boundary conditions.}\label{index_flux}
Neumann (\char`\"{}flux\char`\"{}) boundary conditions for the linear wave equation can be applied by attaching elements of type {\ttfamily Linear\+Wave\+Flux\+Element$<$\+B\+U\+L\+K\+\_\+\+L\+I\+N\+E\+A\+R\+\_\+\+W\+A\+V\+E\+\_\+\+E\+L\+E\+M\+E\+N\+T$>$} to the boundary in exactly the same way as in the \href{../../../poisson/two_d_poisson_flux_bc2/html/index.html}{\tt Poisson } and \href{../../../unsteady_heat/two_d_unsteady_heat_adapt/html/index.html}{\tt unsteady heat } examples. We will therefore not discuss this case in detail but simply refer to the listing of the (well-\/documented) \href{../../../../demo_drivers/linear_wave/two_d_linear_wave/two_d_linear_wave_flux.cc}{\tt driver code two\+\_\+d\+\_\+linear\+\_\+wave\+\_\+flux.\+cc}



 

\hypertarget{index_sources}{}\section{Source files for this tutorial}\label{index_sources}

\begin{DoxyItemize}
\item The source files for this tutorial are located in the directory\+: \begin{center} \href{../../../../demo_drivers/linear_wave/two_d_linear_wave/}{\tt demo\+\_\+drivers/linear\+\_\+wave/two\+\_\+d\+\_\+linear\+\_\+wave/ } \end{center} 
\item The driver code is\+: \begin{center} \href{../../../../demo_drivers/linear_wave/two_d_linear_wave/two_d_linear_wave.cc}{\tt demo\+\_\+drivers/linear\+\_\+wave/two\+\_\+d\+\_\+linear\+\_\+wave/two\+\_\+d\+\_\+linear\+\_\+wave.\+cc } \end{center} 
\end{DoxyItemize}



 

 \hypertarget{index_pdf}{}\section{P\+D\+F file}\label{index_pdf}
A \href{../latex/refman.pdf}{\tt pdf version} of this document is available. \end{document}
