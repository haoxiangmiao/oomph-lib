In this document we discuss the finite-\/element-\/based solution of the Helmholtz equation, an elliptic P\+DE that describes time-\/harmonic wave propagation problems. We start by reviewing the relevant theory and then present the solution of a simple model problem -- the scattering of a planar wave from a circular cylinder.

\begin{center} \tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*{1}{|X[-1]}|}
\hline
\begin{center} {\bfseries Acknowledgement\+:} This tutorial and the associated driver codes were developed jointly with Tarak Kharrat (Ensta\+Paris\+Tech, Paris). \end{center}    \\\cline{1-1}
\end{longtabu}
\end{center} 



 

\hypertarget{index_theory}{}\section{Theory\+: The Helmholtz equation for time-\/harmonic scattering problems}\label{index_theory}
The Helmholtz equation governs time-\/harmonic solutions of problems governed by the linear wave equation \[ \nabla^2 U(x,y,t) = \frac{1}{c^2} \frac{\partial^2 U(x,y,t)}{\partial t^2}, \ \ \ \ \ \ \ \ \ \ \ \ (1) \] where $ c $ is the wavespeed. Assuming that $ U(x,y,t) $ is time-\/harmonic, with frequency $ \omega $, we write the real function $ U(x,y,t) $ as \[ U(x,y,t) =Re (u(x,y) \ e^{-i \omega t}) \] where $ u(x,y) $ is complex-\/valued. This transforms (1) into the Helmholtz equation \[ \nabla^2 u(x,y) + k^2 u(x,y) = 0 \ \ \ \ \ \ \ \ \ \ \ \ (2) \] where \[ k = \frac{\omega}{c} \ \ \ \ \ \ \ \ \ \ \ \ (3) \] is the wave number. Like other elliptic P\+D\+Es the Helmholtz equation admits Dirichlet, Neumann (flux) and Robin boundary conditions.

If the equation is solved in an infinite domain (e.\+g. in scattering problems) the solution must satisfy the so-\/called \href{http://en.wikipedia.org/wiki/Sommerfeld_radiation_condition}{\tt Sommerfeld radiation condition} which in 2D has the form \[ \lim_{r\to \infty} \sqrt{r} \left(\frac{\partial u}{\partial r} - iku \right) =0. \] Mathematically, this conditions is required to ensure the uniqueness of the solution (and hence the well-\/posedness of the problem). In a physical context, such as a scattering problem, the condition ensures that scattering of an incoming wave only produces outgoing not incoming waves from infinity.



 

\hypertarget{index_discr}{}\section{Discretisation by finite elements}\label{index_discr}
The discretisation of the Helmholtz equation itself only requires a trivial modification of {\ttfamily oomph-\/lib\textquotesingle{}s} Poisson elements -- we simply add the term $ k^2 u $ to the residual. Since most practical applications of the Helmholtz equation involve complex-\/valued solutions, we provide separate storage for the real and imaginary parts of the solution -- each {\ttfamily Node} therefore stores two unknowns values. By default, the real and imaginary parts are stored as values 0 and 1, respectively; see the section \hyperlink{index_numbering}{The enumeration of the unknowns} for details.

The application of Dirichlet and Neumann boundary conditions is straightforward and follows the pattern employed for the solution of the Poisson equation\+:
\begin{DoxyItemize}
\item Dirichlet conditions are imposed by pinning the relevant nodal values and setting them to the appropriate prescribed values.
\item Neumann (flux) boundary conditions are imposed via {\ttfamily Face\+Elements} (here the {\ttfamily Helmholtz\+Flux\+Elements}). \href{../../../poisson/two_d_poisson_flux_bc/html/index.html}{\tt As usual} we attach these to the faces of the \char`\"{}bulk\char`\"{} elements that are subject to the Neumann boundary conditions.
\end{DoxyItemize}The imposition of the Sommerfeld radiation condition for problems in infinite domains is slightly more complicated. In the following discussion we will restrict ourselves to two dimensions and assume that the infinite domain is truncated at a circular artificial boundary $ \Gamma $ of radius $ R. $ \mbox{[}This assumption is also made in the implementation of {\ttfamily oomph-\/lib\textquotesingle{}s} {\ttfamily Face\+Elements} that allow the (approximate) imposition of the Sommerfeld radiation condition. The methodology can easily be modified to deal with other geometries but this has not been done yet -- any volunteers?\mbox{]} All methods exploit the fact that the relevant solution of the Helmholtz equation can be written in polar coordinates as \[ u(r,\varphi) = \sum_{n=-\infty}^{+\infty} A_n \ H_n^{(1)}(kr) \ e^{i n \varphi}, \ \ \ \ \ \ \ (4) \] where the $A_n $ are suitable coefficients and $ H_n^{(1)}(r) $ is the $ n $-\/th-\/order Hankel function of the first kind.



\hypertarget{index_ABCs}{}\subsection{Approximate/absorbing boundary conditions (\+A\+B\+Cs)}\label{index_ABCs}
It is possible to derive approximate versions of the Sommerfeld radiation condition in which the normal derivative of the solution on the artificial boundary is related to its value and possibly its tangential derivatives. Such boundary conditions (sometimes referred to as approximate or absorbing boundary conditions -- A\+B\+Cs) are typically derived from asymptotic expansions of the solution at large distances from the origin and become more accurate the larger the radius $ R $ of the artificial boundary $ \Gamma $ is. Higher accuracy can therefore only be achieved by increasing the size of the computational domain, with an associated increase in computational cost.

{\ttfamily oomph-\/lib} provides an implementation of the following three boundary conditions (all taken from J. J. Shirron \& I. Babuska\textquotesingle{}s paper "A comparison of approximate boundary conditions and infinite element methods for exterior Helmholtz problems", Computer Methods in Applied Mechanics and Engineering {\bfseries 164} 121-\/139 (1998), in which the authors compare the accuracy of these and many other approximate boundary conditions).


\begin{DoxyItemize}
\item {\bfseries Feng\textquotesingle{}s first order A\+BC\+:} \[ \frac {\partial u}{\partial n}-\bigg( ik - \frac{1}{2R}\bigg) u =0 \mbox{\ \ \ \ \ on\ }\Gamma \] (This is identical to the first-\/order Bayliss and Turkel boundary condition).
\item {\bfseries Feng\textquotesingle{}s second order A\+BC\+:} \[ \frac{\partial u}{\partial n}-\bigg[ik-\frac {1}{2R}+\frac{i}{8kR^{2}}\bigg(1+4 \frac {\partial^{2}}{\partial \varphi^{2}}\bigg)\bigg]u =0 \mbox{\ \ \ \ \ on\ }\Gamma \]
\item {\bfseries Feng\textquotesingle{}s third order A\+BC\+:} \[ \frac {\partial u}{\partial n}-\bigg[ik-\frac {1}{2R}+\frac{1}{8k^{2}R^{2}}\bigg(ik+ \frac {1}{R}\bigg) \bigg(1+4 \frac {\partial^{2}}{\partial \varphi^{2}}\bigg)\bigg]u =0 \mbox{\ \ \ \ \ on\ }\Gamma \]
\end{DoxyItemize}All three boundary conditions are implemented in the class {\ttfamily Helmholtz\+Absorbing\+B\+C\+Element}. The order of the approximation can be set via the member function {\ttfamily Helmholtz\+Absorbing\+B\+C\+Element\+::abc\+\_\+order()}. All three boundary conditions are local (relating the function to its normal derivative) and do therefore not change the sparsity of the resulting finite element equations.



\hypertarget{index_DtN}{}\subsection{The Dirichlet-\/to-\/\+Neumann mapping (\+Dt\+N)}\label{index_DtN}
Using (4), it is easy to show (see, e.\+g., J. Jin \char`\"{}\+The Finite Element Method in Electromagnetics (second
edition)\char`\"{}, Wiley (2002) p. 501ff -- but note that Jin assumes that the potential varies like $ \exp(i\omega t)$ rather than $ \exp(-i\omega t)$ as assumed here) that the normal (radial) derivative, $ \partial u / \partial n = \partial u / \partial r, $ on the artificial boundary $ \Gamma $ is given by \[ \frac {\partial u}{\partial r}\bigg|_{r=R} = \frac {\partial u}{\partial n}\bigg|_{r=R} = \gamma (u) \ \ \ \ \ \ \ (5) \] where \[ \gamma (u) = \frac {k}{2 \pi} \sum_{n=-\infty}^{+\infty} \frac {H_n^{(1)^{'}}(kR)}{H_n^{(1)}(kR)} \quad \int_0^{2\pi}u(R,\varphi^{'}) \ e^{in(\varphi-\varphi^{'})} \,d\varphi^{'}. \ \ \ \ \ \ \ (6) \] Equation (5) again provides a condition on the normal derivative of the solution along the artificial boundary and is implemented in the {\ttfamily Helmholtz\+Dt\+N\+Boundary\+Element} class. Since $ \gamma $ depends on the solution everywhere along the artificial boundary (see (6)), the application of the boundary condition (5) introduces a non-\/local coupling between all the degrees of freedom located on that boundary. This is handled by classifying the unknowns that affect $ \gamma $ but are not associated with the element\textquotesingle{}s own nodes as external {\ttfamily Data}.

To facilitate the setup of the interaction between the {\ttfamily Helmholtz\+Dt\+N\+Boundary\+Elements}, {\ttfamily oomph-\/lib} provides the class {\ttfamily Helmholtz\+Dt\+N\+Mesh} which provides storage for (the pointers to) the {\ttfamily Helmholtz\+Dt\+N\+Boundary\+Elements} that discretise the artificial boundary. The member function {\ttfamily Helmholtz\+Dt\+N\+Mesh\+::setup\+\_\+gamma()} pre-\/computes the $ \gamma $ values required for the imposition of equation (5). The radius $ R $ of the artificial boundary and the (finite) number of (Fourier) terms used in the sum in (6) are specified as arguments to the constructor of the {\ttfamily Helmholtz\+Dt\+N\+Mesh}.

{\bfseries N\+O\+TE\+:} Since $ \gamma $ depends on the solution, it must be recomputed whenever the unknowns are updated during the Newton iteration. This is best done by adding a call to {\ttfamily Helmholtz\+Dt\+N\+Mesh\+::setup\+\_\+gamma()} to {\ttfamily Problem\+::actions\+\_\+before\+\_\+newton\+\_\+convergence\+\_\+check()}. \mbox{[}If Helmholtz\textquotesingle{}s equation is solved in isolation (or within a coupled, but linear problem), Newton\textquotesingle{}s method will converge in one iteration. In such cases the unnecessary recomputation of $ \gamma $ after the one-\/and-\/only Newton iteration can be suppressed by setting {\ttfamily Problem\+::\+Problem\+\_\+is\+\_\+nonlinear} to {\ttfamily false}.\mbox{]}



 

\hypertarget{index_scattering}{}\section{A specific example\+: Scattering of an acoustic wave from a sound-\/hard obstacle}\label{index_scattering}
We will now demonstrate the methodology for a specific example\+: the scattering of sound waves in an acoustic medium of density $ \rho $ and bulk modulus $ B $. Assuming that an incoming sound wave impacts a rigid, impermeable obstacle as shown in this sketch,

 
\begin{DoxyImage}
\includegraphics[width=0.6\textwidth]{scattering}
\doxyfigcaption{Scattering of an incoming wave from a sound-\/hard obstacle -\/-\/ the scatterer. }
\end{DoxyImage}


we wish to find the wave field that is scattered from the body.

For this purpose we denote the time-\/dependent displacement of the fluid particle in the acoustic medium by $ {\bf u}^*(x^*,y^*,t^*) $ and introduce a displacement potential $ \Phi^*(x^*,y^*,t^*) $ such that \[ {\bf u}^* = \nabla^* \Phi^*. \] (As usual we employ asterisks to distinguish dimensional quantities from their non-\/dimensional equivalents, to be introduced below.) It is easy to show that $ \Phi^* $ satisfies the linear wave equation (1) with wave speed $ c = \sqrt{B/\rho}$.

Since the surface $ \partial D_{bound}$ of the scatterer is impenetrable, the normal displacement of the fluid has to vanish on $ \partial D_{bound}$ and the boundary condition for the displacement potential becomes \[ \left. \frac{\partial \Phi^*}{\partial n^*}\right|_{\partial D_{bound}} = 0. \ \ \ \ \ \ \ \ \ \ \ \ \ (7) \]

We non-\/dimensionalise all lengths and displacements on some problem-\/dependent lengthscale $ {\cal L}$ (e.\+g. the radius of the scatterer), non-\/dimensionalise the potential as $ \Phi^* = a^2 \Phi $ and scale time on the period of the oscillation, $ t^* = \frac{2\pi}{\omega} t.$ The governing equation then becomes \[ \nabla^2 \Phi + k^2 \Phi = 0, \ \ \ \ \ \ \ \ \ \ \ (8) \] where the square of the wavenumber is given by \[ k^2 = \frac{\rho (a\omega)^2}{B}. \]

Assuming that the incoming wave (already satisfying (8)) is described by a (known) non-\/dimensional displacement potential of the form \[ \Phi_{inc}(x,y,t) = \phi_{inc}(x,y) \ e^{-i 2\pi t}, \] we write the total potential as \[ \Phi(x,y,t) = \bigg( \phi_{inc}(x,y) + u(x,y) \bigg) \ e^{-i 2\pi t}, \] where $ u(x,y) \ e^{-i 2\pi t} $ represents the displacement potential associated with the scattered field which must satisfy (2). The boundary condition (7) then becomes a Neumann (flux) boundary condition for the scattered field, \[ \left. \frac{\partial u}{\partial n}\right|_{\partial D_{bound}} = - \left. \frac{\partial \phi_{inc}}{\partial n}\right|_{\partial D_{bound}}. \ \ \ \ \ \ \ \ \ \ \ \ \ (9) \]

For the special case of the incoming wave being a planar wave, propagating along the x-\/axis, the incoming field can be written in polar coordinates as \[ \phi_{inc}(r, \varphi) = \sum_{n=-\infty}^{+\infty} i^n J_n(kr) e^{in\varphi}, \] where $ J_n $ is the Bessel function of the first kind of order $ n $. The exact solution for the scattering of such a wave from a circular disk is given by the series \[ u_{ex}(r,\varphi) = -\sum_{n=-\infty}^{+\infty} i^n \frac {H^{'}_{n}(k)}{J^{'}_{n}(k)} H_n(kr) e^{in\varphi}, \ \ \ \ \ \ \ \ \ \ \ \ \ (10) \] where we have chosen the disk\textquotesingle{}s radius, $ a $, as the lengthscale by setting $ {\cal L} = a$. In the above expression, $ H_n $ denotes the Hankel function of the first kind of order $ n $ and the prime denotes differentiation with respect to the function\textquotesingle{}s argument.

A quantity that is of particular interest in wave propagation problems is the time-\/average of the power radiated by the scatterer, \[ \overline{\cal P}^* = \frac{\omega}{2\pi} \int_{0}^{2\pi/\omega} {\cal P}^*(t) \ dt^*. \] In the context of an acoustic wave, the total instantaneous power, $ {\cal P}^*(t), $ radiated over a closed boundary is \[ {\cal P}^*(t) = \oint \frac{\partial {\bf u^*} }{\partial t^*} \cdot p^* {\bf n} \ dS^*, \] where the pressure is related to the displacement potential via \[ p^* = \rho \omega^2 \Phi^*. \] The non-\/dimensional time-\/averaged radiated power can be expressed in terms of the complex potential $ \phi $ as \[ \overline{\cal P} = \frac{\overline{\cal P}^*}{\rho \omega^3 {\cal L}^4} = \frac{1}{2} \oint\bigg[Im\bigg(\frac{\partial \phi}{\partial n}\bigg) \ Re(\phi) - Re\bigg(\frac{\partial \phi}{\partial n}\bigg) \ Im(\phi) \bigg] \ dS. \] 

 

\hypertarget{index_results}{}\section{Results}\label{index_results}
The figure below shows an animation of the displacement potential $ Re(u(x,y,t)) $ for scattering from a circular disk for a non-\/dimensional wavenumber of $ k=1 $ over one period of the oscillation. The simulation was performed in an annular computational domain, bounded by the outer surface the (unit) disk and an artificial outer boundary of non-\/dimensional radius $ R=1.5. $ The Sommerfeld radiation condition was imposed using the DtN mapping and the simulation was performed with spatial adaptivity (note the non-\/uniform refinement).

The \char`\"{}carpet plot\char`\"{} compares the exact (green) and computed (red) solutions for the displacement potential. The colours in the contour plot at the bottom of the figure provide an alternative visualisation of the magnitude of the scattered field.

 
\begin{DoxyImage}
\includegraphics[width=0.6\textwidth]{scattering_animation}
\doxyfigcaption{The displacement potential associated with the scattered wave, animated over one period of the oscillation. }
\end{DoxyImage}




 

\hypertarget{index_num_soln}{}\section{The numerical solution}\label{index_num_soln}
\hypertarget{index_namespace}{}\subsection{The global namespace}\label{index_namespace}
As usual, we define the problem parameters in a global namespace. The main physical parameter is the (square of the) wave number, $ k^2 $. {\ttfamily N\+\_\+fourier} is the number of (Fourier) terms to be used in evaluation of the series in equations (6) and (10). The remaining parameters determine how the Sommerfeld radiation condition is applied.

 
\begin{DoxyCodeInclude}
\textcolor{comment}{//===== start\_of\_namespace=============================================}
\textcolor{comment}{/// Namespace for the Helmholtz problem parameters}
\textcolor{comment}{}\textcolor{comment}{//=====================================================================}
\textcolor{keyword}{namespace }\hyperlink{namespaceGlobalParameters}{GlobalParameters}
\{\textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Square of the wavenumber}
\textcolor{comment}{} \textcolor{keywordtype}{double} K\_squared=10.0; 
 \textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Number of terms used in the computation }
\textcolor{comment}{ /// of the exact solution}
\textcolor{comment}{} \textcolor{keywordtype}{unsigned} N\_fourier=10;
 \textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Flag to choose the Dirichlet to Neumann BC}
\textcolor{comment}{ /// or ABC BC}
\textcolor{comment}{} \textcolor{keywordtype}{bool} DtN\_BC=\textcolor{keyword}{false};
\textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Flag to choose wich order to use}
\textcolor{comment}{} \textcolor{comment}{// in the ABCs BC: 1 for ABC 1st order...}
 \textcolor{keywordtype}{unsigned} ABC\_order=3;
\textcolor{comment}{}
\textcolor{comment}{ /// Radius of outer boundary (must be a circle!)}
\textcolor{comment}{} \textcolor{keywordtype}{double} Outer\_radius=1.5;
\textcolor{comment}{}
\textcolor{comment}{ /// Imaginary unit }
\textcolor{comment}{} std::complex<double> \hyperlink{namespaceGlobalParameters_a7642bd7303d39de0d680340586b7df60}{I}(0.0,1.0);

\end{DoxyCodeInclude}


The function {\ttfamily get\+\_\+exact\+\_\+u} returns the exact solution for the scattering problem. We will use this function for the validation of our results.

 
\begin{DoxyCodeInclude}
 \textcolor{comment}{/// \(\backslash\)short Exact solution for scattered field }
\textcolor{comment}{ /// (vector returns real and impaginary parts).}
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{namespaceGlobalParameters_ae2320da6053f5527b2af5ebb362a8a07}{get\_exact\_u}(\textcolor{keyword}{const} Vector<double>& x, Vector<double>& u)
 \{
  \textcolor{comment}{// Switch to polar coordinates}
  \textcolor{keywordtype}{double} r;
  r=sqrt(x[0]*x[0]+x[1]*x[1]);
  \textcolor{keywordtype}{double} theta;
  theta=atan2(x[1],x[0]);
  
  \textcolor{comment}{// Argument for Bessel/Hankel functions}
  \textcolor{keywordtype}{double} rr=sqrt(K\_squared)*r;  
 
  \textcolor{comment}{// Evaluate Bessel/Hankel functions}
  complex <double > u\_ex(0.0,0.0);
  Vector<double> jn(N\_fourier+1), yn(N\_fourier+1),
   jnp(N\_fourier+1), ynp(N\_fourier+1);
  Vector<double> jn\_a(N\_fourier+1),yn\_a(N\_fourier+1),
   jnp\_a(N\_fourier+1), ynp\_a(N\_fourier+1);
  Vector<complex<double> > h(N\_fourier+1),h\_a(N\_fourier+1),
   hp(N\_fourier+1), hp\_a(N\_fourier+1);

  \textcolor{comment}{// We want to compute N\_fourier terms but the function}
  \textcolor{comment}{// may return fewer than that.}
  \textcolor{keywordtype}{int} n\_actual=0;
  CRBond\_Bessel::bessjyna(N\_fourier,sqrt(K\_squared),n\_actual,
                          &jn\_a[0],&yn\_a[0],
                          &jnp\_a[0],&ynp\_a[0]); 

  \textcolor{comment}{// Shout if things went wrong  }
\textcolor{preprocessor}{#ifdef PARANOID}
  \textcolor{keywordflow}{if} (n\_actual!=\textcolor{keywordtype}{int}(N\_fourier))
   \{
    std::ostringstream error\_stream; 
    error\_stream << \textcolor{stringliteral}{"CRBond\_Bessel::bessjyna() only computed "}
                 << n\_actual << \textcolor{stringliteral}{" rather than "} << N\_fourier 
                 << \textcolor{stringliteral}{" Bessel functions.\(\backslash\)n"};    
    \textcolor{keywordflow}{throw} OomphLibError(error\_stream.str(),
                        OOMPH\_CURRENT\_FUNCTION,
                        OOMPH\_EXCEPTION\_LOCATION);
   \}
\textcolor{preprocessor}{#endif}

  \textcolor{comment}{// Evaluate Hankel at actual radius}
  Hankel\_functions\_for\_helmholtz\_problem::Hankel\_first(N\_fourier,rr,h,hp);

  \textcolor{comment}{// Evaluate Hankel at inner (unit) radius}
  Hankel\_functions\_for\_helmholtz\_problem::Hankel\_first(N\_fourier
                                                       ,sqrt(K\_squared),
                                                       h\_a,hp\_a);
  
  \textcolor{comment}{// Compute the sum: Separate the computation of the negative }
  \textcolor{comment}{// and positive terms}
  \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} i=0;i<\hyperlink{namespaceGlobalParameters_ae4df03bf0ffa55b741ac846ca7b6c155}{N\_fourier};i++)
   \{
    u\_ex-=pow(\hyperlink{namespaceGlobalParameters_a7642bd7303d39de0d680340586b7df60}{I},i)*h[i]*((jnp\_a[i])/hp\_a[i])*pow(exp(\hyperlink{namespaceGlobalParameters_a7642bd7303d39de0d680340586b7df60}{I}*theta),i);
   \}
  \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} i=1;i<\hyperlink{namespaceGlobalParameters_ae4df03bf0ffa55b741ac846ca7b6c155}{N\_fourier};i++)
   \{
    u\_ex-=pow(\hyperlink{namespaceGlobalParameters_a7642bd7303d39de0d680340586b7df60}{I},i)*h[i]*((jnp\_a[i])/hp\_a[i])*pow(exp(-\hyperlink{namespaceGlobalParameters_a7642bd7303d39de0d680340586b7df60}{I}*theta),i);
   \}
  
  \textcolor{comment}{// Get the real & imaginary part of the result}
  u[0]=real(u\_ex);
  u[1]=imag(u\_ex);
  
 \}\textcolor{comment}{// end of get\_exact\_u}

\end{DoxyCodeInclude}


Next we provide a function that computes the prescribed flux (normal derivative) of the solution, $ \partial u/\partial n = -\partial \phi_{inc}/\partial n $, evaluated on the surface of the unit disk.

 
\begin{DoxyCodeInclude}
 \textcolor{comment}{/// \(\backslash\)short Flux (normal derivative) on the unit disk}
\textcolor{comment}{ /// for a planar incoming wave}
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{namespaceGlobalParameters_a5183de63b992338ee60bb4da78a45039}{prescribed\_incoming\_flux}(\textcolor{keyword}{const} Vector<double>& x, 
                               complex<double>& flux)
 \{
  \textcolor{comment}{// Switch to polar coordinates}
  \textcolor{keywordtype}{double} r;
  r=sqrt(x[0]*x[0]+x[1]*x[1]);
  \textcolor{keywordtype}{double} theta;
  theta=atan2(x[1],x[0]);
  
  \textcolor{comment}{// Argument of the Bessel/Hankel fcts}
  \textcolor{keywordtype}{double} rr=sqrt(K\_squared)*r;  
  
  \textcolor{comment}{// Compute Bessel/Hankel functions}
  Vector<double> jn(N\_fourier+1), yn(N\_fourier+1),
   jnp(N\_fourier+1), ynp(N\_fourier+1);

  \textcolor{comment}{// We want to compute N\_fourier terms but the function}
  \textcolor{comment}{// may return fewer than that.}
  \textcolor{keywordtype}{int} n\_actual=0;
  CRBond\_Bessel::bessjyna(N\_fourier,rr,n\_actual,&jn[0],&yn[0],
                          &jnp[0],&ynp[0]);
  
  \textcolor{comment}{// Shout if things went wrong...}
\textcolor{preprocessor}{#ifdef PARANOID}
  \textcolor{keywordflow}{if} (n\_actual!=\textcolor{keywordtype}{int}(N\_fourier))
   \{
    std::ostringstream error\_stream; 
    error\_stream << \textcolor{stringliteral}{"CRBond\_Bessel::bessjyna() only computed "}
                 << n\_actual << \textcolor{stringliteral}{" rather than "} << N\_fourier 
                 << \textcolor{stringliteral}{" Bessel functions.\(\backslash\)n"};    
    \textcolor{keywordflow}{throw} OomphLibError(error\_stream.str(),
                        OOMPH\_CURRENT\_FUNCTION,
                        OOMPH\_EXCEPTION\_LOCATION);
   \}
\textcolor{preprocessor}{#endif}
  
  \textcolor{comment}{// Compute the sum: Separate the computation of the negative and }
  \textcolor{comment}{// positive terms}
  flux=std::complex<double>(0.0,0.0);
  \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} i=0;i<\hyperlink{namespaceGlobalParameters_ae4df03bf0ffa55b741ac846ca7b6c155}{N\_fourier};i++)
   \{
    flux+=pow(\hyperlink{namespaceGlobalParameters_a7642bd7303d39de0d680340586b7df60}{I},i)*(sqrt(K\_squared))*pow(exp(\hyperlink{namespaceGlobalParameters_a7642bd7303d39de0d680340586b7df60}{I}*theta),i)*jnp[i];
   \}
  \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} i=1;i<\hyperlink{namespaceGlobalParameters_ae4df03bf0ffa55b741ac846ca7b6c155}{N\_fourier};i++)
   \{
    flux+=pow(\hyperlink{namespaceGlobalParameters_a7642bd7303d39de0d680340586b7df60}{I},i)*(sqrt(K\_squared))*pow(exp(-\hyperlink{namespaceGlobalParameters_a7642bd7303d39de0d680340586b7df60}{I}*theta),i)*jnp[i];
   \}


 \}\textcolor{comment}{// end of prescribed\_incoming\_flux }

\} \textcolor{comment}{// end of namespace}

\end{DoxyCodeInclude}




 

\hypertarget{index_main}{}\subsection{The driver code}\label{index_main}
The driver code is very straightforward. We parse the command line to determine which boundary condition to use and set the flags in the global namespace accordingly.

 
\begin{DoxyCodeInclude}
\textcolor{comment}{//==========start\_of\_main=================================================}
\textcolor{comment}{/// Solve 2D Helmholtz problem for scattering of a planar wave from a }
\textcolor{comment}{}\textcolor{comment}{/// unit disk }
\textcolor{comment}{}\textcolor{comment}{//========================================================================}
\textcolor{keywordtype}{int} \hyperlink{barrel_8cc_ae66f6b31b5ad750f1fe042a706a4e3d4}{main}(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char} **argv)
\{
 
 \textcolor{comment}{// Store command line arguments}
 CommandLineArgs::setup(argc,argv);

 \textcolor{comment}{// Define case to be run}
 \textcolor{keywordtype}{unsigned} i\_case=0;
 CommandLineArgs::specify\_command\_line\_flag(\textcolor{stringliteral}{"--case"},&i\_case);
 
 \textcolor{comment}{// Parse command line}
 CommandLineArgs::parse\_and\_assign(); 
 
 \textcolor{comment}{// Doc what has actually been specified on the command line}
 CommandLineArgs::doc\_specified\_flags();

 \textcolor{comment}{// Now set flags accordingly}
 \textcolor{keywordflow}{switch}(i\_case)
  \{
  \textcolor{keywordflow}{case} 0:
   \hyperlink{namespaceGlobalParameters_a6e2bba1769e86a5d3db88e2c7062bc63}{GlobalParameters::DtN\_BC}=\textcolor{keyword}{true};
   \textcolor{keywordflow}{break};
   
  \textcolor{keywordflow}{case} 1:
   \hyperlink{namespaceGlobalParameters_a6e2bba1769e86a5d3db88e2c7062bc63}{GlobalParameters::DtN\_BC}=\textcolor{keyword}{false};
   \hyperlink{namespaceGlobalParameters_a552eed3548a269715a95161ad3c4b96a}{GlobalParameters::ABC\_order}=1;
   \textcolor{keywordflow}{break};

  \textcolor{keywordflow}{case} 2:
   \hyperlink{namespaceGlobalParameters_a6e2bba1769e86a5d3db88e2c7062bc63}{GlobalParameters::DtN\_BC}=\textcolor{keyword}{false};
   \hyperlink{namespaceGlobalParameters_a552eed3548a269715a95161ad3c4b96a}{GlobalParameters::ABC\_order}=2;
   \textcolor{keywordflow}{break};

  \textcolor{keywordflow}{case} 3:
   \hyperlink{namespaceGlobalParameters_a6e2bba1769e86a5d3db88e2c7062bc63}{GlobalParameters::DtN\_BC}=\textcolor{keyword}{false};
   \hyperlink{namespaceGlobalParameters_a552eed3548a269715a95161ad3c4b96a}{GlobalParameters::ABC\_order}=3;
   \textcolor{keywordflow}{break};
  \}

\end{DoxyCodeInclude}


Next we build the problem, either with or without enabling spatial adaptivity and define the output directory.


\begin{DoxyCodeInclude}
 
 
 \textcolor{comment}{//Set up the problem}
 \textcolor{comment}{//------------------}
 
\textcolor{preprocessor}{#ifdef ADAPTIVE}
 
 \textcolor{comment}{//Set up the problem with 2D nine-node elements from the}
 \textcolor{comment}{//QHelmholtzElement family.}
 \hyperlink{classScatteringProblem}{ScatteringProblem<RefineableQHelmholtzElement<2,3>} > 
  problem;
 
\textcolor{preprocessor}{#else}
 
 \textcolor{comment}{//Set up the problem with 2D nine-node elements from the}
 \textcolor{comment}{//QHelmholtzElement family. }
 \hyperlink{classScatteringProblem}{ScatteringProblem<QHelmholtzElement<2,3>} > 
  problem;
 

\textcolor{preprocessor}{#endif}
 
 \textcolor{comment}{// Create label for output}
 \textcolor{comment}{//------------------------}
 DocInfo doc\_info;
 
 \textcolor{comment}{// Set output directory}
 doc\_info.set\_directory(\textcolor{stringliteral}{"RESLT"});

\end{DoxyCodeInclude}


Finally, we solve the problem and document the results.


\begin{DoxyCodeInclude}


\textcolor{preprocessor}{#ifdef ADAPTIVE}

 \textcolor{comment}{// Max. number of adaptations}
 \textcolor{keywordtype}{unsigned} max\_adapt=1;
 
   \textcolor{comment}{// Solve the problem with Newton's method, allowing}
   \textcolor{comment}{// up to max\_adapt mesh adaptations after every solve.}
   problem.newton\_solve(max\_adapt);

\textcolor{preprocessor}{#else}

   \textcolor{comment}{// Solve the problem with Newton's method}
   problem.newton\_solve();

\textcolor{preprocessor}{#endif}

 \textcolor{comment}{//Output solution}
 problem.\hyperlink{classScatteringProblem_af83ab14c4f4750ea17c21466f6c6364f}{doc\_solution}(doc\_info);
    
\} \textcolor{comment}{//end of main}

\end{DoxyCodeInclude}




 

\hypertarget{index_class}{}\subsection{The problem class}\label{index_class}
The problem class is very similar to that employed for the \href{../../../poisson/two_d_poisson_flux_bc_adapt/html/index.html}{\tt adaptive solution of the 2D Poisson equation with flux boundary conditions.} The only difference is that we provide two separate meshes of {\ttfamily Face\+Elements\+:} one for the inner boundary where the {\ttfamily Helmholtz\+Flux\+Elements} apply the Neumann condition (9), and one for the outer boundary where we apply the (approximate) Sommerfeld radiation condition. As discussed in section \hyperlink{index_DtN}{The Dirichlet-\/to-\/\+Neumann mapping (DtN)} , we use the function {\ttfamily actions\+\_\+before\+\_\+newton\+\_\+convergence\+\_\+check()} to recompute the $ \gamma $ integral whenever the unknowns are updated during the Newton iteration.

 
\begin{DoxyCodeInclude}
\textcolor{comment}{//========= start\_of\_problem\_class=====================================}
\textcolor{comment}{/// Problem class to compute scattering of planar wave from unit disk}
\textcolor{comment}{}\textcolor{comment}{//=====================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT> 
\textcolor{keyword}{class }\hyperlink{classScatteringProblem}{ScatteringProblem} : \textcolor{keyword}{public} Problem
\{

\textcolor{keyword}{public}:
 \textcolor{comment}{}
\textcolor{comment}{ /// Constructor}
\textcolor{comment}{} \hyperlink{classScatteringProblem_a94710f5d2ee52abc3df9dc8d1fd3eb71}{ScatteringProblem}();
 \textcolor{comment}{}
\textcolor{comment}{ /// Destructor (empty)}
\textcolor{comment}{} \hyperlink{classScatteringProblem_a0a9838027d0286f22706fe6945bbac0a}{~ScatteringProblem}()\{\}
\textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Doc the solution. DocInfo object stores flags/labels for where the}
\textcolor{comment}{ /// output gets written to}
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{classScatteringProblem_af83ab14c4f4750ea17c21466f6c6364f}{doc\_solution}(DocInfo& doc\_info);
 \textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Update the problem specs before solve (empty)}
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{classScatteringProblem_a91ce14b928ec6edbb9d85515a310b1fb}{actions\_before\_newton\_solve}()\{\} 
\textcolor{comment}{}
\textcolor{comment}{ /// Update the problem specs after solve (empty)}
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{classScatteringProblem_abf1e7b97518c94e12802205dec08b15e}{actions\_after\_newton\_solve}()\{\}
 \textcolor{comment}{}
\textcolor{comment}{ /// Recompute gamma integral before checking Newton residuals}
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{classScatteringProblem_ad096c311ee474d23514656d2ba76a4b8}{actions\_before\_newton\_convergence\_check}()
  \{
   \textcolor{keywordflow}{if} (\hyperlink{namespaceGlobalParameters_a6e2bba1769e86a5d3db88e2c7062bc63}{GlobalParameters::DtN\_BC})
    \{
     \hyperlink{classScatteringProblem_a9692c8592b57a4363e557e5b012c744b}{Helmholtz\_outer\_boundary\_mesh\_pt}->setup\_gamma();
    \}
  \}
\textcolor{comment}{}
\textcolor{comment}{ /// Actions before adapt: Wipe the mesh of prescribed flux elements}
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{classScatteringProblem_aca1b756a307f9c1d8a70c7b7e68a296b}{actions\_before\_adapt}();
 \textcolor{comment}{}
\textcolor{comment}{ /// Actions after adapt: Rebuild the mesh of prescribed flux elements}
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{classScatteringProblem_a13d8f85e74666c260de7364917359ed5}{actions\_after\_adapt}();
 \textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Create BC elements on boundary b of the Mesh pointed}
\textcolor{comment}{ /// to by bulk\_mesh\_pt and add them to the specified survace Mesh }
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{classScatteringProblem_a408e05fbe1f1456ab7013a7e8ab29ccc}{create\_outer\_bc\_elements}(
  \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} &b, Mesh* \textcolor{keyword}{const} &bulk\_mesh\_pt,
  Mesh* \textcolor{keyword}{const} & helmholtz\_outer\_boundary\_mesh\_pt);
 \textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Create Helmholtz flux elements on boundary b of the Mesh pointed}
\textcolor{comment}{ /// to by bulk\_mesh\_pt and add them to the specified surface Mesh }
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{classScatteringProblem_af06ff518ad3250f914c0c659af3001c8}{create\_flux\_elements}(\textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} &b, Mesh* \textcolor{keyword}{const} &bulk\_mesh\_pt,
                           Mesh* \textcolor{keyword}{const} & helmholtz\_inner\_boundary\_mesh\_pt);
 \textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Delete boundary face elements and wipe the surface mesh}
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{classScatteringProblem_aaef8a78e317333ddadd0be6a500c1134}{delete\_face\_elements}( Mesh* \textcolor{keyword}{const} & boundary\_mesh\_pt);
 \textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Set pointer to prescribed-flux function for all}
\textcolor{comment}{ /// elements in the surface mesh on the surface of the unit disk}
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{classScatteringProblem_ae75307dde909513a0f11057c96cdd622}{set\_prescribed\_incoming\_flux\_pt}();
\textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Set up boundary condition elements on outer boundary}
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{classScatteringProblem_a76bd8299ea7ed559681b294acfb2aad4}{setup\_outer\_boundary}();

\textcolor{preprocessor}{#ifdef ADAPTIVE}
\textcolor{comment}{}
\textcolor{comment}{/// Pointer to the "bulk" mesh}
\textcolor{comment}{} RefineableTwoDAnnularMesh<ELEMENT>* \hyperlink{classScatteringProblem_a8c61657a1d09ce49a5871ca3febe5658}{Bulk\_mesh\_pt};

\textcolor{preprocessor}{#else}
\textcolor{comment}{}
\textcolor{comment}{ /// Pointer to the "bulk" mesh}
\textcolor{comment}{} TwoDAnnularMesh<ELEMENT>* \hyperlink{classScatteringProblem_a8c61657a1d09ce49a5871ca3febe5658}{Bulk\_mesh\_pt};

\textcolor{preprocessor}{#endif}
\textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Pointer to mesh containing the DtN (or ABC) boundary}
\textcolor{comment}{ /// condition elements}
\textcolor{comment}{} HelmholtzDtNMesh<ELEMENT>* \hyperlink{classScatteringProblem_a9692c8592b57a4363e557e5b012c744b}{Helmholtz\_outer\_boundary\_mesh\_pt};
 \textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Pointer to the mesh containing }
\textcolor{comment}{ /// the Helmholtz inner boundary condition elements }
\textcolor{comment}{} Mesh* \hyperlink{classScatteringProblem_a56b5fc73bbb51b701a43dc38f9815104}{Helmholtz\_inner\_boundary\_mesh\_pt};

\}; \textcolor{comment}{// end of problem class}

\end{DoxyCodeInclude}




 

\hypertarget{index_constr}{}\subsection{The problem constructor}\label{index_constr}
We start by building the bulk mesh, using the refineable or non-\/refineable version of the {\ttfamily Two\+D\+Annular\+Mesh}, depending on the macro {\ttfamily A\+D\+A\+P\+T\+I\+VE}. (The error tolerances for the adaptive version are chosen such that the mesh is refined non-\/uniformly -- with the default tolerances, {\ttfamily oomph-\/lib\textquotesingle{}s} automatic mesh adaptation procedure refine the mesh uniformly.)

 
\begin{DoxyCodeInclude}
\textcolor{comment}{//=======start\_of\_constructor=============================================}
\textcolor{comment}{/// Constructor for Helmholtz problem}
\textcolor{comment}{}\textcolor{comment}{//========================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT>
\hyperlink{classScatteringProblem_a94710f5d2ee52abc3df9dc8d1fd3eb71}{ScatteringProblem<ELEMENT>::}
\hyperlink{classScatteringProblem_a94710f5d2ee52abc3df9dc8d1fd3eb71}{ScatteringProblem}()
\{ 
 
 \textcolor{comment}{// Setup "bulk" mesh}
 
 \textcolor{comment}{// # of elements in theta}
 \textcolor{keywordtype}{unsigned} n\_theta=15;
 
 \textcolor{comment}{// # of elements in radius}
 \textcolor{keywordtype}{unsigned} n\_r=5;
 
 \textcolor{comment}{// Inner radius}
 \textcolor{keywordtype}{double} a=1.0;
 
 \textcolor{comment}{// Thickness of annular computational domain}
 \textcolor{keywordtype}{double} h=0.5; 

 \textcolor{comment}{// Set outer radius}
 \hyperlink{namespaceGlobalParameters_a61b086072a6b8fd38af1a85f1dd1674a}{GlobalParameters::Outer\_radius}=a+h;

 \textcolor{comment}{// Mesh is periodic}
 \textcolor{keywordtype}{bool} periodic=\textcolor{keyword}{true}; 
 
 \textcolor{comment}{// Full circle}
 \textcolor{keywordtype}{double} azimuthal\_fraction=1.0;

\textcolor{preprocessor}{#ifdef ADAPTIVE}
 
 \textcolor{comment}{// Build "bulk" mesh}
 Bulk\_mesh\_pt=
  \textcolor{keyword}{new} RefineableTwoDAnnularMesh<ELEMENT>(periodic,
                                         azimuthal\_fraction,n\_theta,n\_r,a,h);
 
 \textcolor{comment}{// Create/set error estimator}
 Bulk\_mesh\_pt->spatial\_error\_estimator\_pt()=\textcolor{keyword}{new} Z2ErrorEstimator;
 
 \textcolor{comment}{// Choose error tolerances to force some uniform refinement}
 Bulk\_mesh\_pt->min\_permitted\_error()=0.004;
 Bulk\_mesh\_pt->max\_permitted\_error()=0.01;

\textcolor{preprocessor}{#else}
 
 \textcolor{comment}{// Build "bulk" mesh}
 Bulk\_mesh\_pt=
  \textcolor{keyword}{new} TwoDAnnularMesh<ELEMENT>(periodic,
                               azimuthal\_fraction,n\_theta,n\_r,a,h);
 
\textcolor{preprocessor}{#endif}

\end{DoxyCodeInclude}


Next we create the two (empty) meshes for the {\ttfamily Face\+Elements},

 
\begin{DoxyCodeInclude}
 \textcolor{comment}{// Pointer to mesh containing the Helmholtz outer boundary condition}
 \textcolor{comment}{// elements. Specify outer radius and number of Fourier terms to be}
 \textcolor{comment}{// used in gamma integral}
 Helmholtz\_outer\_boundary\_mesh\_pt = 
  \textcolor{keyword}{new} HelmholtzDtNMesh<ELEMENT>(a+h,\hyperlink{namespaceGlobalParameters_ae4df03bf0ffa55b741ac846ca7b6c155}{GlobalParameters::N\_fourier});
 
 \textcolor{comment}{// Pointer to mesh containing the Helmholtz inner boundary condition}
 \textcolor{comment}{// elements. Specify outer radius}
 Helmholtz\_inner\_boundary\_mesh\_pt = \textcolor{keyword}{new} Mesh;

\end{DoxyCodeInclude}


and populate them using the functions {\ttfamily create\+\_\+flux\+\_\+elements}(...) and {\ttfamily create\+\_\+outer\+\_\+bc\+\_\+elements}(...).

 
\begin{DoxyCodeInclude}
 \textcolor{comment}{// Create prescribed-flux elements from all elements that are }
 \textcolor{comment}{// adjacent to the inner boundary , but add them to a separate mesh.}
 create\_flux\_elements(0,Bulk\_mesh\_pt,Helmholtz\_inner\_boundary\_mesh\_pt);

 \textcolor{comment}{// Create outer boundary elements from all elements that are }
 \textcolor{comment}{// adjacent to the outer boundary , but add them to a separate mesh.}
 create\_outer\_bc\_elements(2,Bulk\_mesh\_pt,Helmholtz\_outer\_boundary\_mesh\_pt);

\end{DoxyCodeInclude}


We add the various (sub-\/)meshes to the problem and build the global mesh

 
\begin{DoxyCodeInclude}
 \textcolor{comment}{// Add the several  sub meshes to the problem}
 add\_sub\_mesh(Bulk\_mesh\_pt);
 add\_sub\_mesh(Helmholtz\_outer\_boundary\_mesh\_pt); 
 add\_sub\_mesh(Helmholtz\_inner\_boundary\_mesh\_pt);   
  
 \textcolor{comment}{// Build the Problem's global mesh from its various sub-meshes}
 build\_global\_mesh();

\end{DoxyCodeInclude}


Finally, we complete the build of the various elements by by passing pointers to the relevant quantities to them, and assign the equation numbers.  
\begin{DoxyCodeInclude}
 \textcolor{comment}{// Complete the build of all elements so they are fully functional}
 
 \textcolor{comment}{// Loop over the Helmholtz bulk elements to set up element-specific }
 \textcolor{comment}{// things that cannot be handled by constructor: Pass pointer to }
 \textcolor{comment}{// wave number squared}
 \textcolor{keywordtype}{unsigned} n\_element = Bulk\_mesh\_pt->nelement();
 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} e=0;e<n\_element;e++)
  \{
   \textcolor{comment}{// Upcast from GeneralisedElement to Helmholtz bulk element}
   ELEMENT *el\_pt = \textcolor{keyword}{dynamic\_cast<}ELEMENT*\textcolor{keyword}{>}(Bulk\_mesh\_pt->element\_pt(e));
   
   \textcolor{comment}{//Set the k\_squared  pointer}
   el\_pt->k\_squared\_pt() = &\hyperlink{namespaceGlobalParameters_aae73cb63b27d51a87845c3392cd944eb}{GlobalParameters::K\_squared};
  \}
 
 \textcolor{comment}{// Set up elements on outer boundary}
 setup\_outer\_boundary();
 
 \textcolor{comment}{// Set pointer to prescribed flux function for flux elements}
 set\_prescribed\_incoming\_flux\_pt();

 \textcolor{comment}{// Setup equation numbering scheme}
 cout <<\textcolor{stringliteral}{"Number of equations: "} << assign\_eqn\_numbers() << std::endl; 

\} \textcolor{comment}{// end of constructor}

\end{DoxyCodeInclude}


The problem is now ready to be solved.



 

\hypertarget{index_before_adapt}{}\subsection{Actions before adapt}\label{index_before_adapt}
The mesh adaptation is driven by the error estimates for the bulk elements. The various {\ttfamily Face\+Elements} must therefore be removed from the global mesh before the adaptation takes place. We do this by calling the function {\ttfamily delete\+\_\+flux\+\_\+elements}(...) for the two face meshes, before rebuilding the Problem\textquotesingle{}s global mesh.

 
\begin{DoxyCodeInclude}
\textcolor{comment}{//=====================start\_of\_actions\_before\_adapt======================}
\textcolor{comment}{/// Actions before adapt: Wipe the mesh of face elements}
\textcolor{comment}{}\textcolor{comment}{//========================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT>
\textcolor{keywordtype}{void} \hyperlink{classScatteringProblem_aca1b756a307f9c1d8a70c7b7e68a296b}{ScatteringProblem<ELEMENT>::actions\_before\_adapt}()
\{ 
 \textcolor{comment}{// Kill the flux elements and wipe the boundary meshs}
 delete\_face\_elements(Helmholtz\_outer\_boundary\_mesh\_pt);
 delete\_face\_elements(Helmholtz\_inner\_boundary\_mesh\_pt);

 \textcolor{comment}{// Rebuild the Problem's global mesh from its various sub-meshes}
 rebuild\_global\_mesh();

\}\textcolor{comment}{// end of actions\_before\_adapt}

\end{DoxyCodeInclude}




 

\hypertarget{index_after_adapt}{}\subsection{Actions after adapt}\label{index_after_adapt}
After the (bulk-\/)mesh has been adapted, the flux elements must be re-\/attached. This is done by calling the functions {\ttfamily create\+\_\+flux\+\_\+elements}(...) and {\ttfamily create\+\_\+outer\+\_\+bc\+\_\+elements}, followed by rebuilding the Problem\textquotesingle{}s global mesh. Finally, we complete the build of the {\ttfamily Face\+Elements} by calling the functions {\ttfamily setup\+\_\+outer\+\_\+boundary()} and {\ttfamily set\+\_\+prescribed\+\_\+incoming\+\_\+flux\+\_\+pt()}.

 
\begin{DoxyCodeInclude}
\textcolor{comment}{//=====================start\_of\_actions\_after\_adapt=======================}
\textcolor{comment}{///  Actions after adapt: Rebuild the face element meshes}
\textcolor{comment}{}\textcolor{comment}{//========================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT>
\textcolor{keywordtype}{void} \hyperlink{classScatteringProblem_a13d8f85e74666c260de7364917359ed5}{ScatteringProblem<ELEMENT>::actions\_after\_adapt}()
\{
 \textcolor{comment}{// Create prescribed-flux elements and BC elements }
 \textcolor{comment}{// from all elements that are adjacent to the boundaries and add them to }
 \textcolor{comment}{// Helmholtz\_boundary\_meshes}
 create\_outer\_bc\_elements(2,Bulk\_mesh\_pt,Helmholtz\_outer\_boundary\_mesh\_pt);
 create\_flux\_elements(0,Bulk\_mesh\_pt,Helmholtz\_inner\_boundary\_mesh\_pt);
 
 \textcolor{comment}{// Rebuild the Problem's global mesh from its various sub-meshes}
 rebuild\_global\_mesh();
 
 \textcolor{comment}{// Set pointer to prescribed flux function and DtN mesh}
 setup\_outer\_boundary();
 set\_prescribed\_incoming\_flux\_pt(); 
  
\}\textcolor{comment}{// end of actions\_after\_adapt}

\end{DoxyCodeInclude}




 

\hypertarget{index_delete}{}\subsection{Delete flux elements}\label{index_delete}
The helper function {\ttfamily delete\+\_\+face\+\_\+elements()} is used to delete all {\ttfamily Face\+Elements} in a given surface mesh before the mesh adaptation.

 
\begin{DoxyCodeInclude}
\textcolor{comment}{//============start\_of\_delete\_face\_elements================}
\textcolor{comment}{/// Delete face elements and wipe the boundary mesh}
\textcolor{comment}{}\textcolor{comment}{//==========================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT>
\textcolor{keywordtype}{void} \hyperlink{classScatteringProblem_aaef8a78e317333ddadd0be6a500c1134}{ScatteringProblem<ELEMENT>::}
\hyperlink{classScatteringProblem_aaef8a78e317333ddadd0be6a500c1134}{delete\_face\_elements}(Mesh* \textcolor{keyword}{const} & boundary\_mesh\_pt)
\{
 \textcolor{comment}{// Loop over the surface elements}
 \textcolor{keywordtype}{unsigned} n\_element = boundary\_mesh\_pt->nelement();
 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} e=0;e<n\_element;e++)
  \{
   \textcolor{comment}{// Kill surface element}
   \textcolor{keyword}{delete}  boundary\_mesh\_pt->element\_pt(e);
  \}
 
 \textcolor{comment}{// Wipe the mesh}
 boundary\_mesh\_pt->flush\_element\_and\_node\_storage();
 
\} \textcolor{comment}{// end of delete\_outer\_face\_elements}

\end{DoxyCodeInclude}




 

\hypertarget{index_create_flux}{}\subsection{Creating the face elements}\label{index_create_flux}
The functions {\ttfamily create\+\_\+flux\+\_\+elements}(...) and {\ttfamily create\+\_\+outer\+\_\+bc\+\_\+elements}(...) create the {\ttfamily Face\+Elements} required to apply the boundary conditions on the inner and outer boundaries of the annular computational domain. They both loop over the bulk elements that are adjacent to the appropriate mesh boundary and attach the required {\ttfamily Face\+Elements} to their faces. The newly created {\ttfamily Face\+Elements} are then added to the appropriate mesh.

 
\begin{DoxyCodeInclude}
\textcolor{comment}{//============start\_of\_create\_outer\_bc\_elements==============================}
\textcolor{comment}{/// Create outer BC elements on the b-th boundary of }
\textcolor{comment}{}\textcolor{comment}{/// the Mesh object pointed to by bulk\_mesh\_pt and add the elements }
\textcolor{comment}{}\textcolor{comment}{/// to the Mesh object pointed to by helmholtz\_outer\_boundary\_mesh\_pt.}
\textcolor{comment}{}\textcolor{comment}{//===========================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT>
\textcolor{keywordtype}{void} \hyperlink{classScatteringProblem_a408e05fbe1f1456ab7013a7e8ab29ccc}{ScatteringProblem<ELEMENT>::}
\hyperlink{classScatteringProblem_a408e05fbe1f1456ab7013a7e8ab29ccc}{create\_outer\_bc\_elements}(\textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} &b, Mesh* \textcolor{keyword}{const} &bulk\_mesh\_pt,
                         Mesh* \textcolor{keyword}{const} & helmholtz\_outer\_boundary\_mesh\_pt)
\{
 \textcolor{comment}{// Loop over the bulk elements adjacent to boundary b?}
 \textcolor{keywordtype}{unsigned} n\_element = bulk\_mesh\_pt->nboundary\_element(b);
 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} e=0;e<n\_element;e++)
  \{
   \textcolor{comment}{// Get pointer to the bulk element that is adjacent to boundary b}
   ELEMENT* bulk\_elem\_pt = \textcolor{keyword}{dynamic\_cast<}ELEMENT*\textcolor{keyword}{>}(
    bulk\_mesh\_pt->boundary\_element\_pt(b,e));
   
   \textcolor{comment}{//Find the index of the face of element e along boundary b }
   \textcolor{keywordtype}{int} face\_index = bulk\_mesh\_pt->face\_index\_at\_boundary(b,e);
   
   \textcolor{comment}{// Build the corresponding outer flux element}
   
   \textcolor{comment}{// Dirichlet to Neumann boundary conditon}
   \textcolor{keywordflow}{if} (\hyperlink{namespaceGlobalParameters_a6e2bba1769e86a5d3db88e2c7062bc63}{GlobalParameters::DtN\_BC})
    \{
     HelmholtzDtNBoundaryElement<ELEMENT>* flux\_element\_pt = \textcolor{keyword}{new} 
      HelmholtzDtNBoundaryElement<ELEMENT>(bulk\_elem\_pt,face\_index);
     
     \textcolor{comment}{//Add the flux boundary element to the  helmholtz\_outer\_boundary\_mesh}
     helmholtz\_outer\_boundary\_mesh\_pt->add\_element\_pt(flux\_element\_pt);
    \}
   \textcolor{comment}{//  ABCs BC}
   \textcolor{keywordflow}{else}
    \{
     HelmholtzAbsorbingBCElement<ELEMENT>* flux\_element\_pt = \textcolor{keyword}{new} 
      HelmholtzAbsorbingBCElement<ELEMENT>(bulk\_elem\_pt,face\_index);
     
     \textcolor{comment}{//Add the flux boundary element to the  helmholtz\_outer\_boundary\_mesh}
     helmholtz\_outer\_boundary\_mesh\_pt->add\_element\_pt(flux\_element\_pt);
    \}
  \} \textcolor{comment}{//end of loop over bulk elements adjacent to boundary b}
\} \textcolor{comment}{// end of create\_outer\_bc\_elements}

\end{DoxyCodeInclude}


(We omit the listing of the function {\ttfamily create\+\_\+flux\+\_\+elements}(...) because it is very similar. Feel free to inspect in the \href{../../../../demo_drivers/helmholtz/scattering/scattering.cc}{\tt source code.})



 

\hypertarget{index_doc}{}\subsection{Post-\/processing}\label{index_doc}
The post-\/processing function {\ttfamily doc\+\_\+solution}(...) computes and outputs the total radiated power, and plots the computed and exact solutions (real and complex parts).

 
\begin{DoxyCodeInclude}
\textcolor{comment}{//=====================start\_of\_doc=======================================}
\textcolor{comment}{/// Doc the solution: doc\_info contains labels/output directory etc.}
\textcolor{comment}{}\textcolor{comment}{//========================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT>
\textcolor{keywordtype}{void} \hyperlink{classScatteringProblem_af83ab14c4f4750ea17c21466f6c6364f}{ScatteringProblem<ELEMENT>::doc\_solution}(DocInfo& 
                                              doc\_info) 
\{ 

 ofstream some\_file,some\_file2;
 \textcolor{keywordtype}{char} filename[100];
 
 \textcolor{comment}{// Number of plot points}
 \textcolor{keywordtype}{unsigned} npts;
 npts=5; 

 \textcolor{comment}{// Compute/output the radiated power}
 \textcolor{comment}{//----------------------------------}
 sprintf(filename,\textcolor{stringliteral}{"%s/power%i.dat"},doc\_info.directory().c\_str(),
         doc\_info.number());
 some\_file.open(filename);

 \textcolor{comment}{// Accumulate contribution from elements}
 \textcolor{keywordtype}{double} power=0.0;
 \textcolor{keywordtype}{unsigned} nn\_element=Helmholtz\_outer\_boundary\_mesh\_pt->nelement(); 
 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} e=0;e<nn\_element;e++)
  \{
   HelmholtzBCElementBase<ELEMENT> *el\_pt = 
    \textcolor{keyword}{dynamic\_cast<} HelmholtzBCElementBase<ELEMENT>*\textcolor{keyword}{>}(
     Helmholtz\_outer\_boundary\_mesh\_pt->element\_pt(e)); 
   power += el\_pt->global\_power\_contribution(some\_file);
  \}
 some\_file.close();
 oomph\_info << \textcolor{stringliteral}{"Total radiated power: "} << power << std::endl; 

 \textcolor{comment}{// Output solution }
 \textcolor{comment}{//-----------------}
 sprintf(filename,\textcolor{stringliteral}{"%s/soln%i.dat"},doc\_info.directory().c\_str(),
         doc\_info.number());
 some\_file.open(filename);
 Bulk\_mesh\_pt->output(some\_file,npts);
 some\_file.close();
 
  \textcolor{comment}{// Output exact solution }
 \textcolor{comment}{//----------------------}
 sprintf(filename,\textcolor{stringliteral}{"%s/exact\_soln%i.dat"},doc\_info.directory().c\_str(),
         doc\_info.number());
 some\_file.open(filename);
 Bulk\_mesh\_pt->output\_fct(some\_file,npts,\hyperlink{namespaceGlobalParameters_ae2320da6053f5527b2af5ebb362a8a07}{GlobalParameters::get\_exact\_u}); 
 some\_file.close();
 
 \textcolor{keywordtype}{double} error,norm;
 sprintf(filename,\textcolor{stringliteral}{"%s/error%i.dat"},doc\_info.directory().c\_str(),
         doc\_info.number());
 some\_file.open(filename);
 Bulk\_mesh\_pt->compute\_error(some\_file,\hyperlink{namespaceGlobalParameters_ae2320da6053f5527b2af5ebb362a8a07}{GlobalParameters::get\_exact\_u},
                             error,norm); 
 some\_file.close();
 
 \textcolor{comment}{// Doc L2 error and norm of solution}
 oomph\_info << \textcolor{stringliteral}{"\(\backslash\)nNorm of error   : "} << sqrt(error) << std::endl; 
 oomph\_info << \textcolor{stringliteral}{"Norm of solution: "} << sqrt(norm) << std::endl << std::endl;

\end{DoxyCodeInclude}


Finally, we create the data required to produce an animation of the actual (real) potential at 40 instants during a period of the oscillation.


\begin{DoxyCodeInclude}
 

 \textcolor{comment}{// Do animation of Helmholtz solution}
 \textcolor{comment}{//-----------------------------------}
 \textcolor{keywordtype}{unsigned} nstep=40;
 \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} i=0;i<nstep;i++)
  \{
   sprintf(filename,\textcolor{stringliteral}{"%s/helmholtz\_animation%i\_frame%i.dat"},
           doc\_info.directory().c\_str(),
           doc\_info.number(),i);
   some\_file.open(filename);
   sprintf(filename,\textcolor{stringliteral}{"%s/exact\_helmholtz\_animation%i\_frame%i.dat"},
           doc\_info.directory().c\_str(),
           doc\_info.number(),i);
   some\_file2.open(filename);
   \textcolor{keywordtype}{double} phi=2.0*MathematicalConstants::Pi*double(i)/double(nstep-1);
   \textcolor{keywordtype}{unsigned} nelem=Bulk\_mesh\_pt->nelement();
   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} e=0;e<nelem;e++)
    \{
     ELEMENT* el\_pt=\textcolor{keyword}{dynamic\_cast<}ELEMENT*\textcolor{keyword}{>}(
      Bulk\_mesh\_pt->element\_pt(e));
     el\_pt->output\_real(some\_file,phi,npts);    
     el\_pt->output\_real\_fct(some\_file2,phi,npts,
                            \hyperlink{namespaceGlobalParameters_ae2320da6053f5527b2af5ebb362a8a07}{GlobalParameters::get\_exact\_u}); 
    \}
   some\_file.close();
   some\_file2.close();
  \}

\} \textcolor{comment}{// end of doc}

\end{DoxyCodeInclude}




 

\hypertarget{index_comm_ex}{}\section{Comments and Exercises}\label{index_comm_ex}
\hypertarget{index_numbering}{}\subsection{The enumeration of the unknowns}\label{index_numbering}
As discussed in the introduction, most practically relevant solutions of the Helmholtz equation are complex valued. Since {\ttfamily oomph-\/lib\textquotesingle{}s} solvers only deal with real (double precision) unknowns, the equations are separated into their real and imaginary parts. In the implementation of the Helmholtz elements, we store the real and imaginary parts of the solution as two separate values at each node. By default, the real and imaginary parts are accessible via {\ttfamily Node\+::value(0)} and {\ttfamily Node\+::value(1)}. However, to facilitate the use of the elements in multi-\/physics problems we avoid accessing the unknowns directly in this manner but provide the virtual function 
\begin{DoxyCode}
std::complex<unsigned> HelmholtzEquations<DIM>::u\_index\_helmholtz()
\end{DoxyCode}
 which returns a complex number made of the two unsigneds that indicate which nodal value represents the real and imaginary parts of the solution. This function may be overloaded in combined multi-\/physics elements in which a Helmholtz element is combined (by multiple inheritance) with another element, using the strategy described in \href{../../../multi_physics/b_convection/html/index.html}{\tt the Boussinesq convection tutorial}.



\hypertarget{index_ex}{}\subsection{Exercises}\label{index_ex}
\hypertarget{index_lin}{}\subsubsection{Exploiting linearity}\label{index_lin}
Confirm that the (costly) re-\/computation of the $ \gamma $ integral in {\ttfamily actions\+\_\+before\+\_\+newton\+\_\+convergence\+\_\+check()} after the first (and only) linear solve in the Newton iteration can be avoided by declaring the problem to be linear.\hypertarget{index_acc}{}\subsubsection{The accuracy of the boundary condition elements}\label{index_acc}
Explore the accuracy (and computational cost) of the various {\ttfamily Face\+Elements} that apply the Sommmerfeld radiation condition. In particular, confirm that the accuracy of the DtN boundary condition is (nearly) independent of the radius of the artificial outer boundary, whereas the accuracy of the A\+BC boundary condition can only be improved by increasing the size of the computational domain.



 

\hypertarget{index_sources}{}\section{Source files for this tutorial}\label{index_sources}

\begin{DoxyItemize}
\item The source files for this tutorial are located in the directory\+: \begin{center} \href{../../../../demo_drivers/helmholtz/scattering}{\tt demo\+\_\+drivers/helmholtz/scattering/ } \end{center} 
\item The driver code is\+: \begin{center} \href{../../../../demo_drivers/helmholtz/scattering/scattering.cc}{\tt demo\+\_\+drivers/helmholtz/scattering/scattering.\+cc } \end{center} 
\end{DoxyItemize}



 

 \hypertarget{index_pdf}{}\section{P\+D\+F file}\label{index_pdf}
A \href{../latex/refman.pdf}{\tt pdf version} of this document is available. \end{document}
