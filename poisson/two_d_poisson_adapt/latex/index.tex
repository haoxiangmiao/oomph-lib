In a \href{../../../poisson/fish_poisson/html/index.html}{\tt previous example} we gave an overview of {\ttfamily oomph-\/lib\textquotesingle{}s} powerful mesh adaptation capabilities and demonstrated the use of the functions
\begin{DoxyItemize}
\item {\ttfamily Problem\+::refine\+\_\+uniformly()} which performs automatic, uniform refinement of a given (refineable) mesh.
\item {\ttfamily Problem\+::adapt()} which performs automatic mesh adaptation (local refinement or unrefinement), based on error estimates that are computed (automatically) by a chosen error estimator.
\item {\ttfamily Problem\+::newton\+\_\+solve}(...) -- a black-\/box adaptive Newton solver that automatically adapts the mesh and recomputes the solution until it satisfies the prescribed error bounds.
\end{DoxyItemize}Provided the problem has been discretised with suitable \char`\"{}refineable mesh\char`\"{} and \char`\"{}refineable element\char`\"{} objects from {\ttfamily oomph-\/lib\textquotesingle{}s} mesh and finite element libraries, none of these functions require any intervention by the user. Most of {\ttfamily oomph-\/lib} finite elements are already available in \char`\"{}refineable\char`\"{} and \char`\"{}non-\/refineable\char`\"{} forms. For instance, the {\ttfamily Refineable\+Q\+Poisson\+Element} that we used in the \href{../../../poisson/fish_poisson/html/index.html}{\tt previous example} is the refineable equivalent of the 2D {\ttfamily Q\+Poisson\+Element}. \href{../../../to_be_written/html/index.html}{\tt Another document} describes how to create new refineable elements. Here we shall discuss how to \char`\"{}upgrade\char`\"{} existing meshes to {\ttfamily Refineable\+Meshes}, i.\+e. meshes that can be used with {\ttfamily oomph-\/lib\textquotesingle{}s} mesh adaptation routines.

The minimum functionality that must be provided by such meshes is specified by the pure virtual functions in the abstract base class {\ttfamily Refineable\+Mesh} and all refineable Meshes should be derived from this class. Here is a graphical representation of the typical inheritance structure for refineable meshes, illustrated for 2D quad meshes\+:

 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{refineable_mesh_inheritance}
\doxyfigcaption{Typical inheritance structure for refineable meshes, illustrated for 2D quad meshes. }
\end{DoxyImage}


The diagram contains two fully-\/functional meshes\+:
\begin{DoxyItemize}
\item The {\ttfamily Some\+Mesh} is some basic, non-\/refineable mesh that is derived directly from the generic {\ttfamily Mesh} base class. Typically, it provides a coarse discretisation of a 2D domain with 2D elements from the {\ttfamily Q\+Element} family. Its constructor creates the mesh\textquotesingle{}s nodes and elements and initialises the various boundary lookup schemes. (Consult the \href{../../../quick_guide/html/index.html#mesh}{\tt \char`\"{}\+How to build a mesh\char`\"{}} section of the \href{../../../quick_guide/html/index.html}{\tt Quick Guide} for details of the generic mesh generation process.)
\item The {\ttfamily Refineable\+Some\+Mesh} is the refineable equivalent of the basic {\ttfamily Some\+Mesh}. It inherits the original mesh layout from the {\ttfamily Some\+Mesh} class. Refineability is added by inheriting from the {\ttfamily Refineable\+Quad\+Mesh} class; this class implements the mesh adaptation procedures, specified as pure virtual functions in the {\ttfamily Refineable\+Mesh} class, for 2D quad meshes, employing {\ttfamily Quad\+Tree} -\/ based refinement techniques.
\end{DoxyItemize}Equivalent inheritance structures can be/are implemented for meshes with different element topologies\+: For instance, the {\ttfamily Refineable\+Brick\+Mesh} class is the 3D equivalent of the {\ttfamily Refineable\+Quad\+Mesh} class\+: It performs the mesh adaptation for 3D brick meshes by {\ttfamily Oc\+Tree} -\/ based refinement techniques.

Typically, most of the \char`\"{}hard work\char`\"{} involved in the mesh adaptation process is implemented in the intermediate classes (such as {\ttfamily Refineable\+Quad\+Mesh} or {\ttfamily Refineable\+Brick\+Mesh}). Upgrading an existing mesh to a refineable version therefore usually requires very little effort. We demonstrate this by re-\/visiting the 2D Poisson problem that we analysed in an \href{../../../poisson/two_d_poisson/html/index.html}{\tt earlier example\+: }

\begin{center} \tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*{1}{|X[-1]}|}
\hline
\begin{center} {\bfseries Two-\/dimensional model Poisson problem} \end{center}  Solve \[ \sum_{i=1}^2 \frac{\partial^2u}{\partial x_i^2} = f(x_1,x_2), \ \ \ \ \ \ \ \ \ \ (1) \] in the rectangular domain $D =\left\{ (x_1,x_2) \in [0,1] \times [0,2]\right\}$, with Dirichlet boundary conditions \[ \left. u\right|_{\partial D}=u_0 \ \ \ \ \ \ \ \ \ \ (2) \] where \[ u_0(x_1,x_2) = \tanh(1-\alpha(x_1 \tan\Phi - x_2)) \ \ \ \ \ \ \ \ \ (3) \] and \[ f(x_1,x_2) = \sum_{i=1}^2 \frac{\partial^2 u_0}{\partial x_i^2} \ \ \ \ \ \ \ \ \ (4) \] so that $u_0(x_1,x_2) $ represents the exact solution of the problem.   \\\cline{1-1}
\end{longtabu}
\end{center} 

Recall that for large values of $ \alpha $ the solution approaches a step function \[ u_{step}(x_1,x_2) = \left\{ \begin{array}{rl} -1 & \mbox {for $x_2 < x_1 \ \tan\Phi$} \\ 1 & \mbox {for $x_2 > x_1 \ \tan\Phi$} \end{array} \right. \] Accurate numerical solution can therefore only be obtained if the mesh is refined -- ideally only in the vicinity of the \char`\"{}step\char`\"{}\+:

 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{TanhPoissonAdaptive}
\doxyfigcaption{Plot of the solution with adaptive mesh refinement }
\end{DoxyImage}


We shall discuss the driver code \href{../../../../demo_drivers/poisson/two_d_poisson_adapt/two_d_poisson_adapt.cc}{\tt two\+\_\+d\+\_\+poisson\+\_\+adapt.\+cc} which solves the above problem with adaptive mesh refinement. Its key feature is the creation of the refineable mesh {\ttfamily \hyperlink{classSimpleRefineableRectangularQuadMesh}{Simple\+Refineable\+Rectangular\+Quad\+Mesh}} -- the refineable equivalent of the {\ttfamily Simple\+Rectangular\+Quad\+Mesh} used in the \href{../../../poisson/two_d_poisson/html/index.html}{\tt earlier example.} 

 

\hypertarget{index_refineable}{}\section{Creating the refineable mesh}\label{index_refineable}
{\ttfamily Quad\+Tree-\/based} mesh refinement, as implemented in the {\ttfamily Refineable\+Quad\+Mesh} class, requires the coarse initial mesh to be represented by a {\ttfamily Quad\+Tree\+Forest\+:} Each element in the mesh must be associated with a {\ttfamily Quad\+Tree}, and the relative orientation of the various {\ttfamily Quad\+Trees} relative to each other must be established. This can be done automatically by calling the function {\ttfamily Refineable\+Quad\+Mesh\+::setup\+\_\+quadtree\+\_\+forest()}. The {\ttfamily \hyperlink{classSimpleRefineableRectangularQuadMesh}{Simple\+Refineable\+Rectangular\+Quad\+Mesh}} class is therefore very compact. The mesh is derived from the {\ttfamily Simple\+Rectangular\+Quad\+Mesh} and the {\ttfamily Refineable1\+Quad\+Mesh} classes, both of which are templated by the element type\+:

 
\begin{DoxyCodeInclude}
\textcolor{comment}{//==============================start\_of\_mesh======================}
\textcolor{comment}{/// Refineable equivalent of the SimpleRectangularQuadMesh.}
\textcolor{comment}{}\textcolor{comment}{/// Refinement is performed by the QuadTree-based procedures}
\textcolor{comment}{}\textcolor{comment}{/// implemented in the RefineableQuadMesh base class.}
\textcolor{comment}{}\textcolor{comment}{//=================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT>
\textcolor{keyword}{class }\hyperlink{classSimpleRefineableRectangularQuadMesh}{SimpleRefineableRectangularQuadMesh} : 
 \textcolor{keyword}{public} \textcolor{keyword}{virtual} SimpleRectangularQuadMesh<ELEMENT>,  
 \textcolor{keyword}{public} RefineableQuadMesh<ELEMENT>

\end{DoxyCodeInclude}


The mesh constructor first calls the constructor of the underlying {\ttfamily Simple\+Rectangular\+Quad\+Mesh} to create the nodes and elements, and to set up the various boundary lookup schemes. The call to {\ttfamily Refineable\+Quad\+Mesh\+::setup\+\_\+quadtree\+\_\+forest()} creates the {\ttfamily Quad\+Tree\+Forest} representation of the mesh. That\textquotesingle{}s all!


\begin{DoxyCodeInclude}
\textcolor{keyword}{public}: 
\textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short  Pass number of elements in the horizontal }
\textcolor{comment}{ /// and vertical directions, and the corresponding dimensions.}
\textcolor{comment}{ /// Timestepper defaults to Static.}
\textcolor{comment}{} \hyperlink{classSimpleRefineableRectangularQuadMesh_ae0eab85a2c97fce00d7c82a613378e79}{SimpleRefineableRectangularQuadMesh}(\textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} &Nx,
                                     \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} &Ny, 
                                     \textcolor{keyword}{const} \textcolor{keywordtype}{double} &Lx, \textcolor{keyword}{const} \textcolor{keywordtype}{double} &Ly,
                                     TimeStepper* time\_stepper\_pt=
                                     &Mesh::Default\_TimeStepper) :
  SimpleRectangularQuadMesh<ELEMENT>(Nx,Ny,Lx,Ly,time\_stepper\_pt)
  \{
   \textcolor{comment}{// Nodal positions etc. were created in constructor for}
   \textcolor{comment}{// SimpleRectangularQuadMesh<...> --> We only need to set up }
   \textcolor{comment}{// adaptivity information: Associate finite elements with their }
   \textcolor{comment}{// QuadTrees and plant them in a QuadTreeForest:}
   this->setup\_quadtree\_forest();

  \} \textcolor{comment}{// end of constructor}

\end{DoxyCodeInclude}


The destructor can remain empty, as all memory de-\/allocation is handled in the mesh base classes.


\begin{DoxyCodeInclude}
 \textcolor{comment}{/// Destructor: Empty}
 \textcolor{keyword}{virtual} \hyperlink{classSimpleRefineableRectangularQuadMesh_a8f258e0b5178ccb33f0596ae5a33c3c5}{~SimpleRefineableRectangularQuadMesh}() \{\}

\end{DoxyCodeInclude}




 

\hypertarget{index_global}{}\section{Global parameters and functions}\label{index_global}
The specification of the source function and the exact solution in the namespace {\ttfamily \hyperlink{namespaceTanhSolnForPoisson}{Tanh\+Soln\+For\+Poisson}} is identical to that in the non-\/refineable version discussed in the \href{../../../poisson/two_d_poisson/html/index.html}{\tt previous example}.



 

\hypertarget{index_main}{}\section{The driver code}\label{index_main}
The driver code is very similar to that in the \href{../../../poisson/two_d_poisson/html/index.html}{\tt non-\/refineable version}. We simply change the mesh from the {\ttfamily Simple\+Rectangular\+Quad\+Mesh} to its refineable equivalent, and discretise the problem with nine-\/node {\ttfamily Refineable\+Q\+Poisson\+Elements} instead of nine-\/node 2D {\ttfamily Q\+Poisson\+Elements}. We choose a large value of $ \alpha = 50$ for the \char`\"{}steepness\char`\"{} parameter and solve the problem with the \char`\"{}black-\/box\char`\"{} Newton solver, allowing for up to four adaptive refinements\+:

 
\begin{DoxyCodeInclude}
\textcolor{comment}{//===== start\_of\_main=====================================================}
\textcolor{comment}{/// Driver code for 2D Poisson problem}
\textcolor{comment}{}\textcolor{comment}{//========================================================================}
\textcolor{keywordtype}{int} \hyperlink{two__d__poisson__adapt_8cc_ae66f6b31b5ad750f1fe042a706a4e3d4}{main}()
\{

 \textcolor{comment}{//Set up the problem}
 \textcolor{comment}{//------------------}

 \textcolor{comment}{// Create the problem with 2D nine-node refineable elements from the}
 \textcolor{comment}{// RefineableQuadPoissonElement family. Pass pointer to source function. }
 \hyperlink{classRefineablePoissonProblem}{RefineablePoissonProblem<RefineableQPoissonElement<2,3>}
       > 
  problem(&\hyperlink{namespaceTanhSolnForPoisson_ae1b9d6789ff301e3d63a4e292213036c}{TanhSolnForPoisson::get\_source});
 
 \textcolor{comment}{// Create label for output}
 \textcolor{comment}{//------------------------}
 DocInfo doc\_info;

 \textcolor{comment}{// Set output directory}
 doc\_info.set\_directory(\textcolor{stringliteral}{"RESLT"});

 \textcolor{comment}{// Step number}
 doc\_info.number()=0;

 \textcolor{comment}{// Check if we're ready to go:}
 \textcolor{comment}{//----------------------------}
 cout << \textcolor{stringliteral}{"\(\backslash\)n\(\backslash\)n\(\backslash\)nProblem self-test "};
 \textcolor{keywordflow}{if} (problem.self\_test()==0) 
  \{
   cout << \textcolor{stringliteral}{"passed: Problem can be solved."} << std::endl;
  \}
 \textcolor{keywordflow}{else} 
  \{
   \textcolor{keywordflow}{throw} OomphLibError(\textcolor{stringliteral}{"Self test failed"},
                       OOMPH\_CURRENT\_FUNCTION,
                       OOMPH\_EXCEPTION\_LOCATION);
  \}

 
 \textcolor{comment}{// Set the orientation of the "step" to 45 degrees}
 \hyperlink{namespaceTanhSolnForPoisson_a785ccd00a727125a5138fbbcac173294}{TanhSolnForPoisson::TanPhi}=1.0;
 
 \textcolor{comment}{// Choose a large value for the steepness of the "step"}
 \hyperlink{namespaceTanhSolnForPoisson_ae676ccd186d5df119cce811596d949c1}{TanhSolnForPoisson::Alpha}=50.0; 

 \textcolor{comment}{// Solve the problem, performing up to 4 adaptive refinements}
 problem.newton\_solve(4);
 
 \textcolor{comment}{//Output the solution}
 problem.doc\_solution(doc\_info);
 
\} \textcolor{comment}{//end of main}

\end{DoxyCodeInclude}




 

\hypertarget{index_problem}{}\section{The problem class}\label{index_problem}
The problem class definition is virtually identical to that in the \href{../../../poisson/two_d_poisson/html/index.html}{\tt non-\/refineable version}. The only new function is an overloaded version of the {\ttfamily Problem\+::mesh\+\_\+pt()} function which returns a pointer to the generic {\ttfamily Mesh} object. Our version returns a pointer to the specific mesh, to avoid the use of explicit casts in the rest of the code.

 
\begin{DoxyCodeInclude}
\textcolor{comment}{//====== start\_of\_problem\_class=======================================}
\textcolor{comment}{/// 2D Poisson problem on rectangular domain, discretised with}
\textcolor{comment}{}\textcolor{comment}{/// refineable 2D QPoisson elements. The specific type of element is}
\textcolor{comment}{}\textcolor{comment}{/// specified via the template parameter.}
\textcolor{comment}{}\textcolor{comment}{//====================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT> 
\textcolor{keyword}{class }\hyperlink{classRefineablePoissonProblem}{RefineablePoissonProblem} : \textcolor{keyword}{public} Problem
\{

\textcolor{keyword}{public}:
\textcolor{comment}{}
\textcolor{comment}{ /// Constructor: Pass pointer to source function}
\textcolor{comment}{} \hyperlink{classRefineablePoissonProblem_a019ec586c38163e04e177de92503c02f}{RefineablePoissonProblem}(PoissonEquations<2>::PoissonSourceFctPt 
                          source\_fct\_pt);
\textcolor{comment}{}
\textcolor{comment}{ /// Destructor (empty)}
\textcolor{comment}{} \hyperlink{classRefineablePoissonProblem_a84980680d8a6576e14af42a8639d391a}{~RefineablePoissonProblem}()\{\}
\textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Update the problem specs before solve: Reset boundary conditions}
\textcolor{comment}{ /// to the values from the exact solution.}
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{classRefineablePoissonProblem_a883906ab6c06ffa10ed55dc4fc02ce96}{actions\_before\_newton\_solve}();
\textcolor{comment}{}
\textcolor{comment}{ /// Update the problem after solve (empty)}
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{classRefineablePoissonProblem_ac4d433dad09bce5bd9be21e86d347e38}{actions\_after\_newton\_solve}()\{\}
\textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Doc the solution. DocInfo object stores flags/labels for where the}
\textcolor{comment}{ /// output gets written to}
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{classRefineablePoissonProblem_aaf9482084473a6ca2bd0de24acae08e9}{doc\_solution}(DocInfo& doc\_info);
\textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Overloaded version of the Problem's access function to }
\textcolor{comment}{ /// the mesh. Recasts the pointer to the base Mesh object to }
\textcolor{comment}{ /// the actual mesh type.}
\textcolor{comment}{} \hyperlink{classSimpleRefineableRectangularQuadMesh}{SimpleRefineableRectangularQuadMesh<ELEMENT>}* 
      \hyperlink{classRefineablePoissonProblem_ad8148aada59e279cbd9eb34272b65fa5}{mesh\_pt}() 
  \{
   \textcolor{keywordflow}{return} \textcolor{keyword}{dynamic\_cast<}\hyperlink{classSimpleRefineableRectangularQuadMesh}{SimpleRefineableRectangularQuadMesh<ELEMENT>}
      *\textcolor{keyword}{>}(
    Problem::mesh\_pt());
  \}

\textcolor{keyword}{private}:
\textcolor{comment}{}
\textcolor{comment}{ /// Pointer to source function}
\textcolor{comment}{} PoissonEquations<2>::PoissonSourceFctPt \hyperlink{classRefineablePoissonProblem_abaf852221a8673550f96bbb507d6b05a}{Source\_fct\_pt};

\}; \textcolor{comment}{// end of problem class}

\end{DoxyCodeInclude}


\mbox{[}See the discussion of the \href{../../one_d_poisson/html/index.html}{\tt 1D Poisson problem} for a more detailed discussion of the function type Poisson\+Equations$<$2$>$\+::\+Poisson\+Source\+Fct\+Pt.\mbox{]}



 

\hypertarget{index_constructor}{}\section{The Problem constructor}\label{index_constructor}
The problem constructor is virtually identical to that in the \href{../../../poisson/two_d_poisson/html/index.html}{\tt non-\/refineable version}. The only change required is the specification of an error estimator for the mesh adaptations\+: We create an instance of the {\ttfamily Z2\+Error\+Estimator} and pass a pointer to it to the mesh.


\begin{DoxyCodeInclude}
\textcolor{comment}{//=====start\_of\_constructor===============================================}
\textcolor{comment}{/// Constructor for Poisson problem: Pass pointer to source function.}
\textcolor{comment}{}\textcolor{comment}{//========================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT>
\hyperlink{classRefineablePoissonProblem_a019ec586c38163e04e177de92503c02f}{RefineablePoissonProblem<ELEMENT>::}
\hyperlink{classRefineablePoissonProblem_a019ec586c38163e04e177de92503c02f}{      RefineablePoissonProblem}(PoissonEquations<2>::PoissonSourceFctPt 
                               source\_fct\_pt)
       :  Source\_fct\_pt(source\_fct\_pt)
\{ 

 \textcolor{comment}{// Setup mesh}

 \textcolor{comment}{// # of elements in x-direction}
 \textcolor{keywordtype}{unsigned} n\_x=4;

 \textcolor{comment}{// # of elements in y-direction}
 \textcolor{keywordtype}{unsigned} n\_y=4;

 \textcolor{comment}{// Domain length in x-direction}
 \textcolor{keywordtype}{double} l\_x=1.0;

 \textcolor{comment}{// Domain length in y-direction}
 \textcolor{keywordtype}{double} l\_y=2.0;

 \textcolor{comment}{// Build and assign mesh}
 Problem::mesh\_pt() = 
  \textcolor{keyword}{new} \hyperlink{classSimpleRefineableRectangularQuadMesh}{SimpleRefineableRectangularQuadMesh<ELEMENT>}(n\_x,n\_y,l\_x,
      l\_y);

 \textcolor{comment}{// Create/set error estimator}
 mesh\_pt()->spatial\_error\_estimator\_pt()=\textcolor{keyword}{new} Z2ErrorEstimator;
  
 \textcolor{comment}{// Set the boundary conditions for this problem: All nodes are}
 \textcolor{comment}{// free by default -- only need to pin the ones that have Dirichlet conditions}
 \textcolor{comment}{// here. }
 \textcolor{keywordtype}{unsigned} num\_bound = mesh\_pt()->nboundary();
 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} ibound=0;ibound<num\_bound;ibound++)
  \{
   \textcolor{keywordtype}{unsigned} num\_nod= mesh\_pt()->nboundary\_node(ibound);
   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} inod=0;inod<num\_nod;inod++)
    \{
     mesh\_pt()->boundary\_node\_pt(ibound,inod)->pin(0); 
    \}
  \}

 \textcolor{comment}{// Complete the build of all elements so they are fully functional}

 \textcolor{comment}{// Loop over the elements to set up element-specific }
 \textcolor{comment}{// things that cannot be handled by the (argument-free!) ELEMENT }
 \textcolor{comment}{// constructor: Pass pointer to source function}
 \textcolor{keywordtype}{unsigned} n\_element = mesh\_pt()->nelement();
 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} i=0;i<n\_element;i++)
  \{
   \textcolor{comment}{// Upcast from GeneralsedElement to the present element}
   ELEMENT *el\_pt = \textcolor{keyword}{dynamic\_cast<}ELEMENT*\textcolor{keyword}{>}(mesh\_pt()->element\_pt(i));

   \textcolor{comment}{//Set the source function pointer}
   el\_pt->source\_fct\_pt() = Source\_fct\_pt;
  \}

 \textcolor{comment}{// Setup equation numbering scheme}
 cout <<\textcolor{stringliteral}{"Number of equations: "} << assign\_eqn\_numbers() << std::endl; 

\} \textcolor{comment}{// end of constructor}

\end{DoxyCodeInclude}




 

\hypertarget{index_actions_before}{}\section{\char`\"{}\+Actions before solve\char`\"{}}\label{index_actions_before}
This function is identical to that in the \href{../../../poisson/two_d_poisson/html/index.html}{\tt non-\/refineable version}.



 

\hypertarget{index_doc}{}\section{Post-\/processing}\label{index_doc}
The function {\ttfamily doc\+\_\+solution}(...) is identical to that in the \href{../../../poisson/two_d_poisson/html/index.html}{\tt non-\/refineable version}.



 

\hypertarget{index_exercises}{}\section{Comments}\label{index_exercises}
Since most of the \char`\"{}hard work\char`\"{} involved in the mesh adaptation is hidden from \char`\"{}user\char`\"{} we briefly comment on various steps involved in the mesh adaptation process and highlight certain important implications.\hypertarget{index_splitting}{}\subsection{The refinement pattern}\label{index_splitting}
The {\ttfamily Quad\+Tree} -\/ based mesh adaption routines, implemented in the {\ttfamily Refineable\+Quad\+Mesh} class, split elements into four \char`\"{}son elements\char`\"{} if the error estimate exceeds the acceptable maximum. By default, the position of any newly created nodes is determined from the geometric mapping of the \char`\"{}father\char`\"{} element. For instance, when a four-\/node quad \char`\"{}father\char`\"{} element is split into four \char`\"{}sons\char`\"{}, five new nodes are created and they are located at $ (s_0,s_1) = (0,-1), \ (1,0), \ (0,1), \ (-1,0) $ and $ (0,0)$ in the father element\textquotesingle{}s local coordinate system. This procedure is adequate for problems in which the coarse initial mesh provides a perfect representation of the domain (e.\+g. polygonal domains). If the domain has curvilinear boundaries, successive mesh refinements must generate a more and more accurate representation of these boundaries. This requires slight changes to the mesh adaptation procedures. We will discuss these in \href{../../../poisson/fish_poisson2/html/index.html}{\tt another example}.

The splitting of \char`\"{}father\char`\"{} elements into four equal-\/sized \char`\"{}sons\char`\"{} maintains the aspect ratio of the elements during the mesh adaptation. The good news is that mesh adaption will not cause a deterioration in the element quality. The bad news is that poorly designed coarse meshes cannot be improved by mesh adaptation. It is therefore worthwhile to invest some time into the initial mesh design. For complicated domains, it may be sensible to perform the initial mesh generation with a dedicated, third-\/party mesh generator. (We provide \href{../../../meshes/third_party_meshes/html/index.html}{\tt another example} to illustrate how to build {\ttfamily oomph-\/lib} meshes based on the output from a third-\/party mesh generator.)\hypertarget{index_hang}{}\subsection{Hanging nodes}\label{index_hang}
The local splitting of elements can create so-\/called \char`\"{}hanging
nodes\char`\"{} -- nodes on element edges that are not shared by any adjacent elements. The nodal values and coordinates at such nodes must be constrained to ensure the inter-\/element continuity of the solution. Specifically, the nodal values and coordinates at hanging nodes must be suitable linear combinations of the values at a number of \char`\"{}master nodes\char`\"{}. (In the first instance, the master nodes are the nodes on the adjacent element\textquotesingle{}s edge that {\itshape are} shared by adjacent elements. If there are multiple levels of refinement, such nodes can themselves be hanging; the ultimate set of master nodes is therefore be determined recursively.)

The setup of the hanging node constraints is handled automatically by the mesh adaptation routines and the technical details are therefore of little relevance to the general user. (The \href{../../../the_data_structure/html/index.html}{\tt \char`\"{}bottom up\char`\"{} discussion of the data structure} provides details if you are interested.) One aspect of the way in which hanging nodes are handled in {\ttfamily oomph-\/lib} is important, however. Up to now we have accessed nodal values either via the function


\begin{DoxyCode}
Node::set\_value(...)
\end{DoxyCode}


which sets the values stored at a {\ttfamily Node}, or the pointer-\/based access function


\begin{DoxyCode}
Node::value\_pt(...)
\end{DoxyCode}


which returns a pointer to these values.

What happens when a node is hanging, i.\+e. if {\ttfamily Node\+::is\+\_\+hanging()} returns {\ttfamily true}?

\tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*{1}{|X[-1]}|}
\hline
\begin{center}{\bfseries A convention}\end{center}  The functions


\begin{DoxyCode}
Node::set\_value(...)
\end{DoxyCode}


and


\begin{DoxyCode}
Node::value\_pt(...)
\end{DoxyCode}


always refer to the nodal values stored at the {\ttfamily Node} itself.

{\bfseries Important\+:} If a node is hanging, the value pointed to by {\ttfamily Node\+::value\+\_\+pt}(...) is {\bfseries not} kept up to date!

The correctly constrained nodal value must be computed \char`\"{}on the fly\char`\"{}, using the list of master nodes and their respective weights, stored in the node\textquotesingle{}s {\ttfamily Hanging\+Info} object. This is done automatically by the function


\begin{DoxyCode}
Node::value(...)
\end{DoxyCode}


which returns the appropriate value for hanging {\itshape and} non-\/hanging nodes\+: For non-\/hanging nodes it returns the value pointed to by {\ttfamily Node\+::value\+\_\+pt}(...); for hanging nodes, it computes the correctly constrained values. When developing new elements or writing new post-\/processing routines, the user should therefore always refer to nodal values with the {\ttfamily Node\+::value}(...) function to ensure that the code works correctly in the presence of hanging nodes.

We provide equivalent functions to access the nodal positions\+: The function


\begin{DoxyCode}
Node::x(...)
\end{DoxyCode}


returns the values of (Eulerian) coordinates stored at the node. These values can be out of date if the node is hanging. The function


\begin{DoxyCode}
Node::position(...)
\end{DoxyCode}


should be used to determine a node\textquotesingle{}s Eulerian position -- this function is the equivalent of {\ttfamily Node\+::value}(...) and determines the nodal coordinates of hanging nodes \char`\"{}on the fly\char`\"{}, using the node\textquotesingle{}s list of master nodes and weights.

Finally, we note that while the nodal values and coordinates stored at a node might be out of date {\itshape while} a node is hanging, the values are automatically assigned up-\/to-\/date values when subsequent mesh adaptations change a node\textquotesingle{}s status from hanging to non-\/hanging.

\\\cline{1-1}
\end{longtabu}




 

\hypertarget{index_sources}{}\section{Source files for this tutorial}\label{index_sources}

\begin{DoxyItemize}
\item The source files for this tutorial are located in the directory\+: \begin{center} \href{../../../../demo_drivers/poisson/two_d_poisson_adapt/}{\tt demo\+\_\+drivers/poisson/two\+\_\+d\+\_\+poisson\+\_\+adapt/ } \end{center} 
\item The driver code is\+: \begin{center} \href{../../../../demo_drivers/poisson/two_d_poisson_adapt/two_d_poisson_adapt.cc}{\tt demo\+\_\+drivers/poisson/two\+\_\+d\+\_\+poisson\+\_\+adapt/two\+\_\+d\+\_\+poisson\+\_\+adapt.\+cc } \end{center} 
\end{DoxyItemize}

 

 \hypertarget{index_pdf}{}\section{P\+D\+F file}\label{index_pdf}
A \href{../latex/refman.pdf}{\tt pdf version} of this document is available. \end{document}
