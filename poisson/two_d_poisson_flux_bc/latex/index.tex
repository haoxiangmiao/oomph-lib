In this document, we demonstrate how to solve a 2D Poisson problem with Neumann boundary conditions, using existing objects from the {\ttfamily oomph-\/lib} library\+: \begin{center} \tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*{1}{|X[-1]}|}
\hline
\begin{center} {\bfseries Two-\/dimensional model Poisson problem with Neumann boundary conditions} \end{center}  Solve \[ \sum_{i=1}^2 \frac{\partial^2u}{\partial x_i^2} = f(x_1,x_2), \ \ \ \ \ \ \ \ \ \ (1) \] in the rectangular domain $ D = \left\{ (x_1,x_2) \in [0,1] \times [0,2]\right\} $. The domain boundary $ \partial D = \partial D_{Neumann} \cup \partial D_{Dirichlet} $, where $ \partial D_{Neumann} = \left\{ (x_1,x_2) | x_1=1, \ x_2\in [0,2] \right\} $. On $ \partial D_{Dirichlet} $ we apply the Dirichlet boundary conditions \[ \left. u\right|_{\partial D_{Dirichlet}}=u_0, \ \ \ \ \ \ \ \ \ \ (2) \] where the function $ u_0 $ is given. On $ \partial D_{Neumann} $ we apply the Neumann conditions \[ \left. \frac{\partial u}{\partial n}\right|_{\partial D_{Neumann}} = \left. \frac{\partial u}{\partial x_1}\right|_{\partial D_{Neumann}} =g_0, \ \ \ \ \ \ \ \ \ \ (3) \] where the function $ g_0 $ is given.   \\\cline{1-1}
\end{longtabu}
\end{center} 

We provide a detailed discussion of the driver code \href{../../../../demo_drivers/poisson/two_d_poisson_flux_bc/two_d_poisson_flux_bc.cc}{\tt two\+\_\+d\+\_\+poisson\+\_\+flux\+\_\+bc.\+cc} which solves the problem for \[ u_0(x_1,x_2) = \tanh(1-\alpha(x_1 \tan\Phi - x_2)), \ \ \ \ \ \ \ \ \ (4) \] \[ f(x_1,x_2) = \sum_{i=1}^2 \frac{\partial^2 u_0}{\partial x_i^2}, \ \ \ \ \ \ \ \ \ (5) \] and \[ g_0 = \left. \frac{\partial u_0}{\partial n} \right|_{x_1=1} = \left. \frac{\partial u_0}{\partial x_1} \right|_{x_1=1}, \ \ \ \ \ \ \ \ \ (6) \] so that $ u_0(x_1,x_2) $ is the exact solution of the problem. For large values of $ \alpha $ the solution approaches a step function \[ u_{step}(x_1,x_2) = \left\{ \begin{array}{rl} -1 & \mbox {for $x_2 < x_1 \ \tan\Phi$} \\ 1 & \mbox {for $x_2 > x_1 \ \tan\Phi$} \end{array} \right. \] and presents a serious challenge for any numerical method. The figure below compares the numerical and exact solutions for $ \alpha = 1 $ and $ \Phi = 45^o $.

 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{soln}
\doxyfigcaption{Plot of the solution }
\end{DoxyImage}


Most of the driver code is identical to the code that solves the \href{../../../poisson/two_d_poisson/html/index.html}{\tt equivalent problem without Neumann boundary conditions}. Therefore we only provide a detailed discussion of those functions that needed to be changed to accommodate the Neumann boundary conditions.



 

\hypertarget{index_global}{}\section{Global parameters and functions}\label{index_global}
As in the Dirichlet problem, we define the source function (5) and the exact solution (4), together with the problem parameters $ \tan \Phi $ and $ \alpha $, in a namespace {\ttfamily \hyperlink{namespaceTanhSolnForPoisson}{Tanh\+Soln\+For\+Poisson}}. We add the function {\ttfamily \hyperlink{namespaceTanhSolnForPoisson_a0e99ccf27df36f28f091de6d57484172}{Tanh\+Soln\+For\+Poisson\+::prescribed\+\_\+flux\+\_\+on\+\_\+fixed\+\_\+x\+\_\+boundary}}(...) which computes the prescribed flux $ g_0 $ required in the Neumann boundary condition (3). The function evaluates $ \partial u_0 /\partial n = {\bf N} \cdot \nabla u_0 $ for the normal direction specified by the vector $ {\bf N} = (1,0)^T. $

 
\begin{DoxyCodeInclude}
\textcolor{comment}{//===== start\_of\_namespace=============================================}
\textcolor{comment}{/// Namespace for exact solution for Poisson equation with "sharp step" }
\textcolor{comment}{}\textcolor{comment}{//=====================================================================}
\textcolor{keyword}{namespace }\hyperlink{namespaceTanhSolnForPoisson}{TanhSolnForPoisson}
\{
\textcolor{comment}{}
\textcolor{comment}{ /// Parameter for steepness of "step"}
\textcolor{comment}{} \textcolor{keywordtype}{double} Alpha=1.0;
\textcolor{comment}{}
\textcolor{comment}{ /// Parameter for angle Phi of "step"}
\textcolor{comment}{} \textcolor{keywordtype}{double} TanPhi=0.0;
\textcolor{comment}{}
\textcolor{comment}{ /// Exact solution as a Vector}
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{namespaceTanhSolnForPoisson_af7896e9c18ce6438c73ae2a875e8b7de}{get\_exact\_u}(\textcolor{keyword}{const} Vector<double>& x, Vector<double>& u)
 \{
  u[0]=tanh(1.0-Alpha*(TanPhi*x[0]-x[1]));
 \}
\textcolor{comment}{}
\textcolor{comment}{ /// Source function required to make the solution above an exact solution }
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{namespaceTanhSolnForPoisson_a967bc28320e02534beb714846b63e251}{source\_function}(\textcolor{keyword}{const} Vector<double>& x, \textcolor{keywordtype}{double}& source)
 \{
  source = 2.0*tanh(-1.0+Alpha*(TanPhi*x[0]-x[1]))*
   (1.0-pow(tanh(-1.0+Alpha*(TanPhi*x[0]-x[1])),2.0))*
   Alpha*Alpha*TanPhi*TanPhi+2.0*tanh(-1.0+Alpha*(TanPhi*x[0]-x[1]))*
   (1.0-pow(tanh(-1.0+Alpha*(TanPhi*x[0]-x[1])),2.0))*Alpha*Alpha;
 \}
\textcolor{comment}{}
\textcolor{comment}{ /// Flux required by the exact solution on a boundary on which x is fixed}
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{namespaceTanhSolnForPoisson_a0e99ccf27df36f28f091de6d57484172}{prescribed\_flux\_on\_fixed\_x\_boundary}(\textcolor{keyword}{const} Vector<double>& x, 
                                          \textcolor{keywordtype}{double}& flux)
 \{
  \textcolor{comment}{//The outer unit normal to the boundary is (1,0)}
  \textcolor{keywordtype}{double} N[2] = \{1.0, 0.0\};
  \textcolor{comment}{//The flux in terms of the normal is}
  flux = 
   -(1.0-pow(tanh(-1.0+Alpha*(TanPhi*x[0]-x[1])),2.0))*Alpha*TanPhi*N[0]+(
   1.0-pow(tanh(-1.0+Alpha*(TanPhi*x[0]-x[1])),2.0))*Alpha*N[1];
 \}
 
\} \textcolor{comment}{// end of namespace}

\end{DoxyCodeInclude}




 

\hypertarget{index_main}{}\section{The driver code}\label{index_main}
The driver code is very similar to that for the \href{../../../poisson/two_d_poisson/html/index.html}{\tt pure Dirichlet problem\+:} We set up the problem, check its integrity and define the problem parameters. Following this, we solve the problem for a number of $ \alpha $ values and document the solution.

 
\begin{DoxyCodeInclude}
\textcolor{comment}{//==========start\_of\_main=================================================}
\textcolor{comment}{/// Demonstrate how to solve 2D Poisson problem with flux boundary }
\textcolor{comment}{}\textcolor{comment}{/// conditions}
\textcolor{comment}{}\textcolor{comment}{//========================================================================}
\textcolor{keywordtype}{int} \hyperlink{two__d__poisson__flux__bc_8cc_ae66f6b31b5ad750f1fe042a706a4e3d4}{main}()
\{

 \textcolor{comment}{//Set up the problem}
 \textcolor{comment}{//------------------}

 \textcolor{comment}{//Set up the problem with 2D nine-node elements from the}
 \textcolor{comment}{//QPoissonElement family. Pass pointer to source function. }
 \hyperlink{classFluxPoissonProblem}{FluxPoissonProblem<QPoissonElement<2,3>} > 
  problem(&\hyperlink{namespaceTanhSolnForPoisson_a967bc28320e02534beb714846b63e251}{TanhSolnForPoisson::source\_function});
 

 \textcolor{comment}{// Create label for output}
 \textcolor{comment}{//------------------------}
 DocInfo doc\_info;

 \textcolor{comment}{// Set output directory}
 doc\_info.set\_directory(\textcolor{stringliteral}{"RESLT"});

 \textcolor{comment}{// Step number}
 doc\_info.number()=0;



 \textcolor{comment}{// Check that we're ready to go:}
 \textcolor{comment}{//----------------------------}
 cout << \textcolor{stringliteral}{"\(\backslash\)n\(\backslash\)n\(\backslash\)nProblem self-test "};
 \textcolor{keywordflow}{if} (problem.self\_test()==0) 
  \{
   cout << \textcolor{stringliteral}{"passed: Problem can be solved."} << std::endl;
  \}
 \textcolor{keywordflow}{else} 
  \{
   \textcolor{keywordflow}{throw} OomphLibError(\textcolor{stringliteral}{"Self test failed"},
                       OOMPH\_CURRENT\_FUNCTION,
                       OOMPH\_EXCEPTION\_LOCATION);
  \}

 
 \textcolor{comment}{// Set the orientation of the "step" to 45 degrees}
 \hyperlink{namespaceTanhSolnForPoisson_a785ccd00a727125a5138fbbcac173294}{TanhSolnForPoisson::TanPhi}=1.0;
 
 \textcolor{comment}{// Initial value for the steepness of the "step"}
 \hyperlink{namespaceTanhSolnForPoisson_ae676ccd186d5df119cce811596d949c1}{TanhSolnForPoisson::Alpha}=1.0; 

 \textcolor{comment}{// Do a couple of solutions for different forcing functions}
 \textcolor{comment}{//---------------------------------------------------------}
 \textcolor{keywordtype}{unsigned} nstep=4;
 \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} istep=0;istep<nstep;istep++)
  \{
   \textcolor{comment}{// Increase the steepness of the step:}
   \hyperlink{namespaceTanhSolnForPoisson_ae676ccd186d5df119cce811596d949c1}{TanhSolnForPoisson::Alpha}+=2.0;

   cout << \textcolor{stringliteral}{"\(\backslash\)n\(\backslash\)nSolving for TanhSolnForPoisson::Alpha="}
        << \hyperlink{namespaceTanhSolnForPoisson_ae676ccd186d5df119cce811596d949c1}{TanhSolnForPoisson::Alpha} << std::endl << std::endl;

   \textcolor{comment}{// Solve the problem}
   problem.newton\_solve();

   \textcolor{comment}{//Output solution}
   problem.doc\_solution(doc\_info);
 
   \textcolor{comment}{//Increment counter for solutions }
   doc\_info.number()++; 
  \}

\} \textcolor{comment}{//end of main}

\end{DoxyCodeInclude}




 

\hypertarget{index_problem}{}\section{The problem class}\label{index_problem}
The problem class is virtually identical to that used for the \href{../../../poisson/two_d_poisson/html/index.html}{\tt pure Dirichlet problem}\+: The only difference is that the class now contains an additional private data member, {\ttfamily \hyperlink{classFluxPoissonProblem_a1ee0cfcbc307252430a3a5ba7ab7fd6e}{Flux\+Poisson\+Problem\+::\+Npoisson\+\_\+elements}}, which stores the number of 2D \char`\"{}bulk\char`\"{} elements in the mesh, and an additional private member function {\ttfamily \hyperlink{classFluxPoissonProblem_a542ce9cc1c4e17eae68d51d2e13ac0c3}{Flux\+Poisson\+Problem\+::create\+\_\+flux\+\_\+elements}}(...). pwd

 
\begin{DoxyCodeInclude}
\textcolor{comment}{//========= start\_of\_problem\_class=====================================}
\textcolor{comment}{/// 2D Poisson problem on rectangular domain, discretised with}
\textcolor{comment}{}\textcolor{comment}{/// 2D QPoisson elements. Flux boundary conditions are applied}
\textcolor{comment}{}\textcolor{comment}{/// along boundary 1 (the boundary where x=L). The specific type of }
\textcolor{comment}{}\textcolor{comment}{/// element is specified via the template parameter.}
\textcolor{comment}{}\textcolor{comment}{//====================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT> 
\textcolor{keyword}{class }\hyperlink{classFluxPoissonProblem}{FluxPoissonProblem} : \textcolor{keyword}{public} Problem
\{

\textcolor{keyword}{public}:
\textcolor{comment}{}
\textcolor{comment}{ /// Constructor: Pass pointer to source function}
\textcolor{comment}{} \hyperlink{classFluxPoissonProblem_a1b57e0c67634586cb69fbeeec7874e36}{FluxPoissonProblem}(PoissonEquations<2>::PoissonSourceFctPt source\_fct\_pt);
\textcolor{comment}{}
\textcolor{comment}{ /// Destructor (empty)}
\textcolor{comment}{} \hyperlink{classFluxPoissonProblem_afe4848aa1478883fa4dd59abbd7c7547}{~FluxPoissonProblem}()\{\}
\textcolor{comment}{}
\textcolor{comment}{ /// Doc the solution. DocInfo object stores flags/labels for where the}
\textcolor{comment}{ /// output gets written to}
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{classFluxPoissonProblem_ae410950b9dc1f2bd4991480df15a1586}{doc\_solution}(DocInfo& doc\_info);

\textcolor{keyword}{private}:
\textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Update the problem specs before solve: Reset boundary conditions}
\textcolor{comment}{ /// to the values from the exact solution.}
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{classFluxPoissonProblem_aaea8f7f6f7a2e1aedfd2854e1ae12338}{actions\_before\_newton\_solve}();
\textcolor{comment}{}
\textcolor{comment}{ /// Update the problem specs after solve (empty)}
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{classFluxPoissonProblem_aa52ae9abbe805520a697929ab115f114}{actions\_after\_newton\_solve}()\{\}
\textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Create Poisson flux elements on the b-th boundary of the }
\textcolor{comment}{ /// problem's mesh}
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{classFluxPoissonProblem_a542ce9cc1c4e17eae68d51d2e13ac0c3}{create\_flux\_elements}(\textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} &b);
\textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Number of Poisson "bulk" elements (We're attaching the flux }
\textcolor{comment}{ /// elements to the bulk mesh --> only the first Npoisson\_elements elements}
\textcolor{comment}{ /// in the mesh are bulk elements!)}
\textcolor{comment}{} \textcolor{keywordtype}{unsigned} \hyperlink{classFluxPoissonProblem_a1ee0cfcbc307252430a3a5ba7ab7fd6e}{Npoisson\_elements};
\textcolor{comment}{}
\textcolor{comment}{ /// Pointer to source function}
\textcolor{comment}{} PoissonEquations<2>::PoissonSourceFctPt \hyperlink{classFluxPoissonProblem_ad003b34801b1c58b762bec0fe00b86aa}{Source\_fct\_pt};

\}; \textcolor{comment}{// end of problem class}

\end{DoxyCodeInclude}


\mbox{[}See the discussion of the \href{../../../poisson/one_d_poisson/html/index.html}{\tt 1D Poisson problem} for a more detailed discussion of the function type Poisson\+Equations$<$2$>$\+::\+Poisson\+Source\+Fct\+Pt.\mbox{]}



 

\hypertarget{index_constructor}{}\section{The Problem constructor}\label{index_constructor}
The first part of the {\ttfamily Problem} constructor is identical to that used for the \href{../../../poisson/two_d_poisson/html/index.html}{\tt pure Dirichlet problem}\+: We create a 2D Mesh consisting of 4x4 quadrilateral Poisson elements\+:


\begin{DoxyCodeInclude}
\textcolor{comment}{//=======start\_of\_constructor=============================================}
\textcolor{comment}{/// Constructor for Poisson problem: Pass pointer to source function.}
\textcolor{comment}{}\textcolor{comment}{//========================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT>
\hyperlink{classFluxPoissonProblem_a1b57e0c67634586cb69fbeeec7874e36}{FluxPoissonProblem<ELEMENT>::}
\hyperlink{classFluxPoissonProblem_a1b57e0c67634586cb69fbeeec7874e36}{      FluxPoissonProblem}(PoissonEquations<2>::PoissonSourceFctPt source\_fct\_pt)
       :  Source\_fct\_pt(source\_fct\_pt)
\{ 

 \textcolor{comment}{// Setup mesh}

 \textcolor{comment}{// # of elements in x-direction}
 \textcolor{keywordtype}{unsigned} n\_x=4;

 \textcolor{comment}{// # of elements in y-direction}
 \textcolor{keywordtype}{unsigned} n\_y=4;

 \textcolor{comment}{// Domain length in x-direction}
 \textcolor{keywordtype}{double} l\_x=1.0;

 \textcolor{comment}{// Domain length in y-direction}
 \textcolor{keywordtype}{double} l\_y=2.0;

 \textcolor{comment}{// Build and assign mesh}
 Problem::mesh\_pt()=\textcolor{keyword}{new} SimpleRectangularQuadMesh<ELEMENT>(n\_x,n\_y,l\_x,l\_y);

\end{DoxyCodeInclude}


Before continuing, we store the number of 2D \char`\"{}bulk\char`\"{} Poisson elements in the variable {\ttfamily Flux\+Poisson\+Problem\+::\+Npoisson\+\_\+element\+:} 


\begin{DoxyCodeInclude}
 \textcolor{comment}{// Store number of Poisson bulk elements (= number of elements so far).}
 Npoisson\_elements=mesh\_pt()->nelement();

\end{DoxyCodeInclude}


Now, we need to apply the prescribed-\/flux boundary condition along the Neumann boundary $ \partial D_{Neumann} $. The documentation for the {\ttfamily Simple\+Rectangular\+Quad\+Mesh} shows that this boundary is mesh boundary 1. The necessary steps are performed by the function {\ttfamily create\+\_\+flux\+\_\+elements}(..), described in the section \hyperlink{index_create_flux}{Creating the flux elements} below.


\begin{DoxyCodeInclude}
 \textcolor{comment}{// Create prescribed-flux elements from all elements that are }
 \textcolor{comment}{// adjacent to boundary 1 and add them to the (single) global mesh}
 create\_flux\_elements(1);

\end{DoxyCodeInclude}


The rest of the constructor is very similar to its counterpart in the \href{../../../poisson/two_d_poisson/html/index.html}{\tt pure Dirichlet problem}. First we apply Dirichlet conditions on the remaining boundaries by pinning the nodal values. Next, we finish the problem setup by looping over all \char`\"{}bulk\char`\"{} Poisson elements and set the pointer to the source function. Since we have added the {\ttfamily Poisson\+Flux\+Elements} to the {\ttfamily Mesh}, only the first {\ttfamily Npoisson\+\_\+element} elements are \char`\"{}bulk\char`\"{} elements and the loop is restricted to these. We then perform a second loop over the {\ttfamily Poisson\+Flux\+Elements} which need to be passed the pointer to the prescribed-\/flux function {\ttfamily \hyperlink{namespaceTanhSolnForPoisson_a0e99ccf27df36f28f091de6d57484172}{Tanh\+Soln\+For\+Poisson\+::prescribed\+\_\+flux\+\_\+on\+\_\+fixed\+\_\+x\+\_\+boundary}}(...). Finally, we generate the equation numbering scheme.


\begin{DoxyCodeInclude}
 \textcolor{comment}{// Set the boundary conditions for this problem: All nodes are}
 \textcolor{comment}{// free by default -- just pin the ones that have Dirichlet conditions}
 \textcolor{comment}{// here. }
 \textcolor{keywordtype}{unsigned} n\_bound = mesh\_pt()->nboundary();
 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} b=0;b<n\_bound;b++)
  \{
   \textcolor{comment}{//Leave nodes on boundary 1 free}
   \textcolor{keywordflow}{if}(b!=1)
    \{
     \textcolor{keywordtype}{unsigned} n\_node= mesh\_pt()->nboundary\_node(b);
     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} n=0;n<n\_node;n++)
      \{
       mesh\_pt()->boundary\_node\_pt(b,n)->pin(0); 
      \}
    \}
  \}

 \textcolor{comment}{// Loop over the Poisson bulk elements to set up element-specific }
 \textcolor{comment}{// things that cannot be handled by constructor: Pass pointer to source}
 \textcolor{comment}{// function}
 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} e=0;e<Npoisson\_elements;e++)
  \{
   \textcolor{comment}{// Upcast from GeneralisedElement to Poisson bulk element}
   ELEMENT *el\_pt = \textcolor{keyword}{dynamic\_cast<}ELEMENT*\textcolor{keyword}{>}(mesh\_pt()->element\_pt(e));

   \textcolor{comment}{//Set the source function pointer}
   el\_pt->source\_fct\_pt() = Source\_fct\_pt;
  \}

 \textcolor{comment}{// Total number of elements:}
 \textcolor{keywordtype}{unsigned} n\_element=mesh\_pt()->nelement();
 
 \textcolor{comment}{// Loop over the flux elements (located at the "end" of the}
 \textcolor{comment}{// mesh) to pass function pointer to prescribed-flux function.}
 \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} e=Npoisson\_elements;e<n\_element;e++)
  \{
   \textcolor{comment}{// Upcast from GeneralisedElement to Poisson flux element}
   PoissonFluxElement<ELEMENT> *el\_pt = 
    \textcolor{keyword}{dynamic\_cast<}PoissonFluxElement<ELEMENT>*\textcolor{keyword}{>}(mesh\_pt()->element\_pt(e));

   \textcolor{comment}{// Set the pointer to the prescribed flux function}
   el\_pt->flux\_fct\_pt() = 
    &\hyperlink{namespaceTanhSolnForPoisson_a0e99ccf27df36f28f091de6d57484172}{TanhSolnForPoisson::prescribed\_flux\_on\_fixed\_x\_boundary}
      ;
  \}

 \textcolor{comment}{// Setup equation numbering scheme}
 cout <<\textcolor{stringliteral}{"Number of equations: "} << assign\_eqn\_numbers() << std::endl; 

\} \textcolor{comment}{// end of constructor}

\end{DoxyCodeInclude}




 

\hypertarget{index_create_flux}{}\section{Creating the flux elements}\label{index_create_flux}
{\ttfamily oomph-\/lib} provides an element type {\ttfamily Poisson\+Flux\+Element}, which allows the application of Neumann (flux) boundary conditions along the \char`\"{}faces\char`\"{} of higher-\/dimensional \char`\"{}bulk\char`\"{} Poisson elements. {\ttfamily Poisson\+Flux\+Elements} are templated by the type of the corresponding higher-\/dimensional \char`\"{}bulk\char`\"{} element, so that a {\ttfamily Poisson\+Flux\+Element$<$Q\+Poisson\+Element$<$2,3$>$} $>$ is a one-\/dimensional three-\/node element that applies Neumann boundary conditions along the one-\/dimensional edge of a nine-\/node quadrilateral Poisson element. Similarly, a {\ttfamily Poisson\+Flux\+Element$<$Q\+Poisson\+Element$<$3,2$>$} $>$ is a two-\/dimensional quadrilateral four-\/node element that applies Neumann boundary conditions along the two-\/dimensional face of a eight-\/node brick-\/shaped Poisson element; etc.

The constructor of the {\ttfamily Poisson\+Flux\+Element} takes two arguments\+:
\begin{DoxyItemize}
\item a pointer to the corresponding bulk element
\item the index {\ttfamily face\+\_\+index} of the face that is to be constructed. The convention for two-\/dimensional Q-\/type elements is that the face\+\_\+index is $ -(i+1) $ when the coordinate $ s_i $ is fixed at its minimum value over the face and $ +(i+1) $ when $ s_i $ is fixed at its maximum value over the face
\end{DoxyItemize}The layout of the elements in the {\ttfamily Simple\+Rectangular\+Quad\+Mesh} is sufficiently simple to allow the direct determination of the face index\+: Elements 3, 7, 11 and 15 are located next to mesh boundary 1 and along this boundary the element\textquotesingle{}s local coordinate $ s_0 $ has a constant (maximum) value of +1.0. Hence we need to set {\ttfamily face\+\_\+index=1} 

In more complicated meshes, the determination of the face index can be more difficult (or at least very tedious), especially if a {\ttfamily Mesh} has been refined non-\/uniformly. The generic {\ttfamily Mesh} class therefore provides helper functions to determine the required face index for all elements adjacent to a specified {\ttfamily Mesh} boundary. This allows the creation of the flux elements by the following, completely generic procedure\+: We use the function {\ttfamily Mesh\+::boundary\+\_\+element\+\_\+pt}(...) to determine the \char`\"{}bulk\char`\"{} elements that are adjacent to the Neumann boundary, and obtain {\ttfamily face\+\_\+index} from the function {\ttfamily Mesh\+::face\+\_\+index\+\_\+at\+\_\+boundary}(...). We pass the parameters to the constructor of the {\ttfamily Poisson\+Flux\+Element} and add the (pointer to) the newly created element to the {\ttfamily Problem\textquotesingle{}s} mesh.


\begin{DoxyCodeInclude}
\textcolor{comment}{//============start\_of\_create\_flux\_elements==============================}
\textcolor{comment}{/// Create Poisson Flux Elements on the b-th boundary of the Mesh}
\textcolor{comment}{}\textcolor{comment}{//=======================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT>
\textcolor{keywordtype}{void} \hyperlink{classFluxPoissonProblem_a542ce9cc1c4e17eae68d51d2e13ac0c3}{FluxPoissonProblem<ELEMENT>::create\_flux\_elements}(\textcolor{keyword}{
      const} \textcolor{keywordtype}{unsigned} &b)
\{
 \textcolor{comment}{// How many bulk elements are adjacent to boundary b?}
 \textcolor{keywordtype}{unsigned} n\_element = mesh\_pt()->nboundary\_element(b);

 \textcolor{comment}{// Loop over the bulk elements adjacent to boundary b?}
 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} e=0;e<n\_element;e++)
  \{
   \textcolor{comment}{// Get pointer to the bulk element that is adjacent to boundary b}
   ELEMENT* bulk\_elem\_pt = \textcolor{keyword}{dynamic\_cast<}ELEMENT*\textcolor{keyword}{>}(
    mesh\_pt()->boundary\_element\_pt(b,e));
   
   \textcolor{comment}{// What is the index of the face of the bulk element at the boundary}
   \textcolor{keywordtype}{int} face\_index = mesh\_pt()->face\_index\_at\_boundary(b,e);

   \textcolor{comment}{// Build the corresponding prescribed-flux element}
   PoissonFluxElement<ELEMENT>* flux\_element\_pt = \textcolor{keyword}{new} 
   PoissonFluxElement<ELEMENT>(bulk\_elem\_pt,face\_index);

   \textcolor{comment}{//Add the prescribed-flux element to the mesh}
   mesh\_pt()->add\_element\_pt(flux\_element\_pt);

  \} \textcolor{comment}{//end of loop over bulk elements adjacent to boundary b}

\} \textcolor{comment}{// end of create\_flux\_elements}

\end{DoxyCodeInclude}




 

\hypertarget{index_actions_before}{}\section{\char`\"{}\+Actions before solve\char`\"{}}\label{index_actions_before}
The function {\ttfamily Problem\+::actions\+\_\+before\+\_\+newton\+\_\+solve()} is identical to that in the \href{../../../poisson/two_d_poisson/html/index.html}{\tt pure Dirichlet problem} and is only listed here for the sake of completeness\+:


\begin{DoxyCodeInclude}
\textcolor{comment}{//====================start\_of\_actions\_before\_newton\_solve================}
\textcolor{comment}{/// Update the problem specs before solve: Reset boundary conditions}
\textcolor{comment}{}\textcolor{comment}{/// to the values from the exact solution.}
\textcolor{comment}{}\textcolor{comment}{//========================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT>
\textcolor{keywordtype}{void} \hyperlink{classFluxPoissonProblem_aaea8f7f6f7a2e1aedfd2854e1ae12338}{FluxPoissonProblem<ELEMENT>::actions\_before\_newton\_solve}
      ()
\{
 \textcolor{comment}{// How many boundaries are there?}
 \textcolor{keywordtype}{unsigned} n\_bound = mesh\_pt()->nboundary();
 
 \textcolor{comment}{//Loop over the boundaries}
 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} i=0;i<n\_bound;i++)
  \{
   \textcolor{comment}{// Only update Dirichlet nodes}
   \textcolor{keywordflow}{if} (i!=1)
    \{
     \textcolor{comment}{// How many nodes are there on this boundary?}
     \textcolor{keywordtype}{unsigned} n\_node = mesh\_pt()->nboundary\_node(i);
     
     \textcolor{comment}{// Loop over the nodes on boundary}
     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} n=0;n<n\_node;n++)
      \{
       \textcolor{comment}{// Get pointer to node}
       Node* nod\_pt = mesh\_pt()->boundary\_node\_pt(i,n);
       
       \textcolor{comment}{// Extract nodal coordinates from node:}
       Vector<double> x(2);
       x[0]=nod\_pt->x(0);
       x[1]=nod\_pt->x(1);
       
       \textcolor{comment}{// Compute the value of the exact solution at the nodal point}
       Vector<double> u(1);
       \hyperlink{namespaceTanhSolnForPoisson_af7896e9c18ce6438c73ae2a875e8b7de}{TanhSolnForPoisson::get\_exact\_u}(x,u);
       
       \textcolor{comment}{// Assign the value to the one (and only) nodal value at this node}
       nod\_pt->set\_value(0,u[0]);
      \}
    \} 
  \}
\} \textcolor{comment}{// end of actions before solve}

\end{DoxyCodeInclude}




 

\hypertarget{index_doc}{}\section{Post-\/processing}\label{index_doc}
The post-\/processing, implemented in {\ttfamily doc\+\_\+solution}(...) is similar to that in \href{../../../poisson/two_d_poisson/html/index.html}{\tt pure Dirichlet problem}. However, since the {\ttfamily Poisson\+Flux\+Elements} are auxiliary elements which are only used to apply Neumann boundary conditions on adjacent \char`\"{}bulk\char`\"{} elements, their error checking function is not implemented. We cannot use the generic {\ttfamily Mesh} member function {\ttfamily Mesh\+::compute\+\_\+error()} to compute an overall error since this function would try to execute the \char`\"{}broken virtual\char`\"{} function {\ttfamily Generalised\+Element\+::compute\+\_\+error}(...); see the section \hyperlink{index_exercises}{Exercises and Comments} for a more detailed discussion of \char`\"{}broken virtual\char`\"{} functions. Error checking would therefore have to be implemented \char`\"{}by hand\char`\"{} (excluding the {\ttfamily Poisson\+Flux\+Elements}), or a suitable error measure would have to be defined in the {\ttfamily Poisson\+Flux\+Elements}.

We do not pursue either approach here because the difficulty is a direct consequence of our (questionable) decision to include elements of different types in the same {\ttfamily Mesh} object. While this is perfectly \char`\"{}legal\char`\"{} and often convenient, the practice introduces additional difficulties in refineable problems and we shall demonstrate \href{../../../poisson/two_d_poisson_flux_bc2/html/index.html}{\tt an alternative approach in another example}.


\begin{DoxyCodeInclude}
\textcolor{comment}{//=====================start\_of\_doc=======================================}
\textcolor{comment}{/// Doc the solution: doc\_info contains labels/output directory etc.}
\textcolor{comment}{}\textcolor{comment}{//========================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT>
\textcolor{keywordtype}{void} \hyperlink{classFluxPoissonProblem_ae410950b9dc1f2bd4991480df15a1586}{FluxPoissonProblem<ELEMENT>::doc\_solution}(DocInfo& doc\_info)
\{ 

 ofstream some\_file;
 \textcolor{keywordtype}{char} filename[100];

 \textcolor{comment}{// Number of plot points}
 \textcolor{keywordtype}{unsigned} npts;
 npts=5; 

 \textcolor{comment}{// Output solution }
 \textcolor{comment}{//-----------------}
 sprintf(filename,\textcolor{stringliteral}{"%s/soln%i.dat"},doc\_info.directory().c\_str(),
         doc\_info.number());
 some\_file.open(filename);
 mesh\_pt()->output(some\_file,npts);
 some\_file.close();

 \textcolor{comment}{// Output exact solution }
 \textcolor{comment}{//----------------------}
 sprintf(filename,\textcolor{stringliteral}{"%s/exact\_soln%i.dat"},doc\_info.directory().c\_str(),
         doc\_info.number());
 some\_file.open(filename);
 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} e=0;e<Npoisson\_elements;e++)
  \{
   ELEMENT *el\_pt = \textcolor{keyword}{dynamic\_cast<}ELEMENT*\textcolor{keyword}{>}(mesh\_pt()->element\_pt(e));
   el\_pt->output\_fct(some\_file,npts,\hyperlink{namespaceTanhSolnForPoisson_af7896e9c18ce6438c73ae2a875e8b7de}{TanhSolnForPoisson::get\_exact\_u}); 
  \}
 some\_file.close();

 \textcolor{comment}{// Can't use black-box error computatation routines because}
 \textcolor{comment}{// the mesh contains two different types of elements. }
 \textcolor{comment}{// error function hasn't been implemented for the prescribed}
 \textcolor{comment}{// flux elements...}

\} \textcolor{comment}{// end of doc}

\end{DoxyCodeInclude}




 

\hypertarget{index_exercises}{}\section{Exercises and Comments}\label{index_exercises}

\begin{DoxyEnumerate}
\item What happens if you do not create the {\ttfamily Poisson\+Flux\+Elements} but leave the nodes on the Neumann boundary un-\/pinned? Compare the computational result to those obtained when you set the prescribed flux to zero, $ g_0 = 0 $. Does this make sense? \mbox{[}Hint\+: Remember the \char`\"{}natural\char`\"{} boundary conditions for Poisson\textquotesingle{}s equation\mbox{]}.
\item Try to compute the error of the computed solution by re-\/instating the global error checking procedure 
\begin{DoxyCode}
\textcolor{comment}{// Doc error and return of the square of the L2 error}
\textcolor{comment}{//---------------------------------------------------}
\textcolor{keywordtype}{double} error,norm;
sprintf(filename,\textcolor{stringliteral}{"%s/error%i.dat"},doc\_info.directory().c\_str(),
        doc\_info.number());
some\_file.open(filename);
mesh\_pt()->compute\_error(some\_file,\hyperlink{namespaceTanhSolnForPoisson_af7896e9c18ce6438c73ae2a875e8b7de}{TanhSolnForPoisson::get\_exact\_u},
                         error,norm); 
some\_file.close();
\end{DoxyCode}
 in {\ttfamily doc\+\_\+solution}(...). What happens when you run the code? The code\textquotesingle{}s behaviour illustrates a general convention in {\ttfamily oomph-\/lib}\+: \tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*{1}{|X[-1]}|}
\hline
\begin{center}{\bfseries \label{index_broken_virtual}%
\Hypertarget{index_broken_virtual}%
A general convention}\end{center}  Some {\ttfamily oomph-\/lib} functions, such as {\ttfamily Generalised\+Element\+::compute\+\_\+error}(...), are defined as virtual functions in a base class to allow the implementation of generic procedures such as {\ttfamily Mesh\+::compute\+\_\+error}(...), which loops over all of the {\ttfamily Mesh\textquotesingle{}s} constituent elements and executes their specific {\ttfamily compute\+\_\+error}(...) member functions. In some rare cases (such as the one encountered here), the implementation of a particular virtual function might not be sensible for a specific element. Therefore, rather than forcing the \char`\"{}element-\/writer\char`\"{} to implement a dummy version of this function in his/her derived class (by declaring it as a pure virtual function in the base class), we provide a {\bfseries  \char`\"{}broken virtual\char`\"{} } implementation in {\ttfamily Generalised\+Element}. If the function is (re-\/)implemented in a derived element, the broken version is ignored; if the function is not overloaded, the broken virtual function throws an error, allowing a traceback in a debugger to find out where the broken function was called from. We note that this practice is not universally approved of in the C++ community but we believe it to have its place in situations such as the one described here. ~\newline
 ~\newline
 Incidentally, the code discussed above contains another (possibly more convincing) example of why \char`\"{}broken virtual\char`\"{} functions can be useful. Recall that the creation of the {\ttfamily Poisson\+Flux\+Elements} on the Neumann boundary was greatly facilitated by the availability of the helper functions {\ttfamily Mesh\+::boundary\+\_\+element\+\_\+pt}(...) and {\ttfamily Mesh\+::face\+\_\+index\+\_\+at\+\_\+boundary}(...). These functions are implemented in the generic {\ttfamily Mesh} base class and determine the relevant parameters via lookup schemes that are stored in that class. Obviously, the lookup schemes need to be set up when a specific {\ttfamily Mesh} is built and this task can involve a considerable amount of work (see also \hyperlink{index_footnote}{Setting up the boundary lookup schemes}). Since the lookup schemes are useful but by no means essential, the three helper functions are again implemented as broken virtual functions. If the functions are called before the required lookup schemes have been set up, code execution stops with a suitable warning message.   \\\cline{1-1}
\end{longtabu}

\item Implement the error computation by hand to familiarise yourself with the way in which the {\ttfamily Mesh\+::compute\+\_\+error}(...) function works.
\end{DoxyEnumerate}



 \hypertarget{index_footnote}{}\subsection{Setting up the boundary lookup schemes}\label{index_footnote}
{\ttfamily oomph-\/lib} provides a range of helper functions that set up the boundary lookup schemes for specific {\ttfamily Mesh} classes. For instance, the {\ttfamily Quad\+Mesh\+Base} class forms a base class for all {\ttfamily Meshes} that consist of two-\/dimensional quadrilateral elements and has a member function {\ttfamily Quad\+Mesh\+Base\+::setup\+\_\+boundary\+\_\+element\+\_\+info()} which can be called from the constructor of any derived {\ttfamily Mesh} class to set up the lookup schemes required by {\ttfamily Mesh\+::boundary\+\_\+element\+\_\+pt}(...) and {\ttfamily Mesh\+::face\+\_\+index\+\_\+at\+\_\+boundary}(...).



 

\hypertarget{index_sources}{}\section{Source files for this tutorial}\label{index_sources}

\begin{DoxyItemize}
\item The source files for this tutorial are located in the directory\+: \begin{center} \href{../../../../demo_drivers/poisson/two_d_poisson_flux_bc/}{\tt demo\+\_\+drivers/poisson/two\+\_\+d\+\_\+poisson\+\_\+flux\+\_\+bc/ } \end{center} 
\item The driver code is\+: \begin{center} \href{../../../../demo_drivers/poisson/two_d_poisson_flux_bc/two_d_poisson_flux_bc.cc}{\tt demo\+\_\+drivers/poisson/two\+\_\+d\+\_\+poisson\+\_\+flux\+\_\+bc/two\+\_\+d\+\_\+poisson\+\_\+flux\+\_\+bc.\+cc } \end{center} 
\end{DoxyItemize}



 

 \hypertarget{index_pdf}{}\section{P\+D\+F file}\label{index_pdf}
A \href{../latex/refman.pdf}{\tt pdf version} of this document is available. \end{document}
