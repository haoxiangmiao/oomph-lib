In an \href{../../fsi_collapsible_channel/html/index.html}{\tt earlier example,} we demonstrated how the {\ttfamily Macro\+Element/\+Domain} -\/ based node-\/update procedure that we originally developed for problems with moving, curvilinear domain boundaries may also be used in fluid-\/structure interaction problems in which the position of the domain boundary has to be determined as part of the solution. We demonstrated that the driver code for the coupled multi-\/physics problem was a straightforward combination of the driver codes for the two constituent single-\/physics problems. The two key steps required to couple the two single-\/physics codes were\+:
\begin{DoxyEnumerate}
\item Recast the wall mesh to a {\ttfamily Geom\+Object}, using the {\ttfamily Mesh\+As\+Geom\+Object} class. This class turns an existing solid mechanics mesh into a \char`\"{}compound\char`\"{} {\ttfamily Geom\+Object} in which material points on the wall are identified by their Lagrangian coordinate, $ \xi $ , which doubles as the {\ttfamily Geom\+Object\textquotesingle{}s} intrinsic coordinate, $ \zeta $ . ~\newline
~\newline

\item Use the \char`\"{}compound\char`\"{} {\ttfamily Geom\+Object} to represent the moving boundary of the fluid mesh. \char`\"{}\+Upgrade\char`\"{} the fluid elements (of type {\ttfamily F\+L\+U\+I\+D\+\_\+\+E\+L\+E\+M\+E\+NT}, say) to the \char`\"{}wrapped\char`\"{} version {\ttfamily Macro\+Element\+Node\+Update\+Element$<$\+F\+L\+U\+I\+D\+\_\+\+E\+L\+E\+M\+E\+N\+T$>$} to allow the the node-\/update to be performed node-\/by-\/node, and to automatically evaluate the \char`\"{}shape derivatives\char`\"{} -- the derivatives of the fluid equations with respect to the (solid mechanics) degrees of freedom that determine their nodal positions. ~\newline
~\newline

\end{DoxyEnumerate}While the implementation of these steps is very straightforward, we pointed out that the resulting code was not particularly efficient as the fluid-\/node update is not as sparse as it could (should!) be\+: Since it is impossible to distinguish between the various sub-\/objects in the \char`\"{}compound\char`\"{} {\ttfamily Geom\+Object}, we can do no better than to assume the worst-\/case scenario, namely that the positional degrees of freedom of all {\ttfamily Solid\+Nodes} in the wall mesh potentially affect the nodal position in all fluid elements. This dramatically increases the size of the elemental Jacobian matrices, and creates many nonzero entries in the off-\/diagonal blocks in the global Jacobian matrix.\hypertarget{index_alg_sparse}{}\section{Sparse algebraic node updates in F\+S\+I problems}\label{index_alg_sparse}
To avoid this problem we need a node-\/update strategy in which the position of each fluid node is determined by only a small number of solid mechanics degrees of freedom. The algebraic node-\/update strategy discussed in the \href{../../../navier_stokes/algebraic_collapsible_channel/html/index.html}{\tt non-\/\+F\+SI version of the collapsible channel problem,} provides an ideal framework for this, as it allows each node to update its own position, using a node-\/specific update function. Recall that in the {\ttfamily Algebraic\+Mesh} -\/ version of the {\ttfamily Collapsible\+Channel\+Mesh}, each {\ttfamily Algebraic\+Node} stored a pointer to the (single) {\ttfamily Geom\+Object} that represented the moving curvilinear boundary, and the Lagrangian coordinate of a reference point on this {\ttfamily Geom\+Object}. The node\textquotesingle{}s node-\/update function then placed the node at a fixed vertical fraction on the line connecting the reference point on the \char`\"{}elastic\char`\"{} wall to a second reference point on the fixed lower channel wall. Furthermore, the \char`\"{}wrapped\char`\"{} element, {\ttfamily Algebraic\+Element$<$\+F\+L\+U\+I\+D\+\_\+\+E\+L\+E\+M\+E\+N\+T$>$}, automatically computes the \char`\"{}shape derivatives\char`\"{} by finite-\/differencing the fluid residuals with respect to the degrees of freedom stored in the {\ttfamily Geom\+Object\textquotesingle{}s} geometric {\ttfamily Data}, just as in the case of the {\ttfamily Macro\+Element} -\/ based node-\/update procedure.

If used in the form discussed in the \href{../../../navier_stokes/algebraic_collapsible_channel/html/index.html}{\tt earlier example,} this methodology does not (yet!) improve the sparsity of the node update\+: The geometric {\ttfamily Data} of the \char`\"{}compound\char`\"{} {\ttfamily Geom\+Object} that represents the wall still contains the positional degrees of freedom of {\itshape all} of the mesh\textquotesingle{}s constituent {\ttfamily F\+S\+I\+Hermite\+Beam\+Elements}. This is wasteful because the position of a material point on the (discretised) wall depends only on the positional degrees of freedom of the element that this point is located in. The (costly-\/to-\/compute) derivatives with respect to all other solid mechanics degree of freedom are zero. We will therefore modify the node-\/update procedure as follows\+: Each {\ttfamily Algebraic\+Node} stores a pointer to the {\ttfamily F\+S\+I\+Hermite\+Beam\+Element} that its reference point is located in. This is possible because {\ttfamily F\+S\+I\+Hermite\+Beam\+Elements} are derived from the {\ttfamily Finite\+Element} class which, in turn, is derived from the {\ttfamily Geom\+Object} class. In other words, the sub-\/objects of the compound {\ttfamily Mesh\+As\+Geom\+Object} are {\ttfamily Geom\+Objects} themselves. Their shape is parametrised by the {\ttfamily F\+S\+I\+Hermite\+Beam\+Element\textquotesingle{}s} local coordinate, $ s $ , which acts as the (sub-\/){\ttfamily Geom\+Object\textquotesingle{}s} intrinsic coordinate, $ \zeta $ .

Given a pointer to a compound {\ttfamily Geom\+Object}, {\ttfamily geom\+\_\+obj\+\_\+pt}, say, and the intrinsic coordinate $ \zeta_{compound} $ = {\ttfamily zeta\+\_\+compound} of a point in that {\ttfamily Geom\+Object}, the function {\ttfamily Geom\+Object\+::locate\+\_\+zeta}(...) may be used to determine a pointer, {\ttfamily sub\+\_\+obj\+\_\+pt}, to the sub-\/object that this point is located in, and the vector of intrinsic coordinates {\ttfamily zeta\+\_\+sub\+\_\+obj} of the point in this sub-\/object. This procedure is illustrated in this code fragment\+:


\begin{DoxyCode}
 [...] 

\textcolor{comment}{// Vector containing the (1D) intrinsic coordinate in the }
\textcolor{comment}{// compound GeomObject:}
Vector<double> zeta\_compound(1);
zeta\_compound[0]=0.3;

\textcolor{comment}{// Pointer to the sub-GeomObject:}
GeomObject* sub\_geom\_obj\_pt;

\textcolor{comment}{// Vector containing the (1D) intrinsic coordinate in the }
\textcolor{comment}{// sub-GeomObject:}
Vector<double> zeta\_sub\_obj(1);

\textcolor{comment}{// Get it...}
geom\_obj\_pt->locate\_zeta(zeta\_compound, sub\_geom\_obj\_pt, zeta\_sub\_obj);


\textcolor{comment}{// Check the result: }

\textcolor{comment}{// Position vector to the point when viewed from}
\textcolor{comment}{// the compound GeomObject}
Vector<double> r\_compound(2);
geom\_obj\_pt->position(zeta\_compound,r\_compound);

\textcolor{comment}{// Position vector to the point when viewed from}
\textcolor{comment}{// the sub-GeomObject}
Vector<double> r\_sub(2);
sub\_geom\_obj\_pt->position(zeta\_sub,r\_sub);

\textcolor{comment}{// With a bit of luck we should now have r\_sub == r\_compound...}

[...]
\end{DoxyCode}


Here is an illustration of the relation between the various coordinates and {\ttfamily Geom\+Objects\+:} 

 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{locate_zeta}
\doxyfigcaption{Sketch of the various coordinates and Geom\+Objects. The (continuous) beam is parametrised by its Lagrangian coordinate xi which doubles as the intrinsic coordinate zeta for its role as a Geom\+Object. The (discretised) beam is a compound Geom\+Object, parametrised by the Lagrangian coordinate xi; its constituent F\+SI beam elements are sub-\/\+Geom\+Objects that are parametrised by their local coordinates, s. }
\end{DoxyImage}


We note that the {\ttfamily Geom\+Object} base class provides a default implementation for the {\ttfamily Geom\+Object\+::locate\+\_\+zeta}(...) function as a virtual member function which returns the {\ttfamily Geom\+Object\textquotesingle{}s} {\ttfamily \char`\"{}this\char`\"{}} pointer and sets $ \zeta_{compound} = \zeta_{sub} $ . Unless the function is overloaded in a specific derived class, the {\ttfamily Geom\+Object} therefore acts as its own sub-\/object. This is a sensible default as it ensures that ({\ttfamily geom\+\_\+obj\+\_\+pt}, $ \zeta_{compound}$ ) and ({\ttfamily sub\+\_\+geom\+\_\+obj\+\_\+pt}, {\ttfamily $ \zeta_{sub}$} ) always identify the same point, regardless of whether nor not the {\ttfamily Geom\+Object} pointed to by {\ttfamily geom\+\_\+obj\+\_\+pt} is a \char`\"{}compound\char`\"{} {\ttfamily Geom\+Object}.



 

\hypertarget{index_impl}{}\section{The implementation}\label{index_impl}
The implementation of the sparse node-\/update strategy requires only a few minor modifications to the {\ttfamily Algebraic\+Collapsible\+Channel\+Mesh}, first discussed in the \href{../../../navier_stokes/algebraic_collapsible_channel/html/index.html}{\tt non-\/\+F\+SI example.}



\hypertarget{index_mesh}{}\subsection{The Algebraic\+Collapsible\+Channel\+Mesh}\label{index_mesh}
We construct the mesh by multiple inheritance, combining the already existing {\ttfamily Collapsible\+Channel\+Mesh} with the {\ttfamily Algebraic\+Mesh} base class\+:

 
\begin{DoxyCodeInclude}
\textcolor{comment}{//========start\_of\_algebraic\_collapsible\_channel\_mesh==============}
\textcolor{comment}{/// Collapsible channel mesh with algebraic node update}
\textcolor{comment}{}\textcolor{comment}{//=================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT>
\textcolor{keyword}{class }AlgebraicCollapsibleChannelMesh : 
  \textcolor{keyword}{public} \textcolor{keyword}{virtual} CollapsibleChannelMesh<ELEMENT>,
  \textcolor{keyword}{public} AlgebraicMesh
\{ 

\end{DoxyCodeInclude}


The constructor calls the constructor of the underlying {\ttfamily Collapsible\+Channel\+Mesh} and then calls the private member function {\ttfamily setup\+\_\+algebraic\+\_\+node\+\_\+update()} to initialise the data for the algebraic node update procedures. (The initialisation is implemented in a separate function so it can be called from additional mesh constructors that are not discussed here.) The destructor remains empty.


\begin{DoxyCodeInclude}

\textcolor{keyword}{public}: 

\textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Constructor: Pass number of elements in upstream/collapsible/}
\textcolor{comment}{ /// downstream segment and across the channel; lengths of upstream/}
\textcolor{comment}{ /// collapsible/downstream segments and width of channel, pointer to }
\textcolor{comment}{ /// GeomObject that defines the collapsible segment and pointer to }
\textcolor{comment}{ /// TimeStepper (defaults to the default timestepper, Steady). }
\textcolor{comment}{} AlgebraicCollapsibleChannelMesh(\textcolor{keyword}{const} \textcolor{keywordtype}{unsigned}& nup, 
                                 \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned}& ncollapsible, 
                                 \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned}& ndown, 
                                 \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned}& ny, 
                                 \textcolor{keyword}{const} \textcolor{keywordtype}{double}& lup, 
                                 \textcolor{keyword}{const} \textcolor{keywordtype}{double}& lcollapsible, 
                                 \textcolor{keyword}{const} \textcolor{keywordtype}{double}& ldown, 
                                 \textcolor{keyword}{const} \textcolor{keywordtype}{double}& ly,
                                 GeomObject* wall\_pt,
                                 TimeStepper* time\_stepper\_pt=
                                 &Mesh::Default\_TimeStepper) :
  CollapsibleChannelMesh<ELEMENT>(nup, ncollapsible, ndown, ny,
                                  lup, lcollapsible, ldown, ly,
                                  wall\_pt,
                                  time\_stepper\_pt)
  \{
   \textcolor{comment}{// Add the geometric object to the list associated with this AlgebraicMesh}
   AlgebraicMesh::add\_geom\_object\_list\_pt(wall\_pt);

   \textcolor{comment}{// Setup algebraic node update operations}
   setup\_algebraic\_node\_update();
  \}
 \textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Destructor: empty}
\textcolor{comment}{} \textcolor{keyword}{virtual} ~AlgebraicCollapsibleChannelMesh()\{\}

\end{DoxyCodeInclude}


The function {\ttfamily algebraic\+\_\+node\+\_\+update}(...) is defined as a pure virtual function in the {\ttfamily Algebraic\+Mesh} base class and therefore must be implemented, whereas the virtual function {\ttfamily update\+\_\+node\+\_\+update}(...) is only required for refineable meshes and can remain empty.


\begin{DoxyCodeInclude}
 \textcolor{comment}{/// \(\backslash\)short Update nodal position at time level t (t=0: present; }
\textcolor{comment}{ /// t>0: previous)}
\textcolor{comment}{} \textcolor{keywordtype}{void} algebraic\_node\_update(\textcolor{keyword}{const} \textcolor{keywordtype}{unsigned}& t, AlgebraicNode*& node\_pt);
 \textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Update the node-udate data after mesh adaptation.}
\textcolor{comment}{ /// Empty -- no update of node update required as this is }
\textcolor{comment}{ /// non-refineable mesh.}
\textcolor{comment}{} \textcolor{keywordtype}{void} update\_node\_update(AlgebraicNode*& node\_pt)\{\}

\textcolor{keyword}{protected}:
\textcolor{comment}{}
\textcolor{comment}{ /// Function to setup the algebraic node update}
\textcolor{comment}{} \textcolor{keywordtype}{void} setup\_algebraic\_node\_update();
\textcolor{comment}{}
\textcolor{comment}{ /// Dummy function pointer }
\textcolor{comment}{} CollapsibleChannelDomain::BLSquashFctPt Dummy\_fct\_pt;

\};

\end{DoxyCodeInclude}


The setup of the algebraic node update is very similar to that used in the \href{../../../navier_stokes/algebraic_collapsible_channel/html/index.html}{\tt non-\/\+F\+SI example discussed earlier.} The main difference between the two versions of the mesh is that we use the function {\ttfamily Geom\+Object\+::locate\+\_\+zeta}(...) to determine the sub-\/{\ttfamily Geom\+Object} within which the reference point on the wall is located. As discussed above, the default implementation of this function in the {\ttfamily Geom\+Object} base class ensures that the mesh can be used with compound and non-\/compound {\ttfamily Geom\+Objects}.

We start by determining the x and y-\/coordinates of the nodes and decide if they are located in the collapsible part of the mesh. (The positions of nodes that are located in the rigid upstream and downstream channel segments do not have to be updated; for such nodes we skip the assignment of the node-\/update data. See the discussion in the \href{../../../navier_stokes/algebraic_collapsible_channel/html/index.html}{\tt non-\/\+F\+SI example} for details.)

 
\begin{DoxyCodeInclude}
\textcolor{comment}{//=====start\_setup=================================================}
\textcolor{comment}{/// Setup algebraic mesh update -- assumes that mesh has}
\textcolor{comment}{}\textcolor{comment}{/// initially been set up with a flush upper wall}
\textcolor{comment}{}\textcolor{comment}{//=================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT>
\textcolor{keywordtype}{void} AlgebraicCollapsibleChannelMesh<ELEMENT>::setup\_algebraic\_node\_update()
\{
 \textcolor{comment}{// Shorthand for some geometric data:}
 \textcolor{keywordtype}{double} l\_up=this->domain\_pt()->l\_up();
 \textcolor{keywordtype}{double} l\_collapsible=this->domain\_pt()->l\_collapsible();

 \textcolor{comment}{// Loop over all nodes in mesh}
 \textcolor{keywordtype}{unsigned} nnod=this->nnode();
 \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} j=0;j<nnod;j++)
  \{
   \textcolor{comment}{// Get pointer to node -- recall that that Mesh::node\_pt(...) has been}
   \textcolor{comment}{// overloaded in the AlgebraicMesh class to return a pointer to }
   \textcolor{comment}{// an AlgebraicNode.}
   AlgebraicNode* nod\_pt=node\_pt(j);

   \textcolor{comment}{// Get coordinates}
   \textcolor{keywordtype}{double} x=nod\_pt->x(0);
   \textcolor{keywordtype}{double} y=nod\_pt->x(1);

   \textcolor{comment}{// Check if it's in the collapsible part:}
   \textcolor{keywordflow}{if} ( (x>=l\_up) && (x<=(l\_up+l\_collapsible)) )

\end{DoxyCodeInclude}


Assuming that the wall is in its undeformed position (we\textquotesingle{}ll check this in a second...), we determine the intrinsic coordinate of the reference point on the upper wall (taking the offset between $ x$ and $ \zeta$ into account\+: The left end of the elastic wall is located at $ \zeta=0$ and at $ x = L_{up} $ ), and identify the sub -\/ {\ttfamily Geom\+Object} within which the reference point is located.


\begin{DoxyCodeInclude}
    \{

     \textcolor{comment}{// Get zeta coordinate on the undeformed wall}
     Vector<double> zeta(1);
     zeta[0]=x-l\_up;

     \textcolor{comment}{// Get pointer to geometric (sub-)object and Lagrangian coordinate}
     \textcolor{comment}{// on that sub-object. For a wall that is represented by }
     \textcolor{comment}{// a single geom object, this simply returns the input.}
     \textcolor{comment}{// If the geom object consists of sub-objects (e.g. }
     \textcolor{comment}{// if it is a finite element mesh representing a wall,}
     \textcolor{comment}{// then we'll obtain the pointer to the finite element}
     \textcolor{comment}{// (in its incarnation as a GeomObject) and the}
     \textcolor{comment}{// local coordinate in that element.}
     GeomObject* geom\_obj\_pt;
     Vector<double> s(1);
     this->Wall\_pt->locate\_zeta(zeta,geom\_obj\_pt,s);

\end{DoxyCodeInclude}


Just to be on the safe side, we double check that the wall is still in its undeformed position\+:


\begin{DoxyCodeInclude}

     \textcolor{comment}{// Get position vector to wall:}
     Vector<double> r\_wall(2);
     geom\_obj\_pt->position(s,r\_wall);

     \textcolor{comment}{// Sanity check: Confirm that the wall is in its undeformed position}
\textcolor{preprocessor}{#ifdef PARANOID}
     \textcolor{keywordflow}{if} ((std::fabs(r\_wall[0]-x)>1.0e-15)&&(std::fabs(r\_wall[1]-y)>1.0e-15))
      \{
       std::ostringstream error\_stream;
       error\_stream 
        << \textcolor{stringliteral}{"Wall must be in its undeformed position when\(\backslash\)n"}
        << \textcolor{stringliteral}{"algebraic node update information is set up!\(\backslash\)n "}
        << \textcolor{stringliteral}{"x-discrepancy: "} << std::fabs(r\_wall[0]-x) << std::endl
        << \textcolor{stringliteral}{"y-discrepancy: "} << std::fabs(r\_wall[1]-y) << std::endl;
       
       \textcolor{keywordflow}{throw} OomphLibError(
        error\_stream.str(),
        OOMPH\_CURRENT\_FUNCTION,
        OOMPH\_EXCEPTION\_LOCATION);
      \}
\textcolor{preprocessor}{#endif }

\end{DoxyCodeInclude}


Now we can create the node update data for the present {\ttfamily Algebraic\+Node}. The node update function involves a single {\ttfamily Geom\+Object\+:} The (sub-\/){\ttfamily Geom\+Object} within which the reference point on the upper wall is located.


\begin{DoxyCodeInclude}
     


     \textcolor{comment}{// One geometric object is involved in update operation}
     Vector<GeomObject*> geom\_object\_pt(1);

     \textcolor{comment}{// The actual geometric object (If the wall is simple GeomObject}
     \textcolor{comment}{// this is the same as Wall\_pt; if it's a compound GeomObject}
     \textcolor{comment}{// this points to the sub-object)}
     geom\_object\_pt[0]=geom\_obj\_pt;

\end{DoxyCodeInclude}


As in the mesh used in the \href{../../../navier_stokes/algebraic_collapsible_channel/html/index.html}{\tt non-\/\+F\+SI example} we store the x-\/coordinate of the reference point on the lower wall, the fractional height of the node, and its intrinsic coordinate in the (sub-\/){\ttfamily Geom\+Object} on the upper wall. We also store the intrinsic coordinate of the reference point in the compound {\ttfamily Geom\+Object} (i.\+e. the Lagrangian coordinate of the reference point in the continuous beam). This will turn out to be useful in the refineable version of this mesh, to be discussed in \href{../../fsi_collapsible_channel_adapt/html/index.html}{\tt the next example.}


\begin{DoxyCodeInclude}

     \textcolor{comment}{// The update function requires four  parameters:}
     Vector<double> ref\_value(4);
     
     \textcolor{comment}{// First reference value: Original x-position }
     ref\_value[0]=r\_wall[0];
     
     \textcolor{comment}{// Second  reference value: fractional position along }
     \textcolor{comment}{// straight line from the bottom (at the original x position)}
     \textcolor{comment}{// to the point on the wall)}
     ref\_value[1]=y/r\_wall[1];
     
     \textcolor{comment}{// Third reference value: Reference local coordinate}
     \textcolor{comment}{// in wall element (local coordinate in FE if we're dealing}
     \textcolor{comment}{// with a wall mesh)}
     ref\_value[2]=s[0];   

     \textcolor{comment}{// Fourth reference value: zeta coordinate on wall}
     \textcolor{comment}{// If the wall is a simple GeomObject, zeta[0]=s[0]}
     \textcolor{comment}{// but if it's a compound GeomObject (e.g. a finite element mesh)}
     \textcolor{comment}{// zeta scales during mesh refinement, whereas s[0] and the}
     \textcolor{comment}{// pointer to the geom object have to be re-computed.}
     ref\_value[3]=zeta[0];     

\end{DoxyCodeInclude}


Finally, we create the node update information by passing the pointer to the mesh, the pointer to the {\ttfamily Geom\+Object} and the reference values to the {\ttfamily Algebraic\+Node}.


\begin{DoxyCodeInclude}
  
     \textcolor{comment}{// Setup algebraic update for node: Pass update information}
     nod\_pt->add\_node\_update\_info(
      \textcolor{keyword}{this},               \textcolor{comment}{// mesh}
      geom\_object\_pt,     \textcolor{comment}{// vector of geom objects}
      ref\_value);         \textcolor{comment}{// vector of  ref. values}
    \}
   
  \}

\} \textcolor{comment}{//end of setup\_algebraic\_node\_update }

\end{DoxyCodeInclude}




\hypertarget{index_driver}{}\section{The driver code}\label{index_driver}
Since {\ttfamily oomph-\/lib\textquotesingle{}s} various node update procedures use the same interfaces, changing the node update strategy from the {\ttfamily Domain/\+Macro\+Element} -\/ based procedure, discussed in the \href{../../fsi_collapsible_channel/html/index.html}{\tt previous example,} to the procedure implemented in the {\ttfamily Algebraic\+Collapsible\+Channel\+Mesh}, only requires minimal changes to the driver code. In fact, the changes are so trivial, that both versions are implemented in the same driver code, \href{../../../../demo_drivers/interaction/fsi_collapsible_channel/fsi_collapsible_channel.cc}{\tt fsi\+\_\+collapsible\+\_\+channel.\+cc}, using compiler flags to switch from one version to the other. If the code is compiled with the flag {\ttfamily -\/\+D\+M\+A\+C\+R\+O\+\_\+\+E\+L\+E\+M\+E\+N\+T\+\_\+\+N\+O\+D\+E\+\_\+\+U\+P\+D\+A\+TE} the {\ttfamily Domain/\+Macro\+Element} -\/ based node-\/update procedure, implemented in the {\ttfamily Macro\+Element\+Node\+Update\+Collapsible\+Channel\+Mesh} is used, otherwise the code uses the {\ttfamily Algebraic\+Collapsible\+Channel\+Mesh}, discussed above. Here is one of the few portions of the code where the distinction between the two versions is required\+: The access function to the \char`\"{}bulk\char`\"{} (fluid) mesh in the problem class.

 
\begin{DoxyCodeInclude}
\textcolor{preprocessor}{#ifdef MACRO\_ELEMENT\_NODE\_UPDATE}
\textcolor{comment}{}
\textcolor{comment}{ /// Access function for the specific bulk (fluid) mesh}
\textcolor{comment}{} MacroElementNodeUpdateCollapsibleChannelMesh<ELEMENT>* bulk\_mesh\_pt() 
  \{
   \textcolor{comment}{// Upcast from pointer to the Mesh base class to the specific }
   \textcolor{comment}{// element type that we're using here.}
   \textcolor{keywordflow}{return} \textcolor{keyword}{dynamic\_cast<}
    MacroElementNodeUpdateCollapsibleChannelMesh<ELEMENT>*\textcolor{keyword}{>}
    (Bulk\_mesh\_pt);
  \}

\textcolor{preprocessor}{#else}
\textcolor{comment}{}
\textcolor{comment}{ /// Access function for the specific bulk (fluid) mesh}
\textcolor{comment}{} AlgebraicCollapsibleChannelMesh<ELEMENT>* bulk\_mesh\_pt() 
  \{
   \textcolor{comment}{// Upcast from pointer to the Mesh base class to the specific }
   \textcolor{comment}{// element type that we're using here.}
   \textcolor{keywordflow}{return} \textcolor{keyword}{dynamic\_cast<}
    AlgebraicCollapsibleChannelMesh<ELEMENT>*\textcolor{keyword}{>}
    (Bulk\_mesh\_pt);
  \}

\textcolor{preprocessor}{#endif}

\end{DoxyCodeInclude}


Incidentally, the driver code also uses compiler flags to switch between Crouzeix-\/\+Raviart and Taylor-\/\+Hood elements for the discretisation of the Navier-\/\+Stokes equations. By default, Crouzeix-\/\+Raviart elements are used; Taylor-\/\+Hood elements are used if the code is compiled with with the flag {\ttfamily -\/\+D\+T\+A\+Y\+L\+O\+R\+\_\+\+H\+O\+OD}.



 

\hypertarget{index_results}{}\section{Results}\label{index_results}
The animations shown below illustrate the interaction between fluid and solid mechanics degrees of freedom in the computations with the algebraic node update. Comparison with the corresponding animations for the {\ttfamily Domain/\+Macro\+Element} -\/ based procedures, shown in the \href{../../fsi_collapsible_channel/html/index.html#comments}{\tt earlier example} demonstrates the greatly improved sparsity of the node update. With the algebraic node-\/update procedures, the residuals of the {\ttfamily F\+S\+I\+Hermite\+Beam\+Elements} now only depend on the fluid degrees of freedom in the adjacent fluid elements and on the solid mechanics degree of freedom in the {\ttfamily F\+S\+I\+Hermite\+Beam\+Elements} that affect the nodal position in these fluid elements.

 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{cr_alg}
\doxyfigcaption{Animation of the Data values that affect the fluid traction that the adjacent fluid elements exert onto the various F\+S\+I\+Hermite\+Beam\+Elements in the wall mesh. (The fluid elements are 2D Crouzeix-\/\+Raviart elements.) }
\end{DoxyImage}


Here is the corresponding animation for a discretisation with 2D Taylor-\/\+Hood elements. These elements have no internal {\ttfamily Data} but the pressure degrees of freedom are stored at the fluid element\textquotesingle{}s corner nodes\+:

 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{th_alg}
\doxyfigcaption{Animation of the Data values that affect the fluid traction that the adjacent fluid elements exert onto the various F\+S\+I\+Hermite\+Beam\+Elements in the wall mesh. (The fluid elements are 2D Taylor-\/\+Hood elements.) }
\end{DoxyImage}


Finally, here is an animation that shows the (solid mechanics) degrees of freedom that affect the node-\/update of a given fluid node. The red square marker shows the fluid node; the green numbers show the number of the degrees of freedom at the {\ttfamily Solid\+Nodes} that are involved that fluid node\textquotesingle{}s node update. With the algebraic node update, the position of each fluid node is only affected by the solid mechanics degree of freedom in the {\ttfamily F\+S\+I\+Hermite\+Beam\+Element} that contains its reference point.

 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{fsi_fluid_nodes}
\doxyfigcaption{Animation of the Data values that affect the node update of the fluid nodes. }
\end{DoxyImage}


The improved sparsity leads to a very significant speedup compared to the {\ttfamily Macro\+Element/\+Domain} -\/ based node update procedure.



 

\hypertarget{index_ex}{}\section{Exercises}\label{index_ex}

\begin{DoxyEnumerate}
\item Demonstrate that the dramatically improved execution speed achieved with the {\ttfamily Algebraic\+Collapsible\+Channel\+Mesh} is mainly due to the improved sparsity of the node update, achieved by using the {\ttfamily Geom\+Object\+::locate\+\_\+zeta}(...) function. ~\newline
~\newline
 {\bfseries Hint\+:} You can either copy the basic {\ttfamily My\+Algebraic\+Collapsible\+Channel\+Mesh} in the file \href{../../../../demo_drivers/navier_stokes/collapsible_channel/my_alg_channel_mesh.h}{\tt my\+\_\+algebraic\+\_\+collapsible\+\_\+channel\+\_\+mesh.\+h}, developed for the \href{../../../navier_stokes/algebraic_collapsible_channel/html/index.html}{\tt non-\/\+F\+SI version of the collapsible channel problem,} into the F\+SI driver code \href{../../../../demo_drivers/interaction/fsi_collapsible_channel/fsi_collapsible_channel.cc}{\tt fsi\+\_\+collapsible\+\_\+channel.\+cc} and use that mesh instead of the {\ttfamily Algebraic\+Collapsible\+Channel\+Mesh}, or replace the line ~\newline
~\newline

\begin{DoxyCode}
this->Wall\_pt->locate\_zeta(zeta,geom\_obj\_pt,s);
\end{DoxyCode}
 ~\newline
~\newline
 in the function {\ttfamily Algebraic\+Collapsible\+Channel\+Mesh$<$\+E\+L\+E\+M\+E\+N\+T$>$\+::setup\+\_\+algebraic\+\_\+node\+\_\+update()} in \href{../../../../src/meshes/collapsible_channel_mesh.template.cc}{\tt collapsible\+\_\+channel\+\_\+mesh.\+template.\+cc} by ~\newline
~\newline

\begin{DoxyCode}
this->Wall\_pt->GeomObject::locate\_zeta(zeta,geom\_obj\_pt,s);
\end{DoxyCode}
 ~\newline
~\newline
 thus bypassing the \char`\"{}sparsification\char`\"{}. ~\newline
~\newline

\item Explore how the speedup achievable with the algebraic node update procedure depends on the mesh resolution. A speedup by a factor of ten is typical for computations on the coarse mesh used for the validation runs; much more dramatic speedups tend to be obtained on finer meshes. ~\newline
~\newline

\end{DoxyEnumerate}



 

\hypertarget{index_sources}{}\section{Source files for this tutorial}\label{index_sources}

\begin{DoxyItemize}
\item The source files for this tutorial are located in the directory\+:~\newline
~\newline
\begin{center} \href{../../../../demo_drivers/interaction/fsi_collapsible_channel/}{\tt demo\+\_\+drivers/interaction/fsi\+\_\+collapsible\+\_\+channel/ } \end{center} ~\newline

\item The driver code is\+: ~\newline
~\newline
\begin{center} \href{../../../../demo_drivers/interaction/fsi_collapsible_channel/fsi_collapsible_channel.cc}{\tt demo\+\_\+drivers/interaction/fsi\+\_\+collapsible\+\_\+channel/fsi\+\_\+collapsible\+\_\+channel.\+cc } \end{center} 
\end{DoxyItemize}

 

 \hypertarget{index_pdf}{}\section{P\+D\+F file}\label{index_pdf}
A \href{../latex/refman.pdf}{\tt pdf version} of this document is available. \end{document}
