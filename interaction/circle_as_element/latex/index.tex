In many previous examples we demonstrated how to use {\ttfamily Geom\+Objects} to parametrise curvilinear, moving domain boundaries. We used this functionality extensively to perform simulations of problems in moving domains. The techniques illustrated in these examples are adequate for problems in which the motion of the boundary is prescribed; see e.\+g. the \href{../../../navier_stokes/collapsible_channel/html/index.html}{\tt simulation of fluid flow in a 2D channel in which a part of one channel wall performs a prescribed oscillation}.

Here we shall demonstrate how to use {\ttfamily Geom\+Objects} to parametrise curvilinear, moving domain boundaries in problem in which the position of the boundary is unknown and has to be determined as part of the overall solution. We will also address the following questions\+:
\begin{DoxyItemize}
\item What is a {\ttfamily Geom\+Object\textquotesingle{}s} geometric {\ttfamily Data}?
\item What is a {\ttfamily Generalised\+Element\textquotesingle{}s} external and internal {\ttfamily Data}?
\end{DoxyItemize}



 

\hypertarget{index_geom_data}{}\section{Part 1\+: A closer look at the Geom\+Object class\+: Geometric Data}\label{index_geom_data}
In an \href{../../../poisson/fish_poisson2/html/index.html}{\tt earlier example}, we introduced the {\ttfamily Geom\+Object} as a base class for all objects that provide an analytical parametrisation of a geometric object by specifying its Eulerian coordinates (i.\+e. the position vector to \char`\"{}material points\char`\"{} in the object, $ {\bf r}$) as a function of some intrinsic (Lagrangian) coordinates, $ {\bf \zeta} $, so that $ {\bf r} = {\bf r}({\bf \zeta})$. Every specific {\ttfamily Geom\+Object} must implement the pure virtual function


\begin{DoxyCode}
\textcolor{keywordtype}{void} GeomObject::position(\textcolor{keyword}{const} Vector<double>& zeta, Vector<double>& r);
\end{DoxyCode}


where the number of Lagrangian and Eulerian coordinates involved in the parametrisation (i.\+e. the sizes of the vectors {\ttfamily zeta} and {\ttfamily r}) are stored as unsigned integers in the protected member data, {\ttfamily Geom\+Object\+::\+N\+Lagrangian} and {\ttfamily Geom\+Object\+::\+Ndim}, respectively.

Most specific geometric objects store some additional parameters as private data members. For instance, a {\ttfamily Geom\+Object} that represents a 2D circle, parametrised by the 1D Lagrangian coordinate $ \zeta $ as \[ {\bf r}(\zeta)= \left( \begin{array}{c} X_c + R \cos(\zeta) \\ Y_c + R \sin(\zeta) \end{array} \right) \] may be implemented as follows\+:

 
\begin{DoxyCodeInclude}
\textcolor{comment}{//=====start\_of\_circle=====================================================}
\textcolor{comment}{/// \(\backslash\)short Simple circle in 2D space.}
\textcolor{comment}{}\textcolor{comment}{/// \(\backslash\)f[ x = X\_c + R \(\backslash\)cos(\(\backslash\)zeta)  \(\backslash\)f]}
\textcolor{comment}{}\textcolor{comment}{/// \(\backslash\)f[ y = Y\_c + R \(\backslash\)sin(\(\backslash\)zeta)  \(\backslash\)f]}
\textcolor{comment}{}\textcolor{comment}{//=========================================================================}
\textcolor{keyword}{class }SimpleCircle : \textcolor{keyword}{public} GeomObject
\{

\textcolor{keyword}{public}:
\textcolor{comment}{}
\textcolor{comment}{ /// Constructor:  Pass x and y-coords of centre and radius}
\textcolor{comment}{} SimpleCircle(\textcolor{keyword}{const} \textcolor{keywordtype}{double}& x\_c, \textcolor{keyword}{const} \textcolor{keywordtype}{double}& y\_c, 
               \textcolor{keyword}{const} \textcolor{keywordtype}{double}& r) : GeomObject(1,2), X\_c(x\_c), Y\_c(y\_c), R(r)
  \{\}
\textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Position Vector at Lagrangian coordinate zeta }
\textcolor{comment}{} \textcolor{keywordtype}{void} position(\textcolor{keyword}{const} Vector<double>& zeta, Vector<double>& r)\textcolor{keyword}{ const}
\textcolor{keyword}{  }\{
   \textcolor{comment}{// Position vector}
   r[0] = X\_c+R*cos(zeta[0]);
   r[1] = Y\_c+R*sin(zeta[0]);
  \}
\textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Position Vector at Lagrangian coordinate zeta  at time level t}
\textcolor{comment}{ /// (t=0: present; t>0: previous level). Steady object, so we }
\textcolor{comment}{ /// simply forward the call to the steady version.}
\textcolor{comment}{} \textcolor{keywordtype}{void} position(\textcolor{keyword}{const} \textcolor{keywordtype}{unsigned}& t, \textcolor{keyword}{const} Vector<double>& zeta,
               Vector<double>& r)\textcolor{keyword}{ const}
\textcolor{keyword}{  }\{position(zeta,r);\}

\textcolor{keyword}{protected}:
\textcolor{comment}{}
\textcolor{comment}{ /// X-coordinate of centre}
\textcolor{comment}{} \textcolor{keywordtype}{double} X\_c;
\textcolor{comment}{}
\textcolor{comment}{ /// Y-coordinate of centre}
\textcolor{comment}{} \textcolor{keywordtype}{double} Y\_c;
\textcolor{comment}{}
\textcolor{comment}{ /// Radius}
\textcolor{comment}{} \textcolor{keywordtype}{double} R;

\}; \textcolor{comment}{// end of SimpleCircle class}

\end{DoxyCodeInclude}


The shape and position of this {\ttfamily Geom\+Object} is defined by the parameters $ X_c, Y_c $ and $ R $ which are stored as double precision numbers in the object\textquotesingle{}s private member data.

In many applications (e.\+g. in free-\/boundary problems) it is necessary to regard some (or all) of the parameters that specify the object\textquotesingle{}s shape as (an) unknown(s) in the overall problem. Within {\ttfamily oomph-\/lib} all unknowns are values in {\ttfamily Data} objects. We refer to any {\ttfamily Data} objects whose values affect the shape of a {\ttfamily Geom\+Object} as the {\ttfamily Geom\+Object\textquotesingle{}s} geometric {\ttfamily Data}. The {\ttfamily Geom\+Object} class defines interfaces for two functions that provide access to such {\ttfamily Data}. The function


\begin{DoxyCode}
\textcolor{keyword}{virtual} \textcolor{keywordtype}{unsigned} GeomObject::ngeom\_data() \textcolor{keyword}{const};
\end{DoxyCode}


should return the number of geometric {\ttfamily Data} objects that affect a {\ttfamily Geom\+Object\textquotesingle{}s} shape and position. The function


\begin{DoxyCode}
\textcolor{keyword}{virtual} Data* GeomObject::geom\_data\_pt(\textcolor{keyword}{const} \textcolor{keywordtype}{unsigned}& j);
\end{DoxyCode}


should return a pointer to the {\ttfamily Geom\+Object\textquotesingle{}s} {\ttfamily j} -\/ th geometric {\ttfamily Data} object. Both functions are implemented as \char`\"{}broken\char`\"{} virtual functions in the {\ttfamily Geom\+Object} base class in order to facilitate the creation of new {\ttfamily Geom\+Objects}. The functions should be overloaded in {\ttfamily Geom\+Objects} that actually contain geometric {\ttfamily Data}. If this is not done, the broken versions in the base class issue a suitable explanation before throwing an error.

Here is a re-\/implementation of the above {\ttfamily Geom\+Object} in a form that allows the the parameters $ X_c, Y_c $ and $ R $ to be regarded as unknowns, by storing them as values in a suitable {\ttfamily Data} object\+:


\begin{DoxyCodeInclude}
\textcolor{comment}{//=========================================================================}
\textcolor{comment}{/// \(\backslash\)short GeneralCircle in 2D space.}
\textcolor{comment}{}\textcolor{comment}{/// \(\backslash\)f[ x = X\_c + R \(\backslash\)cos(\(\backslash\)zeta)  \(\backslash\)f]}
\textcolor{comment}{}\textcolor{comment}{/// \(\backslash\)f[ y = Y\_c + R \(\backslash\)sin(\(\backslash\)zeta)  \(\backslash\)f]}
\textcolor{comment}{}\textcolor{comment}{/// The three parameters \(\backslash\)f$ X\_c, Y\_c \(\backslash\)f$ and \(\backslash\)f$ R \(\backslash\)f$ are represented}
\textcolor{comment}{}\textcolor{comment}{/// by Data and can therefore be unknowns in the problem.}
\textcolor{comment}{}\textcolor{comment}{//=========================================================================}
\textcolor{keyword}{class }GeneralCircle : \textcolor{keyword}{public} GeomObject
\{

\end{DoxyCodeInclude}


The object has two constructors which we will discuss separately. The arguments to the first constructor specify the x-\/ and y-\/coordinates of the ring\textquotesingle{}s centre ( $ X_c$ and $ Y_c$), and its radius, $ R $, as double-\/precision numbers. The constructor creates storage for these values in the {\ttfamily Geom\+\_\+data\+\_\+pt} vector which is stored in the object\textquotesingle{}s protected member data. First, the {\ttfamily Geom\+\_\+data\+\_\+pt} vector (empty by default) is resized to provide storage for a (pointer to a) single Data item. Next we create a Data object that provides storage for three values and store the pointer to this {\ttfamily Data} object in the first (and only) component of the {\ttfamily Geom\+\_\+data\+\_\+pt} vector. Finally, we set the values to those specified by the arguments and pin them to reflect the fact that, by default, the values are constants rather than unknowns in the problem. \mbox{[}{\bfseries Note\+:} Clearly, there is some ambiguity as to how to distribute the values of the geometric parameters among the geometric {\ttfamily Data}. Here we chose to store the three values in a single {\ttfamily Data} object, but we could also have stored each value in its own {\ttfamily Data} object.\mbox{]}


\begin{DoxyCodeInclude}
 \textcolor{comment}{/// Constructor:  Pass x and y-coords of centre and radius (all pinned)}
 GeneralCircle(\textcolor{keyword}{const} \textcolor{keywordtype}{double}& x\_c, \textcolor{keyword}{const} \textcolor{keywordtype}{double}& y\_c, 
               \textcolor{keyword}{const} \textcolor{keywordtype}{double}& r) : GeomObject(1,2)
  \{
   \textcolor{comment}{// Create Data: We have one Data item with 3 values. The Data object}
   \textcolor{comment}{// stores the x position of the circle's centre as value 0,}
   \textcolor{comment}{// the y position of the circle's centre as value 1, and the }
   \textcolor{comment}{// circle's radius as value 2.}
   Geom\_data\_pt.resize(1);
   Geom\_data\_pt[0] = \textcolor{keyword}{new} Data(3);
   
   \textcolor{comment}{// Assign data: X\_c -- the value is free by default: Need to pin it.}

   \textcolor{comment}{// Pin the data}
   Geom\_data\_pt[0]->pin(0); 
   \textcolor{comment}{// Give it a value: }
   Geom\_data\_pt[0]->set\_value(0,x\_c);

   \textcolor{comment}{// Assign data: Y\_c -- the value is free by default: Need to pin it.}

   \textcolor{comment}{// Pin the data}
   Geom\_data\_pt[0]->pin(1); 
   \textcolor{comment}{// Give it a value: }
   Geom\_data\_pt[0]->set\_value(1,y\_c);

   \textcolor{comment}{// Assign data: R -- the value is free by default: Need to pin it.}

   \textcolor{comment}{// Pin the data}
   Geom\_data\_pt[0]->pin(2); 
   \textcolor{comment}{// Give it a value: }
   Geom\_data\_pt[0]->set\_value(2,r);

   \textcolor{comment}{// I've created the data, I need to clean up}
   Must\_clean\_up=\textcolor{keyword}{true}; 
  \}

\end{DoxyCodeInclude}


With this constructor, the geometric {\ttfamily Data} that controls the shape of the object is created internally -- the \char`\"{}user\char`\"{} only specifies the values of the parameters. Their values are accessible via the access functions


\begin{DoxyCodeInclude}
 \textcolor{comment}{/// Access function to x-coordinate of centre of circle}
 \textcolor{keywordtype}{double}& x\_c()\{\textcolor{keywordflow}{return} *Geom\_data\_pt[0]->value\_pt(0);\}
\textcolor{comment}{}
\textcolor{comment}{ /// Access function to y-coordinate of centre of circle}
\textcolor{comment}{} \textcolor{keywordtype}{double}& y\_c()\{\textcolor{keywordflow}{return} *Geom\_data\_pt[0]->value\_pt(1);\}
\textcolor{comment}{}
\textcolor{comment}{ /// Access function to radius of circle}
\textcolor{comment}{} \textcolor{keywordtype}{double}& R()\{\textcolor{keywordflow}{return} *Geom\_data\_pt[0]->value\_pt(2);\}

\end{DoxyCodeInclude}


but their internal representation as (pinned) values of a {\ttfamily Data} object remains hidden. Access to the geometric {\ttfamily Data} is, however, possible via the functions


\begin{DoxyCodeInclude}
 \textcolor{comment}{/// How many items of Data does the shape of the object depend on?}
 \textcolor{keywordtype}{unsigned} ngeom\_data()\textcolor{keyword}{ const }\{\textcolor{keywordflow}{return} Geom\_data\_pt.size();\}
 \textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Return pointer to the j-th Data item that the object's }
\textcolor{comment}{ /// shape depends on }
\textcolor{comment}{} Data* geom\_data\_pt(\textcolor{keyword}{const} \textcolor{keywordtype}{unsigned}& j) \{\textcolor{keywordflow}{return} Geom\_data\_pt[j];\}

\end{DoxyCodeInclude}


which overload the broken versions in the {\ttfamily Geom\+Object} base class. Both functions access the protected vector of pointers to the object\textquotesingle{}s geometric {\ttfamily Data\+:} 


\begin{DoxyCodeInclude}
\textcolor{keyword}{protected}:
\textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Vector of pointers to Data items that affects the object's shape}
\textcolor{comment}{} Vector<Data*> Geom\_data\_pt;

\end{DoxyCodeInclude}


The second constructor is appropriate for cases in which the {\ttfamily Data} object that specifies the object\textquotesingle{}s shape has already been created elsewhere. In this case, we simply pass the pointer to the Data object to the constructor and store it in the first entry of the {\ttfamily Geom\+\_\+data\+\_\+pt} vector\+:  
\begin{DoxyCodeInclude}
 \textcolor{comment}{/// \(\backslash\)short Alternative constructor:  Pass x and y-coords of centre and radius}
\textcolor{comment}{ /// (all as part of Data)}
\textcolor{comment}{}\textcolor{comment}{ /// \(\backslash\)code }
\textcolor{comment}{}\textcolor{comment}{ /// Geom\_data\_pt[0]->value(0) = X\_c;}
\textcolor{comment}{}\textcolor{comment}{ /// Geom\_data\_pt[0]->value(1) = Y\_c;}
\textcolor{comment}{}\textcolor{comment}{ /// Geom\_data\_pt[0]->value(2) = R;}
\textcolor{comment}{}\textcolor{comment}{ /// \(\backslash\)endcode}
\textcolor{comment}{} GeneralCircle(Data* geom\_data\_pt) : GeomObject(1,2)
  \{
\textcolor{preprocessor}{#ifdef PARANOID}
   \textcolor{keywordflow}{if} (geom\_data\_pt->nvalue()!=3)
    \{
     std::ostringstream error\_stream;
     error\_stream << \textcolor{stringliteral}{"Geometric Data must have 3 values, not "}
                  << geom\_data\_pt->nvalue() << std::endl;

     \textcolor{keywordflow}{throw} OomphLibError(error\_stream.str(),
                         OOMPH\_CURRENT\_FUNCTION,
                         OOMPH\_EXCEPTION\_LOCATION);
    \}
\textcolor{preprocessor}{#endif}
   Geom\_data\_pt.resize(1);
   Geom\_data\_pt[0]=geom\_data\_pt;

   \textcolor{comment}{// Data has been created externally: Must not clean up}
   Must\_clean\_up=\textcolor{keyword}{false};

  \} \textcolor{comment}{//end of alternative constructor}

\end{DoxyCodeInclude}


The boolean flag {\ttfamily Must\+\_\+clean\+\_\+up} is stored as private member data in the class. It is used in the destructor to decide if the geometric {\ttfamily Data} should be deleted. If the {\ttfamily Data} was created internally by the object (i.\+e. if the first constructor was used), the {\ttfamily Data} must also be deleted by the object; if the {\ttfamily Data} was created externally (i.\+e. if the second constructor was used), the {\ttfamily Data} must not be deleted as it may still be required in other parts of the code.


\begin{DoxyCodeInclude}
 \textcolor{comment}{/// Destructor:  Clean up if necessary}
 \textcolor{keyword}{virtual} ~GeneralCircle()
  \{
   \textcolor{comment}{// Do I need to clean up?}
   \textcolor{keywordflow}{if} (Must\_clean\_up)
    \{
     \textcolor{keywordtype}{unsigned} ngeom\_data=Geom\_data\_pt.size();
     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} i=0;i<ngeom\_data;i++)
      \{
       \textcolor{keyword}{delete} Geom\_data\_pt[i];
       Geom\_data\_pt[i]=0;
      \}
    \}
  \} \textcolor{comment}{// end of destructor}

\end{DoxyCodeInclude}


The function {\ttfamily Geom\+Object\+::position}(...) simply extracts the relevant parameters ( $ X_c, Y_c, R $) from the {\ttfamily Geom\+\_\+data\+\_\+pt} vector and computes the position vector as a function of the 1D Lagrangian coordinate $ \zeta $\+:


\begin{DoxyCodeInclude}
 \textcolor{comment}{/// \(\backslash\)short Position Vector at Lagrangian coordinate zeta }
 \textcolor{keywordtype}{void} position(\textcolor{keyword}{const} Vector<double>& zeta, Vector<double>& r)\textcolor{keyword}{ const}
\textcolor{keyword}{  }\{
   \textcolor{comment}{// Extract data}
   \textcolor{keywordtype}{double} X\_c= Geom\_data\_pt[0]->value(0);
   \textcolor{keywordtype}{double} Y\_c= Geom\_data\_pt[0]->value(1);
   \textcolor{keywordtype}{double} R= Geom\_data\_pt[0]->value(2);

   \textcolor{comment}{// Position vector}
   r[0] = X\_c+R*cos(zeta[0]);
   r[1] = Y\_c+R*sin(zeta[0]);

  \} \textcolor{comment}{// end of position(...)}

\end{DoxyCodeInclude}




 

\hypertarget{index_example}{}\section{Part 2\+: Upgrading a Geom\+Object to a Generalised\+Element}\label{index_example}
We will now consider a (toy!) problem in which the ability to treat a parameter that specifies the shape and/or the position of a geometric object as an unknown (i.\+e. as a value in a {\ttfamily Data} object) is essential\+: A circular ring of radius $ R $ is mounted on a linearly elastic spring of stiffness $ k_{stiff} $. We wish to find the ring\textquotesingle{}s equilibrium position when it is subjected to a vertical load, $ f_{load} $.

 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{circle_as_element_sketch}
\doxyfigcaption{Sketch of the example problem. }
\end{DoxyImage}


To solve this problem with {\ttfamily oomph-\/lib} \mbox{[}Yes, the solution is $ Y_c = f_{load}/k_{stiff}$ but let\textquotesingle{}s pretend we don\textquotesingle{}t know this...\mbox{]}, we employ C++ inheritance to \char`\"{}upgrade\char`\"{} the {\ttfamily General\+Circle} object, discussed above, to a {\ttfamily Generalised\+Element} in which the vertical position of the ring, $ Y_c $, is one of the unknowns whose value is determined by the equilibrium equation (in residual form), \[ f_{load} - Y_c \ k_{stiff} = 0. \ \ \ \ \ \ \ \ \ \ \ (1) \] In the present problem, the load on the ring is a control parameter, but in different applications it may be an unknown whose value has to be determined as part of the solution. (For instance, in fluid-\/structure interaction problems, the load on an elastic structure depends on the unknowns in the adjacent fluid elements.) Therefore, we also represent $ f_{load} $ by a {\ttfamily Data} object.

To solve the above problem with {\ttfamily oomph-\/lib}, the residual equation (1) must be implemented in the {\ttfamily get\+\_\+residuals}(...) function of a suitable {\ttfamily Generalised\+Element}. Recall that the elemental residual vector computed by a {\ttfamily Generalised\+Element} can depend on two types of {\ttfamily Data\+:} 
\begin{DoxyItemize}
\item {\bfseries Internal {\itshape Data}} stores values that are \char`\"{}internal\char`\"{} to the element, i.\+e. values that the element is \char`\"{}in charge of\char`\"{}. Such {\ttfamily Data} is accessible via the pointer-\/based access function {\ttfamily Generalised\+Element\+::internal\+\_\+data\+\_\+pt}(...)
\item {\bfseries External {\itshape Data}} stores values that are \char`\"{}external\char`\"{} to the element. The values stored in such {\ttfamily Data} {\itshape affect} the element\textquotesingle{}s residual vector but its values are not determined {\itshape by} the element. Such {\ttfamily Data} is accessible via the pointer-\/based access function {\ttfamily Generalised\+Element\+::external\+\_\+data\+\_\+pt}(...)
\end{DoxyItemize}In the present context, it is most natural to regard the {\ttfamily General\+Circle\textquotesingle{}s} geometric {\ttfamily Data} as internal to the element and the load {\ttfamily Data} as external.

Here is the class definition for the {\ttfamily Elastically\+Supported\+Ring\+Element} which combines the {\ttfamily Generalised\+Element} and {\ttfamily General\+Circle} classes by multiple inheritance. Its role as a {\ttfamily Geom\+Object} allows the object to be used in the parametrisation of domain boundaries; its role as a {\ttfamily Generalised\+Element} allows the value of $ Y_c $ to be determined as part of the solution.

 
\begin{DoxyCodeInclude}
\textcolor{comment}{//===========start\_of\_general\_circle=========================================}
\textcolor{comment}{/// \(\backslash\)short GeneralCircle "upgraded" to a GeneralisedElement: Circular }
\textcolor{comment}{}\textcolor{comment}{/// ring whose position is given by}
\textcolor{comment}{}\textcolor{comment}{/// \(\backslash\)f[ x = X\_c + R \(\backslash\)cos(\(\backslash\)zeta)  \(\backslash\)f]}
\textcolor{comment}{}\textcolor{comment}{/// \(\backslash\)f[ y = Y\_c + R \(\backslash\)sin(\(\backslash\)zeta)  \(\backslash\)f]}
\textcolor{comment}{}\textcolor{comment}{/// The ring's vertical position \(\backslash\)f$ Y\_c \(\backslash\)f$ is}
\textcolor{comment}{}\textcolor{comment}{/// determined by "pseudo elasticity":}
\textcolor{comment}{}\textcolor{comment}{/// \(\backslash\)f[}
\textcolor{comment}{}\textcolor{comment}{/// 0 = f\_\{load\} - Y\_c \(\backslash\) k\_\{stiff\} }
\textcolor{comment}{}\textcolor{comment}{/// \(\backslash\)f]}
\textcolor{comment}{}\textcolor{comment}{/// This simulates the case where the centre of the ring is mounted on }
\textcolor{comment}{}\textcolor{comment}{/// an elastic spring of stiffness \(\backslash\)f$ k\_\{stiff\} \(\backslash\)f$ and loaded by }
\textcolor{comment}{}\textcolor{comment}{/// the force \(\backslash\)f$ f\_\{load\}. \(\backslash\)f$ The "load" is specified by the }
\textcolor{comment}{}\textcolor{comment}{/// Data object \(\backslash\)c load\_pt(). }
\textcolor{comment}{}\textcolor{comment}{//=========================================================================}
\textcolor{keyword}{class }ElasticallySupportedRingElement : \textcolor{keyword}{public} GeneralisedElement, 
                                        \textcolor{keyword}{public} GeneralCircle

\end{DoxyCodeInclude}


The arguments to the constructor specify the initial geometric parameters, $ X_c, Y_c $ and $ R $. We pass them to the constructor of the {\ttfamily General\+Circle} object and assign a default value for the spring stiffness $ k_{stiff}$ (stored as a private data member of the class; see below)\+:  
\begin{DoxyCodeInclude}
 \textcolor{comment}{/// \(\backslash\)short Constructor: Build  ring from doubles that describe }
\textcolor{comment}{ /// the geometry: x and y positions of centre and the radius.}
\textcolor{comment}{}\textcolor{comment}{ /// Initialise stiffness to 1.0. By default, no load is set.}
\textcolor{comment}{} ElasticallySupportedRingElement(\textcolor{keyword}{const} \textcolor{keywordtype}{double}& x\_c, \textcolor{keyword}{const} \textcolor{keywordtype}{double}& y\_c, 
                                 \textcolor{keyword}{const} \textcolor{keywordtype}{double}& r) : 
  GeneralCircle(x\_c,y\_c,r), K\_stiff(1.0), Load\_data\_has\_been\_set(false)

\end{DoxyCodeInclude}


Next, we add the {\ttfamily General\+Circle\textquotesingle{}s} geometric {\ttfamily Data} (created automatically by the constructor of the {\ttfamily General\+Circle} object; see above) into the element\textquotesingle{}s storage for its internal {\ttfamily Data}. This ensures that the geometric {\ttfamily Data} is included in the element\textquotesingle{}s equation numbering procedures. Within the context of the {\ttfamily General\+Circle}, all geometric parameters were regarded as constants and their values were pinned. Here, the vertical position \mbox{[}stored in the second entry in the geometric {\ttfamily Data}\mbox{]} is unknown, therefore we un-\/pin it.


\begin{DoxyCodeInclude}
  \{
   \textcolor{comment}{// The geometric data is internal to the element -- we copy the pointers}
   \textcolor{comment}{// to the GeomObject's geometric data to the element's internal }
   \textcolor{comment}{// data to ensure that any unknown values of geometric data are }
   \textcolor{comment}{// given global equation numbers. The add\_internal\_data(...)}
   \textcolor{comment}{// function returns the index by which the added Data item}
   \textcolor{comment}{// is accessible from internal\_data\_pt(...). }
   Internal\_geometric\_data\_index=add\_internal\_data(Geom\_data\_pt[0]);

   \textcolor{comment}{// Geometric Data for the GeomObject has been set up (and pinned) in}
   \textcolor{comment}{// constructor for geometric object. Now free the y-position }
   \textcolor{comment}{// of the centre because we want to determine it as an unknown}
   internal\_data\_pt(Internal\_geometric\_data\_index)->unpin(1);

\end{DoxyCodeInclude}


Once {\ttfamily Data} has been added to a {\ttfamily Generalised\+Element\textquotesingle{}s} internal {\ttfamily Data}, it is deleted by the destructor of the {\ttfamily Generalised\+Element} when the {\ttfamily Generalised\+Element} goes out of scope. The {\ttfamily Data} must therefore not be deleted again by the destructor of the {\ttfamily General\+Circle} class, and we change the cleanup responsibilities accordingly\+:

 
\begin{DoxyCodeInclude}
   \textcolor{comment}{// Change cleanup responsibilities: The GeomData will now be killed}
   \textcolor{comment}{// by the GeneralisedElement when it wipes its internal Data}
   Must\_clean\_up=\textcolor{keyword}{false};
  \}

\end{DoxyCodeInclude}


Since the {\ttfamily Generalised\+Element\textquotesingle{}s} destructor will delete the internal {\ttfamily Data}, the destructor can remain empty\+: 
\begin{DoxyCodeInclude}
 \textcolor{comment}{/// Destructor: }
 \textcolor{keyword}{virtual} ~ElasticallySupportedRingElement()
  \{
   \textcolor{comment}{// The GeomObject's GeomData is mirrored in the element's}
   \textcolor{comment}{// Internal Data and therefore gets wiped in the}
   \textcolor{comment}{// destructor of GeneralisedElement --> No need to kill it here}
  \}

\end{DoxyCodeInclude}


The {\ttfamily Data} whose one-\/and-\/only value represents the load must be set by the \char`\"{}user\char`\"{}, using the function {\ttfamily set\+\_\+load\+\_\+pt}(...) As discussed above, we store the pointer to the load {\ttfamily Data} object in the {\ttfamily Generalised\+Element\textquotesingle{}s} external {\ttfamily Data} and record its index within that storage scheme.

 
\begin{DoxyCodeInclude}
 \textcolor{comment}{/// \(\backslash\)short Set pointer to Data object that specifies the "load"}
\textcolor{comment}{ /// on the ElasticallySupportedRingElement}
\textcolor{comment}{} \textcolor{keywordtype}{void} set\_load\_pt(Data* load\_pt)
  \{
\textcolor{preprocessor}{#ifdef PARANOID}
   \textcolor{keywordflow}{if} (load\_pt->nvalue()!=1)
    \{
     std::ostringstream error\_stream;
     error\_stream << \textcolor{stringliteral}{"The data object that stores the load on the "}
                  << \textcolor{stringliteral}{"ElasticallySupportedRingElement\(\backslash\)n"}
                  << \textcolor{stringliteral}{"should only contain a single data value\(\backslash\)n"}
                  << \textcolor{stringliteral}{"This one contains "} << load\_pt->nvalue() << std::endl;

     \textcolor{keywordflow}{throw} OomphLibError(error\_stream.str(),
                         OOMPH\_CURRENT\_FUNCTION,
                         OOMPH\_EXCEPTION\_LOCATION);
    \}
\textcolor{preprocessor}{#endif}

   \textcolor{comment}{// Add load to the element's external data and store}
   \textcolor{comment}{// its index within that storage scheme: Following this assignment, }
   \textcolor{comment}{// the load Data is accessible from}
   \textcolor{comment}{// GeneralisedElement::external\_data\_pt(External\_load\_index)}
   External\_load\_index = add\_external\_data(load\_pt);

   \textcolor{comment}{// Load has now been set}
   Load\_data\_has\_been\_set=\textcolor{keyword}{true};

  \} \textcolor{comment}{// end of set\_load\_pt(...)}

\end{DoxyCodeInclude}


\mbox{[}Note the sanity check which asserts that the load {\ttfamily Data} object only contains a single value; see \hyperlink{index_notes}{Comments and Exercises} for a further discussion of this aspect.\mbox{]}

The {\ttfamily load()} function provides access to the load specified by the load {\ttfamily Data}. It returns zero if no load was set -- a sensible default.


\begin{DoxyCodeInclude}
 \textcolor{comment}{/// "Load" acting on the ring}
 \textcolor{keywordtype}{double} load()
  \{
   \textcolor{comment}{// Return the load if it has been set}
   \textcolor{keywordflow}{if} (Load\_data\_has\_been\_set)
    \{
     \textcolor{keywordflow}{return} external\_data\_pt(External\_load\_index)->value(0);
    \}
   \textcolor{comment}{// ...otherwise return zero load}
   \textcolor{keywordflow}{else}
    \{
     \textcolor{keywordflow}{return} 0.0;
    \}
  \} \textcolor{comment}{// end of load()}

\end{DoxyCodeInclude}


Next, we provide an access functions to the spring stiffness parameter, 
\begin{DoxyCodeInclude}
 \textcolor{comment}{/// Access function for the spring stiffness}
 \textcolor{keywordtype}{double}& k\_stiff() \{\textcolor{keywordflow}{return} K\_stiff;\}

\end{DoxyCodeInclude}


and functions that allow the vertical displacement of the ring to be pinned and un-\/pinned\+:


\begin{DoxyCodeInclude}
 \textcolor{comment}{/// Pin the vertical displacement}
 \textcolor{keywordtype}{void} pin\_yc()
  \{
   \textcolor{comment}{// Vertical position of centre is stored as value 1 in the}
   \textcolor{comment}{// element's one and only internal Data object.}
   internal\_data\_pt(Internal\_geometric\_data\_index)->pin(1);
  \}

\textcolor{comment}{}
\textcolor{comment}{ /// Unpin the vertical displacement}
\textcolor{comment}{} \textcolor{keywordtype}{void} unpin\_yc()
  \{
   \textcolor{comment}{// Vertical position of centre is stored as value 1 in the}
   \textcolor{comment}{// element's one and only internal Data object.}
   internal\_data\_pt(Internal\_geometric\_data\_index)->unpin(1);

  \} \textcolor{comment}{// end of unpin\_yc()}

\end{DoxyCodeInclude}


Finally, we implement the pure virtual functions {\ttfamily Generalised\+Element\+::get\+\_\+jacobian}(...) and {\ttfamily Generalised\+Element\+::get\+\_\+residuals}(...) which are required to make the element functional. These functions must compute the element\textquotesingle{}s contributions to the {\ttfamily Problem\textquotesingle{}s} global residual vector and Jacobian matrix. As usual, we implement them as wrappers to a single function that computes the residual and (optionally) the Jacobian matrix\+:


\begin{DoxyCodeInclude}
 \textcolor{comment}{/// Compute element residual vector (wrapper)}
 \textcolor{keywordtype}{void} get\_residuals(Vector<double> &residuals)
  \{
   \textcolor{comment}{//Initialise residuals to zero}
   residuals.initialise(0.0);
   \textcolor{comment}{//Create a dummy matrix}
   DenseMatrix<double> dummy(1);
   \textcolor{comment}{//Call the generic residuals function with flag set to 0}
   fill\_in\_generic\_residual\_contribution(residuals,dummy,0);
   \}

  \textcolor{comment}{}
\textcolor{comment}{ /// Compute element residual Vector and element Jacobian matrix (wrapper)}
\textcolor{comment}{} \textcolor{keywordtype}{void} get\_jacobian(Vector<double> &residuals,
                   DenseMatrix<double> &jacobian)
  \{
   \textcolor{comment}{//Initialise residuals to zero}
   residuals.initialise(0.0);
   \textcolor{comment}{//Initialise the jacobian matrix to zero}
   jacobian.initialise(0.0);
   \textcolor{comment}{//Call the generic routine with the flag set to 1}
   fill\_in\_generic\_residual\_contribution(residuals,jacobian,1);

  \} \textcolor{comment}{// end of get\_jacobian(...)}

\end{DoxyCodeInclude}


The \char`\"{}real work\char`\"{} is done in the protected member function {\ttfamily get\+\_\+residuals\+\_\+generic}(...), where we distinguish two cases.
\begin{DoxyEnumerate}
\item The load is prescribed, i.\+e. the (single) value in the load {\ttfamily Data} object is pinned. In this case, the element\textquotesingle{}s {\ttfamily Data} contains only one unknown -- the vertical displacement $ Y_c $, stored as value 1 in the internal {\ttfamily Data}. The element\textquotesingle{}s residual vector has a single entry, given by \[ {\tt r}_0 = f_{load} - Y_c \ k_{stiff} \] and the element\textquotesingle{}s Jacobian matrix is a 1x1 matrix whose single entry is given by \[ {\tt J}_{00} = \frac{\partial {\tt r}_0}{\partial Y_c} = - k_{stiff} \]
\item If the load is unknown (i.\+e. an unknown in the overall problem) the element\textquotesingle{}s {\ttfamily Data} contains two unknowns. Recall that an element only makes a contribution to the residuals associated with unknowns that it is \char`\"{}in charge of\char`\"{} -- the external {\ttfamily Data} is assumed to be \char`\"{}determined\char`\"{} by another element. Therefore, the elements residual vectors (i.\+e. its contribution to the {\ttfamily Problem\textquotesingle{}s} global residual vector) is given by \[ \left( \begin{array}{c} {\tt r}_0 \\ {\tt r}_1 \end{array} \right) = \left( \begin{array}{c} f_{load} - Y_c \ k_{stiff}\\ 0 \end{array} \right). \] The element\textquotesingle{}s 2x2 Jacobian matrix contains the derivatives of the residuals with respect to the element\textquotesingle{}s unknowns, $ Y_c $ and $ f_{load}$, \[ \left( \begin{array}{cc} {\tt J}_{00} & {\tt J}_{01} \\ {\tt J}_{10} & {\tt J}_{11} \end{array} \right) = \left( \begin{array}{cc} \partial {\tt r}_0 / \partial Y_c& \partial {\tt r}_0 / \partial f_{load} \\ \partial {\tt r}_1 / \partial Y_c & \partial {\tt r}_1 / \partial f_{load} \end{array} \right) = \left( \begin{array}{cc} - k_{stiff} & 1 \\ 0 & 0 \end{array} \right) \]
\end{DoxyEnumerate}Note that we have (correctly!) assumed that the (fully automatic) local equation numbering procedure, implemented in {\ttfamily Generalised\+Element\+::assign\+\_\+local\+\_\+eqn\+\_\+numbers()}, regards the internal degree of freedom as local unknown \char`\"{}0\char`\"{} and the external one (if it exists) as unknown \char`\"{}1\char`\"{}. However, to be on the safe side, we determine the local equation numbers via the access functions {\ttfamily internal\+\_\+local\+\_\+eqn(i,j)} and {\ttfamily external\+\_\+local\+\_\+eqn(i,j)}, which return the local equation numbers of the j-\/th value, stored in the element\textquotesingle{}s i-\/th internal (or external) {\ttfamily Data} object\+:


\begin{DoxyCodeInclude}
 \textcolor{comment}{/// \(\backslash\)short Compute element residual Vector (only if flag=0) and also}
\textcolor{comment}{ /// the element Jacobian matrix (if flag=1)}
\textcolor{comment}{} \textcolor{keywordtype}{void} fill\_in\_generic\_residual\_contribution(Vector<double> &residuals,
                                            DenseMatrix<double> &jacobian,
                                            \textcolor{keywordtype}{unsigned} flag)
  \{ 
   \textcolor{comment}{//Find out how may dofs there are in the element}
   \textcolor{keywordtype}{unsigned} n\_dof = ndof();
   \textcolor{comment}{//If everything is pinned return straight away}
   \textcolor{keywordflow}{if} (n\_dof==0) \textcolor{keywordflow}{return};
 
   \textcolor{comment}{// Pseudo-elastic force balance to determine the position of the}
   \textcolor{comment}{// ring's centre for a given load.}

   \textcolor{comment}{// What's the local equation number of the force balance equation}
   \textcolor{comment}{// [It's the equation that "determines" the value of the internal}
   \textcolor{comment}{// dof, y\_c, which is stored as the second value of the one-and-only}
   \textcolor{comment}{// internal data object in this element]}
   \textcolor{keywordtype}{int} local\_eqn\_number\_for\_yc = 
    internal\_local\_eqn(Internal\_geometric\_data\_index,1);

   \textcolor{comment}{// Add residual to appropriate entry in the element's residual}
   \textcolor{comment}{// vector:}
   residuals[local\_eqn\_number\_for\_yc]=load()-K\_stiff*y\_c();

   \textcolor{comment}{// Work out Jacobian: }
   \textcolor{keywordflow}{if} (flag)
    \{
     \textcolor{comment}{// Derivative of residual w.r.t. the internal dof, i.e. the vertical}
     \textcolor{comment}{// position of the ring's centre: d residual[0]/d y\_c}
     jacobian(local\_eqn\_number\_for\_yc,local\_eqn\_number\_for\_yc) = -K\_stiff;
     
     
     \textcolor{comment}{// Derivative with respect to external dof, i.e. the applied }
     \textcolor{comment}{// load: d residual[0]/d load -- but only if the load is an unknown}
     \textcolor{keywordflow}{if} (n\_dof==2)
      \{
       \textcolor{comment}{// What's the local equation number of the load parameter?}
       \textcolor{comment}{// It's stored as the 0th value in the the element's}
       \textcolor{comment}{// one-and-only external data item:}
       \textcolor{keywordtype}{int} local\_eqn\_number\_for\_load = 
        external\_local\_eqn(External\_load\_index,0);

\textcolor{preprocessor}{#ifdef PARANOID}
       \textcolor{keywordflow}{if} (local\_eqn\_number\_for\_load<0)
        \{
         \textcolor{keywordflow}{throw} OomphLibError(
          \textcolor{stringliteral}{"Load is pinned and yet n\_dof=2?\(\backslash\)n This is very fishy!\(\backslash\)n"},
          OOMPH\_CURRENT\_FUNCTION,
          OOMPH\_EXCEPTION\_LOCATION);
        \}
\textcolor{preprocessor}{#endif}
         
       \textcolor{comment}{// Add entry into element Jacobian}
       jacobian(local\_eqn\_number\_for\_yc,local\_eqn\_number\_for\_load) = 1.0;
      \}
    \}
  \} \textcolor{comment}{// end of get\_residuals\_generic(...)}

\end{DoxyCodeInclude}




 

\hypertarget{index_driver}{}\section{Part 3\+: The driver code}\label{index_driver}
Finally, we provide an example that shows our {\ttfamily Elastically\+Supported\+Ring\+Element} in action. The animation below shows the result of the computational simulation of the toy problem described at the beginning of the previous section\+: An elastically supported ring, subjected to a vertical load. The animation shows the position of the ring for various values of the load.

 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{circle_as_element}
\doxyfigcaption{Vertical displacement of a Circle, mounted on an elastic support. }
\end{DoxyImage}




\hypertarget{index_main}{}\subsection{The driver code}\label{index_main}
The driver builds the {\ttfamily Problem} object and solves the problem for various load levels\+:

 
\begin{DoxyCodeInclude}
\textcolor{comment}{//===============start\_of\_driver==========================================}
\textcolor{comment}{/// Driver }
\textcolor{comment}{}\textcolor{comment}{//========================================================================}
\textcolor{keywordtype}{int} \hyperlink{algebraic__free__boundary__poisson_8cc_a0ddf1224851353fc92bfbff6f499fa97}{main}()
\{

 \textcolor{comment}{// Set up the problem }
 \hyperlink{classGeomObjectAsGeneralisedElementProblem}{GeomObjectAsGeneralisedElementProblem} problem;
 
 \textcolor{comment}{// Initial value for the load }
 problem.\hyperlink{classGeomObjectAsGeneralisedElementProblem_a5ae799de23742e4c8fa54ee7ae32e679}{load}()=-0.3;
 
 \textcolor{comment}{// Loop for different loads}
 \textcolor{comment}{//-------------------------}
 
 \textcolor{comment}{// Number of steps}
 \textcolor{keywordtype}{unsigned} nstep=5;
 
 \textcolor{comment}{// Increment in load}
 \textcolor{keywordtype}{double} dp=0.6/double(nstep-1);
 
 \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} istep=0;istep<nstep;istep++)
  \{    
   \textcolor{comment}{// Solve/doc}
   problem.newton\_solve();
   problem.\hyperlink{classGeomObjectAsGeneralisedElementProblem_a5092be8e6172d6c9147115bdd485db35}{doc\_solution}();
   
   \textcolor{comment}{//Increment counter for solutions }
   problem.\hyperlink{classGeomObjectAsGeneralisedElementProblem_a4be869d81c0df187d4239a590826f139}{doc\_info}().number()++;    
   
   \textcolor{comment}{// Change load on ring}
   problem.\hyperlink{classGeomObjectAsGeneralisedElementProblem_a5ae799de23742e4c8fa54ee7ae32e679}{load}()+=dp;
  \} 
 
\} \textcolor{comment}{// end of driver}

\end{DoxyCodeInclude}




\hypertarget{index_class}{}\subsection{The problem class definition}\label{index_class}
Here is the problem class definition which requires little comment\+:

 
\begin{DoxyCodeInclude}
\textcolor{comment}{//======start\_of\_problem==============================================}
\textcolor{comment}{/// Problem to demonstrate the use of a GeomObject as a }
\textcolor{comment}{}\textcolor{comment}{/// GeneralisedElement: A geometric object (a Circle) is "upgraded"}
\textcolor{comment}{}\textcolor{comment}{/// to a GeneralisedElement. The position of the Circle is}
\textcolor{comment}{}\textcolor{comment}{/// determined by a balance of forces, assuming that the}
\textcolor{comment}{}\textcolor{comment}{/// Circle is mounted on an elastic spring of specified}
\textcolor{comment}{}\textcolor{comment}{/// stiffness and loaded by a vertical "load". }
\textcolor{comment}{}\textcolor{comment}{//====================================================================}
\textcolor{keyword}{class }\hyperlink{classGeomObjectAsGeneralisedElementProblem}{GeomObjectAsGeneralisedElementProblem} : \textcolor{keyword}{public} Problem
\{

\textcolor{keyword}{public}:
\textcolor{comment}{}
\textcolor{comment}{ /// Constructor}
\textcolor{comment}{} \hyperlink{classGeomObjectAsGeneralisedElementProblem_ad1f15fcb6c055c58d1f71b522f1f7bd6}{GeomObjectAsGeneralisedElementProblem}();
\textcolor{comment}{}
\textcolor{comment}{ /// Update the problem specs after solve (empty)}
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{classGeomObjectAsGeneralisedElementProblem_af396d1789e2552c43e0c68561d88d473}{actions\_after\_newton\_solve}()\{\}
  \textcolor{comment}{}
\textcolor{comment}{ /// Update the problem specs before solve (empty)}
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{classGeomObjectAsGeneralisedElementProblem_a4ae01862ddbbeeacca1ce7a444e28931}{actions\_before\_newton\_solve}() \{\}
\textcolor{comment}{}
\textcolor{comment}{ /// Doc the solution}
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{classGeomObjectAsGeneralisedElementProblem_a5092be8e6172d6c9147115bdd485db35}{doc\_solution}();
\textcolor{comment}{}
\textcolor{comment}{ /// Return value of the "load" on the elastically supported ring}
\textcolor{comment}{} \textcolor{keywordtype}{double}& \hyperlink{classGeomObjectAsGeneralisedElementProblem_a5ae799de23742e4c8fa54ee7ae32e679}{load}()
  \{
   \textcolor{keywordflow}{return} *\hyperlink{classGeomObjectAsGeneralisedElementProblem_ac04469b2dbce010fff3f5b2cf5591bcd}{Load\_pt}->value\_pt(0);
  \}
\textcolor{comment}{}
\textcolor{comment}{ /// Access to DocInfo object}
\textcolor{comment}{} DocInfo& \hyperlink{classGeomObjectAsGeneralisedElementProblem_a4be869d81c0df187d4239a590826f139}{doc\_info}() \{\textcolor{keywordflow}{return} \hyperlink{classGeomObjectAsGeneralisedElementProblem_a89a7f5fa555839193166f802d6ff6be2}{Doc\_info};\}

\textcolor{keyword}{private}:
\textcolor{comment}{}
\textcolor{comment}{ /// Trace file}
\textcolor{comment}{} ofstream \hyperlink{classGeomObjectAsGeneralisedElementProblem_ad6261e556a52596ba8904ee902ea6d70}{Trace\_file};
\textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Pointer to data item that stores the "load" on the ring}
\textcolor{comment}{} Data* \hyperlink{classGeomObjectAsGeneralisedElementProblem_ac04469b2dbce010fff3f5b2cf5591bcd}{Load\_pt};
\textcolor{comment}{}
\textcolor{comment}{ /// Doc info object}
\textcolor{comment}{} DocInfo \hyperlink{classGeomObjectAsGeneralisedElementProblem_a89a7f5fa555839193166f802d6ff6be2}{Doc\_info};

\};

\end{DoxyCodeInclude}




\hypertarget{index_constructor}{}\subsection{The problem constructor}\label{index_constructor}
In the problem constructor, we create the (single) {\ttfamily Elastically\+Supported\+Ring\+Element} and and assign a value to its \char`\"{}spring stiffness\char`\"{} parameter. 
\begin{DoxyCodeInclude}
\textcolor{comment}{//=============================start\_of\_problem\_constructor===============}
\textcolor{comment}{/// Constructor}
\textcolor{comment}{}\textcolor{comment}{//========================================================================}
\hyperlink{classGeomObjectAsGeneralisedElementProblem_ad1f15fcb6c055c58d1f71b522f1f7bd6}{GeomObjectAsGeneralisedElementProblem::GeomObjectAsGeneralisedElementProblem}
      ()
\{ 
 
 \textcolor{comment}{// Set coordinates and radius for the circle}
 \textcolor{keywordtype}{double} x\_c=0.5;
 \textcolor{keywordtype}{double} y\_c=0.0;
 \textcolor{keywordtype}{double} R=1.0;

 \textcolor{comment}{// Build GeomObject that's been upgraded to a GeneralisedElement}
 \textcolor{comment}{// GeneralisedElement* }
 ElasticallySupportedRingElement* geom\_object\_element\_pt = 
  \textcolor{keyword}{new} ElasticallySupportedRingElement(x\_c,y\_c,R);

 \textcolor{comment}{// Set the stiffness of the elastic support}
 geom\_object\_element\_pt->k\_stiff()=0.3;

\end{DoxyCodeInclude}


Next, we create the problem\textquotesingle{}s mesh\+: We start by creating an (empty) {\ttfamily Mesh} object and then add the (pointer to the) newly created {\ttfamily Elastically\+Supported\+Ring\+Element} (in its incarnation as a {\ttfamily Generalised\+Element}) to it\+:


\begin{DoxyCodeInclude}
 \textcolor{comment}{// Build mesh}
 mesh\_pt()=\textcolor{keyword}{new} Mesh;

 \textcolor{comment}{// So far, the mesh is completely empty. Let's add the }
 \textcolor{comment}{// one (and only!) GeneralisedElement to it:}
 mesh\_pt()->add\_element\_pt(geom\_object\_element\_pt);

\end{DoxyCodeInclude}


As discussed in the previous section, the load must be specified as a {\ttfamily Data} object that stores a single value. In our example, the load is prescribed (i.\+e. not an unknown in the problem) therefore the value must be pinned\+:


\begin{DoxyCodeInclude}
 \textcolor{comment}{// Create the load (a Data object with a single value)}
 Load\_pt=\textcolor{keyword}{new} Data(1);
   
 \textcolor{comment}{// The load is prescribed so its one-and-only value is pinned}
 Load\_pt->pin(0);

 \textcolor{comment}{// Set the pointer to the Data object that specifies the }
 \textcolor{comment}{// load on the ring}
 geom\_object\_element\_pt->set\_load\_pt(Load\_pt);

\end{DoxyCodeInclude}


Finally, we set up the equation numbering scheme, set the output directory and open a trace file in which we will document the load/displacement characteristics.


\begin{DoxyCodeInclude}
 \textcolor{comment}{// Setup equation numbering scheme.}
 cout <<\textcolor{stringliteral}{"Number of equations: "} << assign\_eqn\_numbers() << std::endl; 

 \textcolor{comment}{// Set output directory}
 Doc\_info.set\_directory(\textcolor{stringliteral}{"RESLT"}); 
  
 \textcolor{comment}{// Open trace file}
 \textcolor{keywordtype}{char} filename[100];
 sprintf(filename,\textcolor{stringliteral}{"%s/trace.dat"},Doc\_info.directory().c\_str());
 Trace\_file.open(filename);
 Trace\_file << \textcolor{stringliteral}{"VARIABLES=\(\backslash\)"load\(\backslash\)",\(\backslash\)"y<sub>circle</sub>\(\backslash\)""} << std::endl;

\} \textcolor{comment}{// end of constructor}

\end{DoxyCodeInclude}




\hypertarget{index_post}{}\subsection{The post-\/processing function}\label{index_post}
The post-\/processing routine is straightforward and is listed only to highlight the need to cast the pointer to the {\ttfamily Generalised\+Element} (as returned by {\ttfamily Mesh\+::element\+\_\+pt}(...)) to the specific element used here -- obviously, a {\ttfamily Generalised\+Element} does not have member functions that return the load on the ring or its vertical displacement.


\begin{DoxyCodeInclude}
\textcolor{comment}{//===========================start\_of\_doc\_solution========================}
\textcolor{comment}{/// Doc the solution in tecplot format.}
\textcolor{comment}{}\textcolor{comment}{//========================================================================}
\textcolor{keywordtype}{void} \hyperlink{classGeomObjectAsGeneralisedElementProblem_a5092be8e6172d6c9147115bdd485db35}{GeomObjectAsGeneralisedElementProblem::doc\_solution}
      ()
\{ 

 ofstream some\_file;
 \textcolor{keywordtype}{char} filename[100];

 \textcolor{comment}{// Number of plot points}
 \textcolor{keywordtype}{unsigned} npts=100;

 \textcolor{comment}{// Lagrangian coordinate and position vector (both as vectors)}
 Vector<double> zeta(1);
 Vector<double> r(2);
 
 \textcolor{comment}{// Output solution }
 sprintf(filename,\textcolor{stringliteral}{"%s/soln%i.dat"},\hyperlink{classGeomObjectAsGeneralisedElementProblem_a89a7f5fa555839193166f802d6ff6be2}{Doc\_info}.directory().c\_str(),
         \hyperlink{classGeomObjectAsGeneralisedElementProblem_a89a7f5fa555839193166f802d6ff6be2}{Doc\_info}.number());
 some\_file.open(filename);
 \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} i=0;i<npts;i++)
  \{
   zeta[0]=2.0*MathematicalConstants::Pi*double(i)/double(npts-1);
   \textcolor{keyword}{static\_cast<}ElasticallySupportedRingElement*\textcolor{keyword}{>}(mesh\_pt()->element\_pt(0))->
    position(zeta,r);  
   some\_file << r[0] << \textcolor{stringliteral}{" "} << r[1] << std::endl;
  \}
 some\_file.close();


 \textcolor{comment}{// Write "load" and vertical position of the ring's centre}
 \hyperlink{classGeomObjectAsGeneralisedElementProblem_ad6261e556a52596ba8904ee902ea6d70}{Trace\_file} 
  << \textcolor{keyword}{static\_cast<}ElasticallySupportedRingElement*\textcolor{keyword}{>}(
   mesh\_pt()->element\_pt(0))->\hyperlink{classGeomObjectAsGeneralisedElementProblem_a5ae799de23742e4c8fa54ee7ae32e679}{load}()
  << \textcolor{stringliteral}{" "}
  << \textcolor{keyword}{static\_cast<}ElasticallySupportedRingElement*\textcolor{keyword}{>}(
   mesh\_pt()->element\_pt(0))->y\_c()
  << \textcolor{stringliteral}{" "}
  << std::endl;

\} \textcolor{comment}{// end of doc\_solution}

\end{DoxyCodeInclude}




 

\hypertarget{index_notes}{}\section{Comments and Exercises}\label{index_notes}
\hypertarget{index_ex}{}\subsection{Exercises}\label{index_ex}

\begin{DoxyEnumerate}
\item In the current implementation of the {\ttfamily Elastically\+Supported\+Ring\+Element}, the load {\ttfamily Data} must only store a single value\+: Generalise this to the case where the {\ttfamily Data} object can contain an arbitrary number of values. You could add an additional argument to the {\ttfamily set\+\_\+load\+\_\+pt}(...) function to specify which value in the {\ttfamily Data} object represents the load. Think carefully in which other parts of the code this index will be required. ~\newline
~\newline

\end{DoxyEnumerate}



 

\hypertarget{index_sources}{}\section{Source files for this tutorial}\label{index_sources}

\begin{DoxyItemize}
\item The source files for this tutorial are located in the directory\+:~\newline
~\newline
\begin{center} \href{
../../../../
demo_drivers/interaction/free_boundary_poisson/
}{\tt demo\+\_\+drivers/interaction/free\+\_\+boundary\+\_\+poisson/ } \end{center} ~\newline

\item The driver code is\+: ~\newline
~\newline
\begin{center} \href{
../../../../
demo_drivers/interaction/free_boundary_poisson/geom_object_element.cc
}{\tt demo\+\_\+drivers/interaction/free\+\_\+boundary\+\_\+poisson/geom\+\_\+object\+\_\+element.\+cc } \end{center} 
\end{DoxyItemize}

 

 \hypertarget{index_pdf}{}\section{P\+D\+F file}\label{index_pdf}
A \href{../latex/refman.pdf}{\tt pdf version} of this document is available. \end{document}
