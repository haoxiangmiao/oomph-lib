The purpose of this tutorial is to demonstrate the solution of 3D solid mechanics problems on unstructured meshes. The problem studied here also serves as a \char`\"{}warm-\/up problem\char`\"{} for the \href{../../../interaction/unstructured_three_d_fsi/html/index.html}{\tt corresponding fluid-\/structure interaction problem } in which the elastic, bifurcating vessel whose deformation is studied here conveys (and is loaded by) a viscous fluid.



 

\hypertarget{index_problem}{}\section{The problem (and results)}\label{index_problem}
Here is an animation of the problem\+: An elastic, bifurcating vessel is loaded by an internal pressure and by gravity which acts in the negative $x$-\/direction. The \char`\"{}ends\char`\"{} of the vessel are held in a fixed position. As the magnitude of the loading is increased the vessel inflates and sags downwards.

 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{deform}
\doxyfigcaption{An elastic, bifurcating vessel, loaded by an internal pressure and transverse gravity. }
\end{DoxyImage}


The blue frame surrounding the vessel is drawn to clarify its spatial orientation. The yellow edges show the boundaries of the internal faces via which the pressure loading is applied, and the red arrows indicate the direction and magnitude of the pressure loading.



 

\hypertarget{index_mesh}{}\section{3\+D unstructured mesh generation}\label{index_mesh}
We use \href{http://www.wias-berlin.de/~si }{\tt Hang Si\textquotesingle{}s} open-\/source mesh generator \href{http://wias-berlin.de/software/tetgen//}{\tt {\ttfamily tetgen} } to generate the unstructured tetrahedral mesh \char`\"{}offline\char`\"{}. We then process the output files produced by \href{http://wias-berlin.de/software/tetgen//}{\tt {\ttfamily tetgen} } to generate an unstructured {\ttfamily oomph-\/lib} mesh.

\href{http://wias-berlin.de/software/tetgen//}{\tt {\ttfamily Tetgen} } requires the specification of the domain boundaries via so-\/called facets -- planar surface patches that are bounded by closed polygonal line segments. For simplicity, we only consider a very simplistic bifurcation, comprising three tube segments of approximately rectangular cross-\/section that meet at a common junction. Each of the three tube segments has four internal and four external faces. The internal and external faces are connected by three further faces at the \char`\"{}in-\/ and outflow\char`\"{} cross-\/sections (using terminology that anticipates the mesh\textquotesingle{}s use in the corresponding \href{../../../interaction/unstructured_three_d_fsi/html/index.html}{\tt fluid-\/structure interaction problem}), resulting in a total of 27 facets.

The 27 facets are defined in a {\ttfamily $\ast$.poly} file that specifies the position of the vertices, and identifies the facets via a \char`\"{}face list\char`\"{} that establishes their bounding vertices. Facets that have holes (e.\+g. the in-\/ and outflow facets) require the specification of the hole\textquotesingle{}s position. Finally, if the mesh itself has a hole (as in the current example where the vessel\textquotesingle{}s lumen forms a hole in the mesh) the position of the hole must be identified by specifying the position of a single point inside that hole. The well-\/annotated {\ttfamily $\ast$.poly} file is located at\+:

\begin{center} \href{../../../../demo_drivers/solid/unstructured_three_d_solid/fsi_bifurcation_solid.poly}{\tt demo\+\_\+drivers/solid/unstructured\+\_\+three\+\_\+d\+\_\+solid/fsi\+\_\+bifurcation\+\_\+solid.\+poly} \end{center} 

We refer to the \href{http://wias-berlin.de/software/tetgen//}{\tt {\ttfamily tetgen} webpages } and another \href{../../../meshes/mesh_from_tetgen/html/index.html}{\tt {\ttfamily oomph-\/lib} tutorial} for further details on how to create {\ttfamily $\ast$.poly} files.

Here is a plot of the domain specified by \href{../../../../demo_drivers/solid/unstructured_three_d_solid/fsi_bifurcation_solid.poly}{\tt fsi\+\_\+bifurcation\+\_\+solid.\+poly}. The plot was created using {\ttfamily tetview} which is distributed with \href{http://wias-berlin.de/software/tetgen//}{\tt {\ttfamily tetgen} }.

 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{tetgen_boundaries}
\doxyfigcaption{The domain and its bounding facets. }
\end{DoxyImage}


Note that we have deliberately assigned a different boundary ID to each facet. This will make the assignment of the traction boundary condition somewhat tedious as the inner surface of the vessel (where the traction is to be applied) is represented by twelve separate mesh boundaries. However, the assignment of distinct boundary I\+Ds for the different facets is essential for the automatic generation of boundary coordinates in the \href{../../../interaction/unstructured_three_d_fsi/html/index.html}{\tt corresponding fluid-\/structure interaction problem } and is therefore {\bfseries strongly recommended}.

\href{http://wias-berlin.de/software/tetgen//}{\tt {\ttfamily Tetgen} } generates an unstructured volumetric mesh from the information contained in the {\ttfamily $\ast$.poly} file and writes the mesh\textquotesingle{}s nodes, elements and faces in the files
\begin{DoxyItemize}
\item \href{../../../../demo_drivers/solid/unstructured_three_d_solid/fsi_bifurcation_solid.1.node}{\tt demo\+\_\+drivers/solid/unstructured\+\_\+three\+\_\+d\+\_\+solid/fsi\+\_\+bifurcation\+\_\+solid.\+1.\+node }
\item \href{../../../../demo_drivers/solid/unstructured_three_d_solid/fsi_bifurcation_solid.1.ele}{\tt demo\+\_\+drivers/solid/unstructured\+\_\+three\+\_\+d\+\_\+solid/fsi\+\_\+bifurcation\+\_\+solid.\+1.\+ele }
\item \href{../../../../demo_drivers/solid/unstructured_three_d_solid/fsi_bifurcation_solid.1.face}{\tt demo\+\_\+drivers/solid/unstructured\+\_\+three\+\_\+d\+\_\+solid/fsi\+\_\+bifurcation\+\_\+solid.\+1.\+face}
\end{DoxyItemize}These files can be used as input to {\ttfamily oomph-\/lib\textquotesingle{}s} {\ttfamily Tetgen\+Mesh} class, using the procedure discussed in \href{../../../meshes/mesh_from_tetgen/html/index.html}{\tt another tutorial.}

The figure below shows a {\ttfamily tetview} plot of the mesh, created with a volume constraint of 0.\+2 (i.\+e. the maximum volume of each tetrahedron is guaranteed to be less than 0.\+2 units), using the command 
\begin{DoxyCode}
tetgen -a0.2 fsi\_bifurcation\_solid.poly 
\end{DoxyCode}


 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{mesh_boundaries}
\doxyfigcaption{Plot of the mesh, generated by tetgen. }
\end{DoxyImage}


Note how \href{http://wias-berlin.de/software/tetgen//}{\tt {\ttfamily tetgen} } has subdivided each of the 27 original facets specified in the {\ttfamily $\ast$.poly} file into a surface triangulation. The nodes and tetrahedral elements that are located on (or adjacent to) the 27 original facets inherit their boundary I\+Ds. This will be important when we assign the boundary conditions.



 

\hypertarget{index_mesh_code}{}\section{Creating the mesh}\label{index_mesh_code}
We create the solid mesh by multiple inheritance from {\ttfamily oomph-\/lib\textquotesingle{}s} {\ttfamily Tetgen\+Mesh} and the {\ttfamily Solid\+Mesh} base class\+:

 
\begin{DoxyCodeInclude}
\textcolor{comment}{//=======================start\_mesh========================================}
\textcolor{comment}{/// Tetgen-based mesh upgraded to become a solid mesh}
\textcolor{comment}{}\textcolor{comment}{//=========================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT>
\textcolor{keyword}{class }\hyperlink{classMySolidTetgenMesh}{MySolidTetgenMesh} : \textcolor{keyword}{public} \textcolor{keyword}{virtual} TetgenMesh<ELEMENT>, 
                       \textcolor{keyword}{public} \textcolor{keyword}{virtual} SolidMesh 
\{

\end{DoxyCodeInclude}


The constructor calls the constructor of the underlying {\ttfamily Tetgen\+Mesh} (using the {\ttfamily $\ast$.node } {\ttfamily $\ast$.ele} and {\ttfamily $\ast$.face} files created by \href{http://wias-berlin.de/software/tetgen//}{\tt {\ttfamily tetgen}. } As usual we set the nodes\textquotesingle{} Lagrangian coordinates to their current Eulerian positions, making the current configuration stress-\/free.


\begin{DoxyCodeInclude}
 
\textcolor{keyword}{public}:
 \textcolor{comment}{}
\textcolor{comment}{ /// Constructor: }
\textcolor{comment}{} \hyperlink{classMySolidTetgenMesh}{MySolidTetgenMesh}(\textcolor{keyword}{const} std::string& node\_file\_name,
                \textcolor{keyword}{const} std::string& element\_file\_name,
                \textcolor{keyword}{const} std::string& face\_file\_name,
                TimeStepper* time\_stepper\_pt=
                &Mesh::Default\_TimeStepper) : 
  TetgenMesh<ELEMENT>(node\_file\_name, element\_file\_name,
                      face\_file\_name, time\_stepper\_pt)
  \{
   \textcolor{comment}{//Assign the Lagrangian coordinates}
   set\_lagrangian\_nodal\_coordinates();

\end{DoxyCodeInclude}


Finally, we identify the elements that are located next to the various mesh boundaries to facilitate the application of the traction boundary conditions.


\begin{DoxyCodeInclude}
   
   \textcolor{comment}{// Find elements next to boundaries}
   setup\_boundary\_element\_info();
  \}
\textcolor{comment}{}
\textcolor{comment}{ /// Empty Destructor}
\textcolor{comment}{} \textcolor{keyword}{virtual} ~\hyperlink{classMySolidTetgenMesh}{MySolidTetgenMesh}() \{ \}


\};

\end{DoxyCodeInclude}




 

\hypertarget{index_namespace}{}\section{Problem parameters}\label{index_namespace}
As usual, we define the various problem parameters in a global namespace. We use {\ttfamily oomph-\/lib\textquotesingle{}s} generalised Hookean constitutive law as the constitutive equation, using a Poisson\textquotesingle{}s ratio of 0.\+3. (\href{../../solid_theory/html/index.html#non-dim_solid}{\tt Recall} that omitting the specification of Young\textquotesingle{}s modulus, $ E $, implies that the stresses are non-\/dimensionalised on $ E $ .)


\begin{DoxyCodeInclude}
\textcolor{comment}{//=======start\_namespace==========================================}
\textcolor{comment}{/// Global variables}
\textcolor{comment}{}\textcolor{comment}{//================================================================}
\textcolor{keyword}{namespace }\hyperlink{namespaceGlobal__Parameters}{Global\_Parameters}
\{
\textcolor{comment}{}
\textcolor{comment}{ /// Poisson's ratio}
\textcolor{comment}{} \textcolor{keywordtype}{double} Nu=0.3;
 \textcolor{comment}{}
\textcolor{comment}{ /// Create constitutive law}
\textcolor{comment}{} ConstitutiveLaw* Constitutive\_law\_pt=\textcolor{keyword}{new} GeneralisedHookean(&Nu);

\end{DoxyCodeInclude}


Next we define the gravitational body force which acts in the negative $x$-\/direction,


\begin{DoxyCodeInclude}
\textcolor{comment}{}
\textcolor{comment}{ /// Non-dim gravity}
\textcolor{comment}{} \textcolor{keywordtype}{double} Gravity=0.0;
\textcolor{comment}{}
\textcolor{comment}{ /// Non-dimensional gravity as body force}
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{namespaceGlobal__Parameters_a200109847bf4cc26da4d00e8d68d569e}{gravity}(\textcolor{keyword}{const} \textcolor{keywordtype}{double}& time,
              \textcolor{keyword}{const} Vector<double> &xi,
              Vector<double> &b)
 \{
  b[0]=-\hyperlink{namespaceGlobal__Parameters_a335000b5db4206486a116ae0468d2d0c}{Gravity}; 
  b[1]=0.0;
  b[2]=0.0;
 \} \textcolor{comment}{// end gravity}

\end{DoxyCodeInclude}


and the pressure load, $ {\bf t} = -P {\bf n} $, that acts on internal walls of the bifurcation (note that the outer unit normal $ {\bf n} $ on the wall is passed to the function).


\begin{DoxyCodeInclude}
\textcolor{comment}{}
\textcolor{comment}{ /// Uniform pressure}
\textcolor{comment}{} \textcolor{keywordtype}{double} P = 0.0;
\textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Constant pressure load. The arguments to this function are imposed}
\textcolor{comment}{ /// on us by the SolidTractionElements which allow the traction to }
\textcolor{comment}{ /// depend on the Lagrangian and Eulerian coordinates x and xi, and on the }
\textcolor{comment}{ /// outer unit normal to the surface. Here we only need the outer unit}
\textcolor{comment}{ /// normal.}
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{namespaceGlobal__Parameters_a7dc25ca2abd48b7f1bffb2d6129f02bd}{constant\_pressure}(\textcolor{keyword}{const} Vector<double> &xi, \textcolor{keyword}{const} Vector<double> &x,
                        \textcolor{keyword}{const} Vector<double> &n, Vector<double> &traction)
 \{
  \textcolor{keywordtype}{unsigned} dim = traction.size();
  \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} i=0;i<dim;i++)
   \{
    traction[i] = -P*n[i];
   \}
 \} \textcolor{comment}{// end traction}
 
 
\} \textcolor{comment}{//end namespace}

\end{DoxyCodeInclude}




 

\hypertarget{index_main}{}\section{The driver code}\label{index_main}
The driver code is straightforward. We store the command line arguments, specify an output directory and create the problem object, using ten-\/noded tetrahedral solid mechanics elements to discretise the principle of virtual displacements.

 
\begin{DoxyCodeInclude}
\textcolor{comment}{//============================start\_main==================================}
\textcolor{comment}{/// Demonstrate how to solve an unstructured 3D solid problem}
\textcolor{comment}{}\textcolor{comment}{//========================================================================}
\textcolor{keywordtype}{int} \hyperlink{unstructured__three__d__solid_8cc_a3c04138a5bfe5d72780bb7e82a18e627}{main}(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char} **argv)
\{
 \textcolor{comment}{// Store command line arguments}
 CommandLineArgs::setup(argc,argv);
  
 \textcolor{comment}{// Label for output}
 DocInfo doc\_info;
 
 \textcolor{comment}{// Output directory}
 doc\_info.set\_directory(\textcolor{stringliteral}{"RESLT"});
  
 \textcolor{comment}{//Set up the problem}
 \hyperlink{classUnstructuredSolidProblem}{UnstructuredSolidProblem<TPVDElement<3,3>} > problem;

\end{DoxyCodeInclude}


We output the initial configuration and then perform a parameter study in which we increment the gravitational body force and the pressure loads simultaneously, causing the vessel to expand and sag, as shown in the animation at the beginning of this tutorial. (As usual we perform a smaller number of steps if the code is run in self-\/test mode; this is indicated by a non-\/zero number of command line arguments.)


\begin{DoxyCodeInclude}
 
 \textcolor{comment}{//Output initial configuration}
 problem.\hyperlink{classUnstructuredSolidProblem_ab3d66fd61b69d12b4f159d763fc44f15}{doc\_solution}(doc\_info);
 doc\_info.number()++;   

  \textcolor{comment}{// Parameter study}
 \hyperlink{namespaceGlobal__Parameters_a31fb55c20db4aa0127aafa20f0d76731}{Global\_Parameters::P}=0.0; 
 \textcolor{keywordtype}{double} g\_increment=1.0e-3; 
 \textcolor{keywordtype}{double} p\_increment=1.0e-2; 

 \textcolor{keywordtype}{unsigned} nstep=6;
 \textcolor{keywordflow}{if} (CommandLineArgs::Argc!=1)
  \{
   std::cout << \textcolor{stringliteral}{"Validation -- only doing two steps"} << std::endl;
   nstep=2;
  \}
 
 \textcolor{comment}{// Do the parameter study}
 \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} istep=0;istep<nstep;istep++)
  \{
   \textcolor{comment}{// Solve the problem}
   problem.newton\_solve();
   
   \textcolor{comment}{//Output solution}
   problem.\hyperlink{classUnstructuredSolidProblem_ab3d66fd61b69d12b4f159d763fc44f15}{doc\_solution}(doc\_info);
   doc\_info.number()++;

   \textcolor{comment}{// Bump up load}
   \hyperlink{namespaceGlobal__Parameters_a335000b5db4206486a116ae0468d2d0c}{Global\_Parameters::Gravity}+=g\_increment;
   \hyperlink{namespaceGlobal__Parameters_a31fb55c20db4aa0127aafa20f0d76731}{Global\_Parameters::P}+=p\_increment; 
   
  \}
 
\} \textcolor{comment}{// end main}

\end{DoxyCodeInclude}




 

\hypertarget{index_class}{}\section{The Problem class}\label{index_class}
The {\ttfamily Problem} class has the usual member functions, and provides storage for the various sub-\/meshes -- the bulk mesh of 3D solid elements and the meshes of 2D solid traction elements that apply the pressure load to the internal boundaries of the vessel.

 
\begin{DoxyCodeInclude}
\textcolor{comment}{//=============start\_problem===========================================}
\textcolor{comment}{/// Unstructured solid problem}
\textcolor{comment}{}\textcolor{comment}{//=====================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT>
\textcolor{keyword}{class }\hyperlink{classUnstructuredSolidProblem}{UnstructuredSolidProblem} : \textcolor{keyword}{public} Problem
\{

\textcolor{keyword}{public}:
\textcolor{comment}{}
\textcolor{comment}{ /// Constructor: }
\textcolor{comment}{} \hyperlink{classUnstructuredSolidProblem_a18ce02b6e4bbc86403c9e1b32c095772}{UnstructuredSolidProblem}();
\textcolor{comment}{}
\textcolor{comment}{ /// Destructor (empty)}
\textcolor{comment}{} \hyperlink{classUnstructuredSolidProblem_a25fe105d949498bf8f7c15aff96a7d00}{~UnstructuredSolidProblem}()\{\}
\textcolor{comment}{}
\textcolor{comment}{ /// Doc the solution}
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{classUnstructuredSolidProblem_ab3d66fd61b69d12b4f159d763fc44f15}{doc\_solution}(DocInfo& doc\_info);
 
\textcolor{keyword}{private}:
\textcolor{comment}{}
\textcolor{comment}{ /// Create traction elements}
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{classUnstructuredSolidProblem_a9137960284200ed998989f785965f902}{create\_traction\_elements}();
\textcolor{comment}{}
\textcolor{comment}{ /// Bulk solid mesh}
\textcolor{comment}{} \hyperlink{classMySolidTetgenMesh}{MySolidTetgenMesh<ELEMENT>}* \hyperlink{classUnstructuredSolidProblem_ad6a8cbe2c2f3596385e1a2484bfb68f7}{Solid\_mesh\_pt};
\textcolor{comment}{}
\textcolor{comment}{ /// Meshes of traction elements}
\textcolor{comment}{} Vector<SolidMesh*> \hyperlink{classUnstructuredSolidProblem_a32e691a698667053003e21333fc65057}{Solid\_traction\_mesh\_pt};

\end{DoxyCodeInclude}


The two vectors {\ttfamily Pinned\+\_\+solid\+\_\+boundary\+\_\+id} and {\ttfamily Solid\+\_\+traction\+\_\+boundary\+\_\+id} are used to store the I\+Ds of mesh boundaries that make up the in-\/ and outflow cross-\/sections (where the bifurcation is pinned), and the internal boundaries (where the pressure load has to be applied). Recall that {\ttfamily tetgen} requires the domain boundaries to be specified as a collection of planar facets. Boundary of interest in the computation, such as the \char`\"{}internal boundary of the
bifurcation\char`\"{}, therefore tend to comprise multiple distinct mesh boundaries.


\begin{DoxyCodeInclude}
\textcolor{comment}{}
\textcolor{comment}{ /// IDs of solid mesh boundaries where displacements are pinned}
\textcolor{comment}{} Vector<unsigned> Pinned\_solid\_boundary\_id;
\textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short IDs of solid mesh boundaries which make up the traction interface}
\textcolor{comment}{} Vector<unsigned> Solid\_traction\_boundary\_id;

\};

\end{DoxyCodeInclude}




 

\hypertarget{index_constructor}{}\section{The Problem constructor}\label{index_constructor}
We start by building the bulk mesh, using the files created by \href{http://wias-berlin.de/software/tetgen//}{\tt {\ttfamily tetgen} }\+:


\begin{DoxyCodeInclude}
\textcolor{comment}{//=============start\_constructor==========================================}
\textcolor{comment}{/// Constructor for unstructured solid problem}
\textcolor{comment}{}\textcolor{comment}{//========================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT>
\hyperlink{classUnstructuredSolidProblem_a18ce02b6e4bbc86403c9e1b32c095772}{UnstructuredSolidProblem<ELEMENT>::UnstructuredSolidProblem}
      ()
\{ 

  \textcolor{comment}{//Create solid bulk mesh}
 \textcolor{keywordtype}{string} node\_file\_name=\textcolor{stringliteral}{"fsi\_bifurcation\_solid.1.node"};
 \textcolor{keywordtype}{string} element\_file\_name=\textcolor{stringliteral}{"fsi\_bifurcation\_solid.1.ele"};
 \textcolor{keywordtype}{string} face\_file\_name=\textcolor{stringliteral}{"fsi\_bifurcation\_solid.1.face"};
 Solid\_mesh\_pt =  \textcolor{keyword}{new} \hyperlink{classMySolidTetgenMesh}{MySolidTetgenMesh<ELEMENT>}(node\_file\_name,
                                              element\_file\_name,
                                              face\_file\_name);

\end{DoxyCodeInclude}


Next we specify the I\+Ds of the \href{http://wias-berlin.de/software/tetgen//}{\tt {\ttfamily tetgen} } boundaries that form part of specific domain boundaries in our problem. Boundaries 0, 1 and 2 are the in-\/ and outflow faces along which the solid is pinned. (See the specification of the boundaries in \href{../../../../demo_drivers/solid/unstructured_three_d_solid/fsi_bifurcation_solid.poly}{\tt fsi\+\_\+bifurcation\+\_\+solid.\+poly} and/or check the boundary enumeration using {\ttfamily tetview} as shown in the {\ttfamily tetview} plot of the domain boundaries at the beginning of this tutorial.)


\begin{DoxyCodeInclude}
 
 \textcolor{comment}{// The following IDs corresponds to the boundary IDs specified in}
 \textcolor{comment}{// the *.poly file from which tetgen generated the unstructured mesh.}
 \textcolor{comment}{}
\textcolor{comment}{ /// IDs of solid mesh boundaries where displacements are pinned}
\textcolor{comment}{} Pinned\_solid\_boundary\_id.resize(3);
 Pinned\_solid\_boundary\_id[0]=0;
 Pinned\_solid\_boundary\_id[1]=1;
 Pinned\_solid\_boundary\_id[2]=2;

\end{DoxyCodeInclude}


Similarly, boundaries 3 to 15 are the faces that define the internal boundary of the bifurcation, i.\+e. the boundary along which we have to apply the pressure load\+:


\begin{DoxyCodeInclude}
 
  \textcolor{comment}{// The solid mesh boundaries where an internal pressure is applied}
 Solid\_traction\_boundary\_id.resize(12);
 \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} i=0;i<12;i++)
  \{
   Solid\_traction\_boundary\_id[i]=i+3;
  \}

\end{DoxyCodeInclude}


We apply the boundary conditions by pinning the displacements of all nodes that are located on the in-\/ and outflow faces, and document their positions.


\begin{DoxyCodeInclude}
 
 
 \textcolor{comment}{// Apply BCs for solid}
 \textcolor{comment}{//--------------------}
 
 \textcolor{comment}{// Doc pinned solid nodes}
 std::ofstream bc\_file(\textcolor{stringliteral}{"RESLT/pinned\_solid\_nodes.dat"});
 
 \textcolor{comment}{// Pin positions at inflow boundary (boundaries 0 and 1)}
 \textcolor{keywordtype}{unsigned} n=Pinned\_solid\_boundary\_id.size();
 \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} i=0;i<n;i++)
  \{
   \textcolor{comment}{// Get boundary ID}
   \textcolor{keywordtype}{unsigned} b=Pinned\_solid\_boundary\_id[i];
   \textcolor{keywordtype}{unsigned} num\_nod= Solid\_mesh\_pt->nboundary\_node(b);  
   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} inod=0;inod<num\_nod;inod++)
    \{    
     \textcolor{comment}{// Get node}
     SolidNode* nod\_pt=Solid\_mesh\_pt->boundary\_node\_pt(b,inod);
     
     \textcolor{comment}{// Pin all directions}
     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} i=0;i<3;i++)
      \{
       nod\_pt->pin\_position(i);
       
       \textcolor{comment}{// ...and doc it as pinned}
       bc\_file << nod\_pt->x(i) << \textcolor{stringliteral}{" "};
      \}
     
     bc\_file << std::endl;
    \}
  \}
 bc\_file.close();

\end{DoxyCodeInclude}


We complete the build of the elements by setting the pointer to the constitutive equation and the body force.


\begin{DoxyCodeInclude}
 
 
 
 \textcolor{comment}{// Complete the build of all elements so they are fully functional}
 \textcolor{comment}{//----------------------------------------------------------------}
 \textcolor{keywordtype}{unsigned} n\_element = Solid\_mesh\_pt->nelement();
 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} i=0;i<n\_element;i++)
  \{
   \textcolor{comment}{//Cast to a solid element}
   ELEMENT *el\_pt = \textcolor{keyword}{dynamic\_cast<}ELEMENT*\textcolor{keyword}{>}(
    Solid\_mesh\_pt->element\_pt(i));
   
   \textcolor{comment}{// Set the constitutive law   }
   el\_pt->constitutive\_law\_pt() =
    \hyperlink{namespaceGlobal__Parameters_adbd1f040f375c96fe56b3f475f7dbec2}{Global\_Parameters::Constitutive\_law\_pt};
   
   \textcolor{comment}{//Set the body force}
   el\_pt->body\_force\_fct\_pt() = \hyperlink{namespaceGlobal__Parameters_a200109847bf4cc26da4d00e8d68d569e}{Global\_Parameters::gravity};
  \}

\end{DoxyCodeInclude}


Next we create the traction elements, attaching them to the \char`\"{}bulk\char`\"{} solid elements that are adjacent to the boundaries that constitute the inside of the vessel.


\begin{DoxyCodeInclude}
 
 
 \textcolor{comment}{// Create traction elements}
 \textcolor{comment}{//-------------------------}
 
 \textcolor{comment}{// Create meshes of traction elements}
 n=Solid\_traction\_boundary\_id.size();
 Solid\_traction\_mesh\_pt.resize(n);
 \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} i=0;i<n;i++)
  \{
   Solid\_traction\_mesh\_pt[i]=\textcolor{keyword}{new} SolidMesh;
  \}
 
 \textcolor{comment}{// Build the traction elements}
 create\_traction\_elements();

\end{DoxyCodeInclude}


Finally, we add the various meshes as sub-\/meshes to the {\ttfamily Problem}, build the global mesh, and assign the equation numbers.


\begin{DoxyCodeInclude}


 \textcolor{comment}{// Combine the lot}
 \textcolor{comment}{//----------------}
 
 \textcolor{comment}{// The solid bulk mesh}
 add\_sub\_mesh(Solid\_mesh\_pt);

 \textcolor{comment}{// The solid traction meshes}
 n=Solid\_traction\_boundary\_id.size();
 \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} i=0;i<n;i++)
  \{
   add\_sub\_mesh(Solid\_traction\_mesh\_pt[i]);
  \}

 \textcolor{comment}{// Build global mesh}
 build\_global\_mesh();

 \textcolor{comment}{// Setup equation numbering scheme}
 std::cout <<\textcolor{stringliteral}{"Number of equations: "} << assign\_eqn\_numbers() << std::endl; 
 
\} \textcolor{comment}{// end constructor}

\end{DoxyCodeInclude}




 

\hypertarget{index_traction}{}\section{Creating the traction elements}\label{index_traction}
The helper function {\ttfamily create\+\_\+traction\+\_\+elements()} does exactly what it says\+: It loops over the bulk elements that are adjacent to the inner surface of the vessel, and attaches {\ttfamily Solid\+Traction\+Elements} to the appropriate faces. We store the pointers to the newly-\/created traction elements in separate meshes and specify the function pointer to the load function.


\begin{DoxyCodeInclude}



\textcolor{comment}{//============start\_of\_create\_traction\_elements==========================}\textcolor{comment}{}
\textcolor{comment}{/// Create traction elements }
\textcolor{comment}{}\textcolor{comment}{//=======================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT>
\textcolor{keywordtype}{void} \hyperlink{classUnstructuredSolidProblem_a9137960284200ed998989f785965f902}{UnstructuredSolidProblem<ELEMENT>::create\_traction\_elements}
      ()
\{

 \textcolor{comment}{// Loop over traction boundaries}
 \textcolor{keywordtype}{unsigned} n=Solid\_traction\_boundary\_id.size();
 \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} i=0;i<n;i++)
  \{
   \textcolor{comment}{// Get boundary ID}
   \textcolor{keywordtype}{unsigned} b=Solid\_traction\_boundary\_id[i];
   
   \textcolor{comment}{// How many bulk elements are adjacent to boundary b?}
   \textcolor{keywordtype}{unsigned} n\_element = Solid\_mesh\_pt->nboundary\_element(b);
   
   \textcolor{comment}{// Loop over the bulk elements adjacent to boundary b}
   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} e=0;e<n\_element;e++)
    \{
     \textcolor{comment}{// Get pointer to the bulk element that is adjacent to boundary b}
     ELEMENT* bulk\_elem\_pt = \textcolor{keyword}{dynamic\_cast<}ELEMENT*\textcolor{keyword}{>}(
      Solid\_mesh\_pt->boundary\_element\_pt(b,e));
     
     \textcolor{comment}{//What is the index of the face of the element e along boundary b}
     \textcolor{keywordtype}{int} face\_index = Solid\_mesh\_pt->face\_index\_at\_boundary(b,e);
     
     \textcolor{comment}{// Create new element }
     SolidTractionElement<ELEMENT>* el\_pt=
      \textcolor{keyword}{new} SolidTractionElement<ELEMENT>(bulk\_elem\_pt,face\_index);
     
     \textcolor{comment}{// Add it to the mesh}
     Solid\_traction\_mesh\_pt[i]->add\_element\_pt(el\_pt);
     
     \textcolor{comment}{//Set the traction function}
     el\_pt->traction\_fct\_pt() = \hyperlink{namespaceGlobal__Parameters_a7dc25ca2abd48b7f1bffb2d6129f02bd}{Global\_Parameters::constant\_pressure};
    \}
  \}
 
\} \textcolor{comment}{// end of create\_traction\_elements}

\end{DoxyCodeInclude}




 

\hypertarget{index_doc}{}\section{Post-\/processing}\label{index_doc}
The post-\/processing routine outputs the deformed domain shape and the applied traction.


\begin{DoxyCodeInclude}



\textcolor{comment}{//========================================================================}\textcolor{comment}{}
\textcolor{comment}{/// Doc the solution}
\textcolor{comment}{}\textcolor{comment}{//========================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT>
\textcolor{keywordtype}{void} \hyperlink{classUnstructuredSolidProblem_ab3d66fd61b69d12b4f159d763fc44f15}{UnstructuredSolidProblem<ELEMENT>::doc\_solution}(DocInfo
      & doc\_info)
\{ 

 ofstream some\_file;
 \textcolor{keywordtype}{char} filename[100];

 \textcolor{comment}{// Number of plot points}
 \textcolor{keywordtype}{unsigned} npts;
 npts=5;

 \textcolor{comment}{// Output solid solution}
 \textcolor{comment}{//-----------------------}
 sprintf(filename,\textcolor{stringliteral}{"%s/solid\_soln%i.dat"},doc\_info.directory().c\_str(),
         doc\_info.number());
 some\_file.open(filename);
 Solid\_mesh\_pt->output(some\_file,npts);
 some\_file.close();

    
 \textcolor{comment}{// Output traction}
 \textcolor{comment}{//----------------}
 sprintf(filename,\textcolor{stringliteral}{"%s/traction%i.dat"},doc\_info.directory().c\_str(),
         doc\_info.number());
 some\_file.open(filename);
 \textcolor{keywordtype}{unsigned} n=Solid\_traction\_boundary\_id.size();
 \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} i=0;i<n;i++)
  \{
   Solid\_traction\_mesh\_pt[i]->output(some\_file,npts);
  \}
 some\_file.close();

\} \textcolor{comment}{// end doc}

\end{DoxyCodeInclude}




 

\hypertarget{index_comm_ex}{}\section{Comments and Exercises}\label{index_comm_ex}
\hypertarget{index_bound}{}\subsection{Identification/assignment of mesh boundaries}\label{index_bound}
This tutorial shows that the use of unstructured 3D meshes for solid mechanics problems is extremely straightforward. The only aspect that requires some care (and not just for solid mechanics applications) is the correct identification/assignment of domain boundaries. The fact that we documented the position of the pinned nodes in the driver code suggests (correctly!) that we managed to get both assignments (slightly) wrong when we first generated the mesh and wrote the corresponding driver code. As usual, it pays off to {\bfseries be as a paranoid as possible}! Ignore this advice at your own risk...

Here is a plot of the position of the pinned solid nodes

 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{pinned_solid_nodes}
\doxyfigcaption{Plot of the pinned solid nodes. }
\end{DoxyImage}


and here\textquotesingle{}s a plot showing the {\ttfamily Solid\+Traction\+Elements} attached to the inside of the vessel\+:

 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{traction_faces}
\doxyfigcaption{Plot of the Solid\+Traction\+Elements that apply the pressure load to the inner surface of the vessel. }
\end{DoxyImage}




\hypertarget{index_your_own}{}\subsection{Exercise\+: Try it yourself}\label{index_your_own}
Experiment with the {\ttfamily tetgen} -\/based mesh generation by modifying the {\ttfamily $\ast$.poly} file used in this example to different vessel geometries.



 

\hypertarget{index_sources}{}\section{Source files for this tutorial}\label{index_sources}

\begin{DoxyItemize}
\item The source files for this tutorial are located in the directory\+:~\newline
~\newline
\begin{center} \href{../../../../demo_drivers/solid/unstructured_three_d_solid/}{\tt demo\+\_\+drivers/solid/unstructured\+\_\+three\+\_\+d\+\_\+solid/ } \end{center} ~\newline

\item The driver codes are\+: ~\newline
~\newline
\begin{center} \href{../../../../demo_drivers/solid/unstructured_three_d_solid/unstructured_three_d_solid.cc}{\tt demo\+\_\+drivers/solid/unstructured\+\_\+three\+\_\+d\+\_\+solid/unstructured\+\_\+three\+\_\+d\+\_\+solid.\+cc } \end{center}  and \begin{center} \href{../../../../demo_drivers/solid/unstructured_three_d_solid/unstructured_three_d_solid.cc}{\tt demo\+\_\+drivers/solid/unstructured\+\_\+three\+\_\+d\+\_\+solid/unstructured\+\_\+three\+\_\+d\+\_\+solid.\+cc } \end{center} 
\end{DoxyItemize}



 

 \hypertarget{index_pdf}{}\section{P\+D\+F file}\label{index_pdf}
A \href{../latex/refman.pdf}{\tt pdf version} of this document is available. \end{document}
