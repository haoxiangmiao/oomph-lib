The purpose of this tutorial is to demonstrate the adaptive solution of solid mechanics problems using unstructured meshes generated by {\ttfamily oomph-\/lib\textquotesingle{}s} \href{../../../../doc/meshes/mesh_from_inline_triangle/html/index.html}{\tt inline unstructured mesh generation } procedures. The use of these methods for solid mechanics problems required no additional effort on the part of the user and the setup is essentially the same as that described for \href{../../unstructured_solid/html/index.html}{\tt unstructured solid mechanics without mesh adaptation. } Lagrangian coordinates are projected between meshes in the same way as all other field variables, Eulerian coordinates and history values, see the description in \href{../../../meshes/mesh_from_inline_triangle/html/index.html}{\tt another tutorial. }

The solid mechanics problem described here can be regarded as a sub-\/problem for the \href{../../../../doc/interaction/unstructured_adaptive_fsi/html/index.html}{\tt unstructured adaptive fluid--structure interaction tutorial.} In addition, we can use the problem to assess the errors incurred when projecting the solution between different meshes.



 

\hypertarget{index_problem}{}\section{The problem}\label{index_problem}
An elastic bar is fixed at the base and loaded by a constant pressure on its left-\/hand side. The pressure load is increased and then decreased so that at the end of the simulation the bar should return to its undeformed position. The strain energy in the final configuration is a measure of the projection error because if there were no projection at all it would be exactly zero (or certainly zero to less than machine precision).

 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{solid_sketch}
\doxyfigcaption{Sketch of the problem. }
\end{DoxyImage}




 

\hypertarget{index_results}{}\section{Results}\label{index_results}
The animation shown below illustrates the solid\textquotesingle{}s deformation and illustrates the adaptation of the mesh as the load changes.

 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{solid_res}
\doxyfigcaption{Plot of the deformation. }
\end{DoxyImage}


The initial strain energy is $ O(10^{-28}) $, and the strain energy in the final configuration after the external pressure has been reset to zero, but the mesh has been adapted, is $ O(10^{-8}) $. The strain energy at the maximum deflection is $ O(10^{-3}) $.



 

\hypertarget{index_namespace}{}\section{Global Physical Variables}\label{index_namespace}
We define the various physical variables in a global namespace. We define Poisson\textquotesingle{}s ratio and prepare a pointer to a constitutive equation.

 
\begin{DoxyCodeInclude}
\textcolor{comment}{//=======start\_namespace==========================================}
\textcolor{comment}{/// Global variables}
\textcolor{comment}{}\textcolor{comment}{//================================================================}
\textcolor{keyword}{namespace }\hyperlink{namespaceGlobal__Physical__Variables}{Global\_Physical\_Variables}
\{\textcolor{comment}{}
\textcolor{comment}{ /// Poisson's ratio}
\textcolor{comment}{} \textcolor{keywordtype}{double} Nu=0.3;
\textcolor{comment}{}
\textcolor{comment}{ /// Pointer to constitutive law}
\textcolor{comment}{} ConstitutiveLaw* Constitutive\_law\_pt=0;

\end{DoxyCodeInclude}


Next we define the pressure load to be applied at the left-\/hand boundary,


\begin{DoxyCodeInclude}
 \textcolor{comment}{}
\textcolor{comment}{ /// Uniform pressure}
\textcolor{comment}{} \textcolor{keywordtype}{double} P = 0.0;
\textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Constant pressure load. The arguments to this function are imposed}
\textcolor{comment}{ /// on us by the SolidTractionElements which allow the traction to }
\textcolor{comment}{ /// depend on the Lagrangian and Eulerian coordinates x and xi, and on the }
\textcolor{comment}{ /// outer unit normal to the surface. Here we only need the outer unit}
\textcolor{comment}{ /// normal.}
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{namespaceGlobal__Physical__Variables_a19f4e20a92e7d216b4d2b00308f96917}{constant\_pressure}(\textcolor{keyword}{const} Vector<double> &xi, \textcolor{keyword}{const} Vector<double> &x,
                        \textcolor{keyword}{const} Vector<double> &n, Vector<double> &traction)
 \{
  \textcolor{keywordtype}{unsigned} dim = traction.size();
  \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} i=0;i<dim;i++)
   \{
    traction[i] = -P*n[i];
   \}
 \} 

\} \textcolor{comment}{//end namespace}

\end{DoxyCodeInclude}




 

\hypertarget{index_main}{}\section{The driver code}\label{index_main}
The driver code consists of essentially the same code repeated for three different formulations of solid mechanics\+: (i) (compressible) displacement only; (ii) (compressible) displacement-\/pressure; and (iii) incompressible displacement-\/pressure. We shall describe the code only for the first formulation.

Initially, we specify an output directory and instantiate a constitutive equation. (Recall that the single-\/argument constructor to the {\ttfamily Generalised\+Hookean} constitutive law implies that all stresses are non-\/dimensionalised on Young\textquotesingle{}s modulus $ E $).

 
\begin{DoxyCodeInclude}
\textcolor{comment}{//===========start\_main===================================================}
\textcolor{comment}{/// Demonstrate how to solve an unstructured solid problem}
\textcolor{comment}{}\textcolor{comment}{//========================================================================}
\textcolor{keywordtype}{int} \hyperlink{unstructured__adaptive__solid_8cc_a3c04138a5bfe5d72780bb7e82a18e627}{main}(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char} **argv)
\{

 \textcolor{comment}{//Doc info object}
 DocInfo doc\_info;

 \textcolor{comment}{// Output directory}
 doc\_info.set\_directory(\textcolor{stringliteral}{"RESLT"});
 
 \textcolor{comment}{// Create generalised Hookean constitutive equations}
 \hyperlink{namespaceGlobal__Physical__Variables_a2a37fb040c832ee7a086bb13bb02a100}{Global\_Physical\_Variables::Constitutive\_law\_pt} = 
  \textcolor{keyword}{new} GeneralisedHookean(&\hyperlink{namespaceGlobal__Physical__Variables_a3962c36313826b19f216f6bbbdd6a477}{Global\_Physical\_Variables::Nu});

\end{DoxyCodeInclude}


We then open an output file for the strain energy, create the {\ttfamily Problem} object using a displacement formulation of the equations and output the initial configuration.


\begin{DoxyCodeInclude}
 
 \{
  std::ofstream strain(\textcolor{stringliteral}{"RESLT/s\_energy.dat"});
  std::cout << \textcolor{stringliteral}{"Running with pure displacement formulation\(\backslash\)n"};

  \textcolor{comment}{//Set up the problem}
  \hyperlink{classUnstructuredSolidProblem}{UnstructuredSolidProblem<ProjectablePVDElement<TPVDElement<2,3>}
       > > problem;
  
  \textcolor{comment}{//Output initial configuration}
  problem.\hyperlink{classUnstructuredSolidProblem_ab3d66fd61b69d12b4f159d763fc44f15}{doc\_solution}(doc\_info);
  doc\_info.number()++;

\end{DoxyCodeInclude}


Finally, we perform the parameter study by slowly increasing and then reducing the pressure on the left-\/hand boundary. Note that one round of mesh adaptation is specified for every Newton solve.


\begin{DoxyCodeInclude}
  
  \textcolor{comment}{// Parameter study}
  \hyperlink{namespaceGlobal__Physical__Variables_a23c2ade6398f54040b869f7f3a2bcc4b}{Global\_Physical\_Variables::P}=0.0;
  \textcolor{keywordtype}{double} pressure\_increment=0.1e-2;
  
  \textcolor{keywordtype}{unsigned} nstep=5;

  \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} istep=0;istep<nstep;istep++)
   \{
    \textcolor{comment}{// Solve the problem with one round of adaptivity}
    problem.newton\_solve(1);

    \textcolor{keywordtype}{double} strain\_energy = problem.\hyperlink{classUnstructuredSolidProblem_a4da918a1f0cf94ebccc5112b58c28ece}{get\_strain\_energy}();
    std::cout << \textcolor{stringliteral}{"Strain energy is "} << strain\_energy << \textcolor{stringliteral}{"\(\backslash\)n"};
    \textcolor{comment}{//Output strain energy to file}
    strain << \hyperlink{namespaceGlobal__Physical__Variables_a23c2ade6398f54040b869f7f3a2bcc4b}{Global\_Physical\_Variables::P} << \textcolor{stringliteral}{" "} << strain\_energy << std::endl
      ;

    \textcolor{comment}{//Output solution}
    problem.\hyperlink{classUnstructuredSolidProblem_ab3d66fd61b69d12b4f159d763fc44f15}{doc\_solution}(doc\_info);
    doc\_info.number()++;
    
    \textcolor{comment}{//Reverse direction of increment }
    \textcolor{keywordflow}{if}(istep==2) \{pressure\_increment *= -1.0;\}

    \textcolor{comment}{// Increase (or decrease) load}
    \hyperlink{namespaceGlobal__Physical__Variables_a23c2ade6398f54040b869f7f3a2bcc4b}{Global\_Physical\_Variables::P}+=pressure\_increment;
   \}

  strain.close();
 \} \textcolor{comment}{//end\_displacement\_formulation}

\end{DoxyCodeInclude}




 

\hypertarget{index_class}{}\section{The Problem class}\label{index_class}
The {\ttfamily Problem} class has the obvious member functions as well as a function to set whether the material is incompressible and a function to compute the strain energy of the elastic body. The class provides storage for the two sub-\/meshes\+: the bulk mesh of 2D solid elements and the mesh of 1D traction elements that will be attached to the left-\/hand boundary. In addition, storage is provided for the polygon that represents the initial outer boundary of the solid body and a boolean flag that is used to specify whether the material is incompressible or not.

 
\begin{DoxyCodeInclude}
\textcolor{comment}{//==============start\_problem=========================================}
\textcolor{comment}{/// Unstructured solid problem}
\textcolor{comment}{}\textcolor{comment}{//====================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT> 
\textcolor{keyword}{class }\hyperlink{classUnstructuredSolidProblem}{UnstructuredSolidProblem} : \textcolor{keyword}{public} Problem
\{

\textcolor{keyword}{public}:
\textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Constructor: }
\textcolor{comment}{} \hyperlink{classUnstructuredSolidProblem_a18ce02b6e4bbc86403c9e1b32c095772}{UnstructuredSolidProblem}();
\textcolor{comment}{}
\textcolor{comment}{ /// Destructor (empty)}
\textcolor{comment}{} \hyperlink{classUnstructuredSolidProblem_a25fe105d949498bf8f7c15aff96a7d00}{~UnstructuredSolidProblem}()\{\}
 \textcolor{comment}{}
\textcolor{comment}{ /// Set the problem to be incompressible}
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{classUnstructuredSolidProblem_a9b725d83bc051b594d080a40d6d317d3}{set\_incompressible}() \{\hyperlink{classUnstructuredSolidProblem_a956386972054504cdc23fd970b126934}{Incompressible}=\textcolor{keyword}{true};\}
\textcolor{comment}{}
\textcolor{comment}{ /// Doc the solution}
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{classUnstructuredSolidProblem_ab3d66fd61b69d12b4f159d763fc44f15}{doc\_solution}(DocInfo& doc\_info);
\textcolor{comment}{}
\textcolor{comment}{ /// Calculate the strain energy}
\textcolor{comment}{} \textcolor{keywordtype}{double} \hyperlink{classUnstructuredSolidProblem_a4da918a1f0cf94ebccc5112b58c28ece}{get\_strain\_energy}();
\textcolor{comment}{}
\textcolor{comment}{ /// Remove Traction Mesh}
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{classUnstructuredSolidProblem_a463b4b976fdd12129ac2bd23bece1b8b}{actions\_before\_adapt}();
\textcolor{comment}{}
\textcolor{comment}{ /// Add on the traction elements after adaptation}
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{classUnstructuredSolidProblem_acf0bbf57534a1516a633d702d9fd21ab}{actions\_after\_adapt}();

\textcolor{keyword}{private}:
 \textcolor{comment}{}
\textcolor{comment}{ /// Bulk mesh}
\textcolor{comment}{} RefineableSolidTriangleMesh<ELEMENT>* \hyperlink{classUnstructuredSolidProblem_af121067bd532a78b4360373b60aaddd0}{Solid\_mesh\_pt};
 \textcolor{comment}{}
\textcolor{comment}{ /// Pointer to mesh of traction elements}
\textcolor{comment}{} SolidMesh* \hyperlink{classUnstructuredSolidProblem_a42018e62ce6bf48968f389880669c8f4}{Traction\_mesh\_pt};
\textcolor{comment}{}
\textcolor{comment}{ /// Triangle mesh polygon for outer boundary }
\textcolor{comment}{} TriangleMeshPolygon* \hyperlink{classUnstructuredSolidProblem_a2e7ef7b4984d6d2a063c0c2374931d0c}{Outer\_boundary\_polyline\_pt}; 
\textcolor{comment}{}
\textcolor{comment}{ /// Boolean flag used in an incompressible problem}
\textcolor{comment}{} \textcolor{keywordtype}{bool} \hyperlink{classUnstructuredSolidProblem_a956386972054504cdc23fd970b126934}{Incompressible};

\};

\end{DoxyCodeInclude}




 

\hypertarget{index_constructor}{}\section{The Problem constructor}\label{index_constructor}
We begin by building the closed, piecewise linear boundary of the undeformed solid body $ x_{1} \in [0,1] $, $ x_{2} \in [0,5]. $ The boundaries are labelled anticlockwise with boundary with the left-\/hand boundary being boundary 0, see the sketch above. This process is a simplified version of the construction used in \href{../../../../doc/meshes/mesh_from_inline_triangle/html/index.html}{\tt another tutorial. }

 
\begin{DoxyCodeInclude}
\textcolor{comment}{//===============start\_constructor========================================}
\textcolor{comment}{/// Constructor for unstructured solid problem}
\textcolor{comment}{}\textcolor{comment}{//========================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT>
\hyperlink{classUnstructuredSolidProblem_a18ce02b6e4bbc86403c9e1b32c095772}{UnstructuredSolidProblem<ELEMENT>::UnstructuredSolidProblem}
      () :
 Incompressible(false)
\{  
 \textcolor{comment}{// Build the boundary segments for outer boundary, consisting of}
 \textcolor{comment}{//--------------------------------------------------------------}
 \textcolor{comment}{// four separeate polyline segments}
 \textcolor{comment}{//---------------------------------}
 Vector<TriangleMeshCurveSection*> boundary\_segment\_pt(4);
 
 \textcolor{comment}{// Initialize boundary segment}
 Vector<Vector<double> > bound\_seg(2);
 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} i=0;i<2;i++) \{bound\_seg[i].resize(2);\}
 
 \textcolor{comment}{// First boundary segment}
 bound\_seg[0][0]=0.0;
 bound\_seg[0][1]=0.0;
 bound\_seg[1][0]=0.0;
 bound\_seg[1][1]=5.0;
 
 \textcolor{comment}{// Specify 1st boundary id}
 \textcolor{keywordtype}{unsigned} bound\_id = 0;

 \textcolor{comment}{// Build the 1st boundary segment}
 boundary\_segment\_pt[0] = \textcolor{keyword}{new} TriangleMeshPolyLine(bound\_seg,bound\_id);
 
 \textcolor{comment}{// Second boundary segment}
 bound\_seg[0][0]=0.0;
 bound\_seg[0][1]=5.0;
 bound\_seg[1][0]=1.0;
 bound\_seg[1][1]=5.0;

 \textcolor{comment}{// Specify 2nd boundary id}
 bound\_id = 1;

 \textcolor{comment}{// Build the 2nd boundary segment}
 boundary\_segment\_pt[1] = \textcolor{keyword}{new} TriangleMeshPolyLine(bound\_seg,bound\_id);

 \textcolor{comment}{// Third boundary segment}
 bound\_seg[0][0]=1.0;
 bound\_seg[0][1]=5.0;
 bound\_seg[1][0]=1.0;
 bound\_seg[1][1]=0.0;

 \textcolor{comment}{// Specify 3rd boundary id}
 bound\_id = 2;

 \textcolor{comment}{// Build the 3rd boundary segment}
 boundary\_segment\_pt[2] = \textcolor{keyword}{new} TriangleMeshPolyLine(bound\_seg,bound\_id);

 \textcolor{comment}{// Fourth boundary segment}
 bound\_seg[0][0]=1.0;
 bound\_seg[0][1]=0.0;
 bound\_seg[1][0]=0.0;
 bound\_seg[1][1]=0.0;

 \textcolor{comment}{// Specify 4th boundary id}
 bound\_id = 3;

 \textcolor{comment}{// Build the 4th boundary segment}
 boundary\_segment\_pt[3] = \textcolor{keyword}{new} TriangleMeshPolyLine(bound\_seg,bound\_id);
  
 \textcolor{comment}{// Create the triangle mesh polygon for outer boundary using boundary segment}
 Outer\_boundary\_polyline\_pt = \textcolor{keyword}{new} TriangleMeshPolygon(boundary\_segment\_pt);


 \textcolor{comment}{// There are no holes}
 \textcolor{comment}{//-------------------------------}
 
 \textcolor{comment}{// Now build the mesh, based on the boundaries specified by}
 \textcolor{comment}{//---------------------------------------------------------}
 \textcolor{comment}{// polygons just created}
 \textcolor{comment}{//----------------------}
 \textcolor{keywordtype}{double} uniform\_element\_area=0.2;

 TriangleMeshClosedCurve* closed\_curve\_pt=Outer\_boundary\_polyline\_pt;

 \textcolor{comment}{// Use the TriangleMeshParameters object for gathering all}
 \textcolor{comment}{// the necessary arguments for the TriangleMesh object}
 TriangleMeshParameters triangle\_mesh\_parameters(
   closed\_curve\_pt);

 \textcolor{comment}{// Define the maximum element area}
 triangle\_mesh\_parameters.element\_area() =
   uniform\_element\_area;

 \textcolor{comment}{// Create the mesh}
 Solid\_mesh\_pt =
   \textcolor{keyword}{new} RefineableSolidTriangleMesh<ELEMENT>(
     triangle\_mesh\_parameters);

\end{DoxyCodeInclude}


We next construct an error estimator and specify the target errors and element sizes.


\begin{DoxyCodeInclude}
 
 \textcolor{comment}{//hierher}
 \textcolor{comment}{// Disable the use of an iterative solver for the projection}
 \textcolor{comment}{// stage during mesh adaptation}
 Solid\_mesh\_pt->disable\_iterative\_solver\_for\_projection();
 
 \textcolor{comment}{// Set error estimator for bulk mesh}
 Z2ErrorEstimator* error\_estimator\_pt=\textcolor{keyword}{new} Z2ErrorEstimator;
 Solid\_mesh\_pt->spatial\_error\_estimator\_pt()=error\_estimator\_pt;


 \textcolor{comment}{// Set targets for spatial adaptivity}
 Solid\_mesh\_pt->max\_permitted\_error()=0.0001;
 Solid\_mesh\_pt->min\_permitted\_error()=0.001; 
 Solid\_mesh\_pt->max\_element\_size()=0.2;
 Solid\_mesh\_pt->min\_element\_size()=0.001; 

\end{DoxyCodeInclude}


We output the boundaries, construct an empty traction mesh and combine the bulk and traction meshes into a global mesh.


\begin{DoxyCodeInclude}
   
 \textcolor{comment}{// Output mesh boundaries}
 this->Solid\_mesh\_pt->output\_boundaries(\textcolor{stringliteral}{"boundaries.dat"});

 \textcolor{comment}{// Make the traction mesh}
 Traction\_mesh\_pt=\textcolor{keyword}{new} SolidMesh;
 
 \textcolor{comment}{// Add sub meshes}
 add\_sub\_mesh(Solid\_mesh\_pt);
 add\_sub\_mesh(Traction\_mesh\_pt);
 
 \textcolor{comment}{// Build the global mesh}
 build\_global\_mesh();

\end{DoxyCodeInclude}


Finally we call {\ttfamily actions\+\_\+after\+\_\+adapt()}, which constructs the traction elements, sets the boundary conditions and completes the build of the elements, and then we assign the equation numbers


\begin{DoxyCodeInclude}

 \textcolor{comment}{//Call actions after adapt:}
 \textcolor{comment}{// 1) to build the traction elements}
 \textcolor{comment}{// 2) to pin the nodes on the lower boundary (boundary 3)}
 \textcolor{comment}{// 3) to complete the build of the elements}
 \textcolor{comment}{// Note there is slight duplication here because we rebuild the global mesh}
 \textcolor{comment}{// twice.}
 this->actions\_after\_adapt();
   
 \textcolor{comment}{// Setup equation numbering scheme}
 cout <<\textcolor{stringliteral}{"Number of equations: "} << assign\_eqn\_numbers() << std::endl; 
 
\} \textcolor{comment}{//end constructor}

\end{DoxyCodeInclude}




 

\hypertarget{index_adapt_after}{}\section{Actions before adaptation}\label{index_adapt_after}
The {\ttfamily actions\+\_\+before\+\_\+adapt()} function simply deletes the traction elements and clears the storage in the face mesh.

 
\begin{DoxyCodeInclude}
\textcolor{comment}{//==============start\_actions\_before\_adapt================================}
\textcolor{comment}{/// Actions before adapt: remove the traction elements in the surface mesh}
\textcolor{comment}{}\textcolor{comment}{//========================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT>
\textcolor{keywordtype}{void} \hyperlink{classUnstructuredSolidProblem_a463b4b976fdd12129ac2bd23bece1b8b}{UnstructuredSolidProblem<ELEMENT>::actions\_before\_adapt}
      ()
\{
 \textcolor{comment}{// How many surface elements are in the surface mesh}
 \textcolor{keywordtype}{unsigned} n\_element = Traction\_mesh\_pt->nelement();
 
 \textcolor{comment}{// Loop over the surface elements and kill them}
 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} e=0;e<n\_element;e++) \{\textcolor{keyword}{delete} Traction\_mesh\_pt->element\_pt(e);\}
 
 \textcolor{comment}{// Wipe the mesh}
 Traction\_mesh\_pt->flush\_element\_and\_node\_storage();

\} \textcolor{comment}{// end\_actions\_before\_adapt}

\end{DoxyCodeInclude}




 

\hypertarget{index_adapt_after}{}\section{Actions before adaptation}\label{index_adapt_after}
The function {\ttfamily actions\+\_\+after\+\_\+adapt()} first builds the traction elements adjacent to the left-\/hand boundary (boundary 0) and rebuilds the global mesh. The {\ttfamily \hyperlink{namespaceGlobal__Physical__Variables_a19f4e20a92e7d216b4d2b00308f96917}{constant\+\_\+pressure()}} load function is passed to each of the traction elements.


\begin{DoxyCodeInclude}

\textcolor{comment}{//=================start\_actions\_after\_adapt=============================}\textcolor{comment}{}
\textcolor{comment}{ /// Need to add on the traction elements after adaptation}
\textcolor{comment}{}\textcolor{comment}{//=======================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT>
\textcolor{keywordtype}{void} \hyperlink{classUnstructuredSolidProblem_acf0bbf57534a1516a633d702d9fd21ab}{UnstructuredSolidProblem<ELEMENT>::actions\_after\_adapt}
      ()
\{
 \textcolor{comment}{//The boundary in question is boundary 0}
 \textcolor{keywordtype}{unsigned} b=0;
 
 \textcolor{comment}{// How many bulk elements are adjacent to boundary b?}
 \textcolor{keywordtype}{unsigned} n\_element = Solid\_mesh\_pt->nboundary\_element(b);
 \textcolor{comment}{// Loop over the bulk elements adjacent to boundary b}
 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} e=0;e<n\_element;e++)
  \{
   \textcolor{comment}{// Get pointer to the bulk element that is adjacent to boundary b}
   ELEMENT* bulk\_elem\_pt = \textcolor{keyword}{dynamic\_cast<}ELEMENT*\textcolor{keyword}{>}(
    Solid\_mesh\_pt->boundary\_element\_pt(b,e));
   
   \textcolor{comment}{//Find the index of the face of element e along boundary b}
   \textcolor{keywordtype}{int} face\_index = Solid\_mesh\_pt->face\_index\_at\_boundary(b,e);
   
   \textcolor{comment}{//Create solid traction element}
   SolidTractionElement<ELEMENT> *el\_pt = 
    \textcolor{keyword}{new} SolidTractionElement<ELEMENT>(bulk\_elem\_pt,face\_index);   
   
   \textcolor{comment}{// Add to mesh}
   Traction\_mesh\_pt->add\_element\_pt(el\_pt);
   
   \textcolor{comment}{//Set the traction function}
   el\_pt->traction\_fct\_pt() = \hyperlink{namespaceGlobal__Physical__Variables_a19f4e20a92e7d216b4d2b00308f96917}{Global\_Physical\_Variables::constant\_pressure}
      ;
  \}  
 
 \textcolor{comment}{//Now rebuild the global mesh}
 this->rebuild\_global\_mesh();

\end{DoxyCodeInclude}


Next, the boundary conditions of a fixed base (boundary 3) are set. These must be reset every time after an adaptation because completely new nodes are generated.


\begin{DoxyCodeInclude}
 
 \textcolor{comment}{//(Re)set the boundary conditions}
 \textcolor{comment}{//Pin both positions at lower boundary (boundary 3)}
 \textcolor{keywordtype}{unsigned} ibound=3;
 \textcolor{keywordtype}{unsigned} num\_nod= mesh\_pt()->nboundary\_node(ibound);
 \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} inod=0;inod<num\_nod;inod++)
  \{  
   \textcolor{comment}{// Get node}
   SolidNode* nod\_pt=Solid\_mesh\_pt->boundary\_node\_pt(ibound,inod);
   
   \textcolor{comment}{// Pin both directions}
   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} i=0;i<2;i++) \{nod\_pt->pin\_position(i);\}
  \}
 \textcolor{comment}{//End of set boundary conditions }

\end{DoxyCodeInclude}


Finally, the constitutive law and, if required, incompressibility flag are passed to the bulk (solid) elements. Again, this must be performed after every adaptation because a completely new mesh is generated.


\begin{DoxyCodeInclude}
 
 \textcolor{comment}{// Complete the build of all elements so they are fully functional}
 n\_element = Solid\_mesh\_pt->nelement();
 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} e=0;e<n\_element;e++)
  \{
   \textcolor{comment}{//Cast to a solid element}
   ELEMENT *el\_pt = \textcolor{keyword}{dynamic\_cast<}ELEMENT*\textcolor{keyword}{>}(Solid\_mesh\_pt->element\_pt(e));
   
   \textcolor{comment}{// Set the constitutive law}
   el\_pt->constitutive\_law\_pt() =
    \hyperlink{namespaceGlobal__Physical__Variables_a2a37fb040c832ee7a086bb13bb02a100}{Global\_Physical\_Variables::Constitutive\_law\_pt};
   
   \textcolor{comment}{//Set the incompressibility flag if required}
   \textcolor{keywordflow}{if}(Incompressible) 
    \{
     \textcolor{comment}{//Need another dynamic cast}
     \textcolor{keyword}{dynamic\_cast<}TPVDElementWithContinuousPressure<2>*\textcolor{keyword}{>}(el\_pt)
      ->set\_incompressible();
    \}
  \}

\} \textcolor{comment}{// end\_actions\_after\_adapt}

\end{DoxyCodeInclude}




 

\hypertarget{index_strain}{}\section{Computation of the strain energy}\label{index_strain}
The strain energy is computed by looping over all elements in the bulk mesh and adding their contributions to the potential (strain) energy.

 
\begin{DoxyCodeInclude}
\textcolor{comment}{//================start\_get\_strain\_energy================================}
\textcolor{comment}{/// Calculate the strain energy in the entire elastic solid}
\textcolor{comment}{}\textcolor{comment}{//=======================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT>
\textcolor{keywordtype}{double} \hyperlink{classUnstructuredSolidProblem_a4da918a1f0cf94ebccc5112b58c28ece}{UnstructuredSolidProblem<ELEMENT>::get\_strain\_energy}
      ()
\{
 \textcolor{keywordtype}{double} strain\_energy=0.0;
 \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} n\_element = Solid\_mesh\_pt->nelement();
 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} e=0;e<n\_element;e++)
  \{
   \textcolor{comment}{//Cast to a solid element}
   ELEMENT *el\_pt = \textcolor{keyword}{dynamic\_cast<}ELEMENT*\textcolor{keyword}{>}(Solid\_mesh\_pt->element\_pt(e));
   
   \textcolor{keywordtype}{double} pot\_en, kin\_en;
   el\_pt->get\_energy(pot\_en,kin\_en);
   strain\_energy += pot\_en;
  \}
 
 \textcolor{keywordflow}{return} strain\_energy;
\} \textcolor{comment}{// end\_get\_strain\_energy}

\end{DoxyCodeInclude}




 

\hypertarget{index_doc}{}\section{Post-\/processing}\label{index_doc}
The post-\/processing routine outputs the deformed domain shape and the applied traction. In the spirit of continuing paranoia we also document the domain boundaries. It is exactly the same as in the related \href{../../unstructured_solid/html/index.html}{\tt non-\/adaptive unstructured solid tutorial. }



 

\hypertarget{index_comm_ex}{}\section{Comments and Exercises}\label{index_comm_ex}
\hypertarget{index_ex}{}\subsection{Exercises}\label{index_ex}

\begin{DoxyEnumerate}
\item Examine the changes in strain energy under variations in mesh refinement tolerances and number of intermediate steps between the undeformed and maximally deformed states.
\item What happens if the Lagrangian coordinates are reset after every adaptation? Why?
\item Modify the problem so that compression is from the upper surface, rather than the left-\/hand side. What happens when the material is incompressible?
\end{DoxyEnumerate}



 

\hypertarget{index_sources}{}\section{Source files for this tutorial}\label{index_sources}

\begin{DoxyItemize}
\item The source files for this tutorial are located in the directory\+:~\newline
~\newline
\begin{center} \href{../../../../demo_drivers/solid/unstructured_adaptive_solid/}{\tt demo\+\_\+drivers/solid/unstructured\+\_\+adaptive\+\_\+solid/ } \end{center} ~\newline

\item The driver codes are\+: ~\newline
~\newline
\begin{center} \href{../../../../demo_drivers/solid/unstructured_adaptive_solid/unstructured_adaptive_solid.cc}{\tt demo\+\_\+drivers/solid/unstructured\+\_\+solid/unstructured\+\_\+adaptive\+\_\+solid.\+cc } \end{center} 
\end{DoxyItemize}



 

 \hypertarget{index_pdf}{}\section{P\+D\+F file}\label{index_pdf}
A \href{../latex/refman.pdf}{\tt pdf version} of this document is available. \end{document}
