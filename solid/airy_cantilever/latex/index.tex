In this example we solve a classical solid mechanics problem, the bending of a cantilever beam, subject to a pressure loading on its upper face and/or gravity. We assume that the material behaves like a generalised Hookean solid with elastic modulus $ E^* $ and Poisson\textquotesingle{}s ratio $ \nu $ Here is a sketch\+:

 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{airy_cantilever_sketch}
\doxyfigcaption{Sketch of the problem. }
\end{DoxyImage}


This problem is interesting because it has an (approximate) St. Venant solution for the stress field which may be constructed in terms of an Airy stress function (see, e.\+g. H. Eschenauer \& W. Schnell \char`\"{}\+Elastizitaetstheorie I\char`\"{}, BI Wissenschaftsverlag, 2nd edition, 1986).



 

\hypertarget{index_results}{}\section{Results}\label{index_results}
The following figure shows an animation of beam\textquotesingle{}s deformation in response to an increase in the uniform pressure, $ P $, at zero gravity, $ g=0 $. The colour contours represent the magnitude of the \char`\"{}horizontal\char`\"{} component of the 2nd Piola-\/\+Kirchhoff stress tensor, $ \sigma_{11} $ . Its approximately linear variation across the beam\textquotesingle{}s thickness indicates a bending-\/type stress distribution with the stress being positive (tensile) at the top and negative (compressive) at the bottom.

 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{beam_animation}
\doxyfigcaption{Animation of the beam\textquotesingle{}s deformation with contours of its `horizontal\textquotesingle{} stress component. }
\end{DoxyImage}


The next figure shows a comparison of the computational predictions for $ \sigma_{11} $ (in green), and the approximate analytical solution (in red).

 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{stress_comparison}
\doxyfigcaption{Comparison of the computed distribution of the `horizontal\textquotesingle{} stress (in green) against the approximate analytical solution (in red). }
\end{DoxyImage}


The agreement between the two solutions is excellent over most of the domain, apart from two small regions near the left end of the beam where stress singularities develop at the vertices of the domain. The singularities arise because the zero-\/tangential stress boundary condition on the top and bottom faces is inconsistent with the zero-\/displacement boundary condition on the left face. The singularities are not captured by the approximate analytical solution. {\ttfamily oomph-\/lib\textquotesingle{}s} automatic mesh adaptation refines the mesh in an attempt to capture the rapid variations of the stresses in these regions.



 

\hypertarget{index_global}{}\section{Global parameters and functions}\label{index_global}
As usual, we define a namespace, {\ttfamily \hyperlink{namespaceGlobal__Physical__Variables}{Global\+\_\+\+Physical\+\_\+\+Variables}}, to define the problem parameters\+: the dimensions of the cantilever beam, (a pointer to) a constitutive equation, and its parameters $ E $ and $ \nu $.

 
\begin{DoxyCodeInclude}
\textcolor{comment}{//=======start\_namespace==========================================}
\textcolor{comment}{/// Global variables}
\textcolor{comment}{}\textcolor{comment}{//================================================================}
\textcolor{keyword}{namespace }\hyperlink{namespaceGlobal__Physical__Variables}{Global\_Physical\_Variables}
\{
\textcolor{comment}{}
\textcolor{comment}{ /// Half height of beam}
\textcolor{comment}{} \textcolor{keywordtype}{double} H=0.5;
\textcolor{comment}{}
\textcolor{comment}{ /// Length of beam}
\textcolor{comment}{} \textcolor{keywordtype}{double} L=10.0;
\textcolor{comment}{}
\textcolor{comment}{ /// Pointer to constitutive law}
\textcolor{comment}{} ConstitutiveLaw* \hyperlink{namespaceGlobal__Physical__Variables_a5d5f19442938130d36ee7476ae25049c}{Constitutive\_law\_pt};
\textcolor{comment}{}
\textcolor{comment}{ /// Elastic modulus}
\textcolor{comment}{} \textcolor{keywordtype}{double} E=1.0;
\textcolor{comment}{}
\textcolor{comment}{ /// Poisson's ratio}
\textcolor{comment}{} \textcolor{keywordtype}{double} Nu=0.3;

\end{DoxyCodeInclude}


We refer to the document \href{../../solid_theory/html/index.html}{\tt \char`\"{}\+Solid mechanics\+: Theory and implementation\char`\"{}} for a detailed discussion of the non-\/dimensionalisation and merely recall that by setting $ E = 1$, we imply that all stresses are non-\/dimensionalised with the structure\textquotesingle{}s dimensional Young\textquotesingle{}s modulus $ E^* $. Similarly, by setting the half-\/thickness of the beam to 0.\+5, we imply that the beam\textquotesingle{}s dimensional thickness, $ 2H^*$ is used to non-\/dimensionalise all lengths.

Next, we define a function that defines the constant pressure load on the upper face of the cantilever,


\begin{DoxyCodeInclude}
 \textcolor{comment}{/// Uniform pressure}
 \textcolor{keywordtype}{double} P = 0.0;
\textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Constant pressure load. The arguments to this function are imposed}
\textcolor{comment}{ /// on us by the SolidTractionElements which allow the traction to }
\textcolor{comment}{ /// depend on the Lagrangian and Eulerian coordinates x and xi, and on the }
\textcolor{comment}{ /// outer unit normal to the surface. Here we only need the outer unit}
\textcolor{comment}{ /// normal.}
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{namespaceGlobal__Physical__Variables_a19f4e20a92e7d216b4d2b00308f96917}{constant\_pressure}(\textcolor{keyword}{const} Vector<double> &xi, \textcolor{keyword}{const} Vector<double> &x,
                        \textcolor{keyword}{const} Vector<double> &n, Vector<double> &traction)
 \{
  \textcolor{keywordtype}{unsigned} dim = traction.size();
  \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} i=0;i<dim;i++)
   \{
    traction[i] = -P*n[i];
   \}
 \} \textcolor{comment}{// end traction}

\end{DoxyCodeInclude}


and a gravitational body force, acting in the negative $ x_2 $ -\/direction,


\begin{DoxyCodeInclude}
 \textcolor{comment}{/// Non-dim gravity}
 \textcolor{keywordtype}{double} \hyperlink{namespaceGlobal__Physical__Variables_a8b80d3e8d63b8d0a0ed435a2dd7fe2ad}{Gravity}=0.0;
\textcolor{comment}{}
\textcolor{comment}{ /// Non-dimensional gravity as body force}
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{namespaceGlobal__Physical__Variables_a0777aef63372db7f91ad894c38159681}{gravity}(\textcolor{keyword}{const} \textcolor{keywordtype}{double}& time, 
              \textcolor{keyword}{const} Vector<double> &xi, 
              Vector<double> &b)
 \{
  b[0]=0.0;
  b[1]=-\hyperlink{namespaceGlobal__Physical__Variables_a8b80d3e8d63b8d0a0ed435a2dd7fe2ad}{Gravity};
 \}
 
\} \textcolor{comment}{//end namespace}

\end{DoxyCodeInclude}




 

\hypertarget{index_main}{}\section{The driver code}\label{index_main}
The driver code is very short. We start by building a {\ttfamily Generalised\+Hookean} constitutive equation object and store a pointer to it in the namespace {\ttfamily \hyperlink{namespaceGlobal__Physical__Variables}{Global\+\_\+\+Physical\+\_\+\+Variables}}. Next we construct the problem object, using (a wrapped version of) {\ttfamily oomph-\/lib\textquotesingle{}s} {\ttfamily Refineable\+Q\+P\+V\+D\+Element$<$2,3$>$} -- a nine-\/node quadrilateral displacement-\/based solid mechanics element. (The wrapper is used to change the element\textquotesingle{}s output function; see \hyperlink{index_com}{Comment\+: Customising an element\textquotesingle{}s output function} for details).

 
\begin{DoxyCodeInclude}
\textcolor{comment}{//=======start\_of\_main==================================================}
\textcolor{comment}{/// Driver for cantilever beam loaded by surface traction and/or}
\textcolor{comment}{}\textcolor{comment}{/// gravity}
\textcolor{comment}{}\textcolor{comment}{//======================================================================}
\textcolor{keywordtype}{int} \hyperlink{airy__cantilever_8cc_ae66f6b31b5ad750f1fe042a706a4e3d4}{main}()
\{

 \textcolor{comment}{// Create generalised Hookean constitutive equations}
 \hyperlink{namespaceGlobal__Physical__Variables_a5d5f19442938130d36ee7476ae25049c}{Global\_Physical\_Variables::Constitutive\_law\_pt} = 
  \textcolor{keyword}{new} GeneralisedHookean(&\hyperlink{namespaceGlobal__Physical__Variables_a3962c36313826b19f216f6bbbdd6a477}{Global\_Physical\_Variables::Nu},
                         &\hyperlink{namespaceGlobal__Physical__Variables_a09a019474b7405b35da2437f7779bc7e}{Global\_Physical\_Variables::E});
 
 \textcolor{comment}{//Set up the problem}
 \hyperlink{classCantileverProblem}{CantileverProblem<MySolidElement<RefineableQPVDElement<2,3>}
       > > problem;

\end{DoxyCodeInclude}


The subsequent lines may be uncommented to experiment with different element types as suggested in the \hyperlink{index_ex}{Exercises}.


\begin{DoxyCodeInclude}


 \textcolor{comment}{// Uncomment these as an exercise}

 \textcolor{comment}{// CantileverProblem<MySolidElement<}
 \textcolor{comment}{//  RefineableQPVDElementWithContinuousPressure<2> > > problem;}

 \textcolor{comment}{// CantileverProblem<MySolidElement<}
 \textcolor{comment}{//  RefineableQPVDElementWithPressure<2> > > problem;}

\end{DoxyCodeInclude}


We initialise the load parameters and perform a parameter study in which we increment the pressure load in small steps. The gravitational body force remains switched off to allow the comparison with the analytical solution which only applies to the case with zero body force.


\begin{DoxyCodeInclude}

 \textcolor{comment}{// Initial values for parameter values}
 \hyperlink{namespaceGlobal__Physical__Variables_a23c2ade6398f54040b869f7f3a2bcc4b}{Global\_Physical\_Variables::P}=0.0; 
 \hyperlink{namespaceGlobal__Physical__Variables_a8b80d3e8d63b8d0a0ed435a2dd7fe2ad}{Global\_Physical\_Variables::Gravity}=0.0;

 \textcolor{comment}{// Max. number of adaptations per solve}
 \textcolor{keywordtype}{unsigned} max\_adapt=3;
 
 \textcolor{comment}{//Parameter incrementation}
 \textcolor{keywordtype}{unsigned} nstep=5; 
 \textcolor{keywordtype}{double} p\_increment=1.0e-5;   
 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} i=0;i<nstep;i++)
  \{
   \textcolor{comment}{// Increment pressure load}
   \hyperlink{namespaceGlobal__Physical__Variables_a23c2ade6398f54040b869f7f3a2bcc4b}{Global\_Physical\_Variables::P}+=p\_increment;

   \textcolor{comment}{// Solve the problem with Newton's method, allowing}
   \textcolor{comment}{// up to max\_adapt mesh adaptations after every solve.}
   problem.newton\_solve(max\_adapt);

   \textcolor{comment}{// Doc solution}
   problem.\hyperlink{classCantileverProblem_a7571348f8724e71be4e67dc64cea3877}{doc\_solution}();

  \}
 
\} \textcolor{comment}{//end of main}

\end{DoxyCodeInclude}




 

\hypertarget{index_class}{}\section{The problem class}\label{index_class}
The problem class contains the usual member functions, including separate access functions to the two sub-\/meshes\+: The \char`\"{}bulk\char`\"{} mesh that contains the 2D solid elements, and a separate mesh in which we store the 1D {\ttfamily Solid\+Traction\+Elements} that apply the traction boundary condition on the beam\textquotesingle{}s upper face. As usual, we remove these elements before adapting the bulk mesh and re-\/attach them afterwards, using the functions {\ttfamily Problem\+::actions\+\_\+before\+\_\+adapt()} and {\ttfamily Problem\+::actions\+\_\+after\+\_\+adapt()}.

 
\begin{DoxyCodeInclude}
\textcolor{comment}{//=============begin\_problem============================================ }
\textcolor{comment}{/// Problem class for the cantilever "beam" structure.}
\textcolor{comment}{}\textcolor{comment}{//====================================================================== }
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT>
\textcolor{keyword}{class }\hyperlink{classCantileverProblem}{CantileverProblem} : \textcolor{keyword}{public} Problem
\{

\textcolor{keyword}{public}:
\textcolor{comment}{}
\textcolor{comment}{ /// Constructor:}
\textcolor{comment}{} \hyperlink{classCantileverProblem_abba97fc4b8402bc0363fdf16322f6572}{CantileverProblem}();
 \textcolor{comment}{}
\textcolor{comment}{ /// Update function (empty)}
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{classCantileverProblem_a4a70a4328d287aaa15c7811562122013}{actions\_after\_newton\_solve}() \{\}
\textcolor{comment}{}
\textcolor{comment}{ /// Update function (empty)}
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{classCantileverProblem_a293902b825898ce043ffce3f0691f5a5}{actions\_before\_newton\_solve}() \{\}
\textcolor{comment}{}
\textcolor{comment}{ /// Access function for the solid mesh}
\textcolor{comment}{} ElasticRefineableRectangularQuadMesh<ELEMENT>*& \hyperlink{classCantileverProblem_a26843782873897ee5e45647d17204b86}{solid\_mesh\_pt}() 
  \{\textcolor{keywordflow}{return} \hyperlink{classCantileverProblem_a263ff19e4aa0fa4391582242763f08f1}{Solid\_mesh\_pt};\} 
\textcolor{comment}{}
\textcolor{comment}{ /// Access function to the mesh of surface traction elements}
\textcolor{comment}{} SolidMesh*& \hyperlink{classCantileverProblem_af9e9b4a4686ac29bc7e4ef5d6baeae5a}{traction\_mesh\_pt}()\{\textcolor{keywordflow}{return} \hyperlink{classCantileverProblem_a52485434aab5d653010c48a0b0f89088}{Traction\_mesh\_pt};\} 
\textcolor{comment}{}
\textcolor{comment}{ /// Actions before adapt: Wipe the mesh of traction elements}
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{classCantileverProblem_a50f8964219c507562945655e0ed5fc23}{actions\_before\_adapt}();
\textcolor{comment}{}
\textcolor{comment}{ /// Actions after adapt: Rebuild the mesh of traction elements}
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{classCantileverProblem_af4d135ace3eac657b38de362e1644c75}{actions\_after\_adapt}();
\textcolor{comment}{}
\textcolor{comment}{ /// Doc the solution}
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{classCantileverProblem_a7571348f8724e71be4e67dc64cea3877}{doc\_solution}();

\end{DoxyCodeInclude}


The creation/deletion of the {\ttfamily Solid\+Traction\+Elements} is performed by private helper functions. We also store a pointer to a node on the tip of the beam and will record its displacement as a function of the applied load in a trace file.


\begin{DoxyCodeInclude}

\textcolor{keyword}{private}:
\textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Pass pointer to traction function to the}
\textcolor{comment}{ /// elements in the traction mesh}
\textcolor{comment}{} \textcolor{keywordtype}{void} set\_traction\_pt();
\textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Create traction elements}
\textcolor{comment}{} \textcolor{keywordtype}{void} create\_traction\_elements();
\textcolor{comment}{}
\textcolor{comment}{ /// Delete traction elements}
\textcolor{comment}{} \textcolor{keywordtype}{void} delete\_traction\_elements();
\textcolor{comment}{}
\textcolor{comment}{ /// Trace file}
\textcolor{comment}{} ofstream Trace\_file;
 \textcolor{comment}{}
\textcolor{comment}{ /// Pointers to node whose position we're tracing}
\textcolor{comment}{} Node* Trace\_node\_pt;
\textcolor{comment}{}
\textcolor{comment}{ /// Pointer to solid mesh}
\textcolor{comment}{} ElasticRefineableRectangularQuadMesh<ELEMENT>* Solid\_mesh\_pt;
\textcolor{comment}{}
\textcolor{comment}{ /// Pointer to mesh of traction elements}
\textcolor{comment}{} SolidMesh* Traction\_mesh\_pt;
\textcolor{comment}{}
\textcolor{comment}{ /// DocInfo object for output}
\textcolor{comment}{} DocInfo Doc\_info;
 
\};

\end{DoxyCodeInclude}




 

\hypertarget{index_constructor}{}\section{The problem constructor}\label{index_constructor}
The constructor builds the bulk mesh (the standard {\ttfamily Refineable\+Rectangular\+Quad\+Mesh} that we already used in many previous examples, upgraded to a {\ttfamily Solid\+Mesh}, via the procedure discussed in the document \href{../../solid_theory/html/index.html#solid_mesh}{\tt Solid mechanics\+: Theory and implementation}), using the element type specified by the template parameter and the dimensions specified in the namespace {\ttfamily \hyperlink{namespaceGlobal__Physical__Variables}{Global\+\_\+\+Physical\+\_\+\+Variables}}.

 
\begin{DoxyCodeInclude}
\textcolor{comment}{//===========start\_of\_constructor======================================= }
\textcolor{comment}{/// Constructor: }
\textcolor{comment}{}\textcolor{comment}{//====================================================================== }
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT>
\hyperlink{classCantileverProblem_abba97fc4b8402bc0363fdf16322f6572}{CantileverProblem<ELEMENT>::CantileverProblem}() 
\{

 \textcolor{comment}{// Create the mesh}

 \textcolor{comment}{// # of elements in x-direction}
 \textcolor{keywordtype}{unsigned} n\_x=20;

 \textcolor{comment}{// # of elements in y-direction}
 \textcolor{keywordtype}{unsigned} n\_y=2;

 \textcolor{comment}{// Domain length in x-direction}
 \textcolor{keywordtype}{double} l\_x= \hyperlink{namespaceGlobal__Physical__Variables_a1b8bfc451f6b7ac89eca18f04338f47f}{Global\_Physical\_Variables::L};

 \textcolor{comment}{// Domain length in y-direction}
 \textcolor{keywordtype}{double} l\_y=2.0*\hyperlink{namespaceGlobal__Physical__Variables_af6e07423e22c0991084d9a2f43727805}{Global\_Physical\_Variables::H};

 \textcolor{comment}{// Shift mesh downwards so that centreline is at y=0:}
 Vector<double> origin(2);
 origin[0]=0.0;
 origin[1]=-0.5*l\_y;

 \textcolor{comment}{//Now create the mesh }
 solid\_mesh\_pt() = \textcolor{keyword}{new} ElasticRefineableRectangularQuadMesh<ELEMENT>(
  n\_x,n\_y,l\_x,l\_y,origin);

\end{DoxyCodeInclude}


We employ the {\ttfamily Z2\+Error\+Estimator} to assess the accuracy of the computed solution and to control the adaptive mesh refinement. When used with the {\ttfamily Refineable\+Q\+P\+V\+D\+Elements}, the {\ttfamily Z2\+Error\+Estimator} uses the components of Green\textquotesingle{}s strain tensor as \char`\"{}fluxes\char`\"{} in its \char`\"{}flux recovery procedure\char`\"{}.


\begin{DoxyCodeInclude}
 \textcolor{comment}{// Set error estimator}
 solid\_mesh\_pt()->spatial\_error\_estimator\_pt()=\textcolor{keyword}{new} Z2ErrorEstimator;

\end{DoxyCodeInclude}


Next, we pass the constitutive equations and the gravitational body force to the elements, select a control node, and perform one uniform mesh refinement.


\begin{DoxyCodeInclude}

 \textcolor{comment}{//Assign the physical properties to the elements before any refinement}
 \textcolor{comment}{//Loop over the elements in the main mesh}
 \textcolor{keywordtype}{unsigned} n\_element =solid\_mesh\_pt()->nelement();
 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} i=0;i<n\_element;i++)
  \{
   \textcolor{comment}{//Cast to a solid element}
   ELEMENT *el\_pt = \textcolor{keyword}{dynamic\_cast<}ELEMENT*\textcolor{keyword}{>}(solid\_mesh\_pt()->element\_pt(i));
   
   \textcolor{comment}{// Set the constitutive law}
   el\_pt->constitutive\_law\_pt() =
    \hyperlink{namespaceGlobal__Physical__Variables_a5d5f19442938130d36ee7476ae25049c}{Global\_Physical\_Variables::Constitutive\_law\_pt};

   \textcolor{comment}{//Set the body force}
   el\_pt->body\_force\_fct\_pt() = \hyperlink{namespaceGlobal__Physical__Variables_a0777aef63372db7f91ad894c38159681}{Global\_Physical\_Variables::gravity};
  \}


 \textcolor{comment}{// Choose a control node: The last node in the solid mesh}
 \textcolor{keywordtype}{unsigned} nnod=solid\_mesh\_pt()->nnode();
 Trace\_node\_pt=solid\_mesh\_pt()->node\_pt(nnod-1);

 \textcolor{comment}{// Refine the mesh uniformly}
 solid\_mesh\_pt()->refine\_uniformly();

\end{DoxyCodeInclude}


We create a new mesh for the {\ttfamily Solid\+Traction\+Elements} and build the elements using the helper function {\ttfamily create\+\_\+traction\+\_\+elements()} before adding both submeshes to the problem and combining them into a global mesh.


\begin{DoxyCodeInclude}

 \textcolor{comment}{// Construct the traction element mesh}
 Traction\_mesh\_pt=\textcolor{keyword}{new} SolidMesh;
 create\_traction\_elements();
 
 \textcolor{comment}{// Pass pointer to traction function to the elements}
 \textcolor{comment}{// in the traction mesh}
 set\_traction\_pt();
 
 \textcolor{comment}{// Solid mesh is first sub-mesh}
 add\_sub\_mesh(solid\_mesh\_pt());

 \textcolor{comment}{// Add traction sub-mesh}
 add\_sub\_mesh(traction\_mesh\_pt());

 \textcolor{comment}{// Build combined "global" mesh}
 build\_global\_mesh();

\end{DoxyCodeInclude}


We pin the position of all nodes on the left boundary (boundary 3) of the bulk mesh. The subsequent call to {\ttfamily P\+V\+D\+Equations\+Base$<$2$>$\+::pin\+\_\+redundant\+\_\+nodal\+\_\+solid\+\_\+pressures()} is unnecessary (but harmless) for the solid elements used in this driver code since {\ttfamily Refineable\+Q\+P\+V\+D\+Elements} do not contain pressure degrees of freedom. It is a good idea to include this call anyway since our problem class is templated by the element type and may therefore also be used with other elements (see \hyperlink{index_ex}{Exercises} ; we refer to \href{../../../navier_stokes/adaptive_driven_cavity/html/index.html}{\tt another tutorial} for a detailed discussion of the need to pin \char`\"{}redundant\char`\"{} pressure degrees of freedom in computations with spatial adaptivity.)


\begin{DoxyCodeInclude}
 
 \textcolor{comment}{// Pin the left boundary (boundary 3) in both directions}
 \textcolor{keywordtype}{unsigned} n\_side = mesh\_pt()->nboundary\_node(3);
 
 \textcolor{comment}{// Loop over the nodes}
 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} i=0;i<n\_side;i++)
  \{
   solid\_mesh\_pt()->boundary\_node\_pt(3,i)->pin\_position(0);
   solid\_mesh\_pt()->boundary\_node\_pt(3,i)->pin\_position(1);
  \}

 \textcolor{comment}{// Pin the redundant solid pressures (if any)}
 PVDEquationsBase<2>::pin\_redundant\_nodal\_solid\_pressures(
  solid\_mesh\_pt()->element\_pt());

\end{DoxyCodeInclude}


Finally, we assign the equation numbers, create a {\ttfamily Doc\+Info} object and open a trace file in which we shall record the beam\textquotesingle{}s load/displacement characteristics.


\begin{DoxyCodeInclude}

 \textcolor{comment}{//Attach the boundary conditions to the mesh}
 cout << assign\_eqn\_numbers() << std::endl; 

 \textcolor{comment}{// Set output directory}
 Doc\_info.set\_directory(\textcolor{stringliteral}{"RESLT"});

 \textcolor{comment}{// Open trace file}
 \textcolor{keywordtype}{char} filename[100];   
 sprintf(filename,\textcolor{stringliteral}{"%s/trace.dat"},Doc\_info.directory().c\_str());
 Trace\_file.open(filename);
 

\} \textcolor{comment}{//end of constructor}

\end{DoxyCodeInclude}




 

\hypertarget{index_before_adapt}{}\section{Actions before adaptation}\label{index_before_adapt}
Following our usual procedure, we delete the {\ttfamily Solid\+Traction\+Elements} before adapting the bulk mesh\+:

 
\begin{DoxyCodeInclude}
\textcolor{comment}{//=====================start\_of\_actions\_before\_adapt======================}
\textcolor{comment}{/// Actions before adapt: Wipe the mesh of traction elements}
\textcolor{comment}{}\textcolor{comment}{//========================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT>
\textcolor{keywordtype}{void} \hyperlink{classCantileverProblem_a50f8964219c507562945655e0ed5fc23}{CantileverProblem<ELEMENT>::actions\_before\_adapt}()
\{
 \textcolor{comment}{// Kill the traction elements and wipe surface mesh}
 delete\_traction\_elements();
 
 \textcolor{comment}{// Rebuild the Problem's global mesh from its various sub-meshes}
 rebuild\_global\_mesh();

\}\textcolor{comment}{// end of actions\_before\_adapt}

\end{DoxyCodeInclude}




 

\hypertarget{index_after_adapt}{}\section{Actions after adaptation}\label{index_after_adapt}
The {\ttfamily Solid\+Traction\+Elements} are re-\/attached after the mesh adaptation. Again, the call to {\ttfamily P\+V\+D\+Equations\+Base$<$2$>$\+::pin\+\_\+redundant\+\_\+nodal\+\_\+solid\+\_\+pressures()} is not strictly necessary for the elements used in the present driver code but is included \char`\"{}for safety\char`\"{}.

 
\begin{DoxyCodeInclude}
\textcolor{comment}{//=====================start\_of\_actions\_after\_adapt=======================}
\textcolor{comment}{///  Actions after adapt: Rebuild the mesh of traction elements}
\textcolor{comment}{}\textcolor{comment}{//========================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT>
\textcolor{keywordtype}{void} \hyperlink{classCantileverProblem_af4d135ace3eac657b38de362e1644c75}{CantileverProblem<ELEMENT>::actions\_after\_adapt}()
\{
 \textcolor{comment}{// Create traction elements from all elements that are }
 \textcolor{comment}{// adjacent to boundary 2 and add them to surface meshes}
 create\_traction\_elements();
 
 \textcolor{comment}{// Rebuild the Problem's global mesh from its various sub-meshes}
 rebuild\_global\_mesh();
 
 \textcolor{comment}{// Pin the redundant solid pressures (if any)}
 PVDEquationsBase<2>::pin\_redundant\_nodal\_solid\_pressures(
  solid\_mesh\_pt()->element\_pt());

 \textcolor{comment}{// Set pointer to prescribed traction function for traction elements}
 set\_traction\_pt();
 
\}\textcolor{comment}{// end of actions\_after\_adapt}

\end{DoxyCodeInclude}




 

\hypertarget{index_set_traction}{}\section{Setting the pointer to the traction function}\label{index_set_traction}
The helper function {\ttfamily set\+\_\+traction\+\_\+pt()} is used to pass the pointer to the traction function to the {\ttfamily Solid\+Traction\+Elements}.

 
\begin{DoxyCodeInclude}
\textcolor{comment}{//==================start\_of\_set\_traction\_pt==============================}
\textcolor{comment}{/// Set pointer to traction function for the relevant}
\textcolor{comment}{}\textcolor{comment}{/// elements in the traction mesh}
\textcolor{comment}{}\textcolor{comment}{//========================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT>
\textcolor{keywordtype}{void} \hyperlink{classCantileverProblem_a96a9716947a15930f3881fcec6d448e2}{CantileverProblem<ELEMENT>::set\_traction\_pt}()
\{
 \textcolor{comment}{// Loop over the elements in the traction element mesh}
 \textcolor{comment}{// for elements on the top boundary (boundary 2)}
 \textcolor{keywordtype}{unsigned} n\_element=traction\_mesh\_pt()->nelement();
 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} i=0;i<n\_element;i++)
  \{
   \textcolor{comment}{//Cast to a solid traction element}
   SolidTractionElement<ELEMENT> *el\_pt = 
    \textcolor{keyword}{dynamic\_cast<}SolidTractionElement<ELEMENT>*\textcolor{keyword}{>}
    (traction\_mesh\_pt()->element\_pt(i));

   \textcolor{comment}{//Set the traction function}
   el\_pt->traction\_fct\_pt() = \hyperlink{namespaceGlobal__Physical__Variables_a19f4e20a92e7d216b4d2b00308f96917}{Global\_Physical\_Variables::constant\_pressure}
      ;
  \}
 
\}\textcolor{comment}{// end of set traction pt}

\end{DoxyCodeInclude}




 

\hypertarget{index_create_traction}{}\section{Creating the traction elements}\label{index_create_traction}
The helper function {\ttfamily create\+\_\+traction\+\_\+elements()} is used to create the {\ttfamily Solid\+Traction\+Elements} and to store them in the appropriate sub-\/mesh.

 
\begin{DoxyCodeInclude}
\textcolor{comment}{//============start\_of\_create\_traction\_elements==============================}
\textcolor{comment}{/// Create traction elements }
\textcolor{comment}{}\textcolor{comment}{//=======================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT>
\textcolor{keywordtype}{void} \hyperlink{classCantileverProblem_abb6f19d964d96a531bf1a60732c72ce9}{CantileverProblem<ELEMENT>::create\_traction\_elements}
      ()
\{
 \textcolor{comment}{// Traction elements are located on boundary 2:}
 \textcolor{keywordtype}{unsigned} b=2;

 \textcolor{comment}{// How many bulk elements are adjacent to boundary b?}
 \textcolor{keywordtype}{unsigned} n\_element = solid\_mesh\_pt()->nboundary\_element(b);
 
 \textcolor{comment}{// Loop over the bulk elements adjacent to boundary b}
 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} e=0;e<n\_element;e++)
  \{
   \textcolor{comment}{// Get pointer to the bulk element that is adjacent to boundary b}
   ELEMENT* bulk\_elem\_pt = \textcolor{keyword}{dynamic\_cast<}ELEMENT*\textcolor{keyword}{>}(
    solid\_mesh\_pt()->boundary\_element\_pt(b,e));
   
   \textcolor{comment}{//Find the index of the face of element e along boundary b}
   \textcolor{keywordtype}{int} face\_index = solid\_mesh\_pt()->face\_index\_at\_boundary(b,e);
      
   \textcolor{comment}{// Create new element and add to mesh}
   Traction\_mesh\_pt->add\_element\_pt(\textcolor{keyword}{new} SolidTractionElement<ELEMENT>
                                    (bulk\_elem\_pt,face\_index));   
  \}  

 \textcolor{comment}{// Pass the pointer to the traction function to the traction elements}
 set\_traction\_pt();
 
\} \textcolor{comment}{// end of create\_traction\_elements}

\end{DoxyCodeInclude}




 

\hypertarget{index_delete_traction}{}\section{Deleting the traction elements}\label{index_delete_traction}
The helper function {\ttfamily delete\+\_\+traction\+\_\+elements()} is used to delete the {\ttfamily Solid\+Traction\+Elements}.

 
\begin{DoxyCodeInclude}
\textcolor{comment}{//============start\_of\_delete\_traction\_elements==============================}
\textcolor{comment}{/// Delete traction elements and wipe the  traction meshes}
\textcolor{comment}{}\textcolor{comment}{//=======================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT>
\textcolor{keywordtype}{void} \hyperlink{classCantileverProblem_aeb64122ce3783bf36df3696c41e5d2a5}{CantileverProblem<ELEMENT>::delete\_traction\_elements}
      ()
\{
 \textcolor{comment}{// How many surface elements are in the surface mesh}
 \textcolor{keywordtype}{unsigned} n\_element = Traction\_mesh\_pt->nelement();
 
 \textcolor{comment}{// Loop over the surface elements}
 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} e=0;e<n\_element;e++)
  \{
   \textcolor{comment}{// Kill surface element}
   \textcolor{keyword}{delete} Traction\_mesh\_pt->element\_pt(e);
  \}
 
 \textcolor{comment}{// Wipe the mesh}
 Traction\_mesh\_pt->flush\_element\_and\_node\_storage();

\} \textcolor{comment}{// end of delete\_traction\_elements}

\end{DoxyCodeInclude}




 

\hypertarget{index_doc}{}\section{Post-\/processing}\label{index_doc}
The post-\/processing function {\ttfamily doc\+\_\+solution()} outputs the finite-\/element solution, using the modified output function defined in the wrapper class {\ttfamily My\+Solid\+Element}, discussed below.

 
\begin{DoxyCodeInclude}
\textcolor{comment}{//==============start\_doc===========================================}
\textcolor{comment}{/// Doc the solution}
\textcolor{comment}{}\textcolor{comment}{//==================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT>
\textcolor{keywordtype}{void} \hyperlink{classCantileverProblem_a7571348f8724e71be4e67dc64cea3877}{CantileverProblem<ELEMENT>::doc\_solution}()
\{

 ofstream some\_file;
 \textcolor{keywordtype}{char} filename[100];

 \textcolor{comment}{// Number of plot points}
 \textcolor{keywordtype}{unsigned} n\_plot = 5; 

 \textcolor{comment}{// Output shape of and stress in deformed body}
 \textcolor{comment}{//--------------------------------------------}
 sprintf(filename,\textcolor{stringliteral}{"%s/soln%i.dat"},Doc\_info.directory().c\_str(),
         Doc\_info.number());
 some\_file.open(filename);
 solid\_mesh\_pt()->output(some\_file,n\_plot);
 some\_file.close();

\end{DoxyCodeInclude}


Next we output the approximate St. Venant solution at the same plot points and write the load/displacement characteristics to the trace file.


\begin{DoxyCodeInclude}


 \textcolor{comment}{// Output St. Venant solution}
 \textcolor{comment}{//---------------------------}
 sprintf(filename,\textcolor{stringliteral}{"%s/exact\_soln%i.dat"},Doc\_info.directory().c\_str(),
         Doc\_info.number());
 some\_file.open(filename);

 \textcolor{comment}{// Element dimension}
 \textcolor{keywordtype}{unsigned} el\_dim=2;
 
 Vector<double> s(el\_dim);
 Vector<double> x(el\_dim);
 Vector<double> xi(el\_dim);
 DenseMatrix<double> sigma(el\_dim,el\_dim);
 
 \textcolor{comment}{// Constants for exact (St. Venant) solution}
 \textcolor{keywordtype}{double} a=-1.0/4.0*\hyperlink{namespaceGlobal__Physical__Variables_a23c2ade6398f54040b869f7f3a2bcc4b}{Global\_Physical\_Variables::P};
 \textcolor{keywordtype}{double} b=-3.0/8.0*\hyperlink{namespaceGlobal__Physical__Variables_a23c2ade6398f54040b869f7f3a2bcc4b}{Global\_Physical\_Variables::P}/
      \hyperlink{namespaceGlobal__Physical__Variables_af6e07423e22c0991084d9a2f43727805}{Global\_Physical\_Variables::H};
 \textcolor{keywordtype}{double} c=1.0/8.0*\hyperlink{namespaceGlobal__Physical__Variables_a23c2ade6398f54040b869f7f3a2bcc4b}{Global\_Physical\_Variables::P}/
  pow(\hyperlink{namespaceGlobal__Physical__Variables_af6e07423e22c0991084d9a2f43727805}{Global\_Physical\_Variables::H},3);
 \textcolor{keywordtype}{double} d=1.0/20.0*\hyperlink{namespaceGlobal__Physical__Variables_a23c2ade6398f54040b869f7f3a2bcc4b}{Global\_Physical\_Variables::P}/
      \hyperlink{namespaceGlobal__Physical__Variables_af6e07423e22c0991084d9a2f43727805}{Global\_Physical\_Variables::H};

 \textcolor{comment}{// Loop over all elements to plot exact solution for stresses}
 \textcolor{keywordtype}{unsigned} nel=solid\_mesh\_pt()->nelement();
 \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} e=0;e<nel;e++)
  \{   
   \textcolor{comment}{// Get pointer to element}
   SolidFiniteElement* el\_pt=\textcolor{keyword}{dynamic\_cast<}SolidFiniteElement*\textcolor{keyword}{>}(
    solid\_mesh\_pt()->element\_pt(e));
   
   \textcolor{comment}{//Tecplot header info }
   some\_file << \textcolor{stringliteral}{"ZONE I="} << n\_plot << \textcolor{stringliteral}{", J="} << n\_plot << std::endl;
   
   \textcolor{comment}{//Loop over plot points}
   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} l2=0;l2<n\_plot;l2++)
    \{
     s[1] = -1.0 + l2*2.0/(n\_plot-1);
     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} l1=0;l1<n\_plot;l1++)
      \{
       s[0] = -1.0 + l1*2.0/(n\_plot-1);
       
       \textcolor{comment}{// Get Eulerian and Lagrangian coordinates}
       el\_pt->interpolated\_x(s,x);
       el\_pt->interpolated\_xi(s,xi);
       
       \textcolor{comment}{//Output the x,y,..}
       \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} i=0;i<el\_dim;i++) 
        \{some\_file << x[i] << \textcolor{stringliteral}{" "};\}
       
       \textcolor{comment}{// Change orientation of coordinate system relative}
       \textcolor{comment}{// to solution in lecture notes}
       \textcolor{keywordtype}{double} xx=\hyperlink{namespaceGlobal__Physical__Variables_a1b8bfc451f6b7ac89eca18f04338f47f}{Global\_Physical\_Variables::L}-xi[0];
       \textcolor{keywordtype}{double} yy=xi[1];

         \textcolor{comment}{// Approximate analytical (St. Venant) solution}
         sigma(0,0)=c*(6.0*xx*xx*yy-4.0*yy*yy*yy)+
          6.0*d*yy;
         sigma(1,1)=2.0*(a+b*yy+c*yy*yy*yy);
         sigma(1,0)=2.0*(b*xx+3.0*c*xx*yy*yy);
         sigma(0,1)=sigma(1,0);

         \textcolor{comment}{// Output stress}
         some\_file << sigma(0,0) << \textcolor{stringliteral}{" "}
                   << sigma(1,0) << \textcolor{stringliteral}{" "}
                   << sigma(1,1) << \textcolor{stringliteral}{" "}
                   << std::endl;
        \}
      \}
  \}
 some\_file.close();

 \textcolor{comment}{// Write trace file: Load/displacement characteristics}
 Trace\_file << \hyperlink{namespaceGlobal__Physical__Variables_a23c2ade6398f54040b869f7f3a2bcc4b}{Global\_Physical\_Variables::P}  << \textcolor{stringliteral}{" "} 
            << Trace\_node\_pt->x(0) << \textcolor{stringliteral}{" "} 
            << Trace\_node\_pt->x(1) << \textcolor{stringliteral}{" "} 
            << std::endl;

 \textcolor{comment}{// Increment label for output files}
 Doc\_info.number()++;

\} \textcolor{comment}{//end doc}

\end{DoxyCodeInclude}




 

\hypertarget{index_exercises}{}\section{Comments and exercises}\label{index_exercises}
\hypertarget{index_ex}{}\subsection{Exercises}\label{index_ex}

\begin{DoxyEnumerate}
\item Modify the driver code so that the cantilever beam is loaded by gravity rather than a pressure load. Consult the document \href{../../solid_theory/html/index.html}{\tt \char`\"{}\+Solid mechanics\+: Theory and implementation\char`\"{}} for details on the non-\/dimensionalisation of the body force. Verify that for modest deflections and for sufficiently thin beams, the macroscopic deformation due to a gravitational load is identical to that induced by an equivalent pressure load, equivalent meaning that the total force on the beam is the same for both cases. ~\newline
 ~\newline

\item Change the element type to a {\ttfamily Refineable\+Q\+P\+V\+D\+Element\+With\+Pressure$<$2$>$} and {\ttfamily Refineable\+Q\+P\+V\+D\+Element\+With\+Continuous\+Pressure$<$2$>$} and compare the results. Both of these two elements are based on a pressure-\/displacement formulation, the former employing a discontinuous pressure representation (as in Crouzeix-\/\+Raviart Navier-\/\+Stokes elements), the latter employing a continuous pressure representation (as in Taylor-\/\+Hood elements). Confirm that calls to {\ttfamily P\+V\+D\+Equations\+Base$<$2$>$\+::pin\+\_\+redundant\+\_\+nodal\+\_\+solid\+\_\+pressures()} are essential if a continuous pressure representation is used. Explain the code\textquotesingle{}s behaviour when you comment out the calls to this function. ~\newline
 ~\newline

\item Repeat the computation without adaptivity, by using the non-\/refineable versions of the various solid mechanics elements discussed above, namely the {\ttfamily Q\+P\+V\+D\+Element$<$2$>$}, {\ttfamily Q\+P\+V\+D\+Element\+With\+Pressure$<$2$>$} and {\ttfamily Q\+P\+V\+D\+Element\+With\+Continuous\+Pressure$<$2$>$}. This will require various changes to the code\+:
\begin{DoxyEnumerate}
\item You will have to create a solid mechanics version of the (non-\/refineable) {\ttfamily Rectangular\+Quad\+Mesh}. This is necessary because non-\/refineable elements cannot be used with refineable meshes. Try it to find out why! \mbox{[}Note\+: You could, of course, use the existing driver code with its refineable mesh and the refineable elements and simply not use the adaptive capabilities by omitting the {\ttfamily max\+\_\+adapt} argument when calling the Newton solver. However, the main point of this exercise is to force you to understand how to upgrade an existing {\ttfamily Mesh} to a {\ttfamily Solid\+Mesh}. It\textquotesingle{}s easy\+: Simply follow the steps used to create a refineable {\ttfamily Solid\+Mesh} from the {\ttfamily Refineable\+Rectangular\+Quad\+Mesh}, in \href{../../../../src/meshes/rectangular_quadmesh.template.h}{\tt src/meshes/rectangular\+\_\+quadmesh.\+template.\+h}. Instead of inheriting the mesh from the {\ttfamily Refineable\+Rectangular\+Quad\+Mesh} and the {\ttfamily Solid\+Mesh} classes, inherit from the non-\/refineable {\ttfamily Rectangular\+Quad\+Mesh} and the {\ttfamily Solid\+Mesh}.\mbox{]}
\item You must not pass the pointer to the error estimator to the non-\/refineable mesh -- it has no use for it.
\item You cannot call the adaptive Newton solver.
\end{DoxyEnumerate}
\end{DoxyEnumerate}

\hypertarget{index_com}{}\subsection{Comment\+: Customising an element\textquotesingle{}s output function}\label{index_com}
In the driver code discussed above we used the \char`\"{}wrapper\char`\"{} class {\ttfamily My\+Solid\+Element} to customise the solid elements\textquotesingle{} output function so that each element outputs its shape and the three independent components of the second Piola Kirchhoff stress, $ \sigma_{11}, \sigma_{12} $ and $ \sigma_{22}. $

Here is the implementation\+: The \char`\"{}wrapping\char`\"{} element inherits from the element type specified by the template parameter and calls its constructor (recall that element constructors are always argument-\/free!).

 
\begin{DoxyCodeInclude}
\textcolor{comment}{//=================start\_wrapper==================================}
\textcolor{comment}{/// Wrapper class for solid elements to modify their output }
\textcolor{comment}{}\textcolor{comment}{/// functions.}
\textcolor{comment}{}\textcolor{comment}{//================================================================}
\textcolor{keyword}{template} <\textcolor{keyword}{class} ELEMENT>
\textcolor{keyword}{class }MySolidElement : \textcolor{keyword}{public} \textcolor{keyword}{virtual} ELEMENT
\{

\textcolor{keyword}{public}:
\textcolor{comment}{}
\textcolor{comment}{ /// Constructor: Call constructor of underlying element}
\textcolor{comment}{} MySolidElement() : ELEMENT() \{\};

\end{DoxyCodeInclude}


We then overload the (virtual) output function so that the element outputs its shape, i.\+e. the $ x $ and $ y $ coordinates of its plot points, and the three independent components of the second Piola Kirchhoff stress at those points. Other than that, the element behaves exactly as the underlying \char`\"{}wrapped\char`\"{} element.


\begin{DoxyCodeInclude}
\textcolor{comment}{}
\textcolor{comment}{ /// Overload output function:}
\textcolor{comment}{} \textcolor{keywordtype}{void} output(std::ostream &outfile, \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} &n\_plot)
  \{

   \textcolor{comment}{// Element dimension}
   \textcolor{keywordtype}{unsigned} el\_dim = this->dim();

   Vector<double> s(el\_dim);
   Vector<double> x(el\_dim);
   DenseMatrix<double> sigma(el\_dim,el\_dim);
   
   \textcolor{keywordflow}{switch}(el\_dim)
    \{
     
    \textcolor{keywordflow}{case} 2:

     \textcolor{comment}{//Tecplot header info }
     outfile << \textcolor{stringliteral}{"ZONE I="} << n\_plot << \textcolor{stringliteral}{", J="} << n\_plot << std::endl;
     
     \textcolor{comment}{//Loop over element nodes}
     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} l2=0;l2<n\_plot;l2++)
      \{
       s[1] = -1.0 + l2*2.0/(n\_plot-1);
       \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} l1=0;l1<n\_plot;l1++)
        \{
         s[0] = -1.0 + l1*2.0/(n\_plot-1);
         
         \textcolor{comment}{// Get Eulerian coordinates and stress}
         this->interpolated\_x(s,x);
         this->get\_stress(s,sigma);

         \textcolor{comment}{//Output the x,y,..}
         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} i=0;i<el\_dim;i++) 
          \{outfile << x[i] << \textcolor{stringliteral}{" "};\}

         \textcolor{comment}{// Output stress}
         outfile << sigma(0,0) << \textcolor{stringliteral}{" "}
                 << sigma(1,0) << \textcolor{stringliteral}{" "}
                 << sigma(1,1) << \textcolor{stringliteral}{" "}
                 << std::endl;
        \}
      \}

     \textcolor{keywordflow}{break};
     
    \textcolor{keywordflow}{default}:

     std::ostringstream error\_message;
     error\_message << \textcolor{stringliteral}{"Output for dim !=2 not implemented"} << std::endl;
     \textcolor{keywordflow}{throw} OomphLibError(error\_message.str(),
                         OOMPH\_CURRENT\_FUNCTION,
                         OOMPH\_EXCEPTION\_LOCATION);
    \}
  
  \}

\};

\end{DoxyCodeInclude}


\mbox{[}{\bfseries Note\+:} Since this element is only defined and used in a 2D driver code, there is little point in implementing the output for 1D or 3D elements. However, paranoid as we are, we check the dimension of the element and throw an error if it is wrong.\mbox{]}

Finally we declare that the {\ttfamily Face\+Geometry} of the \char`\"{}wrapped\char`\"{} element is the same as that of the underlying element. This step is required to allow the automatic construction of {\ttfamily Solid\+Traction\+Elements} in {\ttfamily create\+\_\+traction\+\_\+elements()}.

 
\begin{DoxyCodeInclude}
\textcolor{comment}{//===========start\_face\_geometry==============================================}
\textcolor{comment}{/// FaceGeometry of wrapped element is the same as the underlying element}
\textcolor{comment}{}\textcolor{comment}{//============================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT>
\textcolor{keyword}{class }FaceGeometry<MySolidElement<ELEMENT> > :
 \textcolor{keyword}{public} \textcolor{keyword}{virtual} FaceGeometry<ELEMENT>
\{
\textcolor{keyword}{public}:
\textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Constructor [this was only required explicitly}
\textcolor{comment}{ /// from gcc 4.5.2 onwards...]}
\textcolor{comment}{} FaceGeometry() : FaceGeometry<ELEMENT>() \{\}

\};

\end{DoxyCodeInclude}




 

\hypertarget{index_sources}{}\section{Source files for this tutorial}\label{index_sources}

\begin{DoxyItemize}
\item The source files for this tutorial are located in the directory\+:~\newline
~\newline
\begin{center} \href{
../../../../
demo_drivers/solid/airy_cantilever/
}{\tt demo\+\_\+drivers/solid/airy\+\_\+cantilever/ } \end{center} ~\newline

\item The driver code is\+: ~\newline
~\newline
\begin{center} \href{
../../../../
demo_drivers/solid/airy_cantilever/airy_cantilever.cc
}{\tt demo\+\_\+drivers/solid/airy\+\_\+cantilever/airy\+\_\+cantilever.\+cc } \end{center} 
\end{DoxyItemize}



 

 \hypertarget{index_pdf}{}\section{P\+D\+F file}\label{index_pdf}
A \href{../latex/refman.pdf}{\tt pdf version} of this document is available. \end{document}
