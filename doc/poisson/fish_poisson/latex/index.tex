In this document, we discuss the solution of a 2D Poisson problem using {\ttfamily oomph-\/lib\textquotesingle{}s} powerful mesh adaptation routines\+:

\begin{center} \tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*{1}{|X[-1]}|}
\hline
\begin{center} {\bfseries Two-\/dimensional model Poisson problem in a non-\/trivial domain} \end{center}  Solve \[ \sum_{i=1}^2 \frac{\partial^2u}{\partial x_i^2} = -1, \ \ \ \ \ \ \ \ \ \ (1) \] in the fish-\/shaped domain $D_{fish} $, with homogeneous Dirichlet boundary conditions \[ \left. u\right|_{\partial D_{fish}}=0. \ \ \ \ \ \ \ \ \ \ (2) \]   \\\cline{1-1}
\end{longtabu}
\end{center} 

 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{fish_poisson_soln}
\doxyfigcaption{Plot of the solution }
\end{DoxyImage}


The sharp corners in the domain create singularities in the solution (its derivatives are unbounded) and so accurate results can only be obtained if we use a sufficiently fine discretisation. Implementing this by uniform mesh refinement would create a huge number of elements in the interior of the domain where the fine discretisation is not required.

To avoid this problem, {\ttfamily oomph-\/lib} provides mesh adaptation routines that automatically adapt the mesh, based on {\itshape a} {\itshape posteriori} error estimates. Regions in which an error estimator indicates that the solution is not resolved to the required accuracy are refined; automatic unrefinement is performed in regions where the discretisation is unnecessarily fine.

We provide a detailed discussion of the driver code \href{../../../../demo_drivers/poisson/fish_poisson/fish_poisson.cc}{\tt fish\+\_\+poisson.\+cc} which illustrates a variety of mesh refinement procedures. \mbox{[}The alternative driver code \href{../../../../demo_drivers/poisson/fish_poisson/fish_poisson_no_adapt.cc}{\tt fish\+\_\+poisson\+\_\+no\+\_\+adapt.\+cc} solves the same problem without mesh adaptation. Its structure is very similar to that in the \href{../../../poisson/two_d_poisson/html/index.html}{\tt 2D Poisson problem considered earlier}. It is provided mainly to illustrate how easy to it is incorporate adaptivity into a {\ttfamily Problem}.\mbox{]}

In the current example we demonstrate how to {\itshape use} existing refineable meshes and elements. Two further examples will demonstrate how easy it is to {\itshape create} refineable meshes in \href{../../../poisson/two_d_poisson_adapt/html/index.html}{\tt domains with polygonal boundaries} and in \href{../../../poisson/fish_poisson2/html/index.html}{\tt domains with curvilinear boundaries.}



 

\hypertarget{index_global}{}\section{Global parameters and functions}\label{index_global}
The namespace {\ttfamily \hyperlink{namespaceConstSourceForPoisson}{Const\+Source\+For\+Poisson}} only contains the constant source function $ f(x)=-1 $.

 
\begin{DoxyCodeInclude}
\textcolor{comment}{//============ start\_of\_namespace=====================================}
\textcolor{comment}{/// Namespace for const source term in Poisson equation}
\textcolor{comment}{}\textcolor{comment}{//====================================================================}
\textcolor{keyword}{namespace }\hyperlink{namespaceConstSourceForPoisson}{ConstSourceForPoisson}
\{ 
 \textcolor{comment}{}
\textcolor{comment}{ /// Strength of source function: default value -1.0}
\textcolor{comment}{} \textcolor{keywordtype}{double} \hyperlink{namespaceConstSourceForPoisson_add351c5acab2561d68d1fc9ec3d5fc5e}{Strength}=-1.0;
\textcolor{comment}{}
\textcolor{comment}{/// Const source function}
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{namespaceConstSourceForPoisson_aeaa1153817bde9598372b803342f3299}{source\_function}(\textcolor{keyword}{const} Vector<double>& x, \textcolor{keywordtype}{double}& source)
 \{
  source = \hyperlink{namespaceConstSourceForPoisson_add351c5acab2561d68d1fc9ec3d5fc5e}{Strength};
 \}

\} \textcolor{comment}{// end of namespace}

\end{DoxyCodeInclude}




 

\hypertarget{index_main}{}\section{The driver code}\label{index_main}
The main code is very short and calls two functions that illustrate two different adaptation strategies\+:
\begin{DoxyItemize}
\item A black-\/box approach in which the adaptation cycle
\begin{DoxyEnumerate}
\item solve the problem on the initial, coarse mesh
\item compute an error estimate
\item adapt the mesh
\item solve again
\end{DoxyEnumerate}is performed automatically until the solution satisfies the required error bounds (or until the maximum permitted number of adaptation steps has been reached).
\item In the second approach we start by performing a number of uniform mesh refinement steps, and then use incremental adaptations, allowing us to document how the refinement proceeds.
\end{DoxyItemize} 
\begin{DoxyCodeInclude}
\textcolor{comment}{//=================start\_of\_main==========================================}
\textcolor{comment}{/// Demonstrate how to solve 2D Poisson problem in }
\textcolor{comment}{}\textcolor{comment}{/// fish-shaped domain with mesh adaptation.}
\textcolor{comment}{}\textcolor{comment}{//========================================================================}
\textcolor{keywordtype}{int} \hyperlink{fish__poisson_8cc_ae66f6b31b5ad750f1fe042a706a4e3d4}{main}()
\{
 \textcolor{comment}{// Solve with adaptation, docing the intermediate steps}
 \hyperlink{fish__poisson_8cc_a9f5ae2c03a7f02e61857d322177ce5d5}{solve\_with\_incremental\_adaptation}();

 \textcolor{comment}{// Solve directly, with fully automatic adaptation}
 \hyperlink{fish__poisson_8cc_a79a1cfcdcd821bd277276d163b85acfb}{solve\_with\_fully\_automatic\_adaptation}();

\} \textcolor{comment}{// end of main}

\end{DoxyCodeInclude}




\hypertarget{index_black_box}{}\subsection{Black-\/box adaptation}\label{index_black_box}
We start by creating the Problem object, using the refineable equivalent of the {\ttfamily Q\+Poisson\+Element} -- the {\ttfamily Refineable\+Q\+Poisson\+Element}, which is templated by the dimension and the number of nodes along the element\textquotesingle{}s edges; the {\ttfamily Refineable\+Q\+Poisson\+Element$<$2,3$>$} is a nine-\/node (bi-\/quadratic) quad element.

 
\begin{DoxyCodeInclude}
\textcolor{comment}{//================================start\_black\_box=========================}
\textcolor{comment}{/// Demonstrate how to solve 2D Poisson problem in }
\textcolor{comment}{}\textcolor{comment}{/// fish-shaped domain with fully automatic mesh adaptation}
\textcolor{comment}{}\textcolor{comment}{//========================================================================}
\textcolor{keywordtype}{void} \hyperlink{fish__poisson_8cc_a79a1cfcdcd821bd277276d163b85acfb}{solve\_with\_fully\_automatic\_adaptation}()
\{

  \textcolor{comment}{//Set up the problem with nine-node refineable Poisson elements}
  \hyperlink{classRefineableFishPoissonProblem}{RefineableFishPoissonProblem<RefineableQPoissonElement<2,3>}
       > problem;

\end{DoxyCodeInclude}


After creating the {\ttfamily Doc\+Info} object, we document the (default) adaptivity targets\+:


\begin{DoxyCodeInclude}
  \textcolor{comment}{// Setup labels for output}
  \textcolor{comment}{//------------------------}
  DocInfo doc\_info;
  
  \textcolor{comment}{// Set output directory}
  doc\_info.set\_directory(\textcolor{stringliteral}{"RESLT\_fully\_automatic"}); 
  
  \textcolor{comment}{// Step number}
  doc\_info.number()=0;


  \textcolor{comment}{// Doc (default) refinement targets}
  \textcolor{comment}{//----------------------------------}
  problem.\hyperlink{classRefineableFishPoissonProblem_a803c9050b07b35aba22f08a5a9e59f2c}{mesh\_pt}()->doc\_adaptivity\_targets(cout);

\end{DoxyCodeInclude}


These include
\begin{DoxyItemize}
\item {\bfseries The target for the maximum error\+:} Any elements whose error estimate exceed this value will be split into four \char`\"{}sons\char`\"{}.
\item {\bfseries The target for the minimum error\+: } Any elements whose error estimate lies below this value are deemed to be unnecessarily small and are scheduled for (possible) unrefinement. \mbox{[}Elements can only be unrefined (i.\+e. merged with their \char`\"{}brothers\char`\"{}) if their \char`\"{}brothers\char`\"{} are also scheduled for unrefinement.\mbox{]}
\item {\bfseries The minimum refinement level\+:} In problems with curvilinear domain boundaries it is often necessary to retain a reasonably accurate representation of the boundary (e.\+g. for postprocessing purposes), even if the error estimate suggests that the mesh could be unrefined further.
\item {\bfseries The maximum refinement level\+:} In problems where the solution has singularities, the refinement process would continue indefinitely, therefore an upper bound on the refinement level must be imposed.
\item Finally, because unrefinement is done purely to speed up the computation, it would not make sense to adapt the mesh if this process would only remove a few elements, while forcing the re-\/computation of the solution on an only slightly coarsened mesh. Therefore, no mesh adaptation is performed if
\begin{DoxyItemize}
\item the adaptation would only perform unrefinements
\item {\bfseries and} the number of elements scheduled for unrefinement is below a certain threshold.
\end{DoxyItemize}
\end{DoxyItemize}These default parameters can be changed by the user; see \hyperlink{index_comments}{Comments and Exercises}.

The fully-\/adaptive solution of the problem is very simple. We simply pass the maximum number of adaptations to the Newton solver and document the results. Done!

 
\begin{DoxyCodeInclude}
  \textcolor{comment}{// Solve/doc the problem with fully automatic adaptation}
  \textcolor{comment}{//------------------------------------------------------}

  \textcolor{comment}{// Maximum number of adaptations:}
  \textcolor{keywordtype}{unsigned} max\_adapt=5;

  \textcolor{comment}{// Solve the problem; perform up to specified number of adaptations.}
  problem.newton\_solve(max\_adapt);
  
  \textcolor{comment}{//Output solution}
  problem.\hyperlink{classRefineableFishPoissonProblem_aeee1bf23216971b50b8822c45e62c48b}{doc\_solution}(doc\_info);   

\} \textcolor{comment}{// end black box}

\end{DoxyCodeInclude}




\hypertarget{index_incremental}{}\subsection{Incremental adaptation}\label{index_incremental}
To allow the user more control over the mesh adaptation process, {\ttfamily oomph-\/lib} provides a number of functions that perform individual adaptation steps without re-\/computing the solution immediately. This allows the user to
\begin{DoxyItemize}
\item perform uniform mesh refinement and unrefinement,
\item impose a specific refinement pattern,
\item monitor/document the progress of the automatic adaptation.
\end{DoxyItemize}The second driver function illustrates some of these functions. We start by setting up the problem, create the {\ttfamily Doc\+Info} object and document the adaptivity targets, exactly as before\+:

 
\begin{DoxyCodeInclude}
\textcolor{comment}{//=====================start\_of\_incremental===============================}
\textcolor{comment}{/// Demonstrate how to solve 2D Poisson problem in }
\textcolor{comment}{}\textcolor{comment}{/// fish-shaped domain with mesh adaptation. First we solve on the original}
\textcolor{comment}{}\textcolor{comment}{/// coarse mesh. Next we do a few uniform refinement steps and re-solve.}
\textcolor{comment}{}\textcolor{comment}{/// Finally, we enter into an automatic adapation loop.}
\textcolor{comment}{}\textcolor{comment}{//========================================================================}
\textcolor{keywordtype}{void} \hyperlink{fish__poisson_8cc_a9f5ae2c03a7f02e61857d322177ce5d5}{solve\_with\_incremental\_adaptation}()
\{
 
 \textcolor{comment}{//Set up the problem with nine-node refineable Poisson elements}
 \hyperlink{classRefineableFishPoissonProblem}{RefineableFishPoissonProblem<RefineableQPoissonElement<2,3>}
       > problem;
 
 \textcolor{comment}{// Setup labels for output}
 \textcolor{comment}{//------------------------}
 DocInfo doc\_info;
 
 \textcolor{comment}{// Set output directory}
 doc\_info.set\_directory(\textcolor{stringliteral}{"RESLT\_incremental"}); 
 
 \textcolor{comment}{// Step number}
 doc\_info.number()=0;
  
  
 \textcolor{comment}{// Doc (default) refinement targets}
 \textcolor{comment}{//----------------------------------}
 problem.\hyperlink{classRefineableFishPoissonProblem_a803c9050b07b35aba22f08a5a9e59f2c}{mesh\_pt}()->doc\_adaptivity\_targets(cout);

\end{DoxyCodeInclude}


Next, we solve the problem on the original, very coarse mesh and document the result\+:

 
\begin{DoxyCodeInclude}
 \textcolor{comment}{// Solve/doc the problem on the initial, very coarse mesh}
 \textcolor{comment}{//-------------------------------------------------------}
 
 \textcolor{comment}{// Solve the problem}
 problem.newton\_solve();
 
 \textcolor{comment}{//Output solution}
 problem.\hyperlink{classRefineableFishPoissonProblem_aeee1bf23216971b50b8822c45e62c48b}{doc\_solution}(doc\_info);
 
 \textcolor{comment}{//Increment counter for solutions }
 doc\_info.number()++;

\end{DoxyCodeInclude}


We know that the result is unlikely to be very accurate, so we apply three levels of uniform refinement, increasing the number of elements from 4 to 256, and re-\/compute\+:

 
\begin{DoxyCodeInclude}
 \textcolor{comment}{// Do three rounds of uniform mesh refinement and re-solve}
 \textcolor{comment}{//--------------------------------------------------------}
 problem.refine\_uniformly();
 problem.refine\_uniformly();
 problem.refine\_uniformly();
 
 \textcolor{comment}{// Solve the problem }
 problem.newton\_solve();
 
 \textcolor{comment}{//Output solution}
 problem.\hyperlink{classRefineableFishPoissonProblem_aeee1bf23216971b50b8822c45e62c48b}{doc\_solution}(doc\_info);
 
 \textcolor{comment}{//Increment counter for solutions }
 doc\_info.number()++;

\end{DoxyCodeInclude}


The solution looks much smoother but we suspect that the corner regions are still under-\/resolved. Therefore, we call the {\ttfamily Problem\+::adapt()} function which computes an error estimate for all elements and automatically performs a single mesh adaptation (refinement/unrefinement) step. If this adaptation changes the mesh, we recompute the solution, using the \char`\"{}normal\char`\"{} Newton solver without automatic adaptation. We document the solution and continue the adaptation cycle until {\ttfamily Problem\+::adapt()} ceases to change the mesh\+:

 
\begin{DoxyCodeInclude}
 \textcolor{comment}{// Now do (up to) four rounds of fully automatic adapation in response to }
 \textcolor{comment}{//-----------------------------------------------------------------------}
 \textcolor{comment}{// error estimate}
 \textcolor{comment}{//---------------}
 \textcolor{keywordtype}{unsigned} max\_solve=4;
 \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} isolve=0;isolve<max\_solve;isolve++)
  \{
   \textcolor{comment}{// Adapt problem/mesh}
   problem.adapt(); 
         
   \textcolor{comment}{// Re-solve the problem if the adaptation has changed anything}
   \textcolor{keywordflow}{if} ((problem.\hyperlink{classRefineableFishPoissonProblem_a803c9050b07b35aba22f08a5a9e59f2c}{mesh\_pt}()->nrefined()  !=0)||
       (problem.\hyperlink{classRefineableFishPoissonProblem_a803c9050b07b35aba22f08a5a9e59f2c}{mesh\_pt}()->nunrefined()!=0))
    \{
     problem.newton\_solve();
    \}
   \textcolor{keywordflow}{else}
    \{
     cout << \textcolor{stringliteral}{"Mesh wasn't adapted --> we'll stop here"} << std::endl;
     \textcolor{keywordflow}{break};
    \}
   
   \textcolor{comment}{//Output solution}
   problem.\hyperlink{classRefineableFishPoissonProblem_aeee1bf23216971b50b8822c45e62c48b}{doc\_solution}(doc\_info);
   
   \textcolor{comment}{//Increment counter for solutions }
   doc\_info.number()++;
  \}
 
 
\} \textcolor{comment}{// end of incremental}

\end{DoxyCodeInclude}


The progress of the adaptation is illustrated in the animated gif at the beginning of this document. The first frame displays the solution on the original four-\/element mesh; the next frame shows the solution on the uniformly refined mesh; the final two frames show the progress of the subsequent, error-\/estimate-\/driven mesh adaptation.



 

\hypertarget{index_problem}{}\section{The problem class}\label{index_problem}
The problem class is virtually identical to that used in the \href{../../../poisson/two_d_poisson/html/index.html}{\tt 2D Poisson problem without mesh refinement}. In the present problem, we leave the function {\ttfamily Problem\+::actions\+\_\+before\+\_\+newton\+\_\+solve()} empty because the boundary conditions do not change. The function {\ttfamily \hyperlink{classRefineableFishPoissonProblem_a803c9050b07b35aba22f08a5a9e59f2c}{Refineable\+Fish\+Poisson\+Problem\+::mesh\+\_\+pt()}} overloads the (virtual) function {\ttfamily Problem\+::mesh\+\_\+pt()} since it returns a pointer to a generic {\ttfamily Mesh} object, rather than a pointer to the specific mesh used in this problem. This avoids explicit re-\/casts in the rest of the code where member functions of the specific mesh need to be accessed.

 
\begin{DoxyCodeInclude}
\textcolor{comment}{//======start\_of\_problem\_class========================================}
\textcolor{comment}{/// Refineable Poisson problem in fish-shaped domain.}
\textcolor{comment}{}\textcolor{comment}{/// Template parameter identifies the element type.}
\textcolor{comment}{}\textcolor{comment}{//====================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT>
\textcolor{keyword}{class }\hyperlink{classRefineableFishPoissonProblem}{RefineableFishPoissonProblem} : \textcolor{keyword}{public} Problem
\{

\textcolor{keyword}{public}:
\textcolor{comment}{}
\textcolor{comment}{ /// Constructor}
\textcolor{comment}{} \hyperlink{classRefineableFishPoissonProblem_a7a9c8258a867de6b3c8b9d00a7c965f1}{RefineableFishPoissonProblem}();
\textcolor{comment}{}
\textcolor{comment}{ /// Destructor: Empty}
\textcolor{comment}{} \textcolor{keyword}{virtual} \hyperlink{classRefineableFishPoissonProblem_a4a5e7c5f264364211ad641353933c222}{~RefineableFishPoissonProblem}()\{\}
\textcolor{comment}{}
\textcolor{comment}{ /// Update the problem specs after solve (empty)}
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{classRefineableFishPoissonProblem_a7f6c356f7c8bd0130de957297e999f40}{actions\_after\_newton\_solve}() \{\}
\textcolor{comment}{}
\textcolor{comment}{ /// Update the problem specs before solve (empty)}
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{classRefineableFishPoissonProblem_a58098181f3b88c2fc65f24fb15c1a529}{actions\_before\_newton\_solve}() \{\}
\textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Overloaded version of the problem's access function to }
\textcolor{comment}{ /// the mesh. Recasts the pointer to the base Mesh object to }
\textcolor{comment}{ /// the actual mesh type.}
\textcolor{comment}{} RefineableFishMesh<ELEMENT>* \hyperlink{classRefineableFishPoissonProblem_a803c9050b07b35aba22f08a5a9e59f2c}{mesh\_pt}() 
  \{
   \textcolor{keywordflow}{return} \textcolor{keyword}{dynamic\_cast<}RefineableFishMesh<ELEMENT>*\textcolor{keyword}{>}(Problem::mesh\_pt());
  \}
\textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Doc the solution. Output directory and labels are specified }
\textcolor{comment}{ /// by DocInfo object}
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{classRefineableFishPoissonProblem_aeee1bf23216971b50b8822c45e62c48b}{doc\_solution}(DocInfo& doc\_info);

\}; \textcolor{comment}{// end of problem class}

\end{DoxyCodeInclude}




 

\hypertarget{index_constructor}{}\section{The Problem constructor}\label{index_constructor}
We start by creating the mesh, using {\ttfamily oomph-\/lib\textquotesingle{}s} {\ttfamily Refineable\+Fish\+Mesh} object\+:


\begin{DoxyCodeInclude}
\textcolor{comment}{//===========start\_of\_constructor=========================================}
\textcolor{comment}{/// Constructor for adaptive Poisson problem in fish-shaped}
\textcolor{comment}{}\textcolor{comment}{/// domain.}
\textcolor{comment}{}\textcolor{comment}{//========================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT>
\hyperlink{classRefineableFishPoissonProblem_a7a9c8258a867de6b3c8b9d00a7c965f1}{RefineableFishPoissonProblem<ELEMENT>::RefineableFishPoissonProblem}
      ()
\{ 
    
 \textcolor{comment}{// Build fish mesh -- this is a coarse base mesh consisting }
 \textcolor{comment}{// of four elements. We'll refine/adapt the mesh later.}
 Problem::mesh\_pt()=\textcolor{keyword}{new} RefineableFishMesh<ELEMENT>;

\end{DoxyCodeInclude}


Next, we create an error estimator for the problem. The {\ttfamily Z2\+Error\+Estimator} is based on Zhu and Zienkiewicz\textquotesingle{}s flux recovery technique and can be used with all elements that are derived from the {\ttfamily Element\+With\+Z2\+Error\+Estimator} base class (or with functions that implement the pure virtual functions that are defined in this class) -- the {\ttfamily Refineable\+Q\+Poisson\+Element} is an element of this type.


\begin{DoxyCodeInclude}
 \textcolor{comment}{// Create/set error estimator}
 mesh\_pt()->spatial\_error\_estimator\_pt()=\textcolor{keyword}{new} Z2ErrorEstimator;

\end{DoxyCodeInclude}


Next we pin the nodal values on all boundaries, apply the homogeneous Dirichlet boundary conditions, pass the pointer to the source function to the elements, and set up the equation numbering scheme.


\begin{DoxyCodeInclude}
 \textcolor{comment}{// Set the boundary conditions for this problem: All nodes are}
 \textcolor{comment}{// free by default -- just pin the ones that have Dirichlet conditions}
 \textcolor{comment}{// here. Since the boundary values are never changed, we set}
 \textcolor{comment}{// them here rather than in actions\_before\_newton\_solve(). }
 \textcolor{keywordtype}{unsigned} n\_bound = mesh\_pt()->nboundary();
 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} i=0;i<n\_bound;i++)
  \{
   \textcolor{keywordtype}{unsigned} n\_node = mesh\_pt()->nboundary\_node(i);
   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} n=0;n<n\_node;n++)
    \{
     \textcolor{comment}{// Pin the single scalar value at this node}
     mesh\_pt()->boundary\_node\_pt(i,n)->pin(0); 

     \textcolor{comment}{// Assign the homogenous boundary condition for the one and only}
     \textcolor{comment}{// nodal value}
     mesh\_pt()->boundary\_node\_pt(i,n)->set\_value(0,0.0); 
    \}
  \}

 \textcolor{comment}{// Loop over elements and set pointers to source function}
 \textcolor{keywordtype}{unsigned} n\_element = mesh\_pt()->nelement();
 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} e=0;e<n\_element;e++)
  \{
   \textcolor{comment}{// Upcast from FiniteElement to the present element}
   ELEMENT *el\_pt = \textcolor{keyword}{dynamic\_cast<}ELEMENT*\textcolor{keyword}{>}(mesh\_pt()->element\_pt(e));

   \textcolor{comment}{//Set the source function pointer}
   el\_pt->source\_fct\_pt() = &\hyperlink{namespaceConstSourceForPoisson_aeaa1153817bde9598372b803342f3299}{ConstSourceForPoisson::source\_function};
  \}

 \textcolor{comment}{// Setup the equation numbering scheme}
 cout <<\textcolor{stringliteral}{"Number of equations: "} << assign\_eqn\_numbers() << std::endl; 

\} \textcolor{comment}{// end of constructor}

\end{DoxyCodeInclude}




 

\hypertarget{index_doc}{}\section{Post-\/processing}\label{index_doc}
The post-\/processing routine writes the computed result to an output file, labeled with the identifiers specified in the {\ttfamily Doc\+Info} object.


\begin{DoxyCodeInclude}
\textcolor{comment}{//=======start\_of\_doc=====================================================}
\textcolor{comment}{/// Doc the solution in tecplot format.}
\textcolor{comment}{}\textcolor{comment}{//========================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT>
\textcolor{keywordtype}{void} \hyperlink{classRefineableFishPoissonProblem_aeee1bf23216971b50b8822c45e62c48b}{RefineableFishPoissonProblem<ELEMENT>::doc\_solution}
      (DocInfo& doc\_info)
\{ 

 ofstream some\_file;
 \textcolor{keywordtype}{char} filename[100];

 \textcolor{comment}{// Number of plot points in each coordinate direction.}
 \textcolor{keywordtype}{unsigned} npts;
 npts=5; 

 \textcolor{comment}{// Output solution }
 sprintf(filename,\textcolor{stringliteral}{"%s/soln%i.dat"},doc\_info.directory().c\_str(),
         doc\_info.number());
 some\_file.open(filename);
 mesh\_pt()->output(some\_file,npts);
 some\_file.close();
 
\} \textcolor{comment}{// end of doc}

\end{DoxyCodeInclude}




 

\hypertarget{index_comments}{}\section{Comments and Exercises}\label{index_comments}
The purpose of this example was to provide a high-\/level overview of {\ttfamily oomph-\/lib\textquotesingle{}s} mesh adaptation procedures. We demonstrated that the implementation of full adaptivity only required us to
\begin{DoxyItemize}
\item replace the {\ttfamily Fish\+Mesh} and the {\ttfamily Q\+Poisson\+Element} objects by their refineable equivalents, {\ttfamily Refineable\+Fish\+Mesh} and {\ttfamily Refineable\+Q\+Poisson\+Element}, respectively
\item specify the error estimator, and
\item specify the maximum number of adaptations for the black-\/box adaptive Newton solver.
\end{DoxyItemize}(Compare the Problem specification for the current problem to that of its non-\/refineable equivalent, contained in the alternative driver code \href{../../../../demo_drivers/poisson/fish_poisson/fish_poisson_no_adapt.cc}{\tt fish\+\_\+poisson\+\_\+no\+\_\+adapt.\+cc.})

Since most of the \char`\"{}hard work\char`\"{} involved in the mesh adaptation is \char`\"{}hidden\char`\"{} from the user, we highlight some important aspects of the procedure\+:\hypertarget{index_adapt_bc}{}\subsection{Automatic transfer of the solution/boundary conditions during the mesh adaptation}\label{index_adapt_bc}
The {\ttfamily Problem\+::adapt()} function automatically determines the correct boundary conditions for newly created nodes on the Mesh boundary; it automatically updates the equation numbering scheme, and interpolates the solution from the original mesh onto the adapted mesh. This is important in nonlinear problems where the provision of a good initial guess for the Newton iteration is vital; and in time-\/dependent problems where the solution at one timestep provides initial conditions for the next one. See the discussion of \href{../../../unsteady_heat/two_d_unsteady_heat_adapt/html/index.html}{\tt the adaptive solution of the unsteady heat equation} for more details. Furthermore, the source function pointers are automatically passed to an element\textquotesingle{}s four \char`\"{}son\char`\"{} elements when the element is subdivided. This allows the adaptation to proceed completely automatically, without any intervention by the \char`\"{}user\char`\"{}. On return from {\ttfamily Problem\+::adapt()} the problem can immediately be re-\/solved.

In some special cases, certain actions may need to be performed before or after the mesh adaptation (e.\+g. if flux boundary conditions are applied by {\ttfamily Face\+Elements}; this is explained in \href{../../../poisson/two_d_poisson_flux_bc_adapt/html/index.html}{\tt another example}). To ensure that these steps are performed when the adaptation is controlled by the \char`\"{}black-\/box\char`\"{} adaptive Newton solver, the {\ttfamily Problem} class provides the two empty virtual functions 
\begin{DoxyCode}
Problem::actions\_before\_adapt()
\end{DoxyCode}
 and 
\begin{DoxyCode}
Problem::actions\_after\_adapt()
\end{DoxyCode}
 which are called automatically before and after the adaptation. The \char`\"{}user\char`\"{} can overload these in his/her specific {\ttfamily Problem} class to implement such actions.\hypertarget{index_how_to}{}\subsection{Automatic mesh adaptation in domains with curvilinear boundaries}\label{index_how_to}
The mesh adaptation not only increases the number of elements but also produces a more accurate representation of the curvilinear domain boundary -- new boundary nodes are placed exactly onto the analytically-\/defined, curvilinear boundary, rather than on the boundaries of the \char`\"{}father\char`\"{} element, which only provides an approximate representation of the exact domain boundary. This is achieved by employing a {\ttfamily Macro\+Element-\/based} representation of the {\ttfamily Domain} -- we will discuss this in more detail in \href{../../../poisson/fish_poisson2/html/index.html}{\tt another example.}\hypertarget{index_problem_vs_mesh}{}\subsection{Problem adaptation vs. Mesh adaptation}\label{index_problem_vs_mesh}
Many adaptation routines in the {\ttfamily Problem} class have equivalents in the {\ttfamily Refineable\+Mesh} class. It is important to appreciate the important differences between them\+: If adaptation is performed at the {\ttfamily Problem} level, the adapted {\ttfamily Problem} is fully functional, i.\+e. boundary conditions will have been assigned for newly created nodes on the mesh boundary, the equation numbering scheme will have been updated, etc. The adapted {\ttfamily Problem} can therefore be re-\/solved immediately. Conversely, if a mesh is refined directly, using the member functions of the {\ttfamily Refineable\+Mesh} class, many of these additional tasks need to be performed \char`\"{}by hand\char`\"{} before the adapted {\ttfamily Problem} can be resolved.



\hypertarget{index_exercises}{}\subsection{Exercises}\label{index_exercises}
To familiarise yourself with {\ttfamily oomph-\/lib\textquotesingle{}s} mesh adaptation procedures we suggest the following exercises\+:
\begin{DoxyEnumerate}
\item When the Poisson problem is solved with the default refinement targets, no elements are unrefined. Increase the minimum permitted error from its default value of $ 10^{-5} $ to $ 10^{-4} $ by adding the statement 
\begin{DoxyCode}
problem.\hyperlink{classRefineableFishPoissonProblem_a803c9050b07b35aba22f08a5a9e59f2c}{mesh\_pt}()->min\_permitted\_error()=1.0e-4;
\end{DoxyCode}
 before 
\begin{DoxyCode}
problem.\hyperlink{classRefineableFishPoissonProblem_a803c9050b07b35aba22f08a5a9e59f2c}{mesh\_pt}()->doc\_adaptivity\_targets(cout);
\end{DoxyCode}
 This value forces an unrefinement of several elements in the mesh\+:  
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{fish_poisson_soln2}
\doxyfigcaption{Plot of the solutions obtained with the modified adaptivity targets. }
\end{DoxyImage}

\item Convince yourself that {\ttfamily Problem\+::adapt()} does indeed interpolate the solution from the coarse mesh to the fine mesh -- call {\ttfamily Problem\+::doc\+\_\+solution}(...) before and after its execution.
\item The {\ttfamily Problem\+::refine\+\_\+uniformly()} function has a counterpart {\ttfamily Problem\+::unrefine\+\_\+uniformly()}. Why does this function not simply unrefine every single element in the mesh? Explore the action of {\ttfamily Problem\+::unrefine\+\_\+uniformly()} by plotting the solution before and after a few executions of this function.  
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{fish_poisson_soln3}
\doxyfigcaption{Uniform unrefinement }
\end{DoxyImage}

\item Impose a \char`\"{}user-\/defined\char`\"{} refinement pattern by calling the function {\ttfamily Problem\+::refine\+\_\+selected\+\_\+elements}(...).
\end{DoxyEnumerate}



 

\hypertarget{index_sources}{}\section{Source files for this tutorial}\label{index_sources}

\begin{DoxyItemize}
\item The source files for this tutorial are located in the directory\+: \begin{center} \href{../../../../demo_drivers/poisson/fish_poisson/}{\tt demo\+\_\+drivers/poisson/fish\+\_\+poisson/ } \end{center} 
\item The driver code is\+: \begin{center} \href{../../../../demo_drivers/poisson/fish_poisson/fish_poisson.cc}{\tt demo\+\_\+drivers/poisson/fish\+\_\+poisson/fish\+\_\+poisson.\+cc } \end{center} 
\end{DoxyItemize}

 

 \hypertarget{index_pdf}{}\section{P\+D\+F file}\label{index_pdf}
A \href{../latex/refman.pdf}{\tt pdf version} of this document is available. \end{document}
