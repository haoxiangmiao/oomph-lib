In an \href{../../../../doc/poisson/two_d_poisson_adapt/html/index.html}{\tt earlier example} we demonstrated how easy it is to \char`\"{}upgrade\char`\"{} an existing quad mesh to a {\ttfamily Refineable\+Mesh} that can be used with {\ttfamily oomph-\/lib\textquotesingle{}s} mesh adaptation routines. The \char`\"{}upgrade\char`\"{} was achieved by multiple inheritance\+: We combined the basic (non-\/refineable) mesh object with {\ttfamily oomph-\/lib\textquotesingle{}s} {\ttfamily Refineable\+Quad\+Mesh} -- a class that implements the required mesh adaptation procedures, using {\ttfamily Quad\+Tree} -\/ based refinement techniques for meshes that contain quadrilateral elements. During the refinement process, selected elements are split into four \char`\"{}son\char`\"{} elements and the nodal values and coordinates of any newly created nodes are determined by interpolation from the \char`\"{}father\char`\"{} element. This procedure is perfectly adequate for problems with polygonal domain boundaries in which the initial coarse mesh provides a perfect representation of the domain. The situation is more complicated in problems with curvilinear domain boundaries since we must ensure that successive mesh refinements lead to an increasingly accurate representation of the domain boundary.

To illustrate these issues we (re-\/)consider the 2D Poisson problem \begin{center} \tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*{1}{|X[-1]}|}
\hline
\begin{center} {\bfseries Two-\/dimensional model Poisson problem in a non-\/trivial domain} \end{center}  Solve \[ \sum_{i=1}^2 \frac{\partial^2u}{\partial x_i^2} = -1, \ \ \ \ \ \ \ \ \ \ (1) \] in the fish-\/shaped domain $D_{fish} $ with homogeneous Dirichlet boundary conditions \[ \left. u\right|_{\partial D_{fish}}=0. \ \ \ \ \ \ \ \ \ \ (2) \]   \\\cline{1-1}
\end{longtabu}
\end{center} 

In Part 1 of this document we shall explain how {\ttfamily oomph-\/lib\textquotesingle{}s} mesh adaptation procedures employ the {\ttfamily Domain} and {\ttfamily Macro\+Element} objects to adapt meshes in domains with curvilinear boundaries. In Part 2, we demonstrate how to create new {\ttfamily Domain} objects.



\hypertarget{index_adapt}{}\section{Part 1\+: Mesh adaptation in domains with curvilinear boundaries, using Domain and Macro\+Element objects}\label{index_adapt}
The plot below shows the domain $D_{fish} $, represented by the multi-\/coloured, shaded region and its (extremely coarse) discretisation with four four-\/node quad elements. The elements\textquotesingle{} edges and nodes are shown in black.

 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{coarse_fish_mesh_and_domain}
\doxyfigcaption{The fish-\/shaped domain and its discretisation with four four-\/node quad elements }
\end{DoxyImage}


Obviously, the curvilinear boundaries of the fish-\/shaped domain (arcs of circles) are very poorly resolved by the elements\textquotesingle{} straight edges. Simple mesh adaptation, based on the techniques described in the \href{../../../../doc/poisson/two_d_poisson_adapt/html/index.html}{\tt earlier example} will not result in convergence to the exact solution since the refined mesh never approaches the exact domain geometry\+:

 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{fish_poisson_soln_no_macro}
\doxyfigcaption{Plot of the mesh adaptation without Macro\+Elements }
\end{DoxyImage}


To overcome this problem, the mesh adaptation routines must be given access to an exact, analytical representation of the actual domain. This is the purpose of {\ttfamily oomph-\/lib\textquotesingle{}s} {\ttfamily Domain} object. A {\ttfamily Domain} provides an analytical description of a mathematical domain, by decomposing it into a number of so-\/called {\ttfamily Macro\+Elements}. Each {\ttfamily Macro\+Element} provides a mapping between a set of local and global coordinates $ {\bf r}_{macro}({\bf s})$ -- similar to the mapping between the local and global coordinates in a finite element. The key difference between the two types of element is that the {\ttfamily Macro\+Element} mapping resolves curvilinear domain boundaries exactly, whereas the finite element mapping interpolates the global coordinates between the coordinates of its nodes. The topology of {\ttfamily Macro\+Elements} mirrors that of the associated (geometric) finite elements\+: For instance, the {\ttfamily Q\+Macro\+Element} family is the counterpart of the {\ttfamily Q\+Element} family of geometric finite elements. Both are templated by the spatial dimension, and the local coordinates (in their right-\/handed local coordinate systems) are in the range between -\/1 and +1.

The different-\/coloured, shaded regions in the above sketch represent the four two-\/dimensional {\ttfamily Q\+Macro\+Elements} by which the {\ttfamily Fish\+Domain} represents the fish-\/shaped domain $ D_{fish} $. For instance, {\ttfamily Macro\+Element} 0 (shown in orange) represents the lower half of the fish\textquotesingle{}s body; within this {\ttfamily Macro\+Element}, the curved \char`\"{}belly\char`\"{} is represented by the line $ {\bf r}_{macro}(s_0,s_1=-1)$ for $s_0\in[-1,1]$; the lower \char`\"{}jaw\char`\"{} is represented by $ {\bf r}_{macro}(s_0=-1,s_1)$ for $s_1\in[-1,1]$; etc.

To illustrate the use of {\ttfamily Macro\+Elements} / {\ttfamily Domains}, the following code fragment (from \href{../../../../src/meshes/fish_mesh.template.cc}{\tt fish\+\_\+mesh.\+template.\+cc }) demonstrates how the constructor of the original, non-\/refineable {\ttfamily Fish\+Mesh} assigns the nodal positions. Each of the {\ttfamily Fish\+Domain\textquotesingle{}s} four {\ttfamily Q\+Macro\+Elements} is associated with one of the four finite elements in the mesh. Since both types of elements are parametrised by the same local coordinate systems, we determine the position of the node that is located at $(s_0, s_1)$ (in the finite element\textquotesingle{}s local coordinate system) from the corresponding {\ttfamily Macro\+Element} mapping, ${\bf r}_{macro}(s_0, s_1)$\+:

 
\begin{DoxyCodeInclude}
 \textcolor{comment}{// Create elements and all nodes in element}
 \textcolor{comment}{//-----------------------------------------}
 \textcolor{comment}{// (ignore repetitions for now -- we'll clean them up later)}
 \textcolor{comment}{//----------------------------------------------------------}
 \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} e=0;e<nelem;e++)
  \{
   \textcolor{comment}{// Create element}
   Element\_pt[e] = \textcolor{keyword}{new} ELEMENT;
   
   \textcolor{comment}{// Loop over rows in y/s\_1-direction}
   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} i1=0;i1<n\_node\_1d;i1++)
    \{
     
     \textcolor{comment}{// Loop over rows in x/s\_0-direction}
     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} i0=0;i0<n\_node\_1d;i0++)
      \{
       \textcolor{comment}{// Local node number}
       \textcolor{keywordtype}{unsigned} j\_local=i0+i1*n\_node\_1d;
       
       \textcolor{comment}{// Create the node and store pointer to it}
       Node* node\_pt=finite\_element\_pt(e)->
        construct\_node(j\_local,time\_stepper\_pt);

       \textcolor{comment}{// Work out the node's coordinates in the finite element's local}
       \textcolor{comment}{// coordinate system:}
       finite\_element\_pt(e)->local\_fraction\_of\_node(j\_local,s\_fraction);
       
       s[0]=-1.0+2.0*s\_fraction[0];
       s[1]=-1.0+2.0*s\_fraction[1];

       \textcolor{comment}{// Get the global position of the node from macro element mapping}
       Domain\_pt->macro\_element\_pt(e)->macro\_map(s,r);
       
       \textcolor{comment}{// Set the nodal position}
       node\_pt->x(0) = r[0];
       node\_pt->x(1) = r[1];
      \}
    \}
  \} \textcolor{comment}{// end of loop over elements}

\end{DoxyCodeInclude}


This technique ensures that the mesh\textquotesingle{}s boundary nodes are placed on the exact domain boundary when the mesh is created.

To retain this functionality during the mesh adaptation, each {\ttfamily Finite\+Element} provides storage for a pointer to an associated {\ttfamily Macro\+Element}. By default, the {\ttfamily Macro\+Element} pointer is set to {\ttfamily N\+U\+LL}, indicating that the element is not associated with a {\ttfamily Macro\+Element}. In that case, the coordinates of newly created nodes are determined by interpolation from the father element, as discussed above. If the {\ttfamily Macro\+Element} pointer is non-\/{\ttfamily N\+U\+LL}, the refinement process refers to the element\textquotesingle{}s {\ttfamily Macro\+Element} representation to determine the new nodal positions.

To enable the mesh adaptation process to respect the domain\textquotesingle{}s curvilinear boundaries, each element in the coarse base mesh must therefore be given a pointer to its associated {\ttfamily Macro\+Element}, e.\+g. by using the following loop\+:  
\begin{DoxyCodeInclude}
 \textcolor{comment}{// Loop over all elements and set macro element pointer}
 \textcolor{keywordtype}{unsigned} n\_element=this->nelement();
 \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} e=0;e<n\_element;e++)
  \{
   \textcolor{comment}{// Get pointer to element}
   FiniteElement* el\_pt=this->finite\_element\_pt(e);
   
   \textcolor{comment}{// Set pointer to macro element to enable MacroElement-based}
   \textcolor{comment}{// remesh. Also enables the curvlinear boundaries}
   \textcolor{comment}{// of the mesh/domain get picked up during adaptive}
   \textcolor{comment}{// mesh refinement in derived classes.}
   el\_pt->set\_macro\_elem\_pt(this->Domain\_pt->macro\_element\_pt(e));
  \}

\end{DoxyCodeInclude}


Once the mesh is aware of the curvilinear boundaries, each level of mesh refinement produces a better representation of the curvilinear domain, ensuring the convergence to the exact solution\+:

 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{fish_poisson_adapt_soln}
\doxyfigcaption{Plot of the mesh adaptation with Macro\+Elements }
\end{DoxyImage}


The results shown in this animation were computed with the demo code \href{../../../../demo_drivers/poisson/fish_poisson2/fish_poisson_adapt.cc}{\tt fish\+\_\+poisson\+\_\+adapt.\+cc} -- a simple modification of the code \href{../../../../demo_drivers/poisson/fish_poisson/fish_poisson.cc}{\tt fish\+\_\+poisson.\+cc} that we used in the \href{../../../../doc/poisson/fish_poisson/html/index.html}{\tt earlier example}. The only difference between the two codes is that in the present example, the {\ttfamily Fish\+Domain} is discretised with four-\/node rather than nine-\/node {\ttfamily Refineable\+Q\+Poisson\+Elements} to highlight the inadequacy of the basic mesh refinement process. Note that, as a result of lower accuracy of the four-\/node elements, we require a much finer discretisation in the interior of the domain.



\hypertarget{index_domain}{}\section{Part 2\+: How to represent domains with curvilinear boundaries by Domain and Macro\+Element objects}\label{index_domain}
The above example demonstrated that \char`\"{}upgrading\char`\"{} existing meshes to {\ttfamily Refineable\+Meshes} that can be used with {\ttfamily oomph-\/lib\textquotesingle{}s} mesh adaptation procedures, can be achieved in two trivial steps\+:
\begin{DoxyEnumerate}
\item Associate each {\ttfamily Refineable\+Q\+Element} with a {\ttfamily Quad\+Tree} -- this can done completely automatically by calling the function {\ttfamily Refineable\+Quad\+Mesh\+::setup\+\_\+quadtree\+\_\+forest()}.
\item If the problem\textquotesingle{}s domain has curvilinear boundaries, associate each {\ttfamily Refineable\+Q\+Element} with a {\ttfamily Macro\+Element} -- defined in the {\ttfamily Domain} object that provides an analytical representation of the domain.
\end{DoxyEnumerate}While this looks (and indeed is) impressively simple, we still have to explain how to create {\ttfamily Domain} objects. We start by introducing yet another useful {\ttfamily oomph-\/lib} class, the {\ttfamily Geom\+Object}.\hypertarget{index_geom_object}{}\subsection{The geometric object, Geom\+Object}\label{index_geom_object}
As the name suggests, {\ttfamily Geom\+Objects} are {\ttfamily oomph-\/lib} objects that provide an analytical description/parametrisation of geometric objects. Mathematically, {\ttfamily Geom\+Objects} define a mapping from a set of \char`\"{}\+Lagrangian\char`\"{} (intrinsic) coordinates to the global \char`\"{}\+Eulerian\char`\"{} coordinates of the object. The number of Lagrangian and Eulerian coordinates can differ. For instance, the unit circle, centred at the origin may be parametrised by a single coordinate, $ \xi $ (representing the polar angle), as \[ {\bf r}_{circle} = \left( \begin{array}{c} \cos \xi \\ \sin \xi \end{array} \right), \] while a 2D disk may be parametrised by two coordinates $ \xi_1 $ and $ \xi_2 $ (representing the radius and the polar angle, respectively) as \[ {\bf r}_{disk} = \xi_1 \left( \begin{array}{c} \cos \xi_2 \\ \sin \xi_2 \end{array} \right). \] All specific {\ttfamily Geom\+Objects} must implement the pure virtual function {\ttfamily Geom\+Object\+::position}(...) which computes the Eulerian position vector $ {\bf r}$ as a function of the (vector of) Lagrangian coordinates $ {\bf \xi}$. (The {\ttfamily Geom\+Object} base class also provides interfaces for a multitude of other functions, such as functions that compute the spatial and temporal derivatives of the position vector. These functions are implemented as \char`\"{}broken\char`\"{} virtual functions and their implementation is optional; see the \href{../../../../doc/poisson/two_d_poisson_flux_bc/html/index.html}{\tt earlier example} for a discussion of \char`\"{}broken\char`\"{} virtual functions.)

Here is a complete example of a specific {\ttfamily Geom\+Object\+:} 

 
\begin{DoxyCodeInclude}
\textcolor{comment}{//=======================start\_of\_unit\_circle==============================}
\textcolor{comment}{/// Unit circle in 2D, centred at the origin, parametrised by a single}
\textcolor{comment}{}\textcolor{comment}{/// Lagrangian coordinate, the polar angle.}
\textcolor{comment}{}\textcolor{comment}{//=========================================================================}
\textcolor{keyword}{class }\hyperlink{classUnitCircle}{UnitCircle} : \textcolor{keyword}{public} GeomObject
\{

 \textcolor{keyword}{public}:
\textcolor{comment}{}
\textcolor{comment}{  /// \(\backslash\)short Constructor: Pass the number of Lagrangian}
\textcolor{comment}{  /// and Eulerian coordinates to the constructor of the}
\textcolor{comment}{  ///  GeomObject base class.}
\textcolor{comment}{}  \hyperlink{classUnitCircle_a494ddf1cb37b659c6f8c44ddde2b9b33}{UnitCircle}() : GeomObject(1,2) \{\}
\textcolor{comment}{}
\textcolor{comment}{  /// Destructor -- emtpy}
\textcolor{comment}{}  \textcolor{keyword}{virtual} \hyperlink{classUnitCircle_a9eb314d8152f5de298e1e155737a69b9}{~UnitCircle}()\{\}
\textcolor{comment}{}
\textcolor{comment}{  /// \(\backslash\)short Position vector, r, to the point on the circle identified by  }
\textcolor{comment}{  /// its 1D Lagrangian coordinate, xi (passed as a 1D Vector):}
\textcolor{comment}{}  \textcolor{keywordtype}{void} \hyperlink{classUnitCircle_adc7fc660ba1d2ecc5bcbe2312e2fb87b}{position}(\textcolor{keyword}{const} Vector<double>& xi, Vector<double>& r)\textcolor{keyword}{ const}
\textcolor{keyword}{  }\{
   \textcolor{comment}{// Eulerian position vector}
   r[0] = cos(xi[0]);
   r[1] = sin(xi[0]);
  \}

\textcolor{comment}{}
\textcolor{comment}{  /// \(\backslash\)short Position vector, r, to the point on the circle identified by  }
\textcolor{comment}{  /// its 1D Lagrangian coordinate, xi (passed as a 1D Vector) at discrete time}
\textcolor{comment}{  /// level t (t=0: present; t>0: previous). The shape of the object }
\textcolor{comment}{  /// is not time-dependent, therefore we forward this call to the }
\textcolor{comment}{  /// steady version. }
\textcolor{comment}{}  \textcolor{keywordtype}{void} \hyperlink{classUnitCircle_adc7fc660ba1d2ecc5bcbe2312e2fb87b}{position}(\textcolor{keyword}{const} \textcolor{keywordtype}{unsigned}& t, \textcolor{keyword}{const} Vector<double>& xi, 
                Vector<double>& r)\textcolor{keyword}{ const}
\textcolor{keyword}{  }\{
   \hyperlink{classUnitCircle_adc7fc660ba1d2ecc5bcbe2312e2fb87b}{position}(xi,r);
  \}

\}; \textcolor{comment}{// end of unit circle class}

\end{DoxyCodeInclude}


\mbox{[}The dummy time-\/dependent version of the {\ttfamily position}(...) function is required to stop the compiler from complaining about \char`\"{}only partially 
overridden\char`\"{} virtual functions\mbox{]}.\hypertarget{index_domain_objects}{}\subsection{Domains}\label{index_domain_objects}
{\ttfamily Geom\+Objects} provide a natural way of representing a {\ttfamily Domain\textquotesingle{}s} curvilinear boundaries. For instance, the fish\textquotesingle{}s body in $ D_{fish}$ is bounded by two circular arcs. These may be represented by {\ttfamily Geom\+Objects} of type {\ttfamily Circle} -- a slight generalisation of the {\ttfamily \hyperlink{classUnitCircle}{Unit\+Circle}} class shown above. The {\ttfamily Fish\+Domain} constructor therefore takes a pointer to a 2D {\ttfamily Geom\+Object} and the \char`\"{}start\char`\"{} and \char`\"{}end\char`\"{} values of the Lagrangian coordinate along this object. The {\ttfamily Geom\+Object} represents the curvilinear boundary of the fish\textquotesingle{}s (upper) body and the two coordinates represent the Lagrangian coordinates of the \char`\"{}nose\char`\"{} and the \char`\"{}tail\char`\"{} on this {\ttfamily Geom\+Object}, as shown in this sketch\+:

 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{fish_domain}
\doxyfigcaption{The fish-\/shaped domain and its Macro\+Element-\/based representation by the Fish\+Domain object. The arrows show the orientation of the Macro\+Elements\textquotesingle{} local coordinate systems. }
\end{DoxyImage}


To construct a {\ttfamily Fish\+Domain} whose curvilinear boundaries are arcs of unit circles, centred at $ (x_0,x_1) = (1/2 , 0) $ we create a {\ttfamily Geom\+Object} of type {\ttfamily Circle}, passing the appropriate parameters to its constructor\+:


\begin{DoxyCode}
\textcolor{comment}{// Fish back is a circle of radius 1, centred at (0.5,0.0)}
\textcolor{keywordtype}{double} x\_c=0.5;
\textcolor{keywordtype}{double} y\_c=0.0;
\textcolor{keywordtype}{double} r\_back=1.0;
GeomObject* back\_pt=\textcolor{keyword}{new} Circle(x\_c,y\_c,r\_back);
\end{DoxyCode}


Next, we pass the (pointer to the) {\ttfamily Circle} object to the constructor of the {\ttfamily Fish\+Domain}, locating the \char`\"{}nose end\char`\"{} of the fish\textquotesingle{}s back at $\xi=2.4$ and its \char`\"{}tail end\char`\"{} at $\xi=0.4$\+:


\begin{DoxyCode}
\textcolor{keywordtype}{double} xi\_nose=2.6; 
\textcolor{keywordtype}{double} xi\_tail=0.4; 
Domain* domain\_pt=\textcolor{keyword}{new} FishDomain(back\_pt,xi\_nose,xi\_tail);
\end{DoxyCode}


To see how this works internally, let us have a look at the {\ttfamily Fish\+Domain} constructor. The constructor stores the pointer to the fish\textquotesingle{}s \char`\"{}back\char`\"{}, and the start and end values of the Lagrangian coordinates in the private data members {\ttfamily Back\+\_\+pt}, {\ttfamily Xi\+\_\+nose} and {\ttfamily Xi\+\_\+tail}. Next we set some additional parameters, that define the geometry (the mouth is located at the origin; the fin is a vertical line at $ x=1.7$, ranging from $ y=-0.9$ to $ y=+0.9$). Finally, we allocate storage for the four {\ttfamily Macro\+Elements} and build them. Note that the constructor of the {\ttfamily Macro\+Element} takes a pointer to the Domain, and the {\ttfamily Macro\+Element\textquotesingle{}s} number within that {\ttfamily Domain\+:} 

 
\begin{DoxyCodeInclude}
 \textcolor{comment}{/// \(\backslash\)short Constructor: Pass pointer to GeomObject that represents the}
\textcolor{comment}{ /// (upper) curved boundary of the fish's body, and the start and end values}
\textcolor{comment}{}\textcolor{comment}{ /// of the Lagrangian coordinates along the GeomObject. }
\textcolor{comment}{} FishDomain(GeomObject* back\_pt, 
            \textcolor{keyword}{const} \textcolor{keywordtype}{double}& xi\_nose,  
            \textcolor{keyword}{const} \textcolor{keywordtype}{double}& xi\_tail) :  
  Xi\_nose(xi\_nose),  Xi\_tail(xi\_tail), Back\_pt(back\_pt)
  \{
   \textcolor{comment}{// Set values for private data members that are describe}
   \textcolor{comment}{// geometric features of the fish: x-coordinate of the fin,}
   \textcolor{comment}{// (half-)height of the fin, and x-position of the mouth.}
   X\_fin=1.7;
   Y\_fin=0.9;
   X\_mouth=0.0;

   \textcolor{comment}{// There are four macro elements}
   \textcolor{keywordtype}{unsigned} nmacro=4;
   Macro\_element\_pt.resize(nmacro); 

   \textcolor{comment}{// Build them}
   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} i=0;i<nmacro;i++)
    \{
     Macro\_element\_pt[i]= \textcolor{keyword}{new} QMacroElement<2>(\textcolor{keyword}{this},i);
    \}
  \} \textcolor{comment}{// end of constructor}

\end{DoxyCodeInclude}


Most of the remaining public member functions are equally straightforward\+: The destructor deletes the {\ttfamily Macro\+Elements},

 
\begin{DoxyCodeInclude}
 \textcolor{comment}{/// Destructor for FishDomain: Kill macro elements}
 \textcolor{keyword}{virtual} ~FishDomain()
 \{
  \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} i=0;i<4;i++) \textcolor{keyword}{delete} Macro\_element\_pt[i];
 \} 

\end{DoxyCodeInclude}


and we provide various access functions to the geometric parameters such as {\ttfamily X\+\_\+mouth}, etc -- we will not list these explicitly. All the \char`\"{}real work\char`\"{} is done in the implementation of the pure virtual function {\ttfamily Domain\+::macro\+\_\+element\+\_\+boundary}(...). Given
\begin{DoxyItemize}
\item the number of the {\ttfamily Macro\+Element} in its {\ttfamily Domain} 
\item the direction of its boundary (N\mbox{[}orth\mbox{]}, S\mbox{[}outh\mbox{]}, E\mbox{[}ast\mbox{]}, W\mbox{[}est\mbox{]}, enumerated in the namespace {\ttfamily Quad\+Tree\+Names})
\end{DoxyItemize}this function must compute the vector $ {\bf r}(\zeta)$ to the {\ttfamily Macro\+Element\textquotesingle{}s} boundary. Here $ \zeta \in [-1,1]$ is the 1D coordinate along the element boundary, aligned with the direction of the {\ttfamily Macro\+Element\textquotesingle{}s} 2D coordinates $(s_0,s_1) $ as indicated in this sketch\+:

 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{macro_element_sketch}
\doxyfigcaption{Sketch illustrating the parametrisation of the Macro\+Element\textquotesingle{}s four boundaries. }
\end{DoxyImage}


Since the shape of the domain can evolve in time, the full interface for the function includes an additional parameter, {\ttfamily t}, which indicates the (discrete) time level at which the domain shape is to be evaluated. If {\ttfamily t=0} the function computes the domain shape at the current time; if {\ttfamily t$>$0} it computes the shape at the {\ttfamily t} -\/th previous timestep. (\href{../../../unsteady_heat/two_d_unsteady_heat_ALE/html/index.html}{\tt Another example} in which we solve the unsteady heat equation in a moving domain, provides a a more detailed discussion of this aspect.) Here is the full interface for the {\ttfamily Fish\+Domain\+::macro\+\_\+element\+\_\+boundary}(...) function\+:


\begin{DoxyCodeInclude}
 \textcolor{comment}{/// \(\backslash\)short Vector representation of the  i\_macro-th macro element}
\textcolor{comment}{ /// boundary i\_direct (N/S/W/E) at the discrete time level t }
\textcolor{comment}{}\textcolor{comment}{ /// (t=0: present; t>0: previous): \(\backslash\)f$ \{\(\backslash\)bf r\}(\{\(\backslash\)bf zeta\}) \(\backslash\)f$}
\textcolor{comment}{}\textcolor{comment}{ /// Note that the local coordinate \(\backslash\)b zeta is a 1D}
\textcolor{comment}{}\textcolor{comment}{ /// Vector rather than a scalar -- this is unavoidable because}
\textcolor{comment}{}\textcolor{comment}{ /// this function implements the pure virtual function in the}
\textcolor{comment}{}\textcolor{comment}{ /// Domain base class.}
\textcolor{comment}{} \textcolor{keywordtype}{void} macro\_element\_boundary(\textcolor{keyword}{const} \textcolor{keywordtype}{unsigned}& t,
                             \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned}& i\_macro,
                             \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned}& i\_direct,
                             \textcolor{keyword}{const} Vector<double>& zeta,
                             Vector<double>& r);

\end{DoxyCodeInclude}


The implementation of this function is the only tedious task that needs to be performed by the \char`\"{}mesh writer\char`\"{}. Once {\ttfamily Domain\+::macro\+\_\+element\+\_\+boundary}(...) is implemented, the {\ttfamily Domain\textquotesingle{}s} constituent {\ttfamily Macro\+Elements} can refer to this function to establish the positions of their boundaries (recall that we passed the pointer to the {\ttfamily Domain} and the {\ttfamily Macro\+Element\textquotesingle{}s} number in the {\ttfamily Domain} to the {\ttfamily Macro\+Element} constructor). The {\ttfamily Macro\+Element\+::macro\+\_\+map}(...) functions interpolate the position of the {\ttfamily Macro\+Element\textquotesingle{}s} boundaries into their interior.

To illustrate the general procedure, here is the complete listing of the {\ttfamily Fish\+Domain\+::macro\+\_\+element\+\_\+boundary}(...) function. The function employs switch statements to identify the private member functions that provide the parametrisation of individual {\ttfamily Macro\+Element} boundaries. Some of these functions are listed below.

 
\begin{DoxyCodeInclude}
\textcolor{comment}{//==========start\_of\_macro\_element\_boundary========================}
\textcolor{comment}{/// \(\backslash\)short Vector representation of the  imacro-th macro element}
\textcolor{comment}{}\textcolor{comment}{/// boundary idirect (N/S/W/E) at time level t }
\textcolor{comment}{}\textcolor{comment}{/// (t=0: present; t>0: previous): \(\backslash\)f$ \{\(\backslash\)bf r\}(\{\(\backslash\)bf zeta\}) \(\backslash\)f$}
\textcolor{comment}{}\textcolor{comment}{/// Note that the local coordinate \(\backslash\)b zeta is a 1D}
\textcolor{comment}{}\textcolor{comment}{/// Vector rather than a scalar -- this is unavoidable because}
\textcolor{comment}{}\textcolor{comment}{/// this function implements the pure virtual function in the}
\textcolor{comment}{}\textcolor{comment}{/// Domain base class.}
\textcolor{comment}{}\textcolor{comment}{//=================================================================}
\textcolor{keywordtype}{void} FishDomain::macro\_element\_boundary(\textcolor{keyword}{const} \textcolor{keywordtype}{unsigned}& t,
                                        \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned}& imacro,
                                        \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned}& idirect,
                                        \textcolor{keyword}{const} Vector<double>& zeta,
                                        Vector<double>& r)
\{
 
 \textcolor{keyword}{using namespace }QuadTreeNames;


\textcolor{preprocessor}{#ifdef WARN\_ABOUT\_SUBTLY\_CHANGED\_OOMPH\_INTERFACES}
   \textcolor{comment}{// Warn about time argument being moved to the front}
   OomphLibWarning(
    \textcolor{stringliteral}{"Order of function arguments has changed between versions 0.8 and 0.85"},
    \textcolor{stringliteral}{"FishDomain::macro\_element\_boundary(...)"},
    OOMPH\_EXCEPTION\_LOCATION);
\textcolor{preprocessor}{#endif}


 \textcolor{comment}{// Which macro element?}
 \textcolor{comment}{// --------------------}
 \textcolor{keywordflow}{switch}(imacro)
  \{
   
   \textcolor{comment}{// Macro element 0: Lower body}
  \textcolor{keywordflow}{case} 0:
   
   \textcolor{comment}{// Which direction?}
   \textcolor{keywordflow}{if} (idirect==N)
    \{
     FishDomain::r\_lower\_body\_N(t,zeta,r);
    \}
   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (idirect==S)
    \{
     FishDomain::r\_lower\_body\_S(t,zeta,r);
    \}
   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (idirect==W)
    \{
     FishDomain::r\_lower\_body\_W(t,zeta,r);
    \}
   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (idirect==E)
    \{
     FishDomain::r\_lower\_body\_E(t,zeta,r);
    \}
   \textcolor{keywordflow}{else}
    \{
     std::ostringstream error\_stream;
     error\_stream << \textcolor{stringliteral}{"idirect is "} << idirect 
                  << \textcolor{stringliteral}{" not one of N, S, E, W"} <<  std::endl;
     
     \textcolor{keywordflow}{throw} OomphLibError(
      error\_stream.str(),
      OOMPH\_CURRENT\_FUNCTION,
      OOMPH\_EXCEPTION\_LOCATION);
    \}
   
   \textcolor{keywordflow}{break};

   \textcolor{comment}{// Macro element 1: Lower Fin}
  \textcolor{keywordflow}{case} 1:
   
   \textcolor{comment}{// Which direction?}
   \textcolor{keywordflow}{if} (idirect==N)
    \{
     FishDomain::r\_lower\_fin\_N(t,zeta,r);
    \}
   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (idirect==S)
    \{
     FishDomain::r\_lower\_fin\_S(t,zeta,r);
    \}
   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (idirect==W)
    \{
     FishDomain::r\_lower\_fin\_W(t,zeta,r);
    \}
   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (idirect==E)
    \{
     FishDomain::r\_lower\_fin\_E(t,zeta,r);
    \}
   \textcolor{keywordflow}{else}
    \{
     std::ostringstream error\_stream;
     error\_stream << \textcolor{stringliteral}{"idirect is "} << idirect 
                  << \textcolor{stringliteral}{" not one of N, S, E, W"} <<  std::endl;

     \textcolor{keywordflow}{throw} OomphLibError(
      error\_stream.str(),
      OOMPH\_CURRENT\_FUNCTION,
      OOMPH\_EXCEPTION\_LOCATION);
    \}
   
   \textcolor{keywordflow}{break};   
   

   \textcolor{comment}{// Macro element 2: Upper body}
  \textcolor{keywordflow}{case} 2:
   
   \textcolor{comment}{// Which direction?}
   \textcolor{keywordflow}{if} (idirect==N)
    \{
     FishDomain::r\_upper\_body\_N(t,zeta,r);
    \}
   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (idirect==S)
    \{
     FishDomain::r\_upper\_body\_S(t,zeta,r);
    \}
   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (idirect==W)
    \{
     FishDomain::r\_upper\_body\_W(t,zeta,r);
    \}
   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (idirect==E)
    \{
     FishDomain::r\_upper\_body\_E(t,zeta,r);
    \}
   \textcolor{keywordflow}{else}
    \{
     std::ostringstream error\_stream;
     error\_stream << \textcolor{stringliteral}{"idirect is "} << idirect 
                  << \textcolor{stringliteral}{" not one of N, S, E, W"} <<  std::endl;

     \textcolor{keywordflow}{throw} OomphLibError(
      error\_stream.str(),
      OOMPH\_CURRENT\_FUNCTION,
      OOMPH\_EXCEPTION\_LOCATION);
    \}
   
   \textcolor{keywordflow}{break};


   \textcolor{comment}{// Macro element 3: Upper Fin}
  \textcolor{keywordflow}{case} 3:
   
   \textcolor{comment}{// Which direction?}
   \textcolor{keywordflow}{if} (idirect==N)
    \{
     FishDomain::r\_upper\_fin\_N(t,zeta,r);
    \}
   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (idirect==S)
    \{
     FishDomain::r\_upper\_fin\_S(t,zeta,r);
    \}
   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (idirect==W)
    \{
     FishDomain::r\_upper\_fin\_W(t,zeta,r);
    \}
   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (idirect==E)
    \{
     FishDomain::r\_upper\_fin\_E(t,zeta,r);
    \}
   \textcolor{keywordflow}{else}
    \{
     std::ostringstream error\_stream;
     error\_stream << \textcolor{stringliteral}{"idirect is "} << idirect 
                  << \textcolor{stringliteral}{" not one of N, S, E, W"} <<  std::endl;

     \textcolor{keywordflow}{throw} OomphLibError(
      error\_stream.str(),
      OOMPH\_CURRENT\_FUNCTION,
      OOMPH\_EXCEPTION\_LOCATION);
    \}
   
   \textcolor{keywordflow}{break};   

  \textcolor{keywordflow}{default}:
   
   \textcolor{comment}{// Error}
   std::ostringstream error\_stream;
   error\_stream << \textcolor{stringliteral}{"Wrong imacro "} << imacro << std::endl;

   \textcolor{keywordflow}{throw} OomphLibError(
    error\_stream.str(),
    OOMPH\_CURRENT\_FUNCTION,
    OOMPH\_EXCEPTION\_LOCATION);
  \}
 
\} \textcolor{comment}{// end of macro\_element\_boundary}

\end{DoxyCodeInclude}


Here are a few of the private member functions that define individual {\ttfamily Macro\+Element} boundaries\+:


\begin{DoxyItemize}
\item The N\mbox{[}orthern\mbox{]} boundary of macro element 2 (which represents the upper body) coincides with the domain boundary that is parametrised by the geometric object pointed to by {\ttfamily Back\+\_\+pt}. The function translates the coordinate $ \zeta \in [-1,1] $ to the Lagrangian coordinate $ \xi \in [\xi_{nose}, \xi_{tail}] $ along the geometric object. We use this Lagrangian coordinate to obtain the position vector to the domain boundary via a call to the {\ttfamily Geom\+Object\+::position}(...) function of the geometric object pointed to by {\ttfamily Back\+\_\+pt\+:}  
\begin{DoxyCodeInclude}
\textcolor{comment}{//===============start\_of\_r\_upper\_body\_N==============================}
\textcolor{comment}{/// Northern edge of upper body macro element; \(\backslash\)f$ \(\backslash\)zeta \(\backslash\)in [-1,1] \(\backslash\)f$}
\textcolor{comment}{}\textcolor{comment}{//=====================================================================}
\textcolor{keywordtype}{void} FishDomain::r\_upper\_body\_N(\textcolor{keyword}{const} \textcolor{keywordtype}{unsigned}& t, 
                                \textcolor{keyword}{const} Vector<double>& zeta,
                                Vector<double>& r)
\{                                   
 \textcolor{comment}{// Lagrangian coordinate along curved "back"}
 Vector<double> x(1);
 x[0]=Xi\_nose+(Xi\_tail-Xi\_nose)*0.5*(zeta[0]+1.0);

 \textcolor{comment}{// Get position on curved back}
 Back\_pt->position(t,x,r);

\}  \textcolor{comment}{// end of r\_upper\_body\_N                                       }

\end{DoxyCodeInclude}

\item The E\mbox{[}astern\mbox{]} boundary of macro element 2 is a straight vertical line from the \char`\"{}tail end\char`\"{} of the curved fish back to the x-\/axis\+:  
\begin{DoxyCodeInclude}
\textcolor{comment}{//================start\_of\_r\_upper\_body\_E=============================}
\textcolor{comment}{/// Eastern edge of upper body macro element; \(\backslash\)f$ \(\backslash\)zeta \(\backslash\)in [-1,1] \(\backslash\)f$}
\textcolor{comment}{}\textcolor{comment}{//=====================================================================}
\textcolor{keywordtype}{void} FishDomain::r\_upper\_body\_E(\textcolor{keyword}{const} \textcolor{keywordtype}{unsigned}& t, 
                                \textcolor{keyword}{const} Vector<double>& zeta,
                                Vector<double>& r)
\{                                   

 \textcolor{comment}{// Top right corner (tail end) of body}
 Vector<double> r\_top(2);
 Vector<double> x(1);
 x[0]=Xi\_tail;
 Back\_pt->position(t,x,r\_top);

 \textcolor{comment}{// Corresponding point on the x-axis}
 Vector<double> r\_back(2);
 r\_back[0]=r\_top[0];
 r\_back[1]=0.0;

 r[0]=r\_back[0]+(r\_top[0]-r\_back[0])*0.5*(zeta[0]+1.0);
 r[1]=r\_back[1]+(r\_top[1]-r\_back[1])*0.5*(zeta[0]+1.0);

 
\} \textcolor{comment}{// end of r\_upper\_body\_E}

\end{DoxyCodeInclude}

\item The S\mbox{[}outhern\mbox{]} boundary of macro element 2 is a straight horizontal line from the \char`\"{}mouth\char`\"{} to the end of the body\+:  
\begin{DoxyCodeInclude}
\textcolor{comment}{//==================start\_of\_r\_upper\_body\_S============================}
\textcolor{comment}{/// Southern edge of upper body macro element; \(\backslash\)f$ \(\backslash\)zeta \(\backslash\)in [-1,1] \(\backslash\)f$}
\textcolor{comment}{}\textcolor{comment}{//=====================================================================}
\textcolor{keywordtype}{void} FishDomain::r\_upper\_body\_S(\textcolor{keyword}{const} \textcolor{keywordtype}{unsigned}& t, 
                                \textcolor{keyword}{const} Vector<double>& zeta,
                                Vector<double>& r)
\{                                   

 \textcolor{comment}{// Top right (tail) corner of fish body}
 Vector<double> r\_top(2);
 Vector<double> x(1);
 x[0]=Xi\_tail;
 Back\_pt->position(t,x,r\_top);

 \textcolor{comment}{// Straight line from mouth to start of fin (=end of body)}
 r[0]=X\_mouth+(r\_top[0]-X\_mouth)*0.5*(zeta[0]+1.0);
 r[1]=0.0;

\} \textcolor{comment}{// end of r\_upper\_body\_S                                          }

\end{DoxyCodeInclude}

\item The W\mbox{[}estern\mbox{]} boundary of macro element 2 is a straight line from the \char`\"{}mouth\char`\"{} to the \char`\"{}mouth\char`\"{} end of the curved upper boundary of the body\+:  
\begin{DoxyCodeInclude}
\textcolor{comment}{//===============start\_of\_r\_upper\_body\_W==============================}
\textcolor{comment}{/// Western edge of upper body macro element; \(\backslash\)f$ \(\backslash\)zeta \(\backslash\)in [-1,1] \(\backslash\)f$}
\textcolor{comment}{}\textcolor{comment}{//====================================================================}
\textcolor{keywordtype}{void} FishDomain::r\_upper\_body\_W(\textcolor{keyword}{const} \textcolor{keywordtype}{unsigned}& t, 
                                \textcolor{keyword}{const} Vector<double>& zeta,
                                Vector<double>& r)
\{                                   
 \textcolor{comment}{// Top left (mouth) corner of curved boundary of upper body}
 Vector<double> r\_top(2);
 Vector<double> x(1);
 x[0]=Xi\_nose;
 Back\_pt->position(t,x,r\_top);

 \textcolor{comment}{// The "mouth"}
 Vector<double> r\_mouth(2);
 r\_mouth[0]=X\_mouth;
 r\_mouth[1]=0.0;

 \textcolor{comment}{// Straight line from mouth to leftmost corner on curved boundary}
 \textcolor{comment}{// of upper body}
 r[0]=r\_mouth[0]+(r\_top[0]-r\_mouth[0])*0.5*(zeta[0]+1.0);
 r[1]=r\_mouth[1]+(r\_top[1]-r\_mouth[1])*0.5*(zeta[0]+1.0);

\}  \textcolor{comment}{// end of r\_upper\_body\_W                                   }

\end{DoxyCodeInclude}

\item The S\mbox{[}outhern\mbox{]} boundary of macro element 0 (which represents the lower body) is simply a reflection of the N\mbox{[}orthern\mbox{]} boundary of macro element 2\+:  
\begin{DoxyCodeInclude}
 \textcolor{comment}{///\(\backslash\)short Southern boundary of lower body macro element zeta \(\backslash\)f$\(\backslash\)in [-1,1] \(\backslash\)f$}
 \textcolor{keywordtype}{void} r\_lower\_body\_S(\textcolor{keyword}{const} \textcolor{keywordtype}{unsigned}& t, \textcolor{keyword}{const} Vector<double>& zeta, 
                     Vector<double>& f)
  \{
   \textcolor{comment}{// South of lower body is element is north of upper one.}
   \textcolor{comment}{// Direction of the coordinate stays the same.}
   r\_upper\_body\_N(t,zeta,f);
   \textcolor{comment}{// Reflect vertical position}
   f[1]=-f[1];
  \}

\end{DoxyCodeInclude}

\item etc.
\end{DoxyItemize}

Tedious? Yes! Rocket Science? No!



 

\hypertarget{index_com}{}\section{Further comments}\label{index_com}
\hypertarget{index_nod_update}{}\subsection{Node updates in response to changes in the Domain shape.}\label{index_nod_update}
You may have noticed that, even though we introduced {\ttfamily Macro\+Elements} in the context of adaptive mesh refinement, the pointer to a refineable element\textquotesingle{}s {\ttfamily Macro\+Element} is stored in the {\ttfamily Finite\+Element}, rather than the (derived) {\ttfamily Refineable\+Element} class, suggesting that {\ttfamily Macro\+Elements} have additional uses outside the context of mesh adaptation. Indeed, the code fragment that illustrated the use of {\ttfamily Domains} and {\ttfamily Macro\+Elements} during mesh generation, was taken from the constructor of the {\itshape non-\/refineable} {\ttfamily Fish\+Mesh}, rather than its adaptive counterpart. During the mesh generation process, the {\ttfamily Finite\+Element\textquotesingle{}s} {\ttfamily Macro\+Element} representation was used to determine the position of its {\ttfamily Nodes} within the {\ttfamily Domain}. The same procedure can be employed to {\itshape update} the nodal positions in response to changes in the domain shape. This is implemented, generically, in the function


\begin{DoxyCode}
Mesh::node\_update()
\end{DoxyCode}


This function loops over all elements in a {\ttfamily Mesh} and updates their nodal positions in response to changes in the domain boundary. (If the {\ttfamily Mesh\textquotesingle{}s} constituent elements\textquotesingle{}s are not associated with {\ttfamily Macro\+Elements} and if the {\ttfamily Mesh} does not implement the node update by other means, this function does not change the mesh.)

The following code fragment illustrates the trivial modifications to the driver code required to compute the solution of Poisson\textquotesingle{}s equation in fish-\/shaped domain of various widths. We simply change the position of the {\ttfamily Geom\+Object} that specifies the curvilinear boundary (by changing the position of the circle\textquotesingle{}s centre), call the {\ttfamily Mesh\+::node\+\_\+update()} function, and recompute the solution.

 
\begin{DoxyCodeInclude}
\textcolor{comment}{//=================start\_of\_main==========================================}
\textcolor{comment}{/// Demonstrate how to solve 2D Poisson problem in }
\textcolor{comment}{}\textcolor{comment}{/// fish-shaped domain with black-box mesh adaptation}
\textcolor{comment}{}\textcolor{comment}{/// and domain updates in response to changes in the domain}
\textcolor{comment}{}\textcolor{comment}{/// shape.}
\textcolor{comment}{}\textcolor{comment}{//========================================================================}
\textcolor{keywordtype}{int} \hyperlink{fish__domain_8cc_ae66f6b31b5ad750f1fe042a706a4e3d4}{main}()
\{

 \textcolor{comment}{//Set up the problem with 9 node refineable Poisson elements}
 \hyperlink{classRefineableFishPoissonProblem}{RefineableFishPoissonProblem<RefineableQPoissonElement<2,3>}
       > problem;
 
 \textcolor{comment}{// Setup labels for output}
 \textcolor{comment}{//------------------------}
 DocInfo doc\_info;
 
 \textcolor{comment}{// Set output directory}
 doc\_info.set\_directory(\textcolor{stringliteral}{"RESLT"}); 
 
 \textcolor{comment}{// Adjust the domain shape by changing the width of the fish}
 \textcolor{comment}{//----------------------------------------------------------}
 \textcolor{keywordtype}{unsigned} nstep=3;
 \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} i=0;i<nstep;i++)
  \{
   \textcolor{comment}{// Get pointer to GeomObject that defines the position of the}
   \textcolor{comment}{// fish's back:}
   GeomObject* fish\_back\_pt=problem.\hyperlink{classRefineableFishPoissonProblem_a803c9050b07b35aba22f08a5a9e59f2c}{mesh\_pt}()->fish\_back\_pt();

   \textcolor{comment}{// Recast to pointer to Circle object to get access to the member function}
   \textcolor{comment}{// that sets the y-position of the Circle's centre and decrease its}
   \textcolor{comment}{// value, making the fish narrower}
   \textcolor{keyword}{dynamic\_cast<}Circle*\textcolor{keyword}{>}(fish\_back\_pt)->y\_c()-=0.1;
   
   \textcolor{comment}{// Update the domain shape in response to the changes in its}
   \textcolor{comment}{// boundary}
   problem.\hyperlink{classRefineableFishPoissonProblem_a803c9050b07b35aba22f08a5a9e59f2c}{mesh\_pt}()->node\_update();

   \textcolor{comment}{// Solve the problem, allowing for up to two levels of refinement}
   problem.newton\_solve(2);
   
   \textcolor{comment}{//Output solution}
   problem.\hyperlink{classRefineableFishPoissonProblem_aeee1bf23216971b50b8822c45e62c48b}{doc\_solution}(doc\_info);
   
   \textcolor{comment}{//Increment counter for solutions }
   doc\_info.number()++;
  \}
 
\} \textcolor{comment}{// end of main}

\end{DoxyCodeInclude}


The \href{../../../../demo_drivers/poisson/fish_poisson2/fish_poisson_node_update.cc}{\tt rest of the code} remains unchanged. Here is a plot of the solution for various widths of the domain (computed with nine-\/node elements).

 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{fish_poisson_node_update}
\doxyfigcaption{Adaptive solution of Poisson\textquotesingle{}s equation in fish-\/shaped domains of varying width. }
\end{DoxyImage}




 

\hypertarget{index_boundary_coords}{}\subsection{Good practice\+: Storing boundary coordinates}\label{index_boundary_coords}
The above example demonstrated how the representation of curvilinear domain boundaries by {\ttfamily Geom\+Objects} allows {\ttfamily oomph-\/lib\textquotesingle{}s} mesh generation and adaptation procedures to place nodes on these boundaries. We note that the Lagrangian coordinate(s) that parametrise(s) the relevant {\ttfamily Geom\+Objects} also provide a parametrisation of the corresponding domain boundaries. In certain applications (such as free-\/boundary or fluid-\/structure interaction problems) it is useful to have direct access to these boundary coordinates. For this purpose the {\ttfamily Node} class provides the function 
\begin{DoxyCode}
Node::set\_coordinates\_on\_boundary(\textcolor{keyword}{const} \textcolor{keywordtype}{unsigned}& b, 
                                  \textcolor{keyword}{const} Vector<double>& xi);
\end{DoxyCode}
 which allows the mesh writer to store the (vector of) boundary coordinates that a given ({\ttfamily Boundary}){\ttfamily Node} is located at. The argument {\ttfamily b} specifies the number of the mesh boundary, reflecting the fact that nodes may be located on multiple domain boundaries, each of which is likely to have a different set of surface coordinates. \mbox{[}{\bfseries Note\+:} The function is implemented as a broken virtual function in the {\ttfamily Node} base class. The actual functionality to store boundary coordinates is only provided in (and required by) the derived {\ttfamily Boundary\+Node} class.\mbox{]}

Since the storage of boundary coordinates is optional, the {\ttfamily Mesh} base class provides a protected vector of bools, 
\begin{DoxyCode}
std::vector<bool> Mesh::Boundary\_coordinate\_exists;
\end{DoxyCode}
 that indicates if the boundary coordinates have been stored for all {\ttfamily Nodes} on a specific mesh boundary. This vector is resized and its entries are initialised to {\ttfamily false}, when the number of mesh boundaries is declared with a call to {\ttfamily Mesh\+::set\+\_\+nboundary}(...). If, during mesh refinement, a new {\ttfamily Boundary\+Node} is created on the mesh\textquotesingle{}s boundary {\ttfamily b}, its boundary coordinates are computed by interpolation from the corresponding values at the nodes in the father element, if {\ttfamily Mesh\+::\+Boundary\+\_\+coordinate\+\_\+exists}\mbox{[}b\mbox{]} has been set to {\ttfamily true}.

We regard it as good practice to set boundary coordinates for all {\ttfamily Boundary\+Nodes} that are located on curvlinear mesh boundaries. The source code \href{../../../../src/meshes/fish_mesh.template.cc}{\tt fish\+\_\+mesh.\+template.\+cc} for the refineable Fish\+Mesh illustrates the methodology.



 

\hypertarget{index_sources}{}\section{Source files for this tutorial}\label{index_sources}

\begin{DoxyItemize}
\item The source files for this tutorial are located in the directory\+: \begin{center} \href{../../../../demo_drivers/poisson/fish_poisson2/}{\tt demo\+\_\+drivers/poisson/fish\+\_\+poisson2/ } \end{center} 
\item The driver code is\+: \begin{center} \href{../../../../demo_drivers/poisson/fish_poisson2/fish_poisson_adapt.cc}{\tt demo\+\_\+drivers/poisson/fish\+\_\+poisson2/fish\+\_\+poisson\+\_\+adapt.\+cc } \end{center} 
\end{DoxyItemize}

 

 \hypertarget{index_pdf}{}\section{P\+D\+F file}\label{index_pdf}
A \href{../latex/refman.pdf}{\tt pdf version} of this document is available. \end{document}
