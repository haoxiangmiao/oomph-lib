Following the numerous 2D problems discussed in earlier examples we now demonstrate that the solution of 3D problems is just as easy. For this purpose we discuss the adaptive solution of the 3D Poisson problem \begin{center} \tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*{1}{|X[-1]}|}
\hline
\begin{center} {\bfseries Three-\/dimensional model Poisson problem} \end{center}  Solve \[ \sum_{i=1}^3 \frac{\partial^2u}{\partial x_i^2} = f(x_1,x_2,x_3), \ \ \ \ \ \ \ \ \ \ (1) \] in the \char`\"{}eighth-\/of-\/a-\/sphere\char`\"{} domain $D$, with Dirichlet boundary conditions \[ \left. u\right|_{\partial D}=u_0 \ \ \ \ \ \ \ \ \ \ (2) \] where the function $ u_0 $ is given.   \\\cline{1-1}
\end{longtabu}
\end{center} 

We choose a source function and boundary conditions for which \[ u_0(x_1,x_2,x_3) = \tanh\left(1-\alpha(({\bf x}-{\bf x_0}) \cdot {\bf N})\right), \ \ \ \ \ \ \ \ \ (3) \] is the exact solution. Here where ${\bf x} = (x_1,x_2,x_3)$ is the vector of the spatial coordinates, and the vectors ${\bf x}_0 = \left(x_1^{(0)},x_2^{(0)},x_3^{(0)}\right)$ and ${\bf N}_0 = (N_1,N_2,N_3)$ are constants. For large values of the constant $ \alpha $ the solution varies rapidly across the plane through ${\bf x}_0$ whose normal is given by ${\bf N}$.

Here are some plots of the exact and computed solutions for ${\bf x}_0 = (0,0,0)$, ${\bf N}_0 = 1/\sqrt{3} \ (-1,-1,1)$, and $ \alpha=50$ at various levels of mesh refinement. Note that the plot of the exact solution was produced by setting the nodal values to the exact solution, obtained by evaluating (3) at the nodal positions. The elements\textquotesingle{} basis functions were then used to interpolate between the nodal values. On the coarse meshes, the interpolation between the \char`\"{}exact\char`\"{} nodal values is clearly inadequate to resolve the rapid variation of the solution.

 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{eight_sphere_poisson}
\doxyfigcaption{Plot of the solution }
\end{DoxyImage}




 

\hypertarget{index_global}{}\section{Global parameters and functions}\label{index_global}
Following our usual practice, we use a namespace, {\ttfamily \hyperlink{namespaceTanhSolnForPoisson}{Tanh\+Soln\+For\+Poisson}}, to define the source function, the exact solution and various problem parameters.

 
\begin{DoxyCodeInclude}
\textcolor{comment}{//=============start\_of\_namespace=====================================}
\textcolor{comment}{/// Namespace for exact solution for Poisson equation with sharp step }
\textcolor{comment}{}\textcolor{comment}{//====================================================================}
\textcolor{keyword}{namespace }\hyperlink{namespaceTanhSolnForPoisson}{TanhSolnForPoisson}
\{
\textcolor{comment}{}
\textcolor{comment}{ /// Parameter for steepness of step}
\textcolor{comment}{} \textcolor{keywordtype}{double} Alpha=1;
\textcolor{comment}{}
\textcolor{comment}{ ///\(\backslash\)short Orientation (non-normalised x-component of unit vector in direction}
\textcolor{comment}{ /// of step plane)}
\textcolor{comment}{} \textcolor{keywordtype}{double} N\_x=-1.0;
\textcolor{comment}{}
\textcolor{comment}{ ///\(\backslash\)short Orientation (non-normalised y-component of unit vector in direction}
\textcolor{comment}{ /// of step plane)}
\textcolor{comment}{} \textcolor{keywordtype}{double} N\_y=-1.0;
\textcolor{comment}{}
\textcolor{comment}{ ///\(\backslash\)short Orientation (non-normalised z-component of unit vector in direction}
\textcolor{comment}{ /// of step plane)}
\textcolor{comment}{} \textcolor{keywordtype}{double} N\_z=1.0;

\textcolor{comment}{}
\textcolor{comment}{ ///\(\backslash\)short Orientation (x-coordinate of step plane) }
\textcolor{comment}{} \textcolor{keywordtype}{double} X\_0=0.0;
\textcolor{comment}{}
\textcolor{comment}{ ///\(\backslash\)short Orientation (y-coordinate of step plane) }
\textcolor{comment}{} \textcolor{keywordtype}{double} Y\_0=0.0;
\textcolor{comment}{}
\textcolor{comment}{ ///\(\backslash\)short Orientation (z-coordinate of step plane) }
\textcolor{comment}{} \textcolor{keywordtype}{double} Z\_0=0.0;


 \textcolor{comment}{// Exact solution as a Vector}
 \textcolor{keywordtype}{void} \hyperlink{namespaceTanhSolnForPoisson_af7896e9c18ce6438c73ae2a875e8b7de}{get\_exact\_u}(\textcolor{keyword}{const} Vector<double>& x, Vector<double>& u)
 \{
  u[0] = tanh(Alpha*((x[0]-X\_0)*N\_x/sqrt(N\_x*N\_x+N\_y*N\_y+N\_z*N\_z)+(x[1]-Y\_0)*
                     N\_y/sqrt(N\_x*N\_x+N\_y*N\_y+N\_z*N\_z)+(x[2]-Z\_0)*
                     N\_z/sqrt(N\_x*N\_x+N\_y*N\_y+N\_z*N\_z)));
 \}
\textcolor{comment}{}
\textcolor{comment}{ /// Exact solution as a scalar}
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{namespaceTanhSolnForPoisson_af7896e9c18ce6438c73ae2a875e8b7de}{get\_exact\_u}(\textcolor{keyword}{const} Vector<double>& x, \textcolor{keywordtype}{double}& u)
 \{
  u = tanh(Alpha*((x[0]-X\_0)*N\_x/sqrt(N\_x*N\_x+N\_y*N\_y+N\_z*N\_z)+(x[1]-Y\_0)*
                     N\_y/sqrt(N\_x*N\_x+N\_y*N\_y+N\_z*N\_z)+(x[2]-Z\_0)*
                     N\_z/sqrt(N\_x*N\_x+N\_y*N\_y+N\_z*N\_z)));
 \}

\textcolor{comment}{}
\textcolor{comment}{ /// Source function to make it an exact solution }
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{namespaceTanhSolnForPoisson_ae1b9d6789ff301e3d63a4e292213036c}{get\_source}(\textcolor{keyword}{const} Vector<double>& x, \textcolor{keywordtype}{double}& source)
 \{

  \textcolor{keywordtype}{double} s1,s2,s3,s4;

  s1 = -2.0*tanh(Alpha*((x[0]-X\_0)*N\_x/sqrt(N\_x*N\_x+N\_y*N\_y+N\_z*N\_z)+(x[1]-
Y\_0)*N\_y/sqrt(N\_x*N\_x+N\_y*N\_y+N\_z*N\_z)+(x[2]-Z\_0)*N\_z/sqrt(N\_x*N\_x+N\_y*N\_y+N\_z*
N\_z)))*(1.0-pow(tanh(Alpha*((x[0]-X\_0)*N\_x/sqrt(N\_x*N\_x+N\_y*N\_y+N\_z*N\_z)+(x[1]-
Y\_0)*N\_y/sqrt(N\_x*N\_x+N\_y*N\_y+N\_z*N\_z)+(x[2]-Z\_0)*N\_z/sqrt(N\_x*N\_x+N\_y*N\_y+N\_z*
N\_z))),2.0))*Alpha*Alpha*N\_x*N\_x/(N\_x*N\_x+N\_y*N\_y+N\_z*N\_z);
      s3 = -2.0*tanh(Alpha*((x[0]-X\_0)*N\_x/sqrt(N\_x*N\_x+N\_y*N\_y+N\_z*N\_z)+(x[1]-
Y\_0)*N\_y/sqrt(N\_x*N\_x+N\_y*N\_y+N\_z*N\_z)+(x[2]-Z\_0)*N\_z/sqrt(N\_x*N\_x+N\_y*N\_y+N\_z*
N\_z)))*(1.0-pow(tanh(Alpha*((x[0]-X\_0)*N\_x/sqrt(N\_x*N\_x+N\_y*N\_y+N\_z*N\_z)+(x[1]-
Y\_0)*N\_y/sqrt(N\_x*N\_x+N\_y*N\_y+N\_z*N\_z)+(x[2]-Z\_0)*N\_z/sqrt(N\_x*N\_x+N\_y*N\_y+N\_z*
N\_z))),2.0))*Alpha*Alpha*N\_y*N\_y/(N\_x*N\_x+N\_y*N\_y+N\_z*N\_z);
      s4 = -2.0*tanh(Alpha*((x[0]-X\_0)*N\_x/sqrt(N\_x*N\_x+N\_y*N\_y+N\_z*N\_z)+(x[1]-
Y\_0)*N\_y/sqrt(N\_x*N\_x+N\_y*N\_y+N\_z*N\_z)+(x[2]-Z\_0)*N\_z/sqrt(N\_x*N\_x+N\_y*N\_y+N\_z*
N\_z)))*(1.0-pow(tanh(Alpha*((x[0]-X\_0)*N\_x/sqrt(N\_x*N\_x+N\_y*N\_y+N\_z*N\_z)+(x[1]-
Y\_0)*N\_y/sqrt(N\_x*N\_x+N\_y*N\_y+N\_z*N\_z)+(x[2]-Z\_0)*N\_z/sqrt(N\_x*N\_x+N\_y*N\_y+N\_z*
N\_z))),2.0))*Alpha*Alpha*N\_z*N\_z/(N\_x*N\_x+N\_y*N\_y+N\_z*N\_z);
      s2 = s3+s4;
      source = s1+s2;
 \}


\} \textcolor{comment}{// end of namespace}

\end{DoxyCodeInclude}




 

\hypertarget{index_main}{}\section{The driver code}\label{index_main}
The driver code solves the 3D Poisson problem with full spatial adaptivity -- a fairly time-\/consuming process. To minimise the run-\/times when the code is executed during {\ttfamily oomph-\/lib\textquotesingle{}s} self-\/tests, we use command line arguments to optionally limit the number of adaptive refinements. If the code is run with a(ny) command line arguments, only a single adaptive refinement is performed; otherwise up to four levels of refinement are permitted. {\ttfamily oomph-\/lib} provides storage for the command line arguments in the namespace {\ttfamily Command\+Line\+Args} to make them accessible to other parts of the code.

Otherwise the driver code is very similar to that used in the \href{../../../poisson/fish_poisson/html/index.html}{\tt corresponding 2D Poisson problems}\+: We construct the problem, passing the pointer to the source function. Next, we create a {\ttfamily Doc\+Info} object to specify the output directory, and execute the global self-\/test to assert that the problem has been set up correctly. Next we solve the problem on the coarse initial mesh (comprising four 27-\/node brick elements) and then adapt the problem based on the elemental error estimates, until the maximum number of adaptations has been reached or until the adaptation ceases to changes the mesh.

 
\begin{DoxyCodeInclude}
\textcolor{comment}{//=========start\_of\_main=============================================}
\textcolor{comment}{/// Driver for 3D Poisson problem in eighth of a sphere. Solution }
\textcolor{comment}{}\textcolor{comment}{/// has a sharp step. If there are}
\textcolor{comment}{}\textcolor{comment}{/// any command line arguments, we regard this as a validation run}
\textcolor{comment}{}\textcolor{comment}{/// and perform only a single adaptation.}
\textcolor{comment}{}\textcolor{comment}{//===================================================================}
\textcolor{keywordtype}{int} \hyperlink{eighth__sphere__poisson_8cc_a0ddf1224851353fc92bfbff6f499fa97}{main}(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char} *argv[]) 
\{ 

 \textcolor{comment}{// Store command line arguments}
 CommandLineArgs::setup(argc,argv);

 \textcolor{comment}{// Set up the problem with 27-node brick elements, pass pointer to }
 \textcolor{comment}{// source function}
 \hyperlink{classEighthSpherePoissonProblem}{EighthSpherePoissonProblem<RefineableQPoissonElement<3,3>}
       >
  problem(&\hyperlink{namespaceTanhSolnForPoisson_ae1b9d6789ff301e3d63a4e292213036c}{TanhSolnForPoisson::get\_source});

 \textcolor{comment}{// Setup labels for output}
  DocInfo doc\_info;

 \textcolor{comment}{// Output directory}
 doc\_info.set\_directory(\textcolor{stringliteral}{"RESLT"});

 \textcolor{comment}{// Step number}
 doc\_info.number()=0;

 \textcolor{comment}{// Check if we're ready to go}
 cout << \textcolor{stringliteral}{"Self test: "} << problem.self\_test() << std::endl;
 
 \textcolor{comment}{// Solve the problem}
 problem.newton\_solve();
 
 \textcolor{comment}{//Output solution}
 problem.doc\_solution(doc\_info);

 \textcolor{comment}{//Increment counter for solutions }
 doc\_info.number()++;

 \textcolor{comment}{// Now do (up to) three rounds of fully automatic adapation in response to }
 \textcolor{comment}{// error estimate}
 \textcolor{keywordtype}{unsigned} max\_solve;
 \textcolor{keywordflow}{if} (CommandLineArgs::Argc>1)
  \{
   \textcolor{comment}{// Validation run: Just one adaptation}
   max\_solve=1;
   cout << \textcolor{stringliteral}{"Only doing one adaptation for validation"} << std::endl;
  \}
 \textcolor{keywordflow}{else}
  \{
   \textcolor{comment}{// Up to four adaptations}
   max\_solve=4;
  \}

 \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} isolve=0;isolve<max\_solve;isolve++)
  \{
   \textcolor{comment}{// Adapt problem/mesh}
   problem.adapt(); 
         
   \textcolor{comment}{// Re-solve the problem if the adaptation has changed anything}
   \textcolor{keywordflow}{if} ((problem.mesh\_pt()->nrefined()  !=0)||
       (problem.mesh\_pt()->nunrefined()!=0))
    \{
     problem.newton\_solve();
    \}
   \textcolor{keywordflow}{else}
    \{
     cout << \textcolor{stringliteral}{"Mesh wasn't adapted --> we'll stop here"} << std::endl;
     \textcolor{keywordflow}{break};
    \}
   
   \textcolor{comment}{//Output solution}
   problem.doc\_solution(doc\_info);
   
   \textcolor{comment}{//Increment counter for solutions }
   doc\_info.number()++;
  \}

\textcolor{comment}{// pause("done");}

\} \textcolor{comment}{// end of main}

\end{DoxyCodeInclude}




 

\hypertarget{index_problem}{}\section{The problem class}\label{index_problem}
The problem class has the usual structure -- the only difference to the corresponding 2D codes is that the assignment of the boundary conditions in {\ttfamily actions\+\_\+before\+\_\+newton\+\_\+solve()} now involves thee nodal coordinates rather than two.

 
\begin{DoxyCodeInclude}
\textcolor{comment}{//=======start\_of\_class\_definition====================================}
\textcolor{comment}{/// Poisson problem in refineable eighth of a sphere mesh.}
\textcolor{comment}{}\textcolor{comment}{//====================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT>
\textcolor{keyword}{class }\hyperlink{classEighthSpherePoissonProblem}{EighthSpherePoissonProblem} : \textcolor{keyword}{public} Problem
\{

\textcolor{keyword}{public}:
\textcolor{comment}{}
\textcolor{comment}{ /// Constructor: Pass pointer to source function}
\textcolor{comment}{} \hyperlink{classEighthSpherePoissonProblem_ae51db2c3e80f0d5628e4d81eb1c11db4}{EighthSpherePoissonProblem}(
  PoissonEquations<3>::PoissonSourceFctPt source\_fct\_pt);
\textcolor{comment}{}
\textcolor{comment}{ /// Destructor: Empty}
\textcolor{comment}{} \hyperlink{classEighthSpherePoissonProblem_a043c7aa08c939fdc019870ad2c2270cc}{~EighthSpherePoissonProblem}()\{\}
\textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Overload generic access function by one that returns}
\textcolor{comment}{ /// a pointer to the specific  mesh}
\textcolor{comment}{} RefineableEighthSphereMesh<ELEMENT>* \hyperlink{classEighthSpherePoissonProblem_aa33edbb75ba8fe8d4daac3c940a7ff6a}{mesh\_pt}() 
  \{
   \textcolor{keywordflow}{return} \textcolor{keyword}{dynamic\_cast<}RefineableEighthSphereMesh<ELEMENT>*\textcolor{keyword}{>}(Problem::mesh\_pt());
  \}
\textcolor{comment}{}
\textcolor{comment}{ /// Update the problem specs after solve (empty)}
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{classEighthSpherePoissonProblem_a480189fe5d2f42fe3ff6062d5f151ea3}{actions\_after\_newton\_solve}()  \{\}
\textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Update the problem specs before solve: }
\textcolor{comment}{ /// Set Dirchlet boundary conditions from exact solution.}
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{classEighthSpherePoissonProblem_af82dd7abdf631950a68c997af314be5d}{actions\_before\_newton\_solve}()
 \{
  \textcolor{comment}{//Loop over the boundaries}
  \textcolor{keywordtype}{unsigned} num\_bound = \hyperlink{classEighthSpherePoissonProblem_aa33edbb75ba8fe8d4daac3c940a7ff6a}{mesh\_pt}()->nboundary();
  \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} ibound=0;ibound<num\_bound;ibound++)
   \{
    \textcolor{comment}{// Loop over the nodes on boundary}
    \textcolor{keywordtype}{unsigned} num\_nod=\hyperlink{classEighthSpherePoissonProblem_aa33edbb75ba8fe8d4daac3c940a7ff6a}{mesh\_pt}()->nboundary\_node(ibound);
   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} inod=0;inod<num\_nod;inod++)
    \{
     Node* nod\_pt=\hyperlink{classEighthSpherePoissonProblem_aa33edbb75ba8fe8d4daac3c940a7ff6a}{mesh\_pt}()->boundary\_node\_pt(ibound,inod);
     \textcolor{keywordtype}{double} u;
     Vector<double> x(3);
     x[0]=nod\_pt->x(0);
     x[1]=nod\_pt->x(1);
     x[2]=nod\_pt->x(2);
     \hyperlink{namespaceTanhSolnForPoisson_af7896e9c18ce6438c73ae2a875e8b7de}{TanhSolnForPoisson::get\_exact\_u}(x,u);
     nod\_pt->set\_value(0,u);
    \}
   \}
 \}
 \textcolor{comment}{}
\textcolor{comment}{ /// Doc the solution}
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{classEighthSpherePoissonProblem_ac8e9911536d04bab829cfe92bb40e302}{doc\_solution}(DocInfo& doc\_info);

\textcolor{keyword}{private}:
\textcolor{comment}{}
\textcolor{comment}{ /// Pointer to source function}
\textcolor{comment}{} PoissonEquations<3>::PoissonSourceFctPt \hyperlink{classEighthSpherePoissonProblem_af41ed0ce372d5932c64b3cd4fe69f312}{Source\_fct\_pt};

\}; \textcolor{comment}{// end of class definition}

\end{DoxyCodeInclude}


\mbox{[}See the discussion of the \href{../../../poisson/one_d_poisson/html/index.html}{\tt 1D Poisson problem} for a more detailed discussion of the function type Poisson\+Equations$<$3$>$\+::\+Poisson\+Source\+Fct\+Pt.\mbox{]}



 

\hypertarget{index_constructor}{}\section{The Problem constructor}\label{index_constructor}
In the {\ttfamily Problem} constructor, we set the \char`\"{}steepness parameter\char`\"{} $ \alpha $ to a large value and create the mesh for a a sphere of radius 5. Next, we create the error estimator and pass it to the adaptive mesh.


\begin{DoxyCodeInclude}
\textcolor{comment}{//====================start\_of\_constructor================================}
\textcolor{comment}{/// Constructor for Poisson problem on eighth of a sphere mesh}
\textcolor{comment}{}\textcolor{comment}{//========================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT>
\hyperlink{classEighthSpherePoissonProblem_ae51db2c3e80f0d5628e4d81eb1c11db4}{EighthSpherePoissonProblem<ELEMENT>::EighthSpherePoissonProblem}
      (
   PoissonEquations<3>::PoissonSourceFctPt source\_fct\_pt) : 
         Source\_fct\_pt(source\_fct\_pt)
\{ 

 \textcolor{comment}{// Setup parameters for exact tanh solution}
 \textcolor{comment}{// Steepness of step}
 \hyperlink{namespaceTanhSolnForPoisson_ae676ccd186d5df119cce811596d949c1}{TanhSolnForPoisson::Alpha}=50.0;
\textcolor{comment}{}
\textcolor{comment}{ /// Create mesh for sphere of radius 5}
\textcolor{comment}{} \textcolor{keywordtype}{double} radius=5.0; 
 Problem::mesh\_pt() = \textcolor{keyword}{new} RefineableEighthSphereMesh<ELEMENT>(radius);

 \textcolor{comment}{// Set error estimator }
 Z2ErrorEstimator* error\_estimator\_pt=\textcolor{keyword}{new} Z2ErrorEstimator;
 mesh\_pt()->spatial\_error\_estimator\_pt()=error\_estimator\_pt;

\end{DoxyCodeInclude}


We adjust the targets for the mesh adaptation so that the single mesh adaptation performed during a validation run produces a non-\/uniform refinement pattern. (The error targets for this case were determined by trial and error.) The tighter error tolerances specified otherwise are appropriate to properly resolve the solution, as shown in the animated gif files at the beginning of this document. 
\begin{DoxyCodeInclude}
 \textcolor{comment}{// Adjust error targets for adaptive refinement}
 \textcolor{keywordflow}{if} (CommandLineArgs::Argc>1)
  \{
   \textcolor{comment}{// Validation: Relax tolerance to get nonuniform refinement during}
   \textcolor{comment}{// first step}
   mesh\_pt()->max\_permitted\_error()=0.7;
   mesh\_pt()->min\_permitted\_error()=0.5;
  \}
 \textcolor{keywordflow}{else}
  \{
   mesh\_pt()->max\_permitted\_error()=0.01;
   mesh\_pt()->min\_permitted\_error()=0.001;
  \} \textcolor{comment}{// end adjustment}

\end{DoxyCodeInclude}


Next, we assign the boundary conditions. In the present problem all boundaries are Dirichlet boundaries, therefore we loop over all nodes on all boundaries and pin their values. If only a subset of the mesh boundaries were of Dirichlet type, only the nodes on those boundaries would have to be pinned. \char`\"{}\+Usually\char`\"{} the numbering of the mesh boundaries is (or at least should be!) documented in the mesh constructor but it can also be obtained from the function {\ttfamily Mesh\+::output\+\_\+boundaries}(...) whose use is illustrated here.


\begin{DoxyCodeInclude}
 \textcolor{comment}{//Doc the mesh boundaries}
 ofstream some\_file;
 some\_file.open(\textcolor{stringliteral}{"boundaries.dat"});
 mesh\_pt()->output\_boundaries(some\_file);
 some\_file.close();

 \textcolor{comment}{// Set the boundary conditions for this problem: All nodes are}
 \textcolor{comment}{// free by default -- just pin the ones that have Dirichlet conditions}
 \textcolor{comment}{// here (all the nodes on the boundary)}
 \textcolor{keywordtype}{unsigned} num\_bound = mesh\_pt()->nboundary();
 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} ibound=0;ibound<num\_bound;ibound++)
  \{
   \textcolor{keywordtype}{unsigned} num\_nod= mesh\_pt()->nboundary\_node(ibound);
   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} inod=0;inod<num\_nod;inod++)
    \{
     mesh\_pt()->boundary\_node\_pt(ibound,inod)->pin(0); 
    \}
  \} \textcolor{comment}{// end of pinning}

\end{DoxyCodeInclude}


Finally we loop over all elements to assign the source function pointer, and then call the generic {\ttfamily Problem\+::assign\+\_\+eqn\+\_\+numbers()} routine to set up the equation numbers.


\begin{DoxyCodeInclude}
 \textcolor{comment}{//Find number of elements in mesh}
 \textcolor{keywordtype}{unsigned} n\_element = mesh\_pt()->nelement();

 \textcolor{comment}{// Loop over the elements to set up element-specific }
 \textcolor{comment}{// things that cannot be handled by constructor}
 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} i=0;i<n\_element;i++)
  \{
   \textcolor{comment}{// Upcast from FiniteElement to the present element}
   ELEMENT *el\_pt = \textcolor{keyword}{dynamic\_cast<}ELEMENT*\textcolor{keyword}{>}(mesh\_pt()->element\_pt(i));

   \textcolor{comment}{//Set the source function pointer}
   el\_pt->source\_fct\_pt() = Source\_fct\_pt;
  \}

 \textcolor{comment}{// Setup equation numbering }
 cout <<\textcolor{stringliteral}{"Number of equations: "} << assign\_eqn\_numbers() << std::endl; 

\} \textcolor{comment}{// end of constructor}

\end{DoxyCodeInclude}




 

\hypertarget{index_doc}{}\section{Post-\/processing}\label{index_doc}
The function {\ttfamily doc\+\_\+solution}(...) writes the FE solution and the corresponding exact solution, defined in {\ttfamily \hyperlink{namespaceTanhSolnForPoisson_af7896e9c18ce6438c73ae2a875e8b7de}{Tanh\+Soln\+For\+Poisson\+::get\+\_\+exact\+\_\+u}}(...) to disk. The {\ttfamily Doc\+Info} object specifies the output directory and the label for the file names. \mbox{[}See the discussion of the \href{../../../poisson/one_d_poisson/html/index.html}{\tt 1D Poisson problem} for a more detailed discussion of the generic {\ttfamily Mesh} member functions {\ttfamily Mesh\+::output}(...), {\ttfamily Mesh\+::output\+\_\+fct}(...) and {\ttfamily Mesh\+::compute\+\_\+error}(...)\mbox{]}.


\begin{DoxyCodeInclude}
\textcolor{comment}{//========================start\_of\_doc====================================}
\textcolor{comment}{/// Doc the solution}
\textcolor{comment}{}\textcolor{comment}{//========================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT>
\textcolor{keywordtype}{void} \hyperlink{classEighthSpherePoissonProblem_ac8e9911536d04bab829cfe92bb40e302}{EighthSpherePoissonProblem<ELEMENT>::doc\_solution}(
      DocInfo& doc\_info)
\{
 ofstream some\_file;
 \textcolor{keywordtype}{char} filename[100];

 \textcolor{comment}{// Number of plot points}
 \textcolor{keywordtype}{unsigned} npts;
 npts=5; 


 \textcolor{comment}{// Output solution }
 \textcolor{comment}{//-----------------}
 sprintf(filename,\textcolor{stringliteral}{"%s/soln%i.dat"},doc\_info.directory().c\_str(),
         doc\_info.number());
 some\_file.open(filename);
 mesh\_pt()->output(some\_file,npts);
 some\_file.close();


 \textcolor{comment}{// Output exact solution }
 \textcolor{comment}{//----------------------}
 sprintf(filename,\textcolor{stringliteral}{"%s/exact\_soln%i.dat"},doc\_info.directory().c\_str(),
         doc\_info.number());
 some\_file.open(filename);
 mesh\_pt()->output\_fct(some\_file,npts,\hyperlink{namespaceTanhSolnForPoisson_af7896e9c18ce6438c73ae2a875e8b7de}{TanhSolnForPoisson::get\_exact\_u}); 
 some\_file.close();


 \textcolor{comment}{// Doc error}
 \textcolor{comment}{//----------}
 \textcolor{keywordtype}{double} error,norm;
 sprintf(filename,\textcolor{stringliteral}{"%s/error%i.dat"},doc\_info.directory().c\_str(),
         doc\_info.number());
 some\_file.open(filename);
 mesh\_pt()->compute\_error(some\_file,\hyperlink{namespaceTanhSolnForPoisson_af7896e9c18ce6438c73ae2a875e8b7de}{TanhSolnForPoisson::get\_exact\_u},
                          error,norm); 
 some\_file.close();
 cout << \textcolor{stringliteral}{"error: "} << sqrt(error) << std::endl; 
 cout << \textcolor{stringliteral}{"norm : "} << sqrt(norm) << std::endl << std::endl;

\} \textcolor{comment}{// end of doc}

\end{DoxyCodeInclude}




 

\hypertarget{index_sources}{}\section{Source files for this tutorial}\label{index_sources}

\begin{DoxyItemize}
\item The source files for this tutorial are located in the directory\+: \begin{center} \href{
../../../../
demo_drivers/poisson/eighth_sphere_poisson/
}{\tt demo\+\_\+drivers/poisson/eighth\+\_\+sphere\+\_\+poisson/ } \end{center} 
\item The driver code is\+: \begin{center} \href{
../../../../
demo_drivers/poisson/eighth_sphere_poisson/eighth_sphere_poisson.cc
}{\tt demo\+\_\+drivers/poisson/eighth\+\_\+sphere\+\_\+poisson/eighth\+\_\+sphere\+\_\+poisson.\+cc } \end{center} 
\end{DoxyItemize}



 

 \hypertarget{index_pdf}{}\section{P\+D\+F file}\label{index_pdf}
A \href{../latex/refman.pdf}{\tt pdf version} of this document is available. \end{document}
