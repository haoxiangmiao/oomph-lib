In this example we consider our first moving-\/boundary Navier-\/\+Stokes problem\+: The flow of a viscous fluid contained in an elliptical ring whose walls perform periodic oscillations.

{\ttfamily oomph-\/lib\textquotesingle{}s} Navier-\/\+Stokes elements are based on the Arbitrary Lagrangian Eulerian (A\+LE) form of the Navier-\/\+Stokes equations and can therefore be used in moving domain problems. In this example we illustrate their use in {\ttfamily Domain} -\/ based meshes (first discussed in the example demonstrating the solution of the \href{../../../unsteady_heat/two_d_unsteady_heat_ALE/html/index.html}{\tt unsteady heat equation in a moving domain}) in which {\ttfamily Macro\+Elements} are used to update the nodal positions in response to changes in the domain boundary. In subsequent examples, we will discuss alternative, sparse mesh update techniques that are useful in problems with free boundaries and in fluid-\/structure interaction problems.

\begin{center} \tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*{1}{|X[-1]}|}
\hline
\begin{center} {\bfseries Finite-\/\+Reynolds-\/number-\/flow driven by an oscillating ellipse} \end{center} 

We consider the unsteady 2D flow of a Newtonian fluid that is contained in an oscillating elliptical ring whose wall shape is parametrised by the Lagrangian coordinate $ \xi $ as \[ {\bf R}_w(\xi) = \left( \begin{array}{l} a(t) \cos(\xi) \\ a^{-1}(t) \sin(\xi) \end{array} \right) \] where \[ a(t) = A + \widehat{A} \cos\left(\frac{2\pi t}{T}\right). \] $ A $ represents the average half-\/axis of the elliptical ring in the $ x_1 $-\/direction, and $ \widehat{A} $ is the amplitude of its periodic variation. The ring has constant cross-\/sectional area -- consistent with the incompressibility of the fluid whose motion is governed by the A\+LE form of the Navier-\/\+Stokes equations, \[ Re\left(St\frac{\partial u_i}{\partial t} + \left(u_j-u_j^M\right)\frac{\partial u_i}{\partial x_j}\right) = - \frac{\partial p}{\partial x_i} + \frac{\partial }{\partial x_j} \left( \frac{\partial u_i}{\partial x_j} + \frac{\partial u_j}{\partial x_i} \right), \ \ \ \ \ \ \ \ \ \ (1) \] and the continuity equation \[ \frac{\partial u_i}{\partial x_i} = 0, \] where $ u_j^M $ is the mesh velocity. We exploit the symmetry of the problem and solve the equations in the quarter domain \[ D = \left\{(x_1,x_2) \, \bigg| \, x_1\geq0, \, x_2\geq0,\, \left(\frac{x_1}{a(t)}\right)^2 + \big(x_2 \, a(t)\big)^2 \leq 1\right\}, \] shown in this sketch (for $ A=1, \ \widehat{A}=1 $ and $T=1$),  
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{wall}
\doxyfigcaption{Sketch of the computational domain. }
\end{DoxyImage}


The fluid is subject to no-\/slip boundary conditions on the curved wall, \[ \left. {\bf u} \right|_{\partial D_{ellipse}} = \frac{\partial {\bf R}_w(\xi, t)}{\partial t} \] and symmetry conditions on the symmetry boundaries, \[ \left.u_1\right|_{x_2=0}=0, \qquad \left.u_2\right|_{x_1=0}=0. \] The initial conditions for the velocity are given by \[ {\bf u}(x_1,x_2,t=0) = {\bf u}_{IC}(x_1,x_2), \] where $ {\bf u}_{IC}(x_1,x_2) $ is a given, divergence-\/free velocity field that satisfies the velocity boundary conditions at $ t=0 $. No initial conditions are required for the pressure.   \\\cline{1-1}
\end{longtabu}
\end{center} 



\hypertarget{index_solution}{}\section{An exact solution}\label{index_solution}
It is easy to show (by inspection) that the unsteady stagnation point flow \[ u_1(x_1,x_2,t) = \frac{1}{a}\frac{da}{dt}\, x_1 = -\frac{2\pi\widehat{A}\sin\left(\frac{2\pi t}{T}\right)} {T\left(A+\widehat{A}\cos\left(\frac{2\pi t}{T}\right)\right)} \, x_1 \mbox{\ \ \ \ and \ \ \ \ \ } u_2(x_1,x_2,t) = -\frac{1}{a}\frac{da}{dt} \, x_2 = -\frac{2\pi\widehat{A}\sin\left(\frac{2\pi t}{T}\right)} {T\left(A+\widehat{A}\cos\left(\frac{2\pi t}{T}\right)\right)} \, x_2, \] is an exact solution of the above problem as it satisfies the Navier-\/\+Stokes equations and the velocity boundary conditions. The pressure is given by \[ p = \frac{2\pi\widehat{A}\, Re\, \left(x_1^2\, St\, \cos\left(\frac{2\pi t}{T}\right)A + x_1^2\, St\, \widehat{A} - x_1^2\widehat{A} + x_1^2\widehat{A}\cos^2\left(\frac{2\pi t}{T}\right) - x_2^2\, St\, \cos\left(\frac{2\pi t}{T}\right) - x_2^2\, St\, \widehat{A} - x_2^2\widehat{A} + x_2^2\widehat{A}\cos^2\left(\frac{2\pi t}{T}\right)\right)} {T^2\left(A^2 + 2A\widehat{A}\cos\left(\frac{2\pi t}{T}\right) + \widehat{A}^2\cos^2\left(\frac{2\pi t}{T}\right)\right)}. \]



\hypertarget{index_results}{}\section{Results}\label{index_results}
The two figures below show two snapshots of the solution for $ Re=Re \ St=100 $ , extracted from an animations of the results computed with \href{../figures/TH.avi}{\tt Taylor-\/\+Hood} and \href{../figures/CR.avi}{\tt Crouzeix-\/\+Raviart elements}. In both cases, the exact solution was used as the initial condition for the velocities. The figures show \char`\"{}carpet plots\char`\"{} of the two velocity components and the pressure, respectively, and a contour plot of the pressure, superimposed on the moving mesh. The carpet plot of the velocities clearly shows that the flow is of stagnation-\/point type as the horizontal velocity, $u_1$ , is a linear function of $x_1$ while the vertical velocity, $u_2$ , is a linear function of $ - x_2$.

 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{CR}
\doxyfigcaption{Plot of the velocity and pressure fields computed with 2D Crouzeix-\/\+Raviart elements, with Re=100 and St=1. }
\end{DoxyImage}


 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{TH}
\doxyfigcaption{Plot of the velocity and pressure fields computed with 2D Taylor-\/\+Hood elements, with Re=100 and St=1. }
\end{DoxyImage}




 

\hypertarget{index_wall}{}\section{The moving wall}\label{index_wall}
As usual, we represent the moving wall as a {\ttfamily Geom\+Object} and define its shape by implementing the pure virtual function {\ttfamily Geom\+Object\+::position}(...). The arguments to the constructor specify the mean half-\/axis of the ellipse, $ A $, the amplitude of its variations, $ \widehat{A} $, and the period of the oscillation, $ T $ . We also pass the pointer to a {\ttfamily Time} object to the constructor and store it in a private data member, to allow the {\ttfamily position}(...) functions to access the current value of the continuous time.

 
\begin{DoxyCodeInclude}
\textcolor{comment}{//============start\_of\_MyEllipse===========================================}
\textcolor{comment}{/// \(\backslash\)short Oscillating ellipse}
\textcolor{comment}{}\textcolor{comment}{/// \(\backslash\)f[ x = (A + \(\backslash\)widehat\{A\} \(\backslash\)cos(2\(\backslash\)pi t/T)) \(\backslash\)cos(\(\backslash\)xi)  \(\backslash\)f]}
\textcolor{comment}{}\textcolor{comment}{/// \(\backslash\)f[ y = \(\backslash\)frac\{\(\backslash\)sin(\(\backslash\)xi)\}\{A + \(\backslash\)widehat\{A\} \(\backslash\)cos(2\(\backslash\)pi t/T)\}   \(\backslash\)f]}
\textcolor{comment}{}\textcolor{comment}{/// Note that cross-sectional area is conserved.}
\textcolor{comment}{}\textcolor{comment}{//=========================================================================}
\textcolor{keyword}{class }\hyperlink{classMyEllipse}{MyEllipse} : \textcolor{keyword}{public} GeomObject
\{

\textcolor{keyword}{public}:
\textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Constructor:  Pass initial x-half axis, amplitude of x-variation, }
\textcolor{comment}{ /// period of oscillation and pointer to time object.}
\textcolor{comment}{} \hyperlink{classMyEllipse_a6d780f1f450d99e175842e88a3079069}{MyEllipse}(\textcolor{keyword}{const} \textcolor{keywordtype}{double}& a, \textcolor{keyword}{const} \textcolor{keywordtype}{double}& a\_hat,
           \textcolor{keyword}{const} \textcolor{keywordtype}{double}& period, Time* time\_pt) : 
  GeomObject(1,2), A(a), A\_hat(a\_hat), T(period), \hyperlink{classMyEllipse_abc1c4c863a599ce87bdff1abb9971953}{Time\_pt}(time\_pt) \{\}
\textcolor{comment}{}
\textcolor{comment}{ /// Destructor: Empty}
\textcolor{comment}{} \textcolor{keyword}{virtual} \hyperlink{classMyEllipse_ac2f2d3fb269c57fb26b4db6d9a0c7c05}{~MyEllipse}() \{\}
\textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Current position vector to material point at }
\textcolor{comment}{ /// Lagrangian coordinate xi }
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{classMyEllipse_a7b139a2f4564005773c83325f2414e3e}{position}(\textcolor{keyword}{const} Vector<double>& xi, Vector<double>& r)\textcolor{keyword}{ const}
\textcolor{keyword}{  }\{
   \textcolor{comment}{// Get current time:}
   \textcolor{keywordtype}{double} time=\hyperlink{classMyEllipse_abc1c4c863a599ce87bdff1abb9971953}{Time\_pt}->time();

   \textcolor{comment}{// Position vector}
   \textcolor{keywordtype}{double} axis=A+A\_hat*cos(2.0*MathematicalConstants::Pi*time/T);
   r[0] = axis*cos(xi[0]);
   r[1] = (1.0/axis)*sin(xi[0]);
  \} 
\textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Parametrised position on object: r(xi). Evaluated at}
\textcolor{comment}{ /// previous time level. t=0: current time; t>0: previous}
\textcolor{comment}{ /// time level.}
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{classMyEllipse_a7b139a2f4564005773c83325f2414e3e}{position}(\textcolor{keyword}{const} \textcolor{keywordtype}{unsigned}& t, \textcolor{keyword}{const} Vector<double>& xi,
               Vector<double>& r)\textcolor{keyword}{ const}
\textcolor{keyword}{  }\{
   \textcolor{comment}{// Get current time:}
   \textcolor{keywordtype}{double} time=\hyperlink{classMyEllipse_abc1c4c863a599ce87bdff1abb9971953}{Time\_pt}->time(t);
   
   \textcolor{comment}{// Position vector}
   \textcolor{keywordtype}{double} axis=A+A\_hat*cos(2.0*MathematicalConstants::Pi*time/T);
   r[0] = axis*cos(xi[0]);
   r[1] = (1.0/axis)*sin(xi[0]);
  \} 

\textcolor{keyword}{private}:
\textcolor{comment}{}
\textcolor{comment}{ /// x-half axis}
\textcolor{comment}{} \textcolor{keywordtype}{double} \hyperlink{classMyEllipse_aa2a0efd0a39f9d4fc307a6ff011682ed}{A};
\textcolor{comment}{}
\textcolor{comment}{ /// Amplitude of variation in x-half axis}
\textcolor{comment}{} \textcolor{keywordtype}{double} \hyperlink{classMyEllipse_a653e71cf296cdc86cc595d16f18004dd}{A\_hat};
\textcolor{comment}{}
\textcolor{comment}{ /// Period of oscillation}
\textcolor{comment}{} \textcolor{keywordtype}{double} \hyperlink{classMyEllipse_ab098069ab23bbbd8f30b0da3523dc87f}{T};
\textcolor{comment}{}
\textcolor{comment}{ /// Pointer to time object}
\textcolor{comment}{} Time* \hyperlink{classMyEllipse_abc1c4c863a599ce87bdff1abb9971953}{Time\_pt};

\}; \textcolor{comment}{// end of MyEllipse}

\end{DoxyCodeInclude}




 

\hypertarget{index_namespace}{}\section{The global parameters}\label{index_namespace}
As in most previous examples, we use a namespace to define and initialise global problem parameters such as the Reynolds and Strouhal numbers\+:

 
\begin{DoxyCodeInclude}
\textcolor{comment}{//===start\_of\_namespace=================================================}
\textcolor{comment}{/// Namepspace for global parameters}
\textcolor{comment}{}\textcolor{comment}{//======================================================================}
\textcolor{keyword}{namespace }\hyperlink{namespaceGlobal__Physical__Variables}{Global\_Physical\_Variables}
\{
\textcolor{comment}{}
\textcolor{comment}{ /// Reynolds number}
\textcolor{comment}{} \textcolor{keywordtype}{double} Re=100.0;
\textcolor{comment}{}
\textcolor{comment}{ /// Womersley = Reynolds times Strouhal}
\textcolor{comment}{} \textcolor{keywordtype}{double} ReSt=100.0;

\end{DoxyCodeInclude}


We also define and initialise the parameters that specify the motion of the domain boundary and specify the exact solution.


\begin{DoxyCodeInclude}
\textcolor{comment}{}
\textcolor{comment}{ /// x-Half axis length}
\textcolor{comment}{} \textcolor{keywordtype}{double} A=1.0;
\textcolor{comment}{}
\textcolor{comment}{ /// x-Half axis amplitude}
\textcolor{comment}{} \textcolor{keywordtype}{double} A\_hat=0.1;
\textcolor{comment}{}
\textcolor{comment}{ /// Period of oscillations}
\textcolor{comment}{} \textcolor{keywordtype}{double} T=1.0;
\textcolor{comment}{}
\textcolor{comment}{ /// Exact solution of the problem as a vector containing u,v,p}
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{namespaceGlobal__Physical__Variables_af29d0fbf7264555610176a1fc931591a}{get\_exact\_u}(\textcolor{keyword}{const} \textcolor{keywordtype}{double}& t, \textcolor{keyword}{const} Vector<double>& x, Vector<double>& u)
 \{
  \textcolor{keyword}{using namespace }MathematicalConstants;

  \textcolor{comment}{// Strouhal number}
  \textcolor{keywordtype}{double} St = ReSt/\hyperlink{namespaceGlobal__Physical__Variables_ab814e627d2eb5bc50318879d19ab16b9}{Re};

  \textcolor{comment}{// Half axis}
  \textcolor{keywordtype}{double} a=A+A\_hat*cos(2.0*Pi*t/T);
  \textcolor{keywordtype}{double} adot=-2.0*A\_hat*Pi*sin(2.0*Pi*t/T)/\hyperlink{namespaceGlobal__Physical__Variables_a1a806ee7c4d04d6afaba1d24d94dceea}{T}; 
  u.resize(3);

  \textcolor{comment}{// Velocity solution}
  u[0]=adot*x[0]/a;
  u[1]=-adot*x[1]/a;

  \textcolor{comment}{// Pressure solution}
  u[2]=(2.0*A\_hat*Pi*Pi*Re*(x[0]*x[0]*St*cos(2.0*Pi*t/T)*A + 
                            x[0]*x[0]*St*A\_hat - x[0]*x[0]*A\_hat +
                            x[0]*x[0]*A\_hat*cos(2.0*Pi*t/T)*cos(2.0*Pi*t/T) -
                            x[1]*x[1]*St*cos(2.0*Pi*t/T)*A - 
                            x[1]*x[1]*St*A\_hat - x[1]*x[1]*A\_hat +
                            x[1]*x[1]*A\_hat*cos(2.0*Pi*t/T)*cos(2.0*Pi*t/T) ))
   /(T*T*(A*A + 2.0*A*A\_hat*cos(2.0*Pi*t/T) + 
          A\_hat*A\_hat*cos(2.0*Pi*t/T)*cos(2.0*Pi*t/T) ));
 \}


\} \textcolor{comment}{// end of namespace}

\end{DoxyCodeInclude}




 

\hypertarget{index_main}{}\section{The driver code}\label{index_main}
As in most previous unsteady demo codes, we allow the code to be run in a validation mode (in which we use a coarser mesh and execute fewer timesteps). This mode is selected by specifying an (arbitrary) command line argument that we store in the namespace {\ttfamily Command\+Line\+Args}.


\begin{DoxyCodeInclude}
\textcolor{comment}{//======start\_of\_main=================================================}
\textcolor{comment}{/// Driver code for unsteady Navier-Stokes flow, driven by}
\textcolor{comment}{}\textcolor{comment}{/// oscillating ellipse. If the code is executed with command line}
\textcolor{comment}{}\textcolor{comment}{/// arguments, a validation run is performed. }
\textcolor{comment}{}\textcolor{comment}{//====================================================================}
\textcolor{keywordtype}{int} \hyperlink{osc__quarter__ellipse_8cc_a0ddf1224851353fc92bfbff6f499fa97}{main}(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char}* argv[])
\{

 \textcolor{comment}{// Store command line arguments}
 CommandLineArgs::setup(argc,argv);

\end{DoxyCodeInclude}


We create a {\ttfamily Doc\+Info} object to specify the output directory, build the problem with adaptive Crouzeix-\/\+Raviart elements and the {\ttfamily B\+D\+F$<$2$>$} timestepper and perform the unsteady simulation.


\begin{DoxyCodeInclude}


 \textcolor{comment}{// Solve with Crouzeix-Raviart elements}
 \{
  \textcolor{comment}{// Create DocInfo object with suitable directory name for output}
  DocInfo doc\_info;
  doc\_info.set\_directory(\textcolor{stringliteral}{"RESLT\_CR"});
  
  \textcolor{comment}{//Set up problem}
  \hyperlink{classOscEllipseProblem}{OscEllipseProblem<RefineableQCrouzeixRaviartElement<2>}
      ,BDF<2> > problem;
  
  \textcolor{comment}{// Run the unsteady simulation}
  problem.\hyperlink{classOscEllipseProblem_ad0d879edbbd8b09b61e802ab66ef98a3}{unsteady\_run}(doc\_info);
 \}

\end{DoxyCodeInclude}


Then we repeat this process for adaptive Taylor-\/\+Hood elements.


\begin{DoxyCodeInclude}

 \textcolor{comment}{// Solve with Taylor-Hood elements}
 \{
  \textcolor{comment}{// Create DocInfo object with suitable directory name for output}
  DocInfo doc\_info;
  doc\_info.set\_directory(\textcolor{stringliteral}{"RESLT\_TH"});

  \textcolor{comment}{//Set up problem}
  \hyperlink{classOscEllipseProblem}{OscEllipseProblem<RefineableQTaylorHoodElement<2>},BDF<2>
       > problem;
  
  \textcolor{comment}{// Run the unsteady simulation}
  problem.\hyperlink{classOscEllipseProblem_ad0d879edbbd8b09b61e802ab66ef98a3}{unsteady\_run}(doc\_info);
 \}
 

\}; \textcolor{comment}{// end of main}

\end{DoxyCodeInclude}




 

\hypertarget{index_problem}{}\section{The problem class}\label{index_problem}
Most of the problem class is a straightforward combination of the problem classes employed in the simulation of \href{../../driven_cavity/html/index.html}{\tt the adaptive driven cavity } and \href{../../rayleigh_channel/html/index.html}{\tt Rayleigh channel } problems, in that the problem combines unsteadiness with spatial adaptivity (though in the present problem the adaptivity is only used to uniformly refine the very coarse base mesh; we refer to {\itshape {\bfseries another example}} for the use of full spatial adaptivity in a moving-\/domain Navier-\/\+Stokes problem).

 
\begin{DoxyCodeInclude}
\textcolor{comment}{//=====start\_of\_problem\_class=========================================}
\textcolor{comment}{/// Navier-Stokes problem in an oscillating ellipse domain.}
\textcolor{comment}{}\textcolor{comment}{//====================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT, \textcolor{keyword}{class} TIMESTEPPER>
\textcolor{keyword}{class }\hyperlink{classOscEllipseProblem}{OscEllipseProblem} : \textcolor{keyword}{public} Problem
\{

\textcolor{keyword}{public}:
\textcolor{comment}{}
\textcolor{comment}{ /// Constructor}
\textcolor{comment}{} \hyperlink{classOscEllipseProblem_aaa836937ec963921243fcb990f6fe538}{OscEllipseProblem}();
\textcolor{comment}{}
\textcolor{comment}{ /// Destructor (empty)}
\textcolor{comment}{} \hyperlink{classOscEllipseProblem_a48a38acb7db1b394f7bfcd02e779b795}{~OscEllipseProblem}() \{\}
\textcolor{comment}{}
\textcolor{comment}{ /// Update the problem specs after solve (empty)}
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{classOscEllipseProblem_a268e14b24e3ac922e7362bbb37ccde1f}{actions\_after\_newton\_solve}()\{\}
\textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Update problem specs before solve (empty)}
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{classOscEllipseProblem_a18bbd70aa8c140637637053a5f839c11}{actions\_before\_newton\_solve}() \{\} 
 \textcolor{comment}{}
\textcolor{comment}{ /// Actions before adapt (empty)}
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{classOscEllipseProblem_a97c1b0056acbb9a6ec6157b6e7ad258a}{actions\_before\_adapt}()\{\}
\textcolor{comment}{}
\textcolor{comment}{ /// Actions after adaptation, pin relevant pressures}
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{classOscEllipseProblem_a6044661f75986848484df2c04bfe7aab}{actions\_after\_adapt}()
  \{
   \textcolor{comment}{// Unpin all pressure dofs}
   RefineableNavierStokesEquations<2>::
    unpin\_all\_pressure\_dofs(mesh\_pt()->element\_pt());

   \textcolor{comment}{// Pin redundant pressure dofs}
   RefineableNavierStokesEquations<2>::
    pin\_redundant\_nodal\_pressures(mesh\_pt()->element\_pt());
   
   \textcolor{comment}{// Now set the first pressure dof in the first element to 0.0}
   \hyperlink{classOscEllipseProblem_a8b70831d1c25a40c814d5d92e77a1085}{fix\_pressure}(0,0,0.0);

  \} \textcolor{comment}{// end of actions\_after\_adapt}

\end{DoxyCodeInclude}


The key new feature in the current problem is the presence of the moving domain which requires updates of
\begin{DoxyEnumerate}
\item all nodal positions
\item the prescribed velocities on the moving wall via the no-\/slip condition.
\end{DoxyEnumerate}before every timestep. Since the nodal positions of the {\ttfamily Quarter\+Circle\+Sector\+Mesh} are determined via its {\ttfamily Macro\+Element} / {\ttfamily Domain} representation (which updates the nodal position in response to changes in the geometry of the {\ttfamily Geom\+Objects} that define its boundaries), the former task may be accomplished by executing the {\ttfamily Mesh\+::node\+\_\+update()} function; the update of the no-\/slip condition may be performed by calling the function {\ttfamily F\+S\+I\+\_\+functions\+::apply\+\_\+no\+\_\+slip\+\_\+on\+\_\+moving\+\_\+wall(\+Node$\ast$ node\+\_\+pt)}, a helper function, defined in the namespace {\ttfamily F\+S\+I\+\_\+functions}, which updates the velocity components $ u_1, u_2 [, u_3] $ according to the no-\/slip boundary condition \[ {\bf u}_{Node} = \frac{\partial {\bf x}_{Node}}{\partial t} \] where the time-\/derivative of the nodal positions is evaluated by the {\ttfamily Node\textquotesingle{}s} positional timestepper. \mbox{[}{\bfseries Note\+:} The function {\ttfamily F\+S\+I\+\_\+functions\+::apply\+\_\+no\+\_\+slip\+\_\+on\+\_\+moving\+\_\+wall}(...) assumes that the velocity components are stored in the {\ttfamily Node\textquotesingle{}s} first 2 \mbox{[}3\mbox{]} values. This is consistent with the storage of the velocity component in all existing Navier-\/\+Stokes elements. If you develop your own Navier-\/\+Stokes elements and use a different storage scheme you use this function at your own risk.\mbox{]}

Here is the implementation of these tasks\+:


\begin{DoxyCodeInclude}

\textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Update the problem specs before next timestep}
\textcolor{comment}{} \textcolor{keywordtype}{void} actions\_before\_implicit\_timestep()
  \{
   \textcolor{comment}{// Update the domain shape}
   mesh\_pt()->node\_update();

   \textcolor{comment}{// Ring boundary: No slip; this implies that the velocity needs}
   \textcolor{comment}{// to be updated in response to wall motion}
   \textcolor{keywordtype}{unsigned} ibound=1;
   \textcolor{keywordtype}{unsigned} num\_nod=mesh\_pt()->nboundary\_node(ibound);
   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} inod=0;inod<num\_nod;inod++)
    \{
     \textcolor{comment}{// Which node are we dealing with?}
     Node* node\_pt=mesh\_pt()->boundary\_node\_pt(ibound,inod);
     
     \textcolor{comment}{// Apply no slip}
     FSI\_functions::apply\_no\_slip\_on\_moving\_wall(node\_pt);
    \}
  \} 
\textcolor{comment}{}
\textcolor{comment}{ /// Update the problem specs after timestep (empty)}
\textcolor{comment}{} \textcolor{keywordtype}{void} actions\_after\_implicit\_timestep()\{\}

\end{DoxyCodeInclude}


The remaining functions are similar to those used in our previous Navier-\/\+Stokes examples and require no further explanation.


\begin{DoxyCodeInclude}
 \textcolor{comment}{}
\textcolor{comment}{ /// Doc the solution}
\textcolor{comment}{} \textcolor{keywordtype}{void} doc\_solution(DocInfo& doc\_info);
\textcolor{comment}{}
\textcolor{comment}{ /// Timestepping loop}
\textcolor{comment}{} \textcolor{keywordtype}{void} unsteady\_run(DocInfo& doc\_info);
\textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Set initial condition}
\textcolor{comment}{} \textcolor{keywordtype}{void} set\_initial\_condition();

\textcolor{keyword}{private}:
\textcolor{comment}{}
\textcolor{comment}{ ///Fix pressure in element e at pressure dof pdof and set to pvalue}
\textcolor{comment}{} \textcolor{keywordtype}{void} fix\_pressure(\textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} &e, \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} &pdof, 
                   \textcolor{keyword}{const} \textcolor{keywordtype}{double} &pvalue)
  \{
   \textcolor{comment}{//Cast to proper element and fix pressure}
   \textcolor{keyword}{dynamic\_cast<}ELEMENT*\textcolor{keyword}{>}(mesh\_pt()->element\_pt(e))->
    fix\_pressure(pdof,pvalue);
  \} \textcolor{comment}{// end\_of\_fix\_pressure}
\textcolor{comment}{}
\textcolor{comment}{ /// Pointer to GeomObject that specifies the domain bondary}
\textcolor{comment}{} GeomObject* Wall\_pt;

\}; \textcolor{comment}{// end of problem\_class}

\end{DoxyCodeInclude}




 

\hypertarget{index_constructor}{}\section{The problem constructor}\label{index_constructor}
We start by creating a timestepper of the type specified by the {\ttfamily Problem\textquotesingle{}s} template parameter and add (a pointer to) it to the {\ttfamily Problem\textquotesingle{}s} collection of {\ttfamily Timesteppers}. Recall that this function also creates the {\ttfamily Problem\textquotesingle{}s} {\ttfamily Time} object.


\begin{DoxyCodeInclude}



\textcolor{comment}{//========start\_of\_constructor============================================}\textcolor{comment}{}
\textcolor{comment}{/// Constructor for Navier-Stokes problem on an oscillating ellipse domain.}
\textcolor{comment}{}\textcolor{comment}{//========================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT, \textcolor{keyword}{class} TIMESTEPPER>
\hyperlink{classOscEllipseProblem_aaa836937ec963921243fcb990f6fe538}{OscEllipseProblem<ELEMENT,TIMESTEPPER>::OscEllipseProblem}
      ()
\{ 

 \textcolor{comment}{//Create the timestepper and add it to the problem}
 add\_time\_stepper\_pt(\textcolor{keyword}{new} TIMESTEPPER);

\end{DoxyCodeInclude}


Next we create the {\ttfamily Geom\+Object} that defines the curvilinear domain boundary and pass it to the Mesh constructor. (Since we will only use adaptivity to refine the mesh uniformly, it is not necessary to define an error estimator.)


\begin{DoxyCodeInclude}

 \textcolor{comment}{// Setup mesh}
 \textcolor{comment}{//-----------}

 \textcolor{comment}{// Build geometric object that forms the curvilinear domain boundary:}
 \textcolor{comment}{// an oscillating ellipse}

 \textcolor{comment}{// Half axes}
 \textcolor{keywordtype}{double} a=\hyperlink{namespaceGlobal__Physical__Variables_a4894f9a3a9cbf84f00d0719f2841e624}{Global\_Physical\_Variables::A};

 \textcolor{comment}{// Variations of half axes}
 \textcolor{keywordtype}{double} a\_hat=\hyperlink{namespaceGlobal__Physical__Variables_a11d1e77201d6b8c250c4c9396fc5ad06}{Global\_Physical\_Variables::A\_hat};

 \textcolor{comment}{// Period of the oscillation}
 \textcolor{keywordtype}{double} period=\hyperlink{namespaceGlobal__Physical__Variables_a1a806ee7c4d04d6afaba1d24d94dceea}{Global\_Physical\_Variables::T};

 \textcolor{comment}{// Create GeomObject that specifies the domain bondary}
 Wall\_pt=\textcolor{keyword}{new} \hyperlink{classMyEllipse}{MyEllipse}(a,a\_hat,period,Problem::time\_pt()); 


 \textcolor{comment}{// Start and end coordinates of curvilinear domain boundary on ellipse}
 \textcolor{keywordtype}{double} xi\_lo=0.0;
 \textcolor{keywordtype}{double} xi\_hi=MathematicalConstants::Pi/2.0;

 \textcolor{comment}{// Now create the mesh. Separating line between the two }
 \textcolor{comment}{// elements next to the curvilinear boundary is located half-way}
 \textcolor{comment}{// along the boundary.}
 \textcolor{keywordtype}{double} fract\_mid=0.5;
 Problem::mesh\_pt() = \textcolor{keyword}{new} RefineableQuarterCircleSectorMesh<ELEMENT>(
  Wall\_pt,xi\_lo,fract\_mid,xi\_hi,time\_stepper\_pt());

 \textcolor{comment}{// Set error estimator NOT NEEDED IN CURRENT PROBLEM SINCE }
 \textcolor{comment}{// WE'RE ONLY REFINING THE MESH UNIFORMLY}
 \textcolor{comment}{//Z2ErrorEstimator* error\_estimator\_pt=new Z2ErrorEstimator;}
 \textcolor{comment}{//mesh\_pt()->spatial\_error\_estimator\_pt()=error\_estimator\_pt;}

\end{DoxyCodeInclude}


Both velocity components on the curvilinear mesh boundary are determined by the no-\/slip condition and must therefore be pinned,


\begin{DoxyCodeInclude}


 \textcolor{comment}{// Fluid boundary conditions}
 \textcolor{comment}{//--------------------------}
 \textcolor{comment}{// Ring boundary: No slip; this also implies that the velocity needs}
 \textcolor{comment}{// to be updated in response to wall motion}
 \textcolor{keywordtype}{unsigned} ibound=1;
 \{
  \textcolor{keywordtype}{unsigned} num\_nod= mesh\_pt()->nboundary\_node(ibound);
  \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} inod=0;inod<num\_nod;inod++)
   \{
     
    \textcolor{comment}{// Pin both velocities}
    \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} i=0;i<2;i++)
     \{
      mesh\_pt()->boundary\_node\_pt(ibound,inod)->pin(i);
     \}
   \}
 \} \textcolor{comment}{// end boundary 1}

\end{DoxyCodeInclude}


whereas on the symmetry boundaries only one of the two velocity components is set to zero\+:


\begin{DoxyCodeInclude}
 \textcolor{comment}{// Bottom boundary: }
 ibound=0;
 \{
  \textcolor{keywordtype}{unsigned} num\_nod= mesh\_pt()->nboundary\_node(ibound);
  \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} inod=0;inod<num\_nod;inod++)
   \{
    \textcolor{comment}{// Pin vertical velocity}
    \{
     mesh\_pt()->boundary\_node\_pt(ibound,inod)->pin(1);
    \}
   \}
 \} \textcolor{comment}{// end boundary 0}

 \textcolor{comment}{// Left boundary:}
 ibound=2;
 \{
  \textcolor{keywordtype}{unsigned} num\_nod= mesh\_pt()->nboundary\_node(ibound);
  \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} inod=0;inod<num\_nod;inod++)
   \{
    \textcolor{comment}{// Pin horizontal velocity}
    \{
     mesh\_pt()->boundary\_node\_pt(ibound,inod)->pin(0);
    \}
   \}
 \} \textcolor{comment}{// end boundary 2}

\end{DoxyCodeInclude}


Finally, we pass the pointers to $ Re $, $ Re \ St $ and the global {\ttfamily Time} object (automatically created by the {\ttfamily Problem} when the timestepper was passed to it at the beginning of the constructor) to the elements, pin the redundant nodal pressure degrees of freedom (see the discussion of the \href{../../../navier_stokes/adaptive_driven_cavity/html/index.html}{\tt adaptive driven-\/cavity problem} for more details), pin one pressure degree of freedom, and set up the equation numbering scheme.


\begin{DoxyCodeInclude}

 
 \textcolor{comment}{// Complete the build of all elements so they are fully functional}
 \textcolor{comment}{//----------------------------------------------------------------}

 \textcolor{comment}{// Find number of elements in mesh}
 \textcolor{keywordtype}{unsigned} n\_element = mesh\_pt()->nelement();

 \textcolor{comment}{// Loop over the elements to set up element-specific }
 \textcolor{comment}{// things that cannot be handled by constructor}
 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} i=0;i<n\_element;i++)
  \{
   \textcolor{comment}{// Upcast from FiniteElement to the present element}
   ELEMENT *el\_pt = \textcolor{keyword}{dynamic\_cast<}ELEMENT*\textcolor{keyword}{>}(mesh\_pt()->element\_pt(i));

   \textcolor{comment}{//Set the Reynolds number, etc}
   el\_pt->re\_pt() = &\hyperlink{namespaceGlobal__Physical__Variables_ab814e627d2eb5bc50318879d19ab16b9}{Global\_Physical\_Variables::Re};
   el\_pt->re\_st\_pt() = &\hyperlink{namespaceGlobal__Physical__Variables_a085ee4bf968ffdd01a41b8c41864f907}{Global\_Physical\_Variables::ReSt};
  \}

 \textcolor{comment}{// Pin redundant pressure dofs}
 RefineableNavierStokesEquations<2>::
  pin\_redundant\_nodal\_pressures(mesh\_pt()->element\_pt());
 
 \textcolor{comment}{// Now set the first pressure dof in the first element to 0.0}
 fix\_pressure(0,0,0.0);

 \textcolor{comment}{// Do equation numbering}
 cout << \textcolor{stringliteral}{"Number of equations: "} << assign\_eqn\_numbers() << std::endl; 

\} \textcolor{comment}{// end of constructor}

\end{DoxyCodeInclude}




 

\hypertarget{index_IC}{}\section{Assigning the initial conditions}\label{index_IC}
This function assigns \char`\"{}history values\char`\"{} for the velocities and the nodal positions from the exact solution. It is implemented in exactly the same way as in the solution of the \href{../../../unsteady_heat/two_d_unsteady_heat_ALE/html/index.html#IC}{\tt unsteady heat equation in a moving domain}. Note that because the domain is moving, the nodal positions must be updated (according to the position of the domain boundary at the relevant previous timestep), before evaluating the exact solution at the nodal position.


\begin{DoxyCodeInclude}
\textcolor{comment}{//======================start\_of\_set\_initial\_condition====================}
\textcolor{comment}{/// \(\backslash\)short Set initial condition: Assign previous and current values}
\textcolor{comment}{}\textcolor{comment}{/// from exact solution.}
\textcolor{comment}{}\textcolor{comment}{//========================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT,\textcolor{keyword}{class} TIMESTEPPER>
\textcolor{keywordtype}{void} \hyperlink{classOscEllipseProblem_ae638f238a7b0e0acb5d6087b7363fe01}{OscEllipseProblem<ELEMENT,TIMESTEPPER>::set\_initial\_condition}
      ()
\{ 
 \textcolor{comment}{// Backup time in global timestepper}
 \textcolor{keywordtype}{double} backed\_up\_time=time\_pt()->time();
   
 \textcolor{comment}{// Past history for velocities must be established for t=time0-deltat, ...}
 \textcolor{comment}{// Then provide current values (at t=time0) which will also form}
 \textcolor{comment}{// the initial guess for first solve at t=time0+deltat}
 
 \textcolor{comment}{// Vector of exact solution value}
 Vector<double> soln(3);
 Vector<double> x(2);
 
 \textcolor{comment}{//Find number of nodes in mesh}
 \textcolor{keywordtype}{unsigned} num\_nod = mesh\_pt()->nnode();
 
 \textcolor{comment}{// Get continuous times at previous timesteps}
 \textcolor{keywordtype}{int} nprev\_steps=time\_stepper\_pt()->nprev\_values();
 Vector<double> prev\_time(nprev\_steps+1);
 \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} itime=nprev\_steps;itime>=0;itime--)
  \{
   prev\_time[itime]=time\_pt()->time(\textcolor{keywordtype}{unsigned}(itime));
  \}
 
 \textcolor{comment}{// Loop over current & previous timesteps (in outer loop because}
 \textcolor{comment}{// the mesh also moves!)}
 \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} itime=nprev\_steps;itime>=0;itime--)
  \{
   \textcolor{keywordtype}{double} time=prev\_time[itime];
   
   \textcolor{comment}{// Set global time (because this is how the geometric object refers }
   \textcolor{comment}{// to continous time )}
   time\_pt()->time()=time;
   
   cout << \textcolor{stringliteral}{"setting IC at time ="} << time << std::endl;
   
   \textcolor{comment}{// Update the mesh for this value of the continuous time}
   \textcolor{comment}{// (The wall object reads the continous time from the }
   \textcolor{comment}{// global time object)}
   mesh\_pt()->node\_update(); 
   
   \textcolor{comment}{// Loop over the nodes to set initial guess everywhere}
   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} jnod=0;jnod<num\_nod;jnod++)
    \{
     \textcolor{comment}{// Get nodal coordinates}
     x[0]=mesh\_pt()->node\_pt(jnod)->x(0);
     x[1]=mesh\_pt()->node\_pt(jnod)->x(1);
     
     \textcolor{comment}{// Get exact solution (unsteady stagnation point flow)}
     \hyperlink{namespaceGlobal__Physical__Variables_af29d0fbf7264555610176a1fc931591a}{Global\_Physical\_Variables::get\_exact\_u}(time,x,soln);
     
     \textcolor{comment}{// Assign solution}
     mesh\_pt()->node\_pt(jnod)->set\_value(itime,0,soln[0]);
     mesh\_pt()->node\_pt(jnod)->set\_value(itime,1,soln[1]);
       
     \textcolor{comment}{// Loop over coordinate directions}
     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} i=0;i<2;i++)
      \{
       mesh\_pt()->node\_pt(jnod)->x(itime,i)=x[i];
      \}
    \} 
  \} \textcolor{comment}{// end of loop over previous timesteps}
 
 \textcolor{comment}{// Reset backed up time for global timestepper}
 time\_pt()->time()=backed\_up\_time;
 
\} \textcolor{comment}{// end of set\_initial\_condition}

\end{DoxyCodeInclude}




 

\hypertarget{index_doc}{}\section{Post processing}\label{index_doc}
The function {\ttfamily doc\+\_\+solution}(...) is similar to that in the \href{../../../unsteady_heat/two_d_unsteady_heat/html/index.html#doc}{\tt unsteady heat examples } and the previous Navier-\/\+Stokes examples. We add dummy zones and tecplot geometries to facilitate the post-\/processing of the results with tecplot.


\begin{DoxyCodeInclude}
\textcolor{comment}{//=======start\_of\_doc\_solution============================================}
\textcolor{comment}{/// Doc the solution}
\textcolor{comment}{}\textcolor{comment}{//========================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT, \textcolor{keyword}{class} TIMESTEPPER>
\textcolor{keywordtype}{void} \hyperlink{classOscEllipseProblem_afca2cc3e3e64ac764323f232cacc7e3b}{OscEllipseProblem<ELEMENT,TIMESTEPPER>::doc\_solution}
      (DocInfo& doc\_info)
\{ 
 ofstream some\_file;
 \textcolor{keywordtype}{char} filename[100];

 \textcolor{comment}{// Number of plot points}
 \textcolor{keywordtype}{unsigned} npts;
 npts=5;

 \textcolor{comment}{// Output solution }
 \textcolor{comment}{//-----------------}
 sprintf(filename,\textcolor{stringliteral}{"%s/soln%i.dat"},doc\_info.directory().c\_str(),
         doc\_info.number());
 some\_file.open(filename);
 mesh\_pt()->output(some\_file,npts);
 some\_file << \textcolor{stringliteral}{"TEXT X=2.5,Y=93.6,F=HELV,HU=POINT,C=BLUE,H=26,T=\(\backslash\)"time = "} 
           << time\_pt()->time() << \textcolor{stringliteral}{"\(\backslash\)""};
 some\_file << \textcolor{stringliteral}{"GEOMETRY X=2.5,Y=98,T=LINE,C=BLUE,LT=0.4"} << std::endl;
 some\_file << \textcolor{stringliteral}{"1"} << std::endl;
 some\_file << \textcolor{stringliteral}{"2"} << std::endl;
 some\_file << \textcolor{stringliteral}{" 0 0"} << std::endl;
 some\_file << time\_pt()->time()*20.0 << \textcolor{stringliteral}{" 0"} << std::endl;

 \textcolor{comment}{// Write dummy zones that force tecplot to keep the axis limits constant}
 \textcolor{comment}{// while the domain is moving.}
 some\_file << \textcolor{stringliteral}{"ZONE I=2,J=2"} << std::endl;
 some\_file << \textcolor{stringliteral}{"0.0 0.0 -0.65 -0.65 -200.0"} << std::endl;
 some\_file << \textcolor{stringliteral}{"1.15 0.0 -0.65 -0.65 -200.0"} << std::endl;
 some\_file << \textcolor{stringliteral}{"0.0 1.15 -0.65 -0.65 -200.0"} << std::endl;
 some\_file << \textcolor{stringliteral}{"1.15 1.15 -0.65 -0.65 -200.0"} << std::endl;
 some\_file << \textcolor{stringliteral}{"ZONE I=2,J=2"} << std::endl;
 some\_file << \textcolor{stringliteral}{"0.0 0.0 0.65 0.65 300.0"} << std::endl;
 some\_file << \textcolor{stringliteral}{"1.15 0.0 0.65 0.65 300.0"} << std::endl;
 some\_file << \textcolor{stringliteral}{"0.0 1.15 0.65 0.65 300.0"} << std::endl;
 some\_file << \textcolor{stringliteral}{"1.15 1.15 0.65 0.65 300.0"} << std::endl;

 some\_file.close();

 \textcolor{comment}{// Output exact solution }
 \textcolor{comment}{//----------------------}
 sprintf(filename,\textcolor{stringliteral}{"%s/exact\_soln%i.dat"},doc\_info.directory().c\_str(),
         doc\_info.number());
 some\_file.open(filename);
 mesh\_pt()->output\_fct(some\_file,npts,time\_pt()->time(),
                       \hyperlink{namespaceGlobal__Physical__Variables_af29d0fbf7264555610176a1fc931591a}{Global\_Physical\_Variables::get\_exact\_u}); 
 some\_file.close();

 \textcolor{comment}{// Doc error}
 \textcolor{comment}{//----------}
 \textcolor{keywordtype}{double} error,norm;
 sprintf(filename,\textcolor{stringliteral}{"%s/error%i.dat"},doc\_info.directory().c\_str(),
         doc\_info.number());
 some\_file.open(filename);
 mesh\_pt()->compute\_error(some\_file,
                          \hyperlink{namespaceGlobal__Physical__Variables_af29d0fbf7264555610176a1fc931591a}{Global\_Physical\_Variables::get\_exact\_u},
                          time\_pt()->time(),
                          error,norm); 
 some\_file.close();


 \textcolor{comment}{// Doc solution and error}
 \textcolor{comment}{//-----------------------}
 cout << \textcolor{stringliteral}{"error: "} << error << std::endl; 
 cout << \textcolor{stringliteral}{"norm : "} << norm << std::endl << std::endl;


 \textcolor{comment}{// Plot wall posn}
 \textcolor{comment}{//---------------}
 sprintf(filename,\textcolor{stringliteral}{"%s/Wall%i.dat"},doc\_info.directory().c\_str(),
         doc\_info.number());
 some\_file.open(filename);
 
 \textcolor{keywordtype}{unsigned} nplot=100;
 \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} iplot=0;iplot<nplot;iplot++)
  \{
   Vector<double> xi\_wall(1), r\_wall(2);
   xi\_wall[0]=0.5*MathematicalConstants::Pi*double(iplot)/double(nplot-1);
   Wall\_pt->position(xi\_wall,r\_wall);
   some\_file << r\_wall[0] << \textcolor{stringliteral}{" "} << r\_wall[1] << std::endl;
  \}
 some\_file.close();
 
 \textcolor{comment}{// Increment number of doc}
 doc\_info.number()++;

\} \textcolor{comment}{// end of doc\_solution}

\end{DoxyCodeInclude}




 

\hypertarget{index_unsteady_run}{}\section{The timestepping loop}\label{index_unsteady_run}
The timestepping loop is extremely straightforward\+: We choose a timestep and the overall length of the simulation, initialise the timestepper(s) by calling {\ttfamily Problem\+::initialise\+\_\+dt}(...) and assign the initial condition.


\begin{DoxyCodeInclude}
\textcolor{comment}{//=======start\_of\_unsteady\_run============================================}
\textcolor{comment}{/// Unsteady run}
\textcolor{comment}{}\textcolor{comment}{//========================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT, \textcolor{keyword}{class} TIMESTEPPER>
\textcolor{keywordtype}{void} \hyperlink{classOscEllipseProblem_ad0d879edbbd8b09b61e802ab66ef98a3}{OscEllipseProblem<ELEMENT,TIMESTEPPER>::unsteady\_run}
      (DocInfo& doc\_info)
\{

 \textcolor{comment}{// Specify duration of the simulation}
 \textcolor{keywordtype}{double} t\_max=3.0;

 \textcolor{comment}{// Initial timestep}
 \textcolor{keywordtype}{double} dt=0.025;

 \textcolor{comment}{// Initialise timestep}
 initialise\_dt(dt);

 \textcolor{comment}{// Set initial conditions.}
 set\_initial\_condition();

\end{DoxyCodeInclude}


Next we set the number of timesteps for a normal run.


\begin{DoxyCodeInclude}

 \textcolor{comment}{// Alternative initial conditions: impulsive start; see exercise.}
 \textcolor{comment}{//assign\_initial\_values\_impulsive(); }

 \textcolor{comment}{// find number of steps}
 \textcolor{keywordtype}{unsigned} nstep = unsigned(t\_max/dt);

\end{DoxyCodeInclude}


We over-\/write this number and perform a single uniform mesh refinement if the code is run in self-\/test mode (indicated by a non-\/zero number of command line arguments),


\begin{DoxyCodeInclude}

 \textcolor{comment}{// If validation: Reduce number of timesteps performed and }
 \textcolor{comment}{// use coarse-ish mesh}
 \textcolor{keywordflow}{if} (CommandLineArgs::Argc>1)
  \{
   nstep=2;
   refine\_uniformly();
   cout << \textcolor{stringliteral}{"validation run"} << std::endl;
  \}

\end{DoxyCodeInclude}


otherwise we refine the mesh three times and output the initial conditions


\begin{DoxyCodeInclude}
 \textcolor{keywordflow}{else}
  \{
   \textcolor{comment}{// Refine the mesh three times, to resolve the pressure distribution}
   \textcolor{comment}{// (the velocities could be represented accurately on a much coarser mesh).}
   refine\_uniformly();
   refine\_uniformly();
   refine\_uniformly();
  \}

 \textcolor{comment}{// Output solution initial }
 doc\_solution(doc\_info);

\end{DoxyCodeInclude}


Finally we execute the proper timestepping loop and document the solution after every timestep


\begin{DoxyCodeInclude}

 \textcolor{comment}{// Timestepping loop}
 \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} istep=0;istep<nstep;istep++)
  \{
   cout << \textcolor{stringliteral}{"TIMESTEP "} << istep << std::endl;
   cout << \textcolor{stringliteral}{"Time is now "} << time\_pt()->time() << std::endl;

   \textcolor{comment}{// Take timestep }
   unsteady\_newton\_solve(dt);
     
   \textcolor{comment}{//Output solution}
   doc\_solution(doc\_info);
  \}

\} \textcolor{comment}{// end of unsteady\_run}

\end{DoxyCodeInclude}




 

\hypertarget{index_comments}{}\section{Comments and Exercises}\label{index_comments}

\begin{DoxyEnumerate}
\item Compare the results of the numerical simulation in which $ {\bf u}_{IC} $ is given by the exact solution (an unsteady stagnation point flow) to that obtained from an \char`\"{}impulsive start\char`\"{} where $ {\bf u}_{IC} = {\bf 0}. $ (This is most easily implemented by replacing the call to {\ttfamily set\+\_\+initial\+\_\+condition()} with a call to {\ttfamily Problem\+::assign\+\_\+initial\+\_\+values\+\_\+impulsive()}. ~\newline
 ~\newline
 Why do we obtain the same velocity with both initial conditions and why does the pressure take a few timesteps (How many exactly? Compare simulations with {\ttfamily B\+D\+F$<$4$>$} and {\ttfamily B\+D\+F$<$2$>$} timesteppers.) to \char`\"{}catch up\char`\"{} with the exact solution? \mbox{[}Hint\+: The unsteady stagnation point flow is a potential flow, therefore the viscous terms in the Navier-\/\+Stokes equations disappear. See also chapter 3.\+19 in Volume 2 of Gresho \& Sani\textquotesingle{}s wonderful book \char`\"{}\+Incompressible Flow and the Finite Element Method\char`\"{}.\mbox{]}
\end{DoxyEnumerate}



 

\hypertarget{index_sources}{}\section{Source files for this tutorial}\label{index_sources}

\begin{DoxyItemize}
\item The source files for this tutorial are located in the directory\+: \begin{center} \href{../../../../demo_drivers/navier_stokes/osc_ellipse/}{\tt demo\+\_\+drivers/navier\+\_\+stokes/osc\+\_\+ellipse/ } \end{center} 
\item The driver code is\+: \begin{center} \href{../../../../demo_drivers/navier_stokes/osc_ellipse/osc_quarter_ellipse.cc}{\tt demo\+\_\+drivers/navier\+\_\+stokes/osc\+\_\+ellipse/osc\+\_\+quarter\+\_\+ellipse.\+cc } \end{center} 
\end{DoxyItemize}



 

 \hypertarget{index_pdf}{}\section{P\+D\+F file}\label{index_pdf}
A \href{../latex/refman.pdf}{\tt pdf version} of this document is available. \end{document}
