The two-\/dimensional flow of a free surface down an inclined plane is a simple exact solution of the Navier--Stokes equations. We describe two different ways of solving the problem using either spines or a pseudo-\/elastic method to define the bulk mesh motion. Reassuringly, the results are the same irrespective of the method chosen.



 

\hypertarget{index_form}{}\section{Problem formulation}\label{index_form}
 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{sketch}
\doxyfigcaption{A film of incompressible viscous fluid of a given thickness flows down a plane inclined at a prescribed angle to the gravitational field. }
\end{DoxyImage}


Formulating the problem in coordinates tangential ( $x^{*}$) and normal ( $y^{*}$) to the plane and assuming that the flow is steady and only in the tangential direction, but independent of the tangential coordinate, reduces the momentum equations to

\begin{center} \[ \frac{\partial p^*}{\partial x^*} = \rho \,g \sin\alpha + \mu\,\frac{\partial^{2} u^*}{\partial y^{*2}}, \] \[ \frac{\partial p^*}{\partial y^*} = -\rho \,g \cos\alpha, \] \end{center}  where $u^*$ is the velocity component tangential to the plane and $p^*$ is the fluid pressure. Note that the continuity equation is automatically satisfied.

We non-\/dimensionalise using the only length-\/scale in the problem $H$, choosing the viscous scale for the pressure and choosing a reference velocity scale $U$\+: \[ x^{*} = H x,\qquad y^{*} = H y,\qquad u^* = U u,\qquad p^* = \mu U/H,\] and the governing equations become \begin{center} \[ \frac{\partial p}{\partial x} = \frac{\rho \,g H^{2}}{\mu U} \sin\alpha + \frac{\partial^{2} u}{\partial y^{2}} = \frac{Re}{Fr} \sin \alpha + \frac{\partial^{2} u}{\partial y^{2}}, \] \[ \frac{\partial p}{\partial y} = -\frac{\rho \,g H^{2}}{\mu U} \cos\alpha = - \frac{Re}{Fr} \cos\alpha. \] \end{center}  The dimensionless grouping $ \rho g H^{2} / (\mu U) $ represents the ratio of gravitational forces to viscous forces and we choose to identify it as a Reynolds number $ Re = \rho U H / \mu$ divided by a Froude number $ Fr = U^{2} / (g H)$.

We proceed by assuming that the flow is driven entirely by the gravitational body force and that there is no additional tangential pressure gradient. Then, integrating the tangential momentum balance twice and using the boundary conditions of no-\/slip at the plane ( $y=0$)and that the free surface ( $y=1$) is tangentially stress-\/free gives \[ u = \frac{1}{2}\frac{Re}{Fr}\sin\alpha \left(2 y - y^{2}\right). \] Integrating the normal momentum balance and setting the reference external pressure to be zero at the free surface gives \[ p = \frac{Re}{Fr}\cos\alpha (1 - y).\]

Finally, we specify a \char`\"{}natural\char`\"{} velocity scale by setting $Re/Fr = 2$, corresponding to the velocity of the free-\/surface for a vertical film ( $\alpha = \pi/2$).

We shall assess the stability of the flat-\/film solution by applying a small, short-\/duration perturbation to the wall velocity and evolving the system in time. If the interface is stable, the perturbation should decay, if not it should grow. A linear stability analysis for this problem was performed by Benjamin (1957) and Yih (1963), who both found that for long waves in the absence of surface tension, the interface was unstable when \[ Re > \frac{5}{4} \sin\alpha. \] (If you read the papers you will see that the Reynolds number was defined such that the average fluid downslope velocity was one; to convert to our Reynolds number, we must multiply by 3/2.)

The figure below shows the time evolution of the interface on a slope of $ \pi/4 $ for Reynolds numbers of zero (red line) and $ 4 \sin\alpha $ (green line). The perturbation wavenumber is $ K = 0.1 $ and the interface rapidly develops waves that grow as they are convected downslope for the higher Reynolds number, but decay when $ Re = 0 $.

 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{animated_surface}
\doxyfigcaption{Time evolution (or static snapshot at t = 7.5) of the interface shape for Re = 0 (Red) and 4 sin(alpha) (Green). }
\end{DoxyImage}


The decay rate of the interfacial perturbation at $ Re = 0 $ is slow, but can be seen in the next figure, which shows the height of the interface at the downstream end of the domain plotted against time. The domain is chosen so that it will contain three waves and the decay or growth of successive crests and troughs can be seen.

 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{time_trace}
\doxyfigcaption{Time history of the interface position at the downstream end of the computational domain. }
\end{DoxyImage}
\hypertarget{index_bound}{}\subsection{A note on the boundary conditions}\label{index_bound}
Resolving the above analytic solution in a finite computational domain requires some thought about boundary conditions. We are only ever free to set one pressure value and setting the external pressure to zero fixes the pressure within the fluid. The boundary conditions at the plane are those of no-\/slip and at the free-\/surface the usual dynamic and kinematic conditions apply. Nonetheless, we have a number of possibilities for the boundary conditions at the \char`\"{}artificial\char`\"{} upstream and downstream computational boundaries.
\begin{DoxyItemize}
\item Prescribe periodic boundary conditions.
\item Prescribe the velocity profile as a Dirichlet condition at both ends.
\item Prescribe the appropriate hydrostatic pressure gradient and zero normal velocity.
\end{DoxyItemize}

We have chosen the last option, in which case the hydrostatic pressure gradient must be consistent with the external pressure. In other words, the pressure must be zero at the free surface ( $y=0$). Changing the external pressure would correspond to changing the film thickness, so the external pressure is directly responsible for enforcing a specific volume constraint, unless $\alpha = \pi/2$. When $\alpha = \pi/2$ there is no variation in hydrostatic pressure through the film and its thickness is not specified by the external pressure.

We must also worry about the boundary conditions on the free surface itself and we choose to impose a contact angle condition of $ \pi/2 $ at the upstream end, which ensures that the film remains flat. At the downstream end, we add a line tension term that arises from use of the surface divergence theorem to integrate the contribution of the dynamic boundary condition. This term can be used to enforce contact angle conditions in a weak formulation, but here we simply add the term using the angle calculated from the current position of the free surface.



 

\hypertarget{index_global}{}\section{Global parameters and functions}\label{index_global}
The global parameters are the Reynolds number, the dimensionless grouping $Re/Fr$, the angle of inclination of the slope $\alpha$, the direction of the gravity vector $G$ and the capillary number $Ca$, which only influences the dynamics.

 
\begin{DoxyCodeInclude}
\textcolor{keyword}{namespace }\hyperlink{namespaceGlobal__Physical__Variables}{Global\_Physical\_Variables}
\{\textcolor{comment}{}
\textcolor{comment}{ ///Reynolds number, based on the average velocity within the fluid film}
\textcolor{comment}{} \textcolor{keywordtype}{double} Re=0.0;
\textcolor{comment}{}
\textcolor{comment}{ ///The product of Reynolds number and inverse Froude number }
\textcolor{comment}{ ///is set to two in this problem, which gives the free surface velocity}
\textcolor{comment}{ ///to be sin(alpha). [Set to three in order to get the same scale as }
\textcolor{comment}{ ///used by Yih, Benjamin, etc]}
\textcolor{comment}{} \textcolor{keywordtype}{double} ReInvFr=2.0;
\textcolor{comment}{}
\textcolor{comment}{ ///Angle of incline of the slope (45 degrees)}
\textcolor{comment}{} \textcolor{keywordtype}{double} Alpha = 1.0*atan(1.0);
\textcolor{comment}{}
\textcolor{comment}{ ///\(\backslash\)short The Vector direction of gravity, set in main()}
\textcolor{comment}{} Vector<double> \hyperlink{namespaceGlobal__Physical__Variables_aa868968dead376240a69f9152bd599b9}{G}(2,0.0);
\textcolor{comment}{}
\textcolor{comment}{ ///The Capillary number}
\textcolor{comment}{} \textcolor{keywordtype}{double} Ca= 1.0;

\end{DoxyCodeInclude}


The hydrostatic pressure field is specified as an applied traction. At the outlet (inlet), the outer unit normal is in the positive (negative) $x$ direction and so the required traction is given by $-p$ ( $p$), \[ \mbox{\boldmath$t$}|_{\mbox{outlet}} = (- (Re/Fr)\cos\alpha (1 - y), 0), \qquad \mbox{\boldmath$t$}|_{\mbox{inlet}} = ((Re/Fr)\cos\alpha (1 - y), 0).\] These tractions are specified by the two different functions 
\begin{DoxyCodeInclude}
 \textcolor{comment}{/// Function that prescribes the hydrostatic pressure field at the outlet}
 \textcolor{keywordtype}{void} \hyperlink{namespaceGlobal__Physical__Variables_ab577639e7c51979d3db7565c08c69c70}{hydrostatic\_pressure\_outlet}(\textcolor{keyword}{const} \textcolor{keywordtype}{double}& time, \textcolor{keyword}{const} Vector<double> &x, 
                                  \textcolor{keyword}{const} Vector<double> &n, 
                                  Vector<double> &traction)
 \{
  traction[0] = ReInvFr*\hyperlink{namespaceGlobal__Physical__Variables_aa868968dead376240a69f9152bd599b9}{G}[1]*(1.0 - x[1]);
  traction[1] = 0.0;
 \}
\textcolor{comment}{}
\textcolor{comment}{ /// Function that prescribes hydrostatic pressure field at the inlet}
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{namespaceGlobal__Physical__Variables_af1f48eb04a3c7f97b1efacea533acdbc}{hydrostatic\_pressure\_inlet}(\textcolor{keyword}{const} \textcolor{keywordtype}{double}& time, \textcolor{keyword}{const} Vector<double> &x, 
                                 \textcolor{keyword}{const} Vector<double> &n,
                                 Vector<double> &traction)
 \{
  traction[0] = -ReInvFr*\hyperlink{namespaceGlobal__Physical__Variables_aa868968dead376240a69f9152bd599b9}{G}[1]*(1.0 - x[1]);
  traction[1] = 0.0;
 \}
 \textcolor{comment}{//end of traction functions}

\end{DoxyCodeInclude}
 Note that {\ttfamily G} \mbox{[} {\ttfamily 1} \mbox{]} is the component of the gravitational body force in the vertical direction, so $ G[1] = - \cos\alpha$.

We must also specify the direction of the normals (directed out of the fluid) to the notional walls that form the inlet and outlet and a contact angle of $ \pi /2 $ that will be used as a boundary condition on the free surface at the upstream end of the domain. In this case the normal to the inlet is in the negative x-\/direction and the normal to the outlet is in the positive x-\/direction. The actual value of the {\ttfamily Wall\+\_\+normal} vector is set in {\ttfamily \hyperlink{inclined__plane_8cc_a3c04138a5bfe5d72780bb7e82a18e627}{main()}} 

 
\begin{DoxyCodeInclude}
 \textcolor{comment}{///Direction of the wall normal vector (at the inlet)}
 Vector<double> \hyperlink{namespaceGlobal__Physical__Variables_a5feb3df21fc4a0adefadecb8a8ed98d7}{Wall\_normal};
\textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Function that specifies the wall unit normal at the inlet}
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{namespaceGlobal__Physical__Variables_aa26e74c1f9f93f8212e45380f55fb562}{wall\_unit\_normal\_inlet\_fct}(\textcolor{keyword}{const} Vector<double> &x, 
                                 Vector<double> &normal)
 \{
  normal=\hyperlink{namespaceGlobal__Physical__Variables_a5feb3df21fc4a0adefadecb8a8ed98d7}{Wall\_normal};
 \}
\textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Function that specified the wall unit normal at the outlet}
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{namespaceGlobal__Physical__Variables_a8ab8f6e823e4cd204ed7264121a42bfb}{wall\_unit\_normal\_outlet\_fct}(\textcolor{keyword}{const} Vector<double> &x, 
                                 Vector<double> &normal)
 \{
  \textcolor{comment}{//Set the normal}
  normal = \hyperlink{namespaceGlobal__Physical__Variables_a5feb3df21fc4a0adefadecb8a8ed98d7}{Wall\_normal};
  \textcolor{comment}{//and flip the sign}
  \textcolor{keywordtype}{unsigned} n\_dim = normal.size();
  \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} i=0;i<n\_dim;++i) \{normal[i] *= -1.0;\}
 \}
\textcolor{comment}{}
\textcolor{comment}{ ///The contact angle that is imposed at the inlet (pi)}
\textcolor{comment}{} \textcolor{keywordtype}{double} Inlet\_Angle = 2.0*atan(1.0);

\end{DoxyCodeInclude}




 

 \hypertarget{index_main}{}\section{The driver code}\label{index_main}
We start by specifying the constitutive law used to define the mesh motion when pseudo-\/elastic deformation is used. 
\begin{DoxyCodeInclude}
\textcolor{comment}{//start of main}
\textcolor{keywordtype}{int} \hyperlink{inclined__plane_8cc_a3c04138a5bfe5d72780bb7e82a18e627}{main}(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char} **argv)
\{
 \textcolor{keyword}{using namespace }\hyperlink{namespaceGlobal__Physical__Variables}{Global\_Physical\_Variables};
 
 \textcolor{comment}{//Set the constitutive law for the mesh deformation}
 \hyperlink{namespaceGlobal__Physical__Variables_a2a37fb040c832ee7a086bb13bb02a100}{Constitutive\_law\_pt}  = \textcolor{keyword}{new} GeneralisedHookean(&
      \hyperlink{namespaceGlobal__Physical__Variables_a3962c36313826b19f216f6bbbdd6a477}{Global\_Physical\_Variables::Nu});

\end{DoxyCodeInclude}
 Next, the type of fluid element is chosen according to specified compiler flags 
\begin{DoxyCodeInclude}
\textcolor{preprocessor}{#ifdef CR\_ELEMENT}
\textcolor{preprocessor}{#define FLUID\_ELEMENT QCrouzeixRaviartElement<2>}
\textcolor{preprocessor}{#else}
\textcolor{preprocessor}{#define FLUID\_ELEMENT QTaylorHoodElement<2>}
\textcolor{preprocessor}{#endif }

\end{DoxyCodeInclude}
 We then initialise the physical parameters, the Reynolds number and the direction of the gravitational body force, both based on the angle of inclination $\alpha$. 
\begin{DoxyCodeInclude}
 \textcolor{comment}{//Initialise physical parameters}
 \textcolor{comment}{//Scale Reynolds number to be independent of alpha.}
 Re = 4.0/sin(Alpha); 

 \textcolor{comment}{//Set the direction of gravity}
 \hyperlink{namespaceGlobal__Physical__Variables_aa868968dead376240a69f9152bd599b9}{G}[0] = sin(Alpha);
 \hyperlink{namespaceGlobal__Physical__Variables_aa868968dead376240a69f9152bd599b9}{G}[1] = -cos(Alpha);

\end{DoxyCodeInclude}
 We also set the direction of the notional wall normal vector. 
\begin{DoxyCodeInclude}

 \textcolor{comment}{//The wall normal to the inlet is in the negative x direction}
 Wall\_normal.resize(2);
 Wall\_normal[0] = -1.0;
 Wall\_normal[1] = 0.0;

\end{DoxyCodeInclude}


We now create the spine version of the problem, solve the steady problem, assign initial conditions by assuming that the problem has been at the steady state for all previous times, and then evolve the system in time. 
\begin{DoxyCodeInclude}
 \textcolor{comment}{//Spine problem}
 \{
  \textcolor{comment}{//Create the problem}
  \hyperlink{classSpineInclinedPlaneProblem}{SpineInclinedPlaneProblem<SpineElement<FLUID\_ELEMENT >}
      , BDF<2> > 
   problem(30,4,\hyperlink{namespaceGlobal__Physical__Variables_a987847160c3cfad8977836291fb9d0e0}{Global\_Physical\_Variables::Length});
  
  \textcolor{comment}{//Solve the steady problem}
  problem.solve\_steady();
  
  \textcolor{comment}{//Prepare the problem for timestepping }
  \textcolor{comment}{//(assume that it's been at the flat-film solution for all previous time)}
  \textcolor{keywordtype}{double} dt = 0.1;
  problem.assign\_initial\_values\_impulsive(dt);
  
  \textcolor{comment}{//Timestep it }
  problem.timestep(dt,2);
 \} \textcolor{comment}{//End of spine problem}

\end{DoxyCodeInclude}
 Finally, exactly the same procedure is performed for the elastic problem 
\begin{DoxyCodeInclude}
 \textcolor{comment}{//Elastic problem}
 \{
  \textcolor{comment}{//Create the problem}
  \hyperlink{classElasticInclinedPlaneProblem}{ElasticInclinedPlaneProblem}<
   PseudoSolidNodeUpdateElement<FLUID\_ELEMENT,QPVDElement<2,3> >, BDF<2> > 
     problem(30,4,\hyperlink{namespaceGlobal__Physical__Variables_a987847160c3cfad8977836291fb9d0e0}{Global\_Physical\_Variables::Length});
  
  \textcolor{comment}{//Solve the steady problem}
  problem.solve\_steady();
  
  \textcolor{comment}{//Prepare the problem for timestepping }
  \textcolor{comment}{//(assume that it's been at the flat-film solution for all previous time)}
  \textcolor{keywordtype}{double} dt = 0.1;
  problem.assign\_initial\_values\_impulsive(dt);

  \textcolor{comment}{//Timestep it}
  problem.timestep(dt,2);
 \} \textcolor{comment}{//End of elastic problem}

\end{DoxyCodeInclude}




 

 \hypertarget{index_mesh}{}\section{The mesh classes}\label{index_mesh}
The base mesh class is the {\ttfamily Simple\+Rectangular\+Quad\+Mesh\+:} boundary 0 will be the wall; boundary 2 will be the free surface; and the remaining boundaries will be the inlet (3) and outlet (1). Below we shall demonstrate how to convert an existing mesh into a {\ttfamily Spine\+Mesh} and {\ttfamily Elastic\+Mesh} suitable for free-\/surface problems.\hypertarget{index_spine_mesh}{}\subsection{Creating the spine mesh}\label{index_spine_mesh}
The {\ttfamily \hyperlink{classSpineInclinedPlaneMesh}{Spine\+Inclined\+Plane\+Mesh}} inherits from the generic {\ttfamily Simple\+Rectangular\+Quad\+Mesh} and adds vertical spines to the Nodes within the mesh in the constructor. Note that the resulting mesh is essentially the same as the {\ttfamily Single\+Layer\+Spine\+Mesh}, but has a somewhat simpler interface.

 
\begin{DoxyCodeInclude}
\textcolor{comment}{/// Create a spine mesh for the problem}
\textcolor{comment}{//======================================================================}
\textcolor{keyword}{template} <\textcolor{keyword}{class} ELEMENT>
\textcolor{keyword}{class }\hyperlink{classSpineInclinedPlaneMesh}{SpineInclinedPlaneMesh} : 
 \textcolor{keyword}{public} SimpleRectangularQuadMesh<ELEMENT>,
 \textcolor{keyword}{public} SpineMesh
\{
\textcolor{keyword}{public}:
 \hyperlink{classSpineInclinedPlaneMesh_a97e770220d4cd41e11c86c5cfa289133}{SpineInclinedPlaneMesh}(\textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} &nx, \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} &ny,
                        \textcolor{keyword}{const} \textcolor{keywordtype}{double} &lx, \textcolor{keyword}{const} \textcolor{keywordtype}{double} &ly,
                        TimeStepper* time\_stepper\_pt) :
  SimpleRectangularQuadMesh<ELEMENT>
 (nx,ny,lx,ly,time\_stepper\_pt), SpineMesh()
  \{
   \textcolor{comment}{//Find the number of linear points in the element}
   \textcolor{keywordtype}{unsigned} n\_p =  \textcolor{keyword}{dynamic\_cast<}ELEMENT*\textcolor{keyword}{>}(finite\_element\_pt(0))->nnode\_1d();
   \textcolor{comment}{//Reserve storage for the number of spines}
   Spine\_pt.reserve((n\_p-1)*nx + 1);
   
   \textcolor{comment}{//Create single pointer to a spine}
   Spine* new\_spine\_pt=0;

   \textcolor{comment}{//Now loop over the elements horizontally}
   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} j=0;j<nx;j++)
    \{
     \textcolor{comment}{//In most elements, we don't assign a spine to the last column,}
     \textcolor{comment}{//beacuse that will be done by the next element}
     \textcolor{keywordtype}{unsigned} n\_pmax = n\_p-1;
     \textcolor{comment}{//In the last element, however, we must assign the final spine}
     \textcolor{keywordflow}{if}(j==nx-1) \{n\_pmax = n\_p;\}

     \textcolor{comment}{//Loop over all nodes horizontally}
     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} l2=0;l2<n\_pmax;l2++)
      \{
       \textcolor{comment}{//Create a new spine with unit height and add to the mesh}
       new\_spine\_pt=\textcolor{keyword}{new} Spine(1.0);
       Spine\_pt.push\_back(new\_spine\_pt);
       
       \textcolor{comment}{// Get the node}
       SpineNode* nod\_pt=element\_node\_pt(j,l2);
       \textcolor{comment}{//Set the pointer to spine}
       nod\_pt->spine\_pt() = new\_spine\_pt;
       \textcolor{comment}{//Set the fraction}
       nod\_pt->fraction() = 0.0;
       \textcolor{comment}{// Pointer to the mesh that implements the update fct}
       nod\_pt->spine\_mesh\_pt() = \textcolor{keyword}{this}; 
       
       \textcolor{comment}{//Loop vertically along the spine}
       \textcolor{comment}{//Loop over the elements }
       \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} i=0;i<ny;i++)
        \{
         \textcolor{comment}{//Loop over the vertical nodes, apart from the first}
         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} l1=1;l1<n\_p;l1++)
          \{
           \textcolor{comment}{// Get the node}
           SpineNode* nod\_pt=element\_node\_pt(i*nx+j,l1*n\_p+l2);
           \textcolor{comment}{//Set the pointer to the spine}
           nod\_pt->spine\_pt() = new\_spine\_pt;
           \textcolor{comment}{//Set the fraction}
           nod\_pt->fraction()=(double(i)+double(l1)/double(n\_p-1))/\textcolor{keywordtype}{double}(ny);
           \textcolor{comment}{// Pointer to the mesh that implements the update fct}
           nod\_pt->spine\_mesh\_pt() = \textcolor{keyword}{this}; 
          \}  
        \}
      \}
    \} \textcolor{comment}{//End of horizontal loop over elements  }
  \} \textcolor{comment}{//end of constructor}

\end{DoxyCodeInclude}
 In addition, a {\ttfamily spine\+\_\+node\+\_\+update()} function must be provided that determines how the {\ttfamily Nodes} move as functions of the {\ttfamily Spines}. 
\begin{DoxyCodeInclude}
 \textcolor{comment}{/// \(\backslash\)short General node update function implements pure virtual function }
\textcolor{comment}{ /// defined in SpineMesh base class and performs specific node update}
\textcolor{comment}{}\textcolor{comment}{ /// actions:  along vertical spines}
\textcolor{comment}{} \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} spine\_node\_update(SpineNode* spine\_node\_pt)
  \{
   \textcolor{comment}{//Get fraction along the spine}
   \textcolor{keywordtype}{double} W = spine\_node\_pt->fraction();
   \textcolor{comment}{//Get spine height}
   \textcolor{keywordtype}{double} H = spine\_node\_pt->h();
   \textcolor{comment}{//Set the value of y}
   spine\_node\_pt->x(1) = W*H;
  \}

\end{DoxyCodeInclude}
\hypertarget{index_elastic_mesh}{}\subsection{Creating the Elastic\+Mesh}\label{index_elastic_mesh}
The {\ttfamily \hyperlink{classElasticInclinedPlaneMesh}{Elastic\+Inclined\+Plane\+Mesh}} inherits from the {\ttfamily Simple\+Rectangular\+Quad\+Mesh} and the undeformed (reference) configuration is set to be the current position of the {\ttfamily Nodes}. 
\begin{DoxyCodeInclude}
\textcolor{comment}{/// Create an Elastic mesh for the problem}
\textcolor{comment}{//======================================================================}
\textcolor{keyword}{template} <\textcolor{keyword}{class} ELEMENT>
\textcolor{keyword}{class }\hyperlink{classElasticInclinedPlaneMesh}{ElasticInclinedPlaneMesh} : 
 \textcolor{keyword}{public} SimpleRectangularQuadMesh<ELEMENT>,
 \textcolor{keyword}{public} SolidMesh
\{
 \textcolor{comment}{//Public functions}
 \textcolor{keyword}{public}:
 \hyperlink{classElasticInclinedPlaneMesh_a61ba6d852505dd1353e791223fdfce04}{ElasticInclinedPlaneMesh}(\textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} &nx, \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} &ny,
                          \textcolor{keyword}{const} \textcolor{keywordtype}{double} &lx, \textcolor{keyword}{const} \textcolor{keywordtype}{double} &ly,
                          TimeStepper* time\_stepper\_pt) :
  SimpleRectangularQuadMesh<ELEMENT>(nx,ny,lx,ly,time\_stepper\_pt), SolidMesh()
  \{
   \textcolor{comment}{//Make the current configuration the undeformed one}
   set\_lagrangian\_nodal\_coordinates();
  \}
\};

\end{DoxyCodeInclude}
 Note that the specification of the Elastic\+Mesh is much simpler than that of a Spine\+Mesh because no decision needs to be taken about how to describe the motion using Spines.



 

\hypertarget{index_problem}{}\section{The problem classes}\label{index_problem}
\hypertarget{index_generic_prob}{}\subsection{The generic problem}\label{index_generic_prob}
For ease of exposition, all generic functionality is included in the {\ttfamily \hyperlink{classInclinedPlaneProblem}{Inclined\+Plane\+Problem}} class, which is templated by the bulk {\ttfamily E\+L\+E\+M\+E\+NT} and the {\ttfamily I\+N\+T\+E\+R\+F\+A\+C\+E\+\_\+\+E\+L\+E\+M\+E\+NT}. The class includes storage for the different sub-\/meshes\+: Bulk, the Traction elements associated with the inlet and outlet, the (free) Surface elements and the point elements associated with the ends of the interface. In addition, a string {\ttfamily Output\+\_\+prefix} is used to distinguish between the output files from different formulations.  
\begin{DoxyCodeInclude}
\textcolor{comment}{///\(\backslash\)short Generic problem class that will form the base class for both }
\textcolor{comment}{///spine and elastic mesh-updates of the problem.}
\textcolor{comment}{}\textcolor{comment}{///Templated by the bulk element and interface element types}
\textcolor{comment}{}\textcolor{comment}{//====================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT, \textcolor{keyword}{class} INTERFACE\_ELEMENT>
\textcolor{keyword}{class }\hyperlink{classInclinedPlaneProblem}{InclinedPlaneProblem} : \textcolor{keyword}{public} Problem
\{

\textcolor{keyword}{protected}:
\textcolor{comment}{}
\textcolor{comment}{ ///Bulk fluid mesh}
\textcolor{comment}{} Mesh* \hyperlink{classInclinedPlaneProblem_a20c506fe684dc146424b8ec019239783}{Bulk\_mesh\_pt};
\textcolor{comment}{}
\textcolor{comment}{ ///Mesh for the traction elements that are added at inlet and outlet}
\textcolor{comment}{} Mesh* \hyperlink{classInclinedPlaneProblem_a85bcc36a8ad4ad7aa3595585e73a3197}{Traction\_mesh\_pt};
\textcolor{comment}{}
\textcolor{comment}{ ///Mesh for the free surface elements}
\textcolor{comment}{} Mesh* \hyperlink{classInclinedPlaneProblem_aba36d367278218bf00356c3bee0733a0}{Surface\_mesh\_pt};
\textcolor{comment}{}
\textcolor{comment}{ ///Mesh for the point elements at each end of the free surface}
\textcolor{comment}{} Mesh* \hyperlink{classInclinedPlaneProblem_adefbac5880323d7de622e2ba0c526746}{Point\_mesh\_pt};
\textcolor{comment}{}
\textcolor{comment}{ ///Prefix for output files}
\textcolor{comment}{} std::string \hyperlink{classInclinedPlaneProblem_a6ad45c76bd24f63c0162313042ce2e7d}{Output\_prefix};

\end{DoxyCodeInclude}


The time-\/dependent perturbation is introduced in the function {\ttfamily actions\+\_\+before\+\_\+implicit\+\_\+timestep()}, which sets the vertical velocity on the wall (boundary 0) \[ v = \epsilon \sin(K x) t \mbox{e}^{-t} \] 
\begin{DoxyCodeInclude}
 \textcolor{keywordtype}{void} actions\_before\_implicit\_timestep()
  \{
   \textcolor{comment}{//Read out the current time}
   \textcolor{keywordtype}{double} time = this->time\_pt()->time();
   \textcolor{comment}{//Now add a temporary sinusoidal suction and blowing to the base}
   \textcolor{comment}{//Amplitude of the perturbation}
   \textcolor{keywordtype}{double} epsilon = 0.01;
   \textcolor{comment}{//Loop over the nodes on the base}
   \textcolor{keywordtype}{unsigned} n\_node = this->Bulk\_mesh\_pt->nboundary\_node(0);
   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} n=0;n<n\_node;n++)
    \{
     Node* nod\_pt = this->Bulk\_mesh\_pt->boundary\_node\_pt(0,n);
     \textcolor{keywordtype}{double} arg = \hyperlink{namespaceGlobal__Physical__Variables_a9da8be10d9e20eb0329af7fd8d6e0e98}{Global\_Physical\_Variables::K}*nod\_pt->x(0);
     \textcolor{keywordtype}{double} value = sin(arg)*epsilon*time*exp(-time);
     nod\_pt->set\_value(1,value);
    \}
  \} \textcolor{comment}{//end\_of\_actions\_before\_implicit\_timestep}

\end{DoxyCodeInclude}


The function {\ttfamily make\+\_\+traction\+\_\+elements()} creates {\ttfamily Navier\+Stokes\+Traction\+Element} s adjacent to the mesh boundaries 3 (the inlet) and 1 (the inlet). These elements are added to the {\ttfamily Mesh} {\ttfamily Traction\+\_\+mesh\+\_\+pt}, which is itself constructed in the function and pointers to the appropriate traction functions are assigned. 
\begin{DoxyCodeInclude}
 \textcolor{comment}{///\(\backslash\)short Function to add the traction boundary elements to boundaries}
\textcolor{comment}{ /// 3(inlet) and 1(outlet) of the mesh}
\textcolor{comment}{} \textcolor{keywordtype}{void} make\_traction\_elements()
  \{
   \textcolor{comment}{//Create a new (empty mesh)}
   Traction\_mesh\_pt = \textcolor{keyword}{new} Mesh;
   \textcolor{comment}{//Inlet boundary conditions (boundary 3)}
   \{
    \textcolor{keywordtype}{unsigned} b = 3;
    \textcolor{comment}{//Find the number of elements adjacent to mesh boundary}
    \textcolor{keywordtype}{unsigned} n\_boundary\_element = Bulk\_mesh\_pt->nboundary\_element(b);
    \textcolor{comment}{//Loop over these elements and create the traction elements}
    \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} e=0;e<n\_boundary\_element;e++)
     \{
      NavierStokesTractionElement<ELEMENT> *surface\_element\_pt =
       \textcolor{keyword}{new} NavierStokesTractionElement<ELEMENT>
       (Bulk\_mesh\_pt->boundary\_element\_pt(b,e),
        Bulk\_mesh\_pt->face\_index\_at\_boundary(b,e));
      \textcolor{comment}{//Add the elements to the mesh}
      Traction\_mesh\_pt->add\_element\_pt(surface\_element\_pt);
      \textcolor{comment}{//Set the traction function}
      surface\_element\_pt->traction\_fct\_pt() = 
       &\hyperlink{namespaceGlobal__Physical__Variables_af1f48eb04a3c7f97b1efacea533acdbc}{Global\_Physical\_Variables::hydrostatic\_pressure\_inlet}
      ;
     \}
   \}
   
   \textcolor{comment}{//Outlet boundary conditions (boundary 1)}
   \{
    \textcolor{keywordtype}{unsigned} b=1;
    \textcolor{comment}{//Find the number of elements adjacent to mesh boundary}
    \textcolor{keywordtype}{unsigned} n\_boundary\_element = Bulk\_mesh\_pt->nboundary\_element(b);
    \textcolor{comment}{//Loop over these elements and create the traction elements}
    \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} e=0;e<n\_boundary\_element;e++)
     \{
      NavierStokesTractionElement<ELEMENT> *surface\_element\_pt =
       \textcolor{keyword}{new} NavierStokesTractionElement<ELEMENT>
       (Bulk\_mesh\_pt->boundary\_element\_pt(b,e),
        Bulk\_mesh\_pt->face\_index\_at\_boundary(b,e));
      \textcolor{comment}{//Add the elements to the mesh}
      Traction\_mesh\_pt->add\_element\_pt(surface\_element\_pt);
      \textcolor{comment}{//Set the traction function}
      surface\_element\_pt->traction\_fct\_pt() = 
       &\hyperlink{namespaceGlobal__Physical__Variables_ab577639e7c51979d3db7565c08c69c70}{Global\_Physical\_Variables::hydrostatic\_pressure\_outlet}
      ;
     \}
   \}
  \} \textcolor{comment}{//end of make\_traction\_elements}

\end{DoxyCodeInclude}


The function {\ttfamily make\+\_\+free\+\_\+surface\+\_\+elements()} creates the appropriate {\ttfamily I\+N\+T\+E\+R\+F\+A\+C\+E\+\_\+\+E\+L\+E\+M\+E\+N\+Ts} adjacent to the free surface (boundary 2), sets the capillary number and also creates free-\/surface boundary elements at the left-\/ and right-\/hand ends of the interface. If these \char`\"{}point\char`\"{} elements are not included then the surface tension is not applied correctly at the edges of the domain. The contact angle is set to be the value {\ttfamily Inlet\+\_\+\+Angle} at the left-\/hand edge of the domain. 
\begin{DoxyCodeInclude}
 \textcolor{comment}{//Make the free surface elements on the top surface}
 \textcolor{keywordtype}{void} make\_free\_surface\_elements()
  \{
   \textcolor{comment}{//Create the (empty) meshes}
   Surface\_mesh\_pt = \textcolor{keyword}{new} Mesh;
   Point\_mesh\_pt = \textcolor{keyword}{new} Mesh;

   \textcolor{comment}{//The free surface is on the boundary 2}
   \textcolor{keywordtype}{unsigned} b = 2;
   \textcolor{keywordtype}{unsigned} n\_boundary\_element = Bulk\_mesh\_pt->nboundary\_element(b);
   \textcolor{comment}{//Loop over the elements and create the appropriate interface elements}
   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} e=0;e<n\_boundary\_element;e++)
    \{
     INTERFACE\_ELEMENT *surface\_element\_pt =
      \textcolor{keyword}{new} INTERFACE\_ELEMENT
      (Bulk\_mesh\_pt->boundary\_element\_pt(b,e),
       Bulk\_mesh\_pt->face\_index\_at\_boundary(b,e));
     \textcolor{comment}{//Add elements to the mesh}
     Surface\_mesh\_pt->add\_element\_pt(surface\_element\_pt);
     \textcolor{comment}{//Assign the capillary number to the free surface}
     surface\_element\_pt->ca\_pt() = 
      &\hyperlink{namespaceGlobal__Physical__Variables_a8b32b93d2e546f9375ec418474107838}{Global\_Physical\_Variables::Ca};
     
     \textcolor{comment}{//Make a point element from left-hand side of the }
     \textcolor{comment}{//first surface element (note that this relies on knowledge of }
     \textcolor{comment}{//the element order within the mesh)}
     \textcolor{keywordflow}{if}(e==0)
      \{
       FluidInterfaceBoundingElement* point\_element\_pt =
        surface\_element\_pt->make\_bounding\_element(-1);
       \textcolor{comment}{//Add element to the point mesh}
       Point\_mesh\_pt->add\_element\_pt(point\_element\_pt);
       \textcolor{comment}{//Set the capillary number}
       point\_element\_pt->ca\_pt() = &\hyperlink{namespaceGlobal__Physical__Variables_a8b32b93d2e546f9375ec418474107838}{Global\_Physical\_Variables::Ca};
       \textcolor{comment}{//Set the wall normal}
       point\_element\_pt->wall\_unit\_normal\_fct\_pt() = 
        &\hyperlink{namespaceGlobal__Physical__Variables_aa26e74c1f9f93f8212e45380f55fb562}{Global\_Physical\_Variables::wall\_unit\_normal\_inlet\_fct}
      ;
       \textcolor{comment}{//Set the contact angle (using the strong version of the constraint)}
       point\_element\_pt->set\_contact\_angle(
        &\hyperlink{namespaceGlobal__Physical__Variables_a1c3587461447262715bd444ac91a29c9}{Global\_Physical\_Variables::Inlet\_Angle});
      \}
     
     \textcolor{comment}{//Make another point element from the right-hand side of the }
     \textcolor{comment}{//last surface element (note that this relies on knowledge of }
     \textcolor{comment}{//the element order within the mesh)}
     \textcolor{keywordflow}{if}(e==n\_boundary\_element-1)
      \{
       FluidInterfaceBoundingElement* point\_element\_pt =
        surface\_element\_pt->make\_bounding\_element(1);
       \textcolor{comment}{//Add element to the mesh}
       Point\_mesh\_pt->add\_element\_pt(point\_element\_pt);
       \textcolor{comment}{//Set the capillary number}
       point\_element\_pt->ca\_pt() = &\hyperlink{namespaceGlobal__Physical__Variables_a8b32b93d2e546f9375ec418474107838}{Global\_Physical\_Variables::Ca};
       \textcolor{comment}{// Set the function that specifies the wall normal}
       point\_element\_pt->wall\_unit\_normal\_fct\_pt() = 
        &\hyperlink{namespaceGlobal__Physical__Variables_a8ab8f6e823e4cd204ed7264121a42bfb}{Global\_Physical\_Variables::wall\_unit\_normal\_outlet\_fct}
      ;
      \}
    \}
  \} \textcolor{comment}{//end of make\_free\_surface\_elements}

\end{DoxyCodeInclude}


The function {\ttfamily complete\+\_\+build()} assigns physical parameters to the fluid elements, sets the boundary conditions and assigns equation numbers.  
\begin{DoxyCodeInclude}
 \textcolor{keywordtype}{void} complete\_build()
  \{
   \textcolor{keyword}{using namespace }\hyperlink{namespaceGlobal__Physical__Variables}{Global\_Physical\_Variables};
   
   \textcolor{comment}{//Complete the build of the fluid elements by passing physical parameters}
   \textcolor{comment}{//Find the number of bulk elements}
   \textcolor{keywordtype}{unsigned} n\_element = Bulk\_mesh\_pt->nelement();
   \textcolor{comment}{//Loop over all the fluid elements }
   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} e=0;e<n\_element;e++)
    \{
     \textcolor{comment}{//Cast to a fluid element}
     ELEMENT *temp\_pt = \textcolor{keyword}{dynamic\_cast<}ELEMENT*\textcolor{keyword}{>}(Bulk\_mesh\_pt->element\_pt(e));
     
     \textcolor{comment}{//Set the Reynolds number}
     temp\_pt->re\_pt() = &\hyperlink{namespaceGlobal__Physical__Variables_ab814e627d2eb5bc50318879d19ab16b9}{Re};
     \textcolor{comment}{//The Strouhal number is 1, so ReSt = Re}
     temp\_pt->re\_st\_pt() = &\hyperlink{namespaceGlobal__Physical__Variables_ab814e627d2eb5bc50318879d19ab16b9}{Re};
     \textcolor{comment}{//Set the Reynolds number / Froude number}
     temp\_pt->re\_invfr\_pt() = &\hyperlink{namespaceGlobal__Physical__Variables_aa6286f02b476912dd7550eced538331a}{ReInvFr};
     \textcolor{comment}{//Set the direction of gravity}
     temp\_pt->g\_pt() = &\hyperlink{namespaceGlobal__Physical__Variables_aa868968dead376240a69f9152bd599b9}{G};
    \}
   
   \textcolor{comment}{//------------Set the boundary conditions for this problem----------}

   \{
    \textcolor{comment}{//Determine whether we are solving an elastic problem or not}
    \textcolor{keywordtype}{bool} elastic = \textcolor{keyword}{false};
    \textcolor{keywordflow}{if}(dynamic\_cast<SolidNode*>(Bulk\_mesh\_pt->node\_pt(0))) \{elastic=\textcolor{keyword}{true};\}

    \textcolor{comment}{//Loop over the bottom of the mesh (the wall of the channel)}
    \textcolor{keywordtype}{unsigned} n\_node = Bulk\_mesh\_pt->nboundary\_node(0);
    \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} j=0;j<n\_node;j++)
     \{
      \textcolor{comment}{//Pin the u- and v- velocities}
      Bulk\_mesh\_pt->boundary\_node\_pt(0,j)->pin(0);
      Bulk\_mesh\_pt->boundary\_node\_pt(0,j)->pin(1);

      \textcolor{comment}{//If we are formulating the elastic problem pin both positions}
      \textcolor{comment}{//of nodes}
      \textcolor{keywordflow}{if}(elastic)
       \{
        \textcolor{keyword}{static\_cast<}SolidNode*\textcolor{keyword}{>}(Bulk\_mesh\_pt->boundary\_node\_pt(0,j))
         ->pin\_position(0);
        \textcolor{keyword}{static\_cast<}SolidNode*\textcolor{keyword}{>}(Bulk\_mesh\_pt->boundary\_node\_pt(0,j))
         ->pin\_position(1);
       \}
     \}
    
    \textcolor{comment}{//Loop over the inlet and set the Dirichlet condition}
    \textcolor{comment}{//of no vertical velocity}
    n\_node = Bulk\_mesh\_pt->nboundary\_node(3);
    \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} j=0;j<n\_node;j++)
     \{
      Bulk\_mesh\_pt->boundary\_node\_pt(3,j)->pin(1);

      \textcolor{comment}{//If elastic pin horizontal position of nodes}
      \textcolor{keywordflow}{if}(elastic)
       \{ 
        \textcolor{keyword}{static\_cast<}SolidNode*\textcolor{keyword}{>}(Bulk\_mesh\_pt->boundary\_node\_pt(3,j))
         ->pin\_position(0);
       \}
     \}
    
    \textcolor{comment}{//Loop over the outlet and set the Dirichlet condition}
    \textcolor{comment}{//of no vertical velocity}
    n\_node = Bulk\_mesh\_pt->nboundary\_node(1);
    \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} j=0;j<n\_node;j++)
     \{
      Bulk\_mesh\_pt->boundary\_node\_pt(1,j)->pin(1);

      \textcolor{comment}{//If elastic pin horizontal position}
      \textcolor{keywordflow}{if}(elastic)
       \{ 
        \textcolor{keyword}{static\_cast<}SolidNode*\textcolor{keyword}{>}(Bulk\_mesh\_pt->boundary\_node\_pt(1,j))
         ->pin\_position(0);
       \}
     \}
   \}
 
   \textcolor{comment}{//Attach the boundary conditions to the mesh}
   std::cout << assign\_eqn\_numbers() << \textcolor{stringliteral}{" in the main problem"} << std::endl; 
  \} \textcolor{comment}{//end of complete\_build}

\end{DoxyCodeInclude}
 Note that boundary conditions for the nodal positions in the pseudo-\/elastic formulation are specified by testing whether the {\ttfamily Nodes} are {\ttfamily Solid\+Nodes}. In this case, the {\ttfamily Nodes} on the inlet and outlet boundaries are constrained to remain at the same horizontal position and the {\ttfamily Nodes} on the plane wall are fixed.

The function {\ttfamily solve\+\_\+steady()} initialises the velocity of at all {\ttfamily Nodes} to the flat-\/film solution, solves the steady equations and writes the solution to a file. 
\begin{DoxyCodeInclude}
\textcolor{keywordtype}{void} \hyperlink{classInclinedPlaneProblem_a0e2fcfdb8230df82729ba7d728e58040}{InclinedPlaneProblem<ELEMENT,INTERFACE\_ELEMENT>::solve\_steady}
      ()
\{
 \textcolor{comment}{//Load the namespace}
 \textcolor{keyword}{using namespace }\hyperlink{namespaceGlobal__Physical__Variables}{Global\_Physical\_Variables};
 
 \textcolor{comment}{//Initially set all nodes to the Nusselt flat-film solution}
 \{
  \textcolor{keywordtype}{unsigned} n\_node = Bulk\_mesh\_pt->nnode();
  \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned}  n=0;n<n\_node;n++)
   \{
    \textcolor{keywordtype}{double} y = Bulk\_mesh\_pt->node\_pt(n)->x(1);
    \textcolor{comment}{//Top row}
    Bulk\_mesh\_pt->node\_pt(n)->set\_value(0,0.5*ReInvFr*sin(Alpha)*(2.0*y - y*y));
   \}
 \}
 
 \textcolor{comment}{//Do one steady solve}
 steady\_newton\_solve();

 \textcolor{comment}{//Output the full flow field}
 std::string filename = Output\_prefix;;
 filename.append(\textcolor{stringliteral}{"\_output.dat"});
 ofstream file(filename.c\_str());
 Bulk\_mesh\_pt->output(file,5);
 file.close();
\} \textcolor{comment}{//end of solve\_steady}

\end{DoxyCodeInclude}


Finally, the function {\ttfamily timestep()} takes a number of fixed timesteps writing vertical positions and the time to a trace file and writing the complete flow field to disk after a given number of timesteps. 
\begin{DoxyCodeInclude}
timestep(\textcolor{keyword}{const} \textcolor{keywordtype}{double} &dt, \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} &n\_tsteps)
\{
 \textcolor{comment}{//Need to use the Global variables here}
 \textcolor{keyword}{using namespace }\hyperlink{namespaceGlobal__Physical__Variables}{Global\_Physical\_Variables};
 
 \textcolor{comment}{//Open an output file}
 std::string filename = Output\_prefix;
 filename.append(\textcolor{stringliteral}{"\_time\_trace.dat"});
 ofstream trace(filename.c\_str()); 
 \textcolor{comment}{//Counter that will be used to output the full flowfield}
 \textcolor{comment}{//at certain timesteps}
 \textcolor{keywordtype}{int} counter=0; 
 
 \textcolor{comment}{//Initial output of the time and the value of the vertical position at the}
 \textcolor{comment}{//left and right-hand end of the free surface}
 trace << time\_pt()->time() << \textcolor{stringliteral}{" "} 
       << Bulk\_mesh\_pt->boundary\_node\_pt(2,0)->value(1) 
       << \textcolor{stringliteral}{" "}
       <<  Bulk\_mesh\_pt->
  boundary\_node\_pt(2, Bulk\_mesh\_pt->nboundary\_node(2)-1)->x(1) 
       << \textcolor{stringliteral}{" "}
       << std::endl;
 
 \textcolor{comment}{//Loop over the desired number of timesteps}
 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} t=1;t<=n\_tsteps;t++)
  \{
   \textcolor{comment}{//Increase the counter}
   counter++;
   cout << std::endl;
   cout << \textcolor{stringliteral}{"--------------TIMESTEP "} << t<< \textcolor{stringliteral}{" ------------------"} << std::endl;
   
   \textcolor{comment}{//Take a timestep of size dt}
   unsteady\_newton\_solve(dt);
   
   \textcolor{comment}{//Uncomment to get full solution output}
   \textcolor{keywordflow}{if}(counter==2) \textcolor{comment}{//Change this number to get output every n steps}
    \{
     std::ofstream file;
     std::ostringstream filename;
     filename << Output\_prefix << \textcolor{stringliteral}{"\_step"} << Re << \textcolor{stringliteral}{"\_"} << t << \textcolor{stringliteral}{".dat"};
     file.open(filename.str().c\_str());
     Bulk\_mesh\_pt->output(file,5);
     file.close();
     
     counter=0;
    \}

   \textcolor{comment}{//Always output the interface}
   \{
    std::ofstream file;
     std::ostringstream filename;
     filename << Output\_prefix << \textcolor{stringliteral}{"\_interface\_"} << Re << \textcolor{stringliteral}{"\_"} << t << \textcolor{stringliteral}{".dat"};
     file.open(filename.str().c\_str());
     Surface\_mesh\_pt->output(file,5);
     file.close();
   \}
   
   \textcolor{comment}{//Output the time and value of the vertical position of the free surface}
   \textcolor{comment}{//at the left- and right-hand ends}
   trace << time\_pt()->time() << \textcolor{stringliteral}{" "}
         << Bulk\_mesh\_pt->boundary\_node\_pt(2,0)->x(1) << \textcolor{stringliteral}{" "}
         << 
    Bulk\_mesh\_pt->
    boundary\_node\_pt(2,Bulk\_mesh\_pt->nboundary\_node(2)-1)->x(1) << \textcolor{stringliteral}{" "}
         << std::endl;
  \}
\} \textcolor{comment}{//end of timestep}

\end{DoxyCodeInclude}
\hypertarget{index_spine_prob}{}\subsection{The spine-\/based formulation}\label{index_spine_prob}
The class {\ttfamily \hyperlink{classSpineInclinedPlaneProblem}{Spine\+Inclined\+Plane\+Problem}} inherits from the generic {\ttfamily \hyperlink{classInclinedPlaneProblem}{Inclined\+Plane\+Problem}} class and requires only minor modification. The constructor sets the string {\ttfamily Output\+\_\+prefix}, builds a timestepper, builds the specific {\ttfamily Spine\+Mesh}, creates the appropriate {\ttfamily Face\+Elements}, adds all sub-\/meshes to the {\ttfamily Problem}, builds the global mesh and then calls {\ttfamily \hyperlink{classInclinedPlaneProblem_ae44e360be4a46e1343c3960c3a43380f}{Inclined\+Plane\+Problem\+::complete\+\_\+build()}}. 
\begin{DoxyCodeInclude}
 \hyperlink{classSpineInclinedPlaneProblem}{SpineInclinedPlaneProblem}(\textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} &nx, \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} &ny,
                      \textcolor{keyword}{const} \textcolor{keywordtype}{double} &length): 
  \hyperlink{classInclinedPlaneProblem}{InclinedPlaneProblem}<ELEMENT,SpineLineFluidInterfaceElement<ELEMENT> >
  (nx,ny,length) 
  \{
   \textcolor{comment}{//Set the name}
   this->Output\_prefix = \textcolor{stringliteral}{"spine"};

   \textcolor{comment}{//Create our one and only timestepper, with adaptive timestepping}
   this->add\_time\_stepper\_pt(\textcolor{keyword}{new} TIMESTEPPER);

   \textcolor{comment}{//Create the bulk mesh}
   this->Bulk\_mesh\_pt = \textcolor{keyword}{new}  \hyperlink{classSpineInclinedPlaneMesh}{SpineInclinedPlaneMesh<ELEMENT>}(
    nx,ny,length,1.0,this->time\_stepper\_pt());

   \textcolor{comment}{//Create the traction elements}
   this->make\_traction\_elements();
   \textcolor{comment}{//Create the free surface elements}
   this->make\_free\_surface\_elements();

   \textcolor{comment}{//Add all sub meshes to the problem}
   this->add\_sub\_mesh(this->Bulk\_mesh\_pt);
   this->add\_sub\_mesh(this->Traction\_mesh\_pt);
   this->add\_sub\_mesh(this->Surface\_mesh\_pt);
   this->add\_sub\_mesh(this->Point\_mesh\_pt);
   \textcolor{comment}{//Create the global mesh}
   this->build\_global\_mesh();

   \textcolor{comment}{//Complete the build of the problem}
   this->complete\_build();
  \}

\end{DoxyCodeInclude}


In a spine-\/based formulation, the nodal positions must be updated after every Newton step, which is achieved by overloading the function {\ttfamily Problem\+::actions\+\_\+before\+\_\+newton\+\_\+convergence\+\_\+check()} 
\begin{DoxyCodeInclude}
 \textcolor{comment}{/// Spine heights/lengths are unknowns in the problem so their}
\textcolor{comment}{ /// values get corrected during each Newton step. However,}
\textcolor{comment}{}\textcolor{comment}{ /// changing their value does not automatically change the}
\textcolor{comment}{}\textcolor{comment}{ /// nodal positions, so we need to update all of them}
\textcolor{comment}{} \textcolor{keywordtype}{void} actions\_before\_newton\_convergence\_check()
  \{this->Bulk\_mesh\_pt->node\_update();\}

\end{DoxyCodeInclude}


We also specify a destructor to clean up memory allocated by the class.\hypertarget{index_elastic_probe}{}\subsection{The pseudo-\/solid-\/based formulation}\label{index_elastic_probe}
The class {\ttfamily \hyperlink{classElasticInclinedPlaneProblem}{Elastic\+Inclined\+Plane\+Problem}} inherits from the generic {\ttfamily \hyperlink{classInclinedPlaneProblem}{Inclined\+Plane\+Problem}} class and also requires only minor modification. The constructor sets the string {\ttfamily Output\+\_\+prefix}, builds a timestepper, builds the specific {\ttfamily Solid\+Mesh}, sets the constitutive law for the bulk elements, creates the appropriate {\ttfamily Face\+Elements}, adds all sub-\/meshes to the {\ttfamily Problem}, builds the global mesh and then calls {\ttfamily \hyperlink{classInclinedPlaneProblem_ae44e360be4a46e1343c3960c3a43380f}{Inclined\+Plane\+Problem\+::complete\+\_\+build()}} 
\begin{DoxyCodeInclude}
 \hyperlink{classElasticInclinedPlaneProblem}{ElasticInclinedPlaneProblem}(\textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} &nx, \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} &ny,
                      \textcolor{keyword}{const} \textcolor{keywordtype}{double} &length) :
  \hyperlink{classInclinedPlaneProblem}{InclinedPlaneProblem}<ELEMENT,ElasticLineFluidInterfaceElement<ELEMENT> >
  (nx,ny,length) 
  \{
   \textcolor{comment}{//Set the name}
   this->Output\_prefix = \textcolor{stringliteral}{"elastic"};
   
   \textcolor{comment}{//Create our one and only timestepper, with adaptive timestepping}
   this->add\_time\_stepper\_pt(\textcolor{keyword}{new} TIMESTEPPER);

   \textcolor{comment}{//Create the bulk mesh}
   this->Bulk\_mesh\_pt = \textcolor{keyword}{new}  \hyperlink{classElasticInclinedPlaneMesh}{ElasticInclinedPlaneMesh<ELEMENT>}(
    nx,ny,length,1.0,this->time\_stepper\_pt());

   \textcolor{comment}{//Set the consititutive law for the elements}
   \textcolor{keywordtype}{unsigned} n\_element = this->Bulk\_mesh\_pt->nelement();
   \textcolor{comment}{//Loop over all the fluid elements }
   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} e=0;e<n\_element;e++)
    \{
     \textcolor{comment}{//Cast to a fluid element}
     ELEMENT *temp\_pt = \textcolor{keyword}{dynamic\_cast<}ELEMENT*\textcolor{keyword}{>}(
      this->Bulk\_mesh\_pt->element\_pt(e));
     \textcolor{comment}{//Set the constitutive law }
     temp\_pt->constitutive\_law\_pt() = 
      \hyperlink{namespaceGlobal__Physical__Variables_a2a37fb040c832ee7a086bb13bb02a100}{Global\_Physical\_Variables::Constitutive\_law\_pt};
    \}
   
   \textcolor{comment}{//Create the traction elements}
   this->make\_traction\_elements();
   \textcolor{comment}{//Create the free surface element}
   this->make\_free\_surface\_elements();

   \textcolor{comment}{//Add all sub meshes to the problem}
   this->add\_sub\_mesh(this->Bulk\_mesh\_pt);
   this->add\_sub\_mesh(this->Traction\_mesh\_pt);
   this->add\_sub\_mesh(this->Surface\_mesh\_pt);
   this->add\_sub\_mesh(this->Point\_mesh\_pt);
   \textcolor{comment}{//Create the global mesh}
   this->build\_global\_mesh();

   \textcolor{comment}{//Complete the rest of the build}
   this->complete\_build();
  \} \textcolor{comment}{//end of constructor}

\end{DoxyCodeInclude}


In a pseudo-\/solid formulation, it is advantageous to reset the undeformed configuration after every timestep (an updated Lagrangian formulation). Hence, the {\ttfamily Problem\+::actions\+\_\+after\+\_\+implicit\+\_\+timestep()} function is overloaded 
\begin{DoxyCodeInclude}
 \textcolor{keywordtype}{void} actions\_after\_implicit\_timestep()
  \{
   \textcolor{comment}{//Now loop over all the nodes and reset their Lagrangian coordinates}
   \textcolor{keywordtype}{unsigned} n\_node = this->Bulk\_mesh\_pt->nnode();
   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} n=0;n<n\_node;n++)
    \{
     \textcolor{comment}{//Cast node to an elastic node}
     SolidNode* temp\_pt = 
      \textcolor{keyword}{static\_cast<}SolidNode*\textcolor{keyword}{>}(this->Bulk\_mesh\_pt->node\_pt(n));
     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} j=0;j<2;j++) \{temp\_pt->xi(j) = temp\_pt->x(j);\}
    \}
  \} \textcolor{comment}{//end of actions\_after\_implicit\_timestep}

\end{DoxyCodeInclude}


We also specify a destructor to clean up memory allocated by the class.



 

\hypertarget{index_exercises}{}\section{Exercises}\label{index_exercises}

\begin{DoxyEnumerate}
\item Confirm that the steady solution agrees with the exact solution.
\item Investigate what happens when the angle is varied. What happens when the angle is set to zero? What happens when the angle is set to $\pi/2$?
\item What happens if the hydrostatic pressure boundary conditions are not applied?
\item How does the stability of the system to the perturbation change with angle, $ Ca $ and $ K $? Are the results in agreement with the theoretical predictions?
\item Are the results independent of the length of the domain?
\item Compare the spine-\/based and pseudo-\/elastic-\/based formulations? What is the same and what is different? Which method do you prefer? 

 


\end{DoxyEnumerate}\hypertarget{index_sources}{}\section{Source files for this tutorial}\label{index_sources}

\begin{DoxyItemize}
\item The source files for this tutorial are located in the directory\+:~\newline
~\newline
\begin{center} \href{../../../../demo_drivers/navier_stokes/inclined_plane/}{\tt demo\+\_\+drivers/navier\+\_\+stokes/inclined\+\_\+plane/ } \end{center} ~\newline

\item The driver code is\+: ~\newline
~\newline
\begin{center} \href{../../../../demo_drivers/navier_stokes/inclined_plane/inclined_plane.cc}{\tt demo\+\_\+drivers/navier\+\_\+stokes/inclined\+\_\+plane/inclined\+\_\+plane.\+cc } \end{center} 
\end{DoxyItemize}



 

 \hypertarget{index_pdf}{}\section{P\+D\+F file}\label{index_pdf}
A \href{../latex/refman.pdf}{\tt pdf version} of this document is available. \end{document}
