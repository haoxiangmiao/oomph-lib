This tutorial discusses the solution of the classical Bretherton problem in which an air-\/finger is driven steadily into a 2D fluid-\/filled, rigid-\/walled channel.

The driver code listed below was originally developed as a test-\/bed for the paper

\begin{center} Hazel, A.\+L. \& Heil, M. (2008) The influence of gravity on the steady propagation of a semi-\/infinite bubble into a flexible channel. Physics of Fluids 20, 092109 \href{http://www.maths.manchester.ac.uk/~mheil/MATTHIAS/PDF/HazelHeilPoF2008.pdf}{\tt (pdf reprint)} \end{center} 

in which we studied the elastic-\/walled equivalent, paying particular attention to the effect of transverse gravity which plays quite an important role in this problem.

Compared to other tutorials, there is no detailed discussion of the driver code itself because the implementation is somewhat messy. However, given that the driver code is (of course!) very well documented you should be able to figure out what\textquotesingle{}s going on once you\textquotesingle{}ve read through the discussion of the problem formulation and our brief comments on the \hyperlink{index_implement}{Implementation}. \href{../../../contact/html/index.html}{\tt Get in touch} if you need more information.\hypertarget{index_problem}{}\section{The problem}\label{index_problem}
The sketch below shows the problem setup\+: An (inviscid) air finger propagates at a steady speed $ U $ into a 2D rigid-\/walled, fluid-\/filled channel of half-\/width $ H_0^* $. In the process it displaces some of the viscous fluid (of density $ \rho $, viscosity $ \mu $ and surface tension $ \sigma^* $) and deposits a film of thickness $ h_0^* $ on the channel walls. \mbox{[}Note that, for the sake of simplicity, we ignore the effect of transverse gravity in this discussion; the driver code listed below allows the specification of a gravitational body force which will break the up-\/down symmetry of the solution.\mbox{]}

 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{bretherton_sketch}
\doxyfigcaption{Sketch of the problem setup }
\end{DoxyImage}


We non-\/dimensionalise the velocities on $ U $, the lengths on $ H_0^* $ and the pressure on the viscous scale, $ \mu U / H_0^* $ and solve the problem in a frame moving with the velocity of the finger. The flow is then governed by the non-\/dimensional Navier-\/\+Stokes equations \[ Re \ u_j\frac{\partial u_i}{\partial x_j} = -\frac{\partial p}{\partial x_i} + \ \frac{\partial }{\partial x_j }\left( \frac{\partial u_i}{\partial x_j} + \frac{\partial u_j}{\partial x_i} \right) \] and the continuity equation \[ \frac{\partial u_i}{\partial x_i}=0, \] where the Reynolds number is defined as $ Re=U H_0 \rho/\mu $. On the free fluid surface, whose outer unit normal we denote by $ {\bf n} $, the fluid normal velocity vanishes, \[ {\bf u} \cdot {\bf n} = 0 \mbox{\ \ \ on the air-liquid interface}. \] We measure the fluid pressure $ p $ relative to the bubble pressure $ p_b $. Then the dynamic boundary condition implies that \[ -p n_i + \left( \frac{\partial u_i}{\partial x_j} + \frac{\partial u_j}{\partial x_i} \right) n_j + \frac{1}{Ca} \ \kappa_f n_i = 0 \mbox{\ \ \ on the air-liquid interface,} \] where $ \kappa_f = \kappa_f^* H_0 $ is the non-\/dimensional interface curvature and the capillary number $ Ca = U\mu/\sigma^* $ is a non-\/dimensional measure of the bubble velocity. The no-\/slip condition on the channel walls requires that $ {\bf u}=(-1,0) $ at $ x_2=\pm 1 $. Far behind the bubble tip, the fluid remains stationary on the walls. In the moving frame of reference, this corresponds to the plug flow profile $ {\bf u}=(-1,0) $ as $ x_1\to -\infty $. The residual film thickness $ h_0 $ has to be determined as part of the solution and it determines the volume flux through the system. The Poiseuille velocity profile far ahead of the bubble tip, \[ {\bf u}=(-1+\frac{3}{2}(1-h_0)(1-x_2^2),0) \mbox{\ \ \ as $ x_1\to \infty$,} \ \ \ \ \ \ \ \ (1) \] is then determined by overall continuity.



 

\hypertarget{index_results}{}\section{Some results}\label{index_results}
Here are some pretty pictures of the computed flow field,

 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{bretherton_flow_with_streamlines}
\doxyfigcaption{Velocity and pressure fields }
\end{DoxyImage}


and here is a comparison of the computational predictions for the bubble pressure and film thickness against Bretherton\textquotesingle{}s famous asymptotic predictions (valid only for small capillary numbers!)\+:

 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{bretherton_trace}
\doxyfigcaption{Bubble pressure and film thickness far behind the finger tip vs. capillary number; computed solution and Bretherton\textquotesingle{}s predictions for small Ca. }
\end{DoxyImage}




 

\hypertarget{index_implement}{}\section{Implementation}\label{index_implement}
The discretisation of the problem is reasonably straightforward, the most (human-\/)time-\/consuming part being the creation of the spine mesh, discussed in \href{../../../navier_stokes/spine_channel/html/index.html}{\tt another tutorial}. The real complication arises from the fact that the application of the \char`\"{}inflow condition\char`\"{} (1) at the right end of the domain -- superficially a Dirichlet condition for the velocity -- depends on the non-\/dimensional film thickness $ h_0 $ at the left end of the domain. This introduces a non-\/local interaction between these degrees of freedom. We handle this by providing a templated wrapper class {\ttfamily \hyperlink{classBrethertonElement}{Bretherton\+Element}} (templated by the type of the \char`\"{}wrapped\char`\"{} fluid element) which allows the specification of the film thickness as external {\ttfamily Data} (i.\+e. {\ttfamily Data} whose values affect the element\textquotesingle{}s residuals but are not determined by the element; see the discussion of {\ttfamily oomph-\/lib\textquotesingle{}s} various types of elemental {\ttfamily Data} in \href{../../../the_data_structure/html/index.html}{\tt the \char`\"{}bottom up\char`\"{} discussion of the library\textquotesingle{}s data structure}). Read the driver code listed below to see how it works!



 

\hypertarget{index_driver}{}\section{The driver code}\label{index_driver}

\begin{DoxyCodeInclude}
\textcolor{comment}{//LIC// ====================================================================}
\textcolor{comment}{//LIC// This file forms part of oomph-lib, the object-oriented, }
\textcolor{comment}{//LIC// multi-physics finite-element library, available }
\textcolor{comment}{//LIC// at http://www.oomph-lib.org.}
\textcolor{comment}{//LIC// }
\textcolor{comment}{//LIC//    Version 1.0; svn revision $LastChangedRevision$}
\textcolor{comment}{//LIC//}
\textcolor{comment}{//LIC// $LastChangedDate$}
\textcolor{comment}{//LIC// }
\textcolor{comment}{//LIC// Copyright (C) 2006-2016 Matthias Heil and Andrew Hazel}
\textcolor{comment}{//LIC// }
\textcolor{comment}{//LIC// This library is free software; you can redistribute it and/or}
\textcolor{comment}{//LIC// modify it under the terms of the GNU Lesser General Public}
\textcolor{comment}{//LIC// License as published by the Free Software Foundation; either}
\textcolor{comment}{//LIC// version 2.1 of the License, or (at your option) any later version.}
\textcolor{comment}{//LIC// }
\textcolor{comment}{//LIC// This library is distributed in the hope that it will be useful,}
\textcolor{comment}{//LIC// but WITHOUT ANY WARRANTY; without even the implied warranty of}
\textcolor{comment}{//LIC// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU}
\textcolor{comment}{//LIC// Lesser General Public License for more details.}
\textcolor{comment}{//LIC// }
\textcolor{comment}{//LIC// You should have received a copy of the GNU Lesser General Public}
\textcolor{comment}{//LIC// License along with this library; if not, write to the Free Software}
\textcolor{comment}{//LIC// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA}
\textcolor{comment}{//LIC// 02110-1301  USA.}
\textcolor{comment}{//LIC// }
\textcolor{comment}{//LIC// The authors may be contacted at oomph-lib@maths.man.ac.uk.}
\textcolor{comment}{//LIC// }
\textcolor{comment}{//LIC//====================================================================}
\textcolor{comment}{// The 2D Bretherton problem}
\textcolor{preprocessor}{#include<algorithm>}
 
\textcolor{comment}{// The oomphlib headers   }
\textcolor{preprocessor}{#include "generic.h"}
\textcolor{preprocessor}{#include "navier\_stokes.h"}
\textcolor{preprocessor}{#include "fluid\_interface.h"}

\textcolor{comment}{// The mesh}
\textcolor{preprocessor}{#include "meshes/bretherton\_spine\_mesh.h"}

\textcolor{keyword}{using namespace }\hyperlink{namespacestd}{std};
 
\textcolor{keyword}{using namespace }\hyperlink{namespaceoomph}{oomph};

\textcolor{comment}{//======================================================================}\textcolor{comment}{}
\textcolor{comment}{/// Namepspace for global parameters}
\textcolor{comment}{}\textcolor{comment}{//======================================================================}
\textcolor{keyword}{namespace }\hyperlink{namespaceGlobal__Physical__Variables}{Global\_Physical\_Variables}
\{
 \textcolor{comment}{}
\textcolor{comment}{ /// Reynolds number}
\textcolor{comment}{} \textcolor{keywordtype}{double} \hyperlink{namespaceGlobal__Physical__Variables_ab814e627d2eb5bc50318879d19ab16b9}{Re};
\textcolor{comment}{}
\textcolor{comment}{ /// Womersley = Reynolds times Strouhal}
\textcolor{comment}{} \textcolor{keywordtype}{double} \hyperlink{namespaceGlobal__Physical__Variables_a085ee4bf968ffdd01a41b8c41864f907}{ReSt}; 
 \textcolor{comment}{}
\textcolor{comment}{ /// Product of Reynolds and Froude number}
\textcolor{comment}{} \textcolor{keywordtype}{double} \hyperlink{namespaceGlobal__Physical__Variables_aa6286f02b476912dd7550eced538331a}{ReInvFr};
\textcolor{comment}{}
\textcolor{comment}{ /// Capillary number}
\textcolor{comment}{} \textcolor{keywordtype}{double} \hyperlink{namespaceGlobal__Physical__Variables_a8b32b93d2e546f9375ec418474107838}{Ca};  
\textcolor{comment}{}
\textcolor{comment}{ /// Direction of gravity}
\textcolor{comment}{} Vector<double> \hyperlink{namespaceGlobal__Physical__Variables_a18fe245262ec8beec764c805bb93e73c}{G}(2);
\textcolor{comment}{}
\textcolor{comment}{ /// Pointer to film thickness at outflow on the lower wall}
\textcolor{comment}{} \textcolor{keywordtype}{double}* \hyperlink{namespaceGlobal__Physical__Variables_a137bdac2ad4b72a03ec9916e8ee7395b}{H\_lo\_pt};
\textcolor{comment}{}
\textcolor{comment}{ /// Pointer to film thickness at outflow on the upper wall}
\textcolor{comment}{} \textcolor{keywordtype}{double}* \hyperlink{namespaceGlobal__Physical__Variables_a83a3a82f89784013805bd23d63faa7e3}{H\_up\_pt};
\textcolor{comment}{}
\textcolor{comment}{ /// Pointer to y-position at inflow on the lower wall}
\textcolor{comment}{} \textcolor{keywordtype}{double}* \hyperlink{namespaceGlobal__Physical__Variables_a84caa2a64e50ba5b390a3cd100f0f835}{Y\_lo\_pt};
\textcolor{comment}{}
\textcolor{comment}{ /// Pointer to y-position at inflow on the upper wall}
\textcolor{comment}{} \textcolor{keywordtype}{double}* \hyperlink{namespaceGlobal__Physical__Variables_a75878a0c79c88065fd9031f273b62698}{Y\_up\_pt};
\textcolor{comment}{}
\textcolor{comment}{ /// Set inflow velocity, based on spine heights at outflow}
\textcolor{comment}{ /// and channel width at inflow}
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{namespaceGlobal__Physical__Variables_a08e9835d71b7f7194ec5475f139211be}{inflow}(\textcolor{keyword}{const} Vector<double>& x, Vector<double>& veloc)
 \{
\textcolor{preprocessor}{#ifdef PARANOID}
  std::ostringstream error\_stream;
  \textcolor{keywordtype}{bool} throw\_error=\textcolor{keyword}{false};
  \textcolor{keywordflow}{if} (H\_lo\_pt==0) 
   \{
    error\_stream << \textcolor{stringliteral}{"You must set H\_lo\_pt\(\backslash\)n"};
    throw\_error = \textcolor{keyword}{true};
   \}
  \textcolor{keywordflow}{if} (H\_up\_pt==0) 
   \{
    error\_stream << \textcolor{stringliteral}{"You must set H\_up\_pt\(\backslash\)n"};
    throw\_error = \textcolor{keyword}{true};
   \}
  \textcolor{keywordflow}{if} (Y\_lo\_pt==0) 
   \{
    error\_stream << \textcolor{stringliteral}{"You must set Y\_lo\_pt\(\backslash\)n"};
    throw\_error = \textcolor{keyword}{true};
   \}
  \textcolor{keywordflow}{if} (Y\_up\_pt==0) 
   \{
    error\_stream << \textcolor{stringliteral}{"You must set Y\_up\_pt\(\backslash\)n"};
    throw\_error = \textcolor{keyword}{true};
   \}

  \textcolor{comment}{//If one of the errors has occured}
  \textcolor{keywordflow}{if}(throw\_error)
   \{
    \textcolor{keywordflow}{throw} OomphLibError(error\_stream.str(),
                        OOMPH\_CURRENT\_FUNCTION,
                        OOMPH\_EXCEPTION\_LOCATION);
   \}
\textcolor{preprocessor}{#endif}


  \textcolor{comment}{// Get average film thickness far ahead}
  \textcolor{keywordtype}{double} h\_av=0.5*(*H\_lo\_pt+*\hyperlink{namespaceGlobal__Physical__Variables_a83a3a82f89784013805bd23d63faa7e3}{H\_up\_pt});

  \textcolor{comment}{// Get position of upper and lower wall at inflow}
  \textcolor{keywordtype}{double} y\_up=*\hyperlink{namespaceGlobal__Physical__Variables_a75878a0c79c88065fd9031f273b62698}{Y\_up\_pt};
  \textcolor{keywordtype}{double} y\_lo=*\hyperlink{namespaceGlobal__Physical__Variables_a84caa2a64e50ba5b390a3cd100f0f835}{Y\_lo\_pt};

  \textcolor{comment}{// Constant in velocity profile}
  \textcolor{keywordtype}{double} C =6.0*(2.0*h\_av+y\_lo-y\_up)/
   (y\_up*y\_up*y\_up-y\_lo*y\_lo*y\_lo-h\_av*y\_up*
    y\_up*y\_up+h\_av*y\_lo*y\_lo*y\_lo-3.0*y\_lo*y\_up*y\_up+
    3.0*y\_lo*y\_lo*y\_up+3.0*y\_lo*y\_up*y\_up*h\_av-3.0*y\_lo*y\_lo*y\_up*h\_av);

  \textcolor{comment}{// y coordinate}
  \textcolor{keywordtype}{double} y=x[1];

  \textcolor{comment}{// Parallel, parabolic inflow}
  veloc[0]=-1.0+C*(1.0-h\_av)*((y\_lo-y)*(y\_up-y));
  veloc[1]=0.0;
 \}

\}




\textcolor{comment}{//======================================================================}\textcolor{comment}{}
\textcolor{comment}{/// "Bretherton element" is a fluid element (of type ELEMENT) for which}
\textcolor{comment}{/// the (inflow) velocity  at those nodes that are located on a }
\textcolor{comment}{/// specified Mesh boundary is prescribed by Dirichlet boundary }
\textcolor{comment}{/// conditions. The key is that prescribed velocity profile can be}
\textcolor{comment}{/// a function of some external Data -- this dependency must}
\textcolor{comment}{/// be taken into account when computing the element's Jacobian}
\textcolor{comment}{/// matrix.}
\textcolor{comment}{/// }
\textcolor{comment}{/// This element type is useful, for instance, in the Bretherton}
\textcolor{comment}{/// problem, where the parabolic "inflow" profile is a function }
\textcolor{comment}{/// of the film thickness (represented by Spine heights) at the}
\textcolor{comment}{/// "outflow".}
\textcolor{comment}{}\textcolor{comment}{//======================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT>
\textcolor{keyword}{class }\hyperlink{classBrethertonElement}{BrethertonElement} : \textcolor{keyword}{public} ELEMENT
\{

\textcolor{keyword}{public}:
\textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Typedef for pointer (global) function that specifies the}
\textcolor{comment}{ /// the inflow}
\textcolor{comment}{} \textcolor{keyword}{typedef} void (*InflowFctPt)(\textcolor{keyword}{const} Vector<double>& x, Vector<double>& veloc);
\textcolor{comment}{}
\textcolor{comment}{ /// Constructor: Call the constructor of the underlying element}
\textcolor{comment}{} \hyperlink{classBrethertonElement}{BrethertonElement}() : ELEMENT() \{\}

\textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Activate the dependency of the "inflow" on the external}
\textcolor{comment}{ /// data. Pass the vector of pointers to the external Data that affects}
\textcolor{comment}{ /// the inflow, the id of the boundary on which the inflow}
\textcolor{comment}{ /// condition is to be applied and the function pointer to }
\textcolor{comment}{ /// to the global function that defines the inflow}
\textcolor{comment}{} \textcolor{keywordtype}{void} activate\_inflow\_dependency\_on\_external\_data(
  \textcolor{keyword}{const} Vector<Data*>& inflow\_ext\_data,
  \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned}& inflow\_boundary,
  InflowFctPt inflow\_fct\_pt)
  \{
   \textcolor{comment}{// Copy data that affects the inflow}
   \textcolor{keywordtype}{unsigned} n\_ext=inflow\_ext\_data.size();
   Inflow\_ext\_data.resize(n\_ext);
   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} i=0;i<n\_ext;i++)
    \{
     Inflow\_ext\_data[i]=inflow\_ext\_data[i];
    \}
   \textcolor{comment}{// Set inflow boundary}
   Inflow\_boundary=inflow\_boundary;
   \textcolor{comment}{// Set fct pointer to inflow condition}
   Inflow\_fct\_pt=inflow\_fct\_pt;
  \}
 
\textcolor{comment}{}
\textcolor{comment}{ /// short Overload assign local equation numbers: Add the dependency }
\textcolor{comment}{ /// on the external Data that affects the inflow profile}
\textcolor{comment}{} \textcolor{keywordtype}{void} assign\_local\_eqn\_numbers(\textcolor{keyword}{const} \textcolor{keywordtype}{bool}  &store\_local\_dof\_pt)
  \{
   \textcolor{comment}{// Call the element's local equation numbering procedure first}
   ELEMENT::assign\_local\_eqn\_numbers(store\_local\_dof\_pt);
   
   \textcolor{comment}{// Now add the equation numbers for the Data that affects the inflow}
   \textcolor{comment}{// profile}
   
   \textcolor{comment}{// Number of local equations so far}
   \textcolor{keywordtype}{unsigned} local\_eqn\_count = this->ndof();
   
   \textcolor{comment}{// Find out max. number of values stored at all Data values }
   \textcolor{comment}{// that affect the inflow}
   \textcolor{keywordtype}{unsigned} max\_nvalue=0;
   \textcolor{keywordtype}{unsigned} n\_ext=Inflow\_ext\_data.size();
   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} i=0;i<n\_ext;i++)
    \{
     \textcolor{comment}{// The external Data:}
     Data* data\_pt=Inflow\_ext\_data[i];
     \textcolor{comment}{// Number of values}
     \textcolor{keywordtype}{unsigned} n\_val=data\_pt->nvalue();
     \textcolor{keywordflow}{if} (n\_val>max\_nvalue) max\_nvalue=n\_val;
    \}

   \textcolor{comment}{// Allocate sufficient storage}
   Inflow\_ext\_data\_eqn.resize(n\_ext,max\_nvalue);
   
   \textcolor{comment}{//A local queue to store the global equation numbers}
   std::deque<unsigned long> global\_eqn\_number\_queue;

   \textcolor{comment}{// Loop over external Data that affect the "inflow"}
   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} i=0;i<n\_ext;i++)
    \{
     \textcolor{comment}{// The external Data:}
     Data* data\_pt=Inflow\_ext\_data[i];
     
     \textcolor{comment}{// Loop over number of values:}
     \textcolor{keywordtype}{unsigned} n\_val=data\_pt->nvalue();
     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} ival=0;ival<n\_val;ival++)
      \{

       \textcolor{comment}{// Is it free or pinned?}
       \textcolor{keywordtype}{long} eqn\_number=data\_pt->eqn\_number(ival);
       \textcolor{keywordflow}{if} (eqn\_number>=0)
        \{
         \textcolor{comment}{// Add global equation number to local storage}
         global\_eqn\_number\_queue.push\_back(eqn\_number);
         \textcolor{comment}{// Store local equation number associated with this external dof}
         Inflow\_ext\_data\_eqn(i,ival)=local\_eqn\_count;
         \textcolor{comment}{// Increment counter for local dofs}
         local\_eqn\_count++;
        \}
       \textcolor{keywordflow}{else}
        \{
         Inflow\_ext\_data\_eqn(i,ival)=-1;
        \}
      \}
    \}
   
   \textcolor{comment}{//Now add our global equations numbers to the internal element storage}
   this->add\_global\_eqn\_numbers(global\_eqn\_number\_queue, 
                                GeneralisedElement::Dof\_pt\_deque);
  \}

 \textcolor{comment}{}
\textcolor{comment}{ /// Overloaded Jacobian computation: Computes the Jacobian}
\textcolor{comment}{ /// of the underlying element and then adds the FD }
\textcolor{comment}{ /// operations to evaluate the derivatives w.r.t. the Data values}
\textcolor{comment}{ /// that affect the inflow.}
\textcolor{comment}{} \textcolor{keywordtype}{void} get\_jacobian(Vector<double>& residuals,
                   DenseMatrix<double>& jacobian)
  \{
   \textcolor{comment}{// Loop over Data values that affect the inflow}
   \textcolor{keywordtype}{unsigned} n\_ext=Inflow\_ext\_data.size();

   \textcolor{comment}{// Call "normal" jacobian first.}
   ELEMENT::get\_jacobian(residuals,jacobian);
   
   \textcolor{keywordflow}{if} (n\_ext==0) \textcolor{keywordflow}{return};
   
   \textcolor{comment}{// Get ready for FD operations}
   Vector<double> residuals\_plus(residuals.size());
   \textcolor{keywordtype}{double} fd\_step=1.0e-8;

   \textcolor{comment}{// Loop over Data values that affect the inflow}
   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} i=0;i<n\_ext;i++)
    \{
     \textcolor{comment}{// Get Data item}
     Data* data\_pt=Inflow\_ext\_data[i];
     
     \textcolor{comment}{// Loop over values}
     \textcolor{keywordtype}{unsigned} n\_val=data\_pt->nvalue();
     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} ival=0;ival<n\_val;ival++)
      \{
       \textcolor{comment}{// Local equation number}
       \textcolor{keywordtype}{int} local\_eqn=Inflow\_ext\_data\_eqn(i,ival);
       
       \textcolor{comment}{// Dof or pinned?}
       \textcolor{keywordflow}{if} (local\_eqn>=0)
        \{
         \textcolor{comment}{//get pointer to the data value}
         \textcolor{keywordtype}{double} *value\_pt = data\_pt->value\_pt(ival);

         \textcolor{comment}{//Backup Data value}
         \textcolor{keywordtype}{double} backup = *value\_pt;
         
         \textcolor{comment}{// Do FD step}
         *value\_pt += fd\_step;
         
         \textcolor{comment}{// Re-assign the inflow velocities for nodes in this element}
         reassign\_inflow();
         
                  
         \textcolor{comment}{// Fill in the relevant column in the Jacobian matrix}
         \textcolor{keywordtype}{unsigned} n\_dof = this->ndof();
         \textcolor{comment}{//Zero the residuals}
         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} idof=0;idof<n\_dof;idof++) \{residuals\_plus[idof] = 0.0;\}
         \textcolor{comment}{// Re-compute the element residual}
         this->get\_residuals(residuals\_plus);

         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} idof=0;idof<n\_dof;idof++)
          \{
           jacobian(idof,local\_eqn)=
            (residuals\_plus[idof]-residuals[idof])/fd\_step;
          \}
         
         \textcolor{comment}{//Reset spine height}
         *value\_pt = backup;
         
        \}
       \textcolor{comment}{// Note: Re-assignment of inflow is done on the fly during next loop}
      \}
    \}
   
   \textcolor{comment}{// Final re-assign for the inflow velocities for nodes in this element}
   reassign\_inflow();
   
  \}
 
 
\textcolor{keyword}{private}:
 

\textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short For all nodes that are located on specified boundary}
\textcolor{comment}{ /// re-assign the inflow velocity, using the function pointed to}
\textcolor{comment}{ /// by the function pointer}
\textcolor{comment}{} \textcolor{keywordtype}{void} reassign\_inflow()
  \{ 
   \textcolor{comment}{// Loop over all nodes in element -- if they are}
   \textcolor{comment}{// on inflow boundary, re-assign their velocities}
   Vector<double> x(2);
   Vector<double> veloc(2);
   \textcolor{keywordtype}{unsigned} n\_nod = this->nnode();
   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} j=0;j<n\_nod;j++)
    \{
     Node* nod\_pt = this->node\_pt(j);

     \textcolor{keywordflow}{if}(nod\_pt->is\_on\_boundary(Inflow\_boundary))
      \{
\textcolor{preprocessor}{#ifdef PARANOID}
           \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} i=0;i<2;i++)
            \{
             \textcolor{keywordflow}{if} (nod\_pt->eqn\_number(0)>=0)
              \{
               std::ostringstream error\_stream;
               error\_stream 
                << \textcolor{stringliteral}{"We're assigning a Dirichlet condition for the "} 
                << i << \textcolor{stringliteral}{"-th "}
                << \textcolor{stringliteral}{"velocity, even though it is not pinned!\(\backslash\)n"} 
                << \textcolor{stringliteral}{"This can't be right! I'm bailing out..."} 
                << std::endl;

               \textcolor{keywordflow}{throw} OomphLibError(error\_stream.str(),
                                   OOMPH\_CURRENT\_FUNCTION,
                                   OOMPH\_EXCEPTION\_LOCATION);
              \}
            \}
\textcolor{preprocessor}{#endif           }
           \textcolor{comment}{// Get inflow profile }
           x[0]=nod\_pt->x(0);
           x[1]=nod\_pt->x(1);
           Inflow\_fct\_pt(x,veloc);
           nod\_pt->set\_value(0,veloc[0]);
           nod\_pt->set\_value(1,veloc[1]);
      \}
    \}
  \}
 
\textcolor{comment}{}
\textcolor{comment}{ /// Storage for the external Data that affects the inflow}
\textcolor{comment}{} Vector<Data*> Inflow\_ext\_data;
\textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Storage for the local equation numbers associated the Data}
\textcolor{comment}{ /// values that affect the inflow}
\textcolor{comment}{} DenseMatrix<int> Inflow\_ext\_data\_eqn;
\textcolor{comment}{}
\textcolor{comment}{ /// Number of the inflow boundary in the global mesh}
\textcolor{comment}{} \textcolor{keywordtype}{unsigned} Inflow\_boundary;
\textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Function pointer to the global function that specifies the}
\textcolor{comment}{ /// inflow velocity profile on the global mesh boundary Inflow\_boundary}
\textcolor{comment}{} InflowFctPt Inflow\_fct\_pt;

\};



\textcolor{comment}{// Note: Specialisation must go into namespace!}
\textcolor{keyword}{namespace }\hyperlink{namespaceoomph}{oomph}
\{

\textcolor{comment}{//=======================================================================}\textcolor{comment}{}
\textcolor{comment}{/// Face geometry of the Bretherton 2D Crouzeix\_Raviart spine elements}
\textcolor{comment}{}\textcolor{comment}{//=======================================================================}
\textcolor{keyword}{template}<>
\textcolor{keyword}{class }FaceGeometry<\hyperlink{classBrethertonElement}{BrethertonElement}<SpineElement<QCrouzeixRaviartElement<2> > > >: \textcolor{keyword}{public}
       \textcolor{keyword}{virtual} QElement<1,3>
\{
  \textcolor{keyword}{public}:
 FaceGeometry() : QElement<1,3>() \{\}
\};



\textcolor{comment}{//=======================================================================}\textcolor{comment}{}
\textcolor{comment}{/// Face geometry of the Bretherton 2D Taylor Hood spine elements}
\textcolor{comment}{}\textcolor{comment}{//=======================================================================}
\textcolor{keyword}{template}<>
\textcolor{keyword}{class }FaceGeometry<\hyperlink{classBrethertonElement}{BrethertonElement}<SpineElement<QTaylorHoodElement<2> > > >: \textcolor{keyword}{public} \textcolor{keyword}{
      virtual} QElement<1,3>
\{
  \textcolor{keyword}{public}:
 FaceGeometry() : QElement<1,3>() \{\}
\};


\textcolor{comment}{//=======================================================================}\textcolor{comment}{}
\textcolor{comment}{/// Face geometry of the Face geometry of the }
\textcolor{comment}{///  the Bretherton 2D Crouzeix\_Raviart spine elements}
\textcolor{comment}{}\textcolor{comment}{//=======================================================================}
\textcolor{keyword}{template}<>
\textcolor{keyword}{class }FaceGeometry<FaceGeometry<\hyperlink{classBrethertonElement}{BrethertonElement}<
 SpineElement<QCrouzeixRaviartElement<2> > > > >: \textcolor{keyword}{public} \textcolor{keyword}{virtual} PointElement
\{
  \textcolor{keyword}{public}:
 FaceGeometry() : PointElement() \{\}
\};



\textcolor{comment}{//=======================================================================}\textcolor{comment}{}
\textcolor{comment}{/// Face geometry of face geometry of }
\textcolor{comment}{/// the Bretherton 2D Taylor Hood spine elements}
\textcolor{comment}{}\textcolor{comment}{//=======================================================================}
\textcolor{keyword}{template}<>
\textcolor{keyword}{class }FaceGeometry<FaceGeometry<\hyperlink{classBrethertonElement}{BrethertonElement}<SpineElement<QTaylorHoodElement<2> > > >
       >: \textcolor{keyword}{public} \textcolor{keyword}{virtual} PointElement
\{
  \textcolor{keyword}{public}:
 FaceGeometry() : PointElement() \{\}
\};


\}
\textcolor{comment}{}
\textcolor{comment}{/////////////////////////////////////////////////////////////////////}
\textcolor{comment}{/////////////////////////////////////////////////////////////////////}
\textcolor{comment}{/////////////////////////////////////////////////////////////////////}
\textcolor{comment}{}

\textcolor{comment}{//======================================================================}\textcolor{comment}{}
\textcolor{comment}{/// Bretherton problem}
\textcolor{comment}{}\textcolor{comment}{//======================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT>
\textcolor{keyword}{class }\hyperlink{classBrethertonProblem}{BrethertonProblem} : \textcolor{keyword}{public} Problem
\{


\textcolor{keyword}{public}:
\textcolor{comment}{}
\textcolor{comment}{ /// Constructor: }
\textcolor{comment}{} \hyperlink{classBrethertonProblem}{BrethertonProblem}();
\textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Spine heights/lengths are unknowns in the problem so their}
\textcolor{comment}{ /// values get corrected during each Newton step. However,}
\textcolor{comment}{ /// changing their value does not automatically change the}
\textcolor{comment}{ /// nodal positions, so we need to update all of them}
\textcolor{comment}{} \textcolor{keywordtype}{void} actions\_before\_newton\_convergence\_check()
  \{
   \textcolor{comment}{// Update}
   Bulk\_mesh\_pt->node\_update();

   \textcolor{comment}{// Apply inflow on boundary 1}
   \textcolor{keywordtype}{unsigned} ibound=1;
   \textcolor{keywordtype}{unsigned} num\_nod=mesh\_pt()->nboundary\_node(ibound);
   
   \textcolor{comment}{// Coordinate and velocity}
   Vector<double> x(2);
   Vector<double> veloc(2);

   \textcolor{comment}{// Loop over all nodes}
   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} inod=0;inod<num\_nod;inod++)
    \{
     \textcolor{comment}{// Get nodal position}
     x[0]=mesh\_pt()->boundary\_node\_pt(ibound,inod)->x(0);
     x[1]=mesh\_pt()->boundary\_node\_pt(ibound,inod)->x(1);

     \textcolor{comment}{// Get inflow profile}
     \hyperlink{namespaceGlobal__Physical__Variables_a08e9835d71b7f7194ec5475f139211be}{Global\_Physical\_Variables::inflow}(x,veloc);
     mesh\_pt()->boundary\_node\_pt(ibound,inod)->set\_value(0,veloc[0]);
     mesh\_pt()->boundary\_node\_pt(ibound,inod)->set\_value(1,veloc[1]);
    \}
  \}
\textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Update before solve: empty}
\textcolor{comment}{} \textcolor{keywordtype}{void} actions\_before\_newton\_solve() \{\}
\textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Update after solve can remain empty, because the update }
\textcolor{comment}{ /// is performed automatically after every Newton step.}
\textcolor{comment}{} \textcolor{keywordtype}{void} actions\_after\_newton\_solve() \{\}
\textcolor{comment}{}
\textcolor{comment}{ ///Fix pressure value l in element e to value p\_value}
\textcolor{comment}{} \textcolor{keywordtype}{void} fix\_pressure(\textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} &e, \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} &l, 
                   \textcolor{keyword}{const} \textcolor{keywordtype}{double} &pvalue)
  \{
   \textcolor{comment}{//Fix the pressure at that element}
   \textcolor{keyword}{dynamic\_cast<}ELEMENT *\textcolor{keyword}{>}(Bulk\_mesh\_pt->element\_pt(e))->
    fix\_pressure(l,pvalue);
  \}

 \textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Activate the dependency of the inflow velocity on the }
\textcolor{comment}{ /// spine heights at the outflow}
\textcolor{comment}{} \textcolor{keywordtype}{void} activate\_inflow\_dependency();
\textcolor{comment}{}
\textcolor{comment}{ /// Run a parameter study; perform specified number of steps}
\textcolor{comment}{} \textcolor{keywordtype}{void} parameter\_study(\textcolor{keyword}{const} \textcolor{keywordtype}{unsigned}& nsteps); 
\textcolor{comment}{}
\textcolor{comment}{ /// Doc the solution}
\textcolor{comment}{} \textcolor{keywordtype}{void} doc\_solution(DocInfo& doc\_info);


\textcolor{keyword}{private}:
\textcolor{comment}{}
\textcolor{comment}{ /// Pointer to control element}
\textcolor{comment}{} ELEMENT* Control\_element\_pt;
\textcolor{comment}{}
\textcolor{comment}{ /// Trace file}
\textcolor{comment}{} ofstream Trace\_file;
\textcolor{comment}{}
\textcolor{comment}{ /// Pointer to bulk mesh}
\textcolor{comment}{} BrethertonSpineMesh<ELEMENT,SpineLineFluidInterfaceElement<ELEMENT> >* 
 Bulk\_mesh\_pt;

\};


\textcolor{comment}{//====================================================================}\textcolor{comment}{}
\textcolor{comment}{/// Problem constructor}
\textcolor{comment}{}\textcolor{comment}{//====================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT>
\hyperlink{classBrethertonProblem_a207cdfe4cf60e83257e759b1ac15e5eb}{BrethertonProblem<ELEMENT>::BrethertonProblem}()
\{

 \textcolor{comment}{// Number of elements in the deposited film region}
 \textcolor{keywordtype}{unsigned} nx1=24;

 \textcolor{comment}{// Number of elements in the bottom part of the transition region}
 \textcolor{keywordtype}{unsigned} nx2=6;

 \textcolor{comment}{// Number of elements in channel region}
 \textcolor{keywordtype}{unsigned} nx3=12;

 \textcolor{comment}{// Number of elements in the vertical part of the transition region}
 \textcolor{comment}{// (=half the number of elements in the liquid filled region ahead}
 \textcolor{comment}{// of the finger tip)}
 \textcolor{keywordtype}{unsigned} nhalf=4;

 \textcolor{comment}{// Number of elements through thickness of deposited film}
 \textcolor{keywordtype}{unsigned} nh=3;
 
 \textcolor{comment}{// Thickness of deposited film}
 \textcolor{keywordtype}{double} h=0.1;

 \textcolor{comment}{// Create wall geom objects}
 GeomObject* lower\_wall\_pt=\textcolor{keyword}{new} StraightLine(-1.0);
 GeomObject* upper\_wall\_pt=\textcolor{keyword}{new} StraightLine( 1.0);

 \textcolor{comment}{// Start coordinate on wall}
 \textcolor{keywordtype}{double} xi0=-4.0;

 \textcolor{comment}{// End of transition region on wall}
 \textcolor{keywordtype}{double} xi1=1.5;

 \textcolor{comment}{// End of liquid filled region (inflow) on wall}
 \textcolor{keywordtype}{double} xi2=5.0;

 \textcolor{comment}{//Now create the mesh}
 Bulk\_mesh\_pt = \textcolor{keyword}{new}  BrethertonSpineMesh<ELEMENT,
  SpineLineFluidInterfaceElement<ELEMENT> > 
  (nx1,nx2,nx3,nh,nhalf,h,lower\_wall\_pt,upper\_wall\_pt,xi0,0.0,xi1,xi2);

 \textcolor{comment}{// Make bulk mesh the global mesh}
 mesh\_pt()=Bulk\_mesh\_pt;

 \textcolor{comment}{// Store the control element}
 Control\_element\_pt=Bulk\_mesh\_pt->control\_element\_pt();


 \textcolor{comment}{// Set pointers to quantities that determine the inflow profile}

 \textcolor{comment}{// Film thickness at outflow on lower wall:}
 \hyperlink{namespaceGlobal__Physical__Variables_a137bdac2ad4b72a03ec9916e8ee7395b}{Global\_Physical\_Variables::H\_lo\_pt}=
  Bulk\_mesh\_pt->spine\_pt(0)->spine\_height\_pt()->value\_pt(0);

 \textcolor{comment}{// Film thickness at outflow on upper wall:}
 \textcolor{keywordtype}{unsigned} last\_spine=Bulk\_mesh\_pt->nfree\_surface\_spines()-1;
 \hyperlink{namespaceGlobal__Physical__Variables_a83a3a82f89784013805bd23d63faa7e3}{Global\_Physical\_Variables::H\_up\_pt}=
  Bulk\_mesh\_pt->spine\_pt(last\_spine)->spine\_height\_pt()->value\_pt(0);

 \textcolor{comment}{// Current y-position on lower wall at inflow}
 \textcolor{keywordtype}{unsigned} ibound=1;
 \hyperlink{namespaceGlobal__Physical__Variables_a84caa2a64e50ba5b390a3cd100f0f835}{Global\_Physical\_Variables::Y\_lo\_pt}=
  Bulk\_mesh\_pt->boundary\_node\_pt(ibound,0)->x\_pt(0,1);

 \textcolor{comment}{// Current y-position on upper wall at inflow}
 \textcolor{keywordtype}{unsigned} nnod=Bulk\_mesh\_pt->nboundary\_node(ibound);
 \hyperlink{namespaceGlobal__Physical__Variables_a75878a0c79c88065fd9031f273b62698}{Global\_Physical\_Variables::Y\_up\_pt}=
  Bulk\_mesh\_pt->boundary\_node\_pt(ibound,nnod-1)->x\_pt(0,1);

 \textcolor{comment}{// Activate dependency of inflow on spine heights at outflow}
 activate\_inflow\_dependency();

 \textcolor{comment}{// Set the boundary conditions for this problem: All nodes are}
 \textcolor{comment}{// free by default -- just pin the ones that have Dirichlet conditions}
 \textcolor{comment}{// here}

 \textcolor{comment}{// No slip on boundaries 0 1 and 2}
 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} ibound=0;ibound<=2;ibound++)
  \{
   \textcolor{keywordtype}{unsigned} num\_nod=mesh\_pt()->nboundary\_node(ibound);
   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} inod=0;inod<num\_nod;inod++)
    \{
     mesh\_pt()->boundary\_node\_pt(ibound,inod)->pin(0);
     mesh\_pt()->boundary\_node\_pt(ibound,inod)->pin(1);
    \}
  \}

 \textcolor{comment}{// Uniform, parallel outflow on boundaries 3 and 5}
 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} ibound=3;ibound<=5;ibound+=2)
  \{
   \textcolor{keywordtype}{unsigned} num\_nod=mesh\_pt()->nboundary\_node(ibound);
   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} inod=0;inod<num\_nod;inod++)
    \{
     mesh\_pt()->boundary\_node\_pt(ibound,inod)->pin(0);
     mesh\_pt()->boundary\_node\_pt(ibound,inod)->pin(1);
    \}
  \}

 \textcolor{comment}{// Pin central spine}
 \textcolor{keywordtype}{unsigned} central\_spine=(Bulk\_mesh\_pt->nfree\_surface\_spines()-1)/2;
 Bulk\_mesh\_pt->spine\_pt(central\_spine)->spine\_height\_pt()->pin(0);


 \textcolor{comment}{// No slip in moving frame on boundaries 0 and 2}
 \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} ibound=0;ibound<=2;ibound+=2)
  \{
   \textcolor{keywordtype}{unsigned} num\_nod=mesh\_pt()->nboundary\_node(ibound);
   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} inod=0;inod<num\_nod;inod++)
    \{
     \textcolor{comment}{// Parallel flow}
     mesh\_pt()->boundary\_node\_pt(ibound,inod)->set\_value(0,-1.0);
     mesh\_pt()->boundary\_node\_pt(ibound,inod)->set\_value(1, 0.0);
    \}
  \}
   

 \textcolor{comment}{// Parallel, uniform outflow on boundaries 3 and 5}
 \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} ibound=3;ibound<=5;ibound+=2)
  \{
   \textcolor{keywordtype}{unsigned} num\_nod=mesh\_pt()->nboundary\_node(ibound);
   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} inod=0;inod<num\_nod;inod++)
    \{
     \textcolor{comment}{// Parallel inflow}
     mesh\_pt()->boundary\_node\_pt(ibound,inod)->set\_value(0,-1.0);
     mesh\_pt()->boundary\_node\_pt(ibound,inod)->set\_value(1, 0.0);
    \}
  \}
   


 \textcolor{comment}{//Complete the problem setup to make the elements fully functional}

 \textcolor{comment}{//Loop over the elements in the layer}
 \textcolor{keywordtype}{unsigned} n\_bulk=Bulk\_mesh\_pt->nbulk();
 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} i=0;i<n\_bulk;i++)
  \{
   \textcolor{comment}{//Cast to a fluid element}
   ELEMENT *el\_pt = \textcolor{keyword}{dynamic\_cast<}ELEMENT*\textcolor{keyword}{>}(Bulk\_mesh\_pt->
                                           bulk\_element\_pt(i));
   \textcolor{comment}{//Set the Reynolds number, etc}
   el\_pt->re\_pt() = &\hyperlink{namespaceGlobal__Physical__Variables_ab814e627d2eb5bc50318879d19ab16b9}{Global\_Physical\_Variables::Re};
   el\_pt->re\_st\_pt() = &\hyperlink{namespaceGlobal__Physical__Variables_a085ee4bf968ffdd01a41b8c41864f907}{Global\_Physical\_Variables::ReSt};
   el\_pt->re\_invfr\_pt() = &\hyperlink{namespaceGlobal__Physical__Variables_aa6286f02b476912dd7550eced538331a}{Global\_Physical\_Variables::ReInvFr};
   el\_pt->g\_pt() = &\hyperlink{namespaceGlobal__Physical__Variables_a18fe245262ec8beec764c805bb93e73c}{Global\_Physical\_Variables::G};
  \}

 \textcolor{comment}{//Loop over 1D interface elements and set capillary number}
 \textcolor{keywordtype}{unsigned} interface\_element\_pt\_range = Bulk\_mesh\_pt->ninterface\_element();
 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} i=0;i<interface\_element\_pt\_range;i++)
  \{
   \textcolor{comment}{//Cast to a interface element}
   SpineLineFluidInterfaceElement<ELEMENT>* el\_pt = 
    \textcolor{keyword}{dynamic\_cast<}SpineLineFluidInterfaceElement<ELEMENT>*\textcolor{keyword}{>}
    (Bulk\_mesh\_pt->interface\_element\_pt(i));

   \textcolor{comment}{//Set the Capillary number}
   el\_pt->ca\_pt() = &\hyperlink{namespaceGlobal__Physical__Variables_a8b32b93d2e546f9375ec418474107838}{Global\_Physical\_Variables::Ca};
  \}

 \textcolor{comment}{//Update the nodal positions, so that the domain is correct}
 \textcolor{comment}{//(and therefore the repeated node test passes)}
 Bulk\_mesh\_pt->node\_update();

 \textcolor{comment}{//Do equation numbering}
 cout << \textcolor{stringliteral}{"Number of unknowns: "} << assign\_eqn\_numbers() << std::endl; 

\}



\textcolor{comment}{//========================================================================}\textcolor{comment}{}
\textcolor{comment}{/// Activate the dependency of the inflow velocity on the }
\textcolor{comment}{/// spine heights at the outflow}
\textcolor{comment}{}\textcolor{comment}{//========================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT>
\textcolor{keywordtype}{void} \hyperlink{classBrethertonProblem_a04257edfb80f2ff3bf865442d9eb01fb}{BrethertonProblem<ELEMENT>::activate\_inflow\_dependency}
      ()
\{

 \textcolor{comment}{// Spine heights that affect the inflow}
 Vector<Data*> outflow\_spines(2);

 \textcolor{comment}{// First spine}
 outflow\_spines[0]=Bulk\_mesh\_pt->spine\_pt(0)->spine\_height\_pt();

 \textcolor{comment}{// Last proper spine}
 \textcolor{keywordtype}{unsigned} last\_spine=Bulk\_mesh\_pt->nfree\_surface\_spines()-1;
 outflow\_spines[1]=Bulk\_mesh\_pt->spine\_pt(last\_spine)->spine\_height\_pt();;


\textcolor{comment}{}
\textcolor{comment}{ /// Loop over elements on inflow boundary (1)}
\textcolor{comment}{} \textcolor{keywordtype}{unsigned} ibound=1;
 \textcolor{keywordtype}{unsigned} nel=Bulk\_mesh\_pt->nboundary\_element(ibound);
 \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} e=0;e<nel;e++)
  \{
   \textcolor{comment}{// Get pointer to element}
   ELEMENT* el\_pt=\textcolor{keyword}{dynamic\_cast<}ELEMENT*\textcolor{keyword}{>}(Bulk\_mesh\_pt->
                                         boundary\_element\_pt(ibound,e));  
   \textcolor{comment}{// Activate depency on inflow}
   el\_pt->activate\_inflow\_dependency\_on\_external\_data(
    outflow\_spines,ibound,&\hyperlink{namespaceGlobal__Physical__Variables_a08e9835d71b7f7194ec5475f139211be}{Global\_Physical\_Variables::inflow});
  \}

\}



\textcolor{comment}{//========================================================================}\textcolor{comment}{}
\textcolor{comment}{/// Doc the solution}
\textcolor{comment}{}\textcolor{comment}{//========================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT>
\textcolor{keywordtype}{void} \hyperlink{classBrethertonProblem_ab6e29ecf0dbffabd4ce897203d35626e}{BrethertonProblem<ELEMENT>::doc\_solution}(DocInfo& doc\_info)
\{ 

 ofstream some\_file;
 \textcolor{keywordtype}{char} filename[100];

 \textcolor{comment}{// Number of plot points}
 \textcolor{keywordtype}{unsigned} npts=5; 

 \textcolor{comment}{// Control coordinate: At bubble tip}
 Vector<double> s(2);
 s[0]=1.0;
 s[1]=1.0;
 
 \textcolor{comment}{// Last proper spine}
 \textcolor{keywordtype}{unsigned} last\_spine=Bulk\_mesh\_pt->nfree\_surface\_spines()-1;

 \textcolor{comment}{// Doc}
 Trace\_file << \textcolor{stringliteral}{" "} << \hyperlink{namespaceGlobal__Physical__Variables_a8b32b93d2e546f9375ec418474107838}{Global\_Physical\_Variables::Ca};
 Trace\_file << \textcolor{stringliteral}{" "} << Bulk\_mesh\_pt->spine\_pt(0)->height();
 Trace\_file << \textcolor{stringliteral}{" "} << Bulk\_mesh\_pt->spine\_pt(last\_spine)->height();
 Trace\_file << \textcolor{stringliteral}{" "} << 1.3375*pow(Global\_Physical\_Variables::Ca,2.0/3.0);
 Trace\_file << \textcolor{stringliteral}{" "} << -Control\_element\_pt->interpolated\_p\_nst(s)*
                      \hyperlink{namespaceGlobal__Physical__Variables_a8b32b93d2e546f9375ec418474107838}{Global\_Physical\_Variables::Ca};
 Trace\_file << \textcolor{stringliteral}{" "} << 1.0+3.8*pow(Global\_Physical\_Variables::Ca,2.0/3.0);
 Trace\_file << \textcolor{stringliteral}{" "} << Control\_element\_pt->interpolated\_u\_nst(s,0);
 Trace\_file << \textcolor{stringliteral}{" "} << Control\_element\_pt->interpolated\_u\_nst(s,1);
 Trace\_file << std::endl;


 \textcolor{comment}{// Output solution }
 sprintf(filename,\textcolor{stringliteral}{"%s/soln%i.dat"},doc\_info.directory().c\_str(),
         doc\_info.number());
 some\_file.open(filename);
 Bulk\_mesh\_pt->output(some\_file,npts);
 some\_file.close();


 \textcolor{comment}{// Output boundaries}
 sprintf(filename,\textcolor{stringliteral}{"%s/boundaries%i.dat"},doc\_info.directory().c\_str(),
         doc\_info.number());
 some\_file.open(filename);
 Bulk\_mesh\_pt->output\_boundaries(some\_file);
 some\_file.close();

\}




\textcolor{comment}{//=============================================================================}\textcolor{comment}{}
\textcolor{comment}{/// Parameter study}
\textcolor{comment}{}\textcolor{comment}{//=============================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT>
\textcolor{keywordtype}{void} \hyperlink{classBrethertonProblem_ac24db9373e1a3005e6b14fc92c16b41c}{BrethertonProblem<ELEMENT>::parameter\_study}(\textcolor{keyword}{const} \textcolor{keywordtype}{unsigned}&
       nsteps)
\{

 \textcolor{comment}{// Increase maximum residual}
 Problem::Max\_residuals=100.0;

 \textcolor{comment}{// Set output directory}
 DocInfo doc\_info;
 doc\_info.set\_directory(\textcolor{stringliteral}{"RESLT"});
 doc\_info.number()=0;


 \textcolor{comment}{// Open trace file}
 \textcolor{keywordtype}{char} filename[100];   
 sprintf(filename,\textcolor{stringliteral}{"%s/trace.dat"},doc\_info.directory().c\_str());
 Trace\_file.open(filename);

 Trace\_file << \textcolor{stringliteral}{"VARIABLES=\(\backslash\)"Ca\(\backslash\)","};
 Trace\_file << \textcolor{stringliteral}{"\(\backslash\)"h<sub>bottom</sub>\(\backslash\)",\(\backslash\)"h<sub>too</sub>\(\backslash\)","};
 Trace\_file << \textcolor{stringliteral}{"\(\backslash\)"h<sub>Bretherton</sub>\(\backslash\)",\(\backslash\)"p<sub>tip</sub>\(\backslash\)","};
 Trace\_file << \textcolor{stringliteral}{"\(\backslash\)"p<sub>tip (Bretherton)</sub>\(\backslash\)",\(\backslash\)"u<sub>stag</sub>\(\backslash\)","};
 Trace\_file << \textcolor{stringliteral}{"\(\backslash\)"v<sub>stag</sub>\(\backslash\)""};
 Trace\_file << \textcolor{stringliteral}{"\(\backslash\)"<greek>a</greek><sub>bottom</sub>\(\backslash\)","};
 Trace\_file << \textcolor{stringliteral}{"\(\backslash\)"<greek>a</greek><sub>top</sub>\(\backslash\)""};
 Trace\_file << std::endl;

 \textcolor{comment}{// Initial scaling factor for Ca reduction}
 \textcolor{keywordtype}{double} factor=2.0;

 \textcolor{comment}{//Doc initial solution}
 doc\_solution(doc\_info);

\textcolor{comment}{//Loop over the steps}
 \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} step=1;step<=nsteps;step++)
  \{
   cout << std::endl << \textcolor{stringliteral}{"STEP "} << step << std::endl;

   \textcolor{comment}{// Newton method tends to converge is initial stays bounded below}
   \textcolor{comment}{// a certain tolerance: This is cheaper to check than restarting}
   \textcolor{comment}{// the Newton method after divergence (we'd also need to back up}
   \textcolor{comment}{// the previous solution)}
   \textcolor{keywordtype}{double} maxres=100.0;
   \textcolor{keywordflow}{while} (\textcolor{keyword}{true})
    \{
     cout << \textcolor{stringliteral}{"Checking max. res for Ca = "} 
          << Global\_Physical\_Variables::Ca << \textcolor{stringliteral}{".   Max. residual: "};

     \textcolor{comment}{// Check the maximum residual}
     DoubleVector residuals;
     actions\_before\_newton\_solve();
     actions\_before\_newton\_convergence\_check();
     get\_residuals(residuals);
     \textcolor{keywordtype}{double} max\_res=residuals.max();
     cout << max\_res;

     \textcolor{comment}{// Check what to do }
     \textcolor{keywordflow}{if} (max\_res>maxres)
      \{
       cout << \textcolor{stringliteral}{". Too big!"} << std::endl;
       \textcolor{comment}{// Reset the capillary number}
       Global\_Physical\_Variables::Ca *= factor;       
       \textcolor{comment}{// Reduce the factor}
       factor=1.0+(factor-1.0)/1.5;
       cout << \textcolor{stringliteral}{"New reduction factor: "} << factor << std::endl;
       \textcolor{comment}{// Reduce the capillary number}
       Global\_Physical\_Variables::Ca /= factor;
       \textcolor{comment}{// Try again}
       \textcolor{keywordflow}{continue};
      \}
     \textcolor{comment}{// Looks promising: Let's proceed to solve}
     \textcolor{keywordflow}{else}
      \{
       cout << \textcolor{stringliteral}{". OK"} << std::endl << std::endl;
       \textcolor{comment}{// Break out of the Ca adjustment loop}
       \textcolor{keywordflow}{break};
      \}
    \}

   \textcolor{comment}{//Solve}
   cout << \textcolor{stringliteral}{"Solving for capillary number: "} 
        << Global\_Physical\_Variables::Ca << std::endl;
   newton\_solve();

   \textcolor{comment}{// Doc solution}
   doc\_info.number()++;
   doc\_solution(doc\_info);
   
   \textcolor{comment}{// Reduce the capillary number}
   Global\_Physical\_Variables::Ca /= factor;
  \}

\}



\textcolor{comment}{//======================================================================}\textcolor{comment}{}
\textcolor{comment}{/// Driver code for unsteady two-layer fluid problem. If there are}
\textcolor{comment}{/// any command line arguments, we regard this as a validation run}
\textcolor{comment}{/// and perform only a single step.}
\textcolor{comment}{}\textcolor{comment}{//======================================================================}
\textcolor{keywordtype}{int} \hyperlink{bretherton_8cc_a0ddf1224851353fc92bfbff6f499fa97}{main}(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char}* argv[]) 
\{


 \textcolor{comment}{// Store command line arguments}
 CommandLineArgs::setup(argc,argv);

 \textcolor{comment}{// Set physical parameters:}

 \textcolor{comment}{//Set direction of gravity: Vertically downwards}
 \hyperlink{namespaceGlobal__Physical__Variables_a18fe245262ec8beec764c805bb93e73c}{Global\_Physical\_Variables::G}[0] = 0.0;
 \hyperlink{namespaceGlobal__Physical__Variables_a18fe245262ec8beec764c805bb93e73c}{Global\_Physical\_Variables::G}[1] = -1.0;

 \textcolor{comment}{// Womersley number = Reynolds number (St = 1)}
 \hyperlink{namespaceGlobal__Physical__Variables_a085ee4bf968ffdd01a41b8c41864f907}{Global\_Physical\_Variables::ReSt} = 0.0;
 \hyperlink{namespaceGlobal__Physical__Variables_ab814e627d2eb5bc50318879d19ab16b9}{Global\_Physical\_Variables::Re} = 
      \hyperlink{namespaceGlobal__Physical__Variables_a085ee4bf968ffdd01a41b8c41864f907}{Global\_Physical\_Variables::ReSt};

 \textcolor{comment}{// The Capillary number}
 Global\_Physical\_Variables::Ca = 0.05;

 \textcolor{comment}{// Re/Fr -- a measure of gravity...}
 \hyperlink{namespaceGlobal__Physical__Variables_aa6286f02b476912dd7550eced538331a}{Global\_Physical\_Variables::ReInvFr} = 0.0;

 \textcolor{comment}{//Set up the problem}
 \hyperlink{classBrethertonProblem}{BrethertonProblem<BrethertonElement<SpineElement<QCrouzeixRaviartElement<2>}
       > > > problem;

 \textcolor{comment}{// Self test:}
 problem.self\_test();

 \textcolor{comment}{// Number of steps: }
 \textcolor{keywordtype}{unsigned} nstep;
 \textcolor{keywordflow}{if} (CommandLineArgs::Argc>1)
  \{
   \textcolor{comment}{// Validation run: Just one step}
   nstep=2;
  \}
 \textcolor{keywordflow}{else}
  \{
   \textcolor{comment}{// Full run otherwise}
   nstep=30;
  \}

 \textcolor{comment}{// Run the parameter study: Perform nstep steps}
 problem.\hyperlink{classBrethertonProblem_ac24db9373e1a3005e6b14fc92c16b41c}{parameter\_study}(nstep);

\}

\end{DoxyCodeInclude}
\hypertarget{index_sources}{}\section{Source files for this tutorial}\label{index_sources}

\begin{DoxyItemize}
\item The source files for this tutorial are located in the directory\+:~\newline
~\newline
\begin{center} \href{../../../../demo_drivers/navier_stokes/bretherton}{\tt demo\+\_\+drivers/navier\+\_\+stokes/bretherton } \end{center} ~\newline

\item The driver code is\+: ~\newline
~\newline
\begin{center} \href{../../../../demo_drivers/navier_stokes/bretherton/bretherton.cc}{\tt demo\+\_\+drivers/navier\+\_\+stokes/bretherton/bretherton.\+cc} \end{center} 
\end{DoxyItemize}



 

 \hypertarget{index_pdf}{}\section{P\+D\+F file}\label{index_pdf}
A \href{../latex/refman.pdf}{\tt pdf version} of this document is available. \end{document}
