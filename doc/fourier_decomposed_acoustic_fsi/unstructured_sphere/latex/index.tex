In this document we discuss the spatially-\/adaptive solution of 3D time-\/harmonic acoustic fluid-\/structure interaction problems in cylindrical polar coordinates on unstructured meshes.

The driver code is very similar to the one presented in \href{../../sphere/html/index.html}{\tt another tutorial} and we only discuss the changes necessary to deal with the generation of the adaptive, unstructured meshes and the assignment of different material properties to different parts of the solid domain.



 

\hypertarget{index_test}{}\section{A test problem}\label{index_test}
The sketch below shows the problem setup\+: An elastic sphere which is reinforced with an azimuthal T-\/rib is immersed in a compressible fluid and subjected to a time-\/periodic pressure load of magnitude \[ {\bf t} = P ( \exp(\alpha(\theta-\pi/4)^2) + \exp(\alpha(\theta-3\pi/4)^2) ) \] (where $ \theta $ is the zenith angle) along its inner surface. The parameter $ \alpha $ controls the \char`\"{}sharpness\char`\"{} of the pressure load. For $ \alpha=0 $ we obtain a uniform, spherically symmetric load; the sketch below shows the pressure distribution (red vectors indicating the traction) for $ \alpha = 200. $

 
\begin{DoxyImage}
\includegraphics[width=0.8\textwidth]{setup}
\doxyfigcaption{Sketch of the problem setup. }
\end{DoxyImage}




 

\hypertarget{index_results}{}\section{Results}\label{index_results}
The figure below shows an animation of the structure\textquotesingle{}s time-\/harmonic oscillation. The blue shaded region shows the shape of the oscillating structure while the pink region shows its undeformed configuration. The left half of the plot is used to show the (mirror image of the) adaptive unstructured mesh on which the displacement field was computed\+:

 
\begin{DoxyImage}
\includegraphics[width=0.8\textwidth]{anim}
\doxyfigcaption{Animation of the time-\/harmonic deformation. }
\end{DoxyImage}


Here is a plot of the corresponding fluid displacement potential, a measure of the fluid pressure\+:

 
\begin{DoxyImage}
\includegraphics[width=0.8\textwidth]{potential_unstr}
\doxyfigcaption{The fluid displacement potential, a measure of the fluid pressure. Elevation\+: real part; contours\+: imaginary part. }
\end{DoxyImage}


This looks very pretty and shows that we can solve acoustic F\+SI problems in non-\/trivial geometries but should you believe the results? Here\textquotesingle{}s an attempt to convince you\+: If we make the rib much softer than the sphere and set its inertia to zero, the rib will not offer much structural resistance and the sphere will deform as if the rib was not present. If we then set $ \alpha = 0 $ we apply a spherically symmetric forcing onto the structure and would expect the resulting displacement field (at least in the sphere) to be spherically symmetric, too.

The animation of the displacement field for this case, shown below, shows that this is indeed the case\+:

 
\begin{DoxyImage}
\includegraphics[width=0.8\textwidth]{anim_alpha0}
\doxyfigcaption{Animation of the time-\/harmonic deformation for a uniform pressure load and a very soft and inertia-\/less rib. }
\end{DoxyImage}


Here is a plot of the corresponding fluid displacement potential, a measure of the fluid pressure\+:

 
\begin{DoxyImage}
\includegraphics[width=0.8\textwidth]{potential_unstr_alpha0}
\doxyfigcaption{The fluid displacement potential, a measure of the fluid pressure for a uniform pressure load and a very soft and inertia-\/less rib. Elevation\+: real part; contours\+: imaginary part. }
\end{DoxyImage}




 

\hypertarget{index_num}{}\section{The numerical solution}\label{index_num}
The driver code for this problem is very similar to the one discussed in \href{../../sphere/html/index.html}{\tt another tutorial}. Running {\ttfamily sdiff} on the two driver codes \begin{center} \href{../../../../demo_drivers/interaction/fourier_decomposed_acoustic_fsi/fourier_decomposed_acoustic_fsi.cc}{\tt demo\+\_\+drivers/interaction/fourier\+\_\+decomposed\+\_\+acoustic\+\_\+fsi/fourier\+\_\+decomposed\+\_\+acoustic\+\_\+fsi.\+cc } \end{center}  and \begin{center} \href{../../../../demo_drivers/interaction/fourier_decomposed_acoustic_fsi/unstructured_fourier_decomposed_acoustic_fsi.cc}{\tt demo\+\_\+drivers/interaction/fourier\+\_\+decomposed\+\_\+acoustic\+\_\+fsi/unstructured\+\_\+fourier\+\_\+decomposed\+\_\+acoustic\+\_\+fsi.\+cc } \end{center}  shows you the differences, the most important of which are\+:
\begin{DoxyItemize}
\item The provision of multiple non-\/dimensional Young\textquotesingle{}s moduli and frequency parameters for the two different regions (the rib and the sphere). \href{../../../time_harmonic_fourier_decomposed_linear_elasticity/cylinder/html/index.html#comments}{\tt Recall} that the non-\/dimensional Young\textquotesingle{}s modulus specified via {\ttfamily Time\+Harmonic\+Fourier\+Decomposed\+Linear\+Elasticity\+Equations\+::youngs\+\_\+modulus\+\_\+pt()} represents the ratio of the material\textquotesingle{}s actual Young\textquotesingle{}s modulus to the Young\textquotesingle{}s modulus used in \href{../../../time_harmonic_fourier_decomposed_linear_elasticity/cylinder/html/index.html#theory}{\tt the non-\/dimensionalisation of the equations. } ~\newline
~\newline

\item The change of forcing from a prescribed time-\/harmonic displacement to a pressure load on the inside boundary -- this requires yet another mesh of {\ttfamily Face\+Elements}. ~\newline
~\newline

\item The provision of the {\ttfamily actions\+\_\+before/after\+\_\+adapt}() functions and a helper function {\ttfamily complete\+\_\+problem\+\_\+setup()} which rebuilds the elements (by passing the problem parameters to the elements) following the unstructured mesh adaptation. (The need/rationale for such a function is discussed in \href{../../../meshes/mesh_from_inline_triangle/html/index.html}{\tt another tutorial.}) ~\newline
~\newline

\item The mesh generation -- the specification of the curvilinear boundaries and the geometry of the rib is somewhat tedious. We refer to \href{../../../meshes/mesh_from_inline_triangle_internal_boundaries/html/index.html}{\tt another tutorial} for a discussion of how to define the internal mesh boundary that separates the two regions (the rib and the sphere) so that we can assign different material properties to them. ~\newline
~\newline

\end{DoxyItemize}All of this is reasonably straightforward and provides a powerful code that automatically adapts both meshes while respecting the curvilinear boundaries of the domain. Have a look through the driver code and play with it.



 

\hypertarget{index_code}{}\section{Code listing}\label{index_code}
Here\textquotesingle{}s a listing of the complete driver code\+:


\begin{DoxyCodeInclude}
\textcolor{comment}{//LIC// ====================================================================}
\textcolor{comment}{//LIC// This file forms part of oomph-lib, the object-oriented, }
\textcolor{comment}{//LIC// multi-physics finite-element library, available }
\textcolor{comment}{//LIC// at http://www.oomph-lib.org.}
\textcolor{comment}{//LIC// }
\textcolor{comment}{//LIC//    Version 1.0; svn revision $LastChangedRevision$}
\textcolor{comment}{//LIC//}
\textcolor{comment}{//LIC// $LastChangedDate$}
\textcolor{comment}{//LIC// }
\textcolor{comment}{//LIC// Copyright (C) 2006-2016 Matthias Heil and Andrew Hazel}
\textcolor{comment}{//LIC// }
\textcolor{comment}{//LIC// This library is free software; you can redistribute it and/or}
\textcolor{comment}{//LIC// modify it under the terms of the GNU Lesser General Public}
\textcolor{comment}{//LIC// License as published by the Free Software Foundation; either}
\textcolor{comment}{//LIC// version 2.1 of the License, or (at your option) any later version.}
\textcolor{comment}{//LIC// }
\textcolor{comment}{//LIC// This library is distributed in the hope that it will be useful,}
\textcolor{comment}{//LIC// but WITHOUT ANY WARRANTY; without even the implied warranty of}
\textcolor{comment}{//LIC// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU}
\textcolor{comment}{//LIC// Lesser General Public License for more details.}
\textcolor{comment}{//LIC// }
\textcolor{comment}{//LIC// You should have received a copy of the GNU Lesser General Public}
\textcolor{comment}{//LIC// License along with this library; if not, write to the Free Software}
\textcolor{comment}{//LIC// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA}
\textcolor{comment}{//LIC// 02110-1301  USA.}
\textcolor{comment}{//LIC// }
\textcolor{comment}{//LIC// The authors may be contacted at oomph-lib@maths.man.ac.uk.}
\textcolor{comment}{//LIC// }
\textcolor{comment}{//LIC//====================================================================}
\textcolor{comment}{// Driver for Helmholtz/TimeHarmonicTimeHarmonicLinElast coupling}
\textcolor{preprocessor}{#include <complex>}
\textcolor{preprocessor}{#include <cmath>}

\textcolor{comment}{//Oomph-lib includes}
\textcolor{preprocessor}{#include "generic.h"}

\textcolor{comment}{//The Helmholtz equation}
\textcolor{preprocessor}{#include "fourier\_decomposed\_helmholtz.h"}

\textcolor{comment}{//The Elasticity equation}
\textcolor{preprocessor}{#include "time\_harmonic\_fourier\_decomposed\_linear\_elasticity.h"}

\textcolor{comment}{// The interaction elements}
\textcolor{preprocessor}{#include "multi\_physics.h"}

\textcolor{comment}{// The meshes}
\textcolor{preprocessor}{#include "meshes/annular\_mesh.h"}
\textcolor{preprocessor}{#include "meshes/triangle\_mesh.h"}

\textcolor{comment}{// Get the Bessel functions}
\textcolor{preprocessor}{#include "oomph\_crbond\_bessel.h"}

\textcolor{keyword}{using namespace }\hyperlink{namespaceoomph}{oomph};
\textcolor{keyword}{using namespace }\hyperlink{namespacestd}{std};

\textcolor{comment}{}
\textcolor{comment}{///////////////////////////////////////////////////////////////////////}
\textcolor{comment}{///////////////////////////////////////////////////////////////////////}
\textcolor{comment}{}\textcolor{comment}{// Straight line as geometric object}\textcolor{comment}{}
\textcolor{comment}{///////////////////////////////////////////////////////////////////////}
\textcolor{comment}{///////////////////////////////////////////////////////////////////////}
\textcolor{comment}{}


\textcolor{comment}{//=========================================================================}\textcolor{comment}{}
\textcolor{comment}{/// Straight 1D line in 2D space }
\textcolor{comment}{}\textcolor{comment}{//=========================================================================}
\textcolor{keyword}{class }\hyperlink{classMyStraightLine}{MyStraightLine} : \textcolor{keyword}{public} GeomObject
\{

\textcolor{keyword}{public}:
\textcolor{comment}{}
\textcolor{comment}{ /// Constructor:  Pass start and end points}
\textcolor{comment}{} \hyperlink{classMyStraightLine}{MyStraightLine}(\textcolor{keyword}{const} Vector<double>& r\_start, \textcolor{keyword}{const} Vector<double>& r\_end) 
  :  GeomObject(1,2), R\_start(r\_start), R\_end(r\_end)
  \{ \}

\textcolor{comment}{}
\textcolor{comment}{ /// Broken copy constructor}
\textcolor{comment}{} \hyperlink{classMyStraightLine}{MyStraightLine}(\textcolor{keyword}{const} \hyperlink{classMyStraightLine}{MyStraightLine}& dummy) 
  \{ 
   BrokenCopy::broken\_copy(\textcolor{stringliteral}{"MyStraightLine"});
  \} 
 \textcolor{comment}{}
\textcolor{comment}{ /// Destructor:  Empty}
\textcolor{comment}{} ~\hyperlink{classMyStraightLine}{MyStraightLine}()\{\}
 \textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Position Vector at Lagrangian coordinate zeta }
\textcolor{comment}{} \textcolor{keywordtype}{void} position(\textcolor{keyword}{const} Vector<double>& zeta, Vector<double>& r)\textcolor{keyword}{ const}
\textcolor{keyword}{  }\{
   \textcolor{comment}{// Position Vector}
   r[0] = R\_start[0]+(R\_end[0]-R\_start[0])*zeta[0];
   r[1] = R\_start[1]+(R\_end[1]-R\_start[1])*zeta[0];
  \}
 
\textcolor{keyword}{private}:
 \textcolor{comment}{}
\textcolor{comment}{ /// Start point of line}
\textcolor{comment}{} Vector<double> R\_start;
 \textcolor{comment}{}
\textcolor{comment}{ /// End point of line}
\textcolor{comment}{} Vector<double> R\_end;

\};

\textcolor{comment}{}
\textcolor{comment}{//////////////////////////////////////////////////////////////////////}
\textcolor{comment}{//////////////////////////////////////////////////////////////////////}
\textcolor{comment}{//////////////////////////////////////////////////////////////////////}
\textcolor{comment}{}

\textcolor{comment}{//=======start\_of\_namespace==========================================}\textcolor{comment}{}
\textcolor{comment}{/// Global variables}
\textcolor{comment}{}\textcolor{comment}{//===================================================================}
\textcolor{keyword}{namespace }\hyperlink{namespaceGlobal__Parameters}{Global\_Parameters}
\{
\textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Square of wavenumber for the Helmholtz equation}
\textcolor{comment}{} \textcolor{keywordtype}{double} K\_squared=10.0;
 \textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Radius of outer boundary of Helmholtz domain}
\textcolor{comment}{} \textcolor{keywordtype}{double} Outer\_radius=2.0; 
\textcolor{comment}{}
\textcolor{comment}{ /// FSI parameter}
\textcolor{comment}{} \textcolor{keywordtype}{double} Q=10.0;
\textcolor{comment}{}
\textcolor{comment}{ /// Non-dim thickness of elastic coating}
\textcolor{comment}{} \textcolor{keywordtype}{double} H\_coating=0.1; 
\textcolor{comment}{}
\textcolor{comment}{ /// Define azimuthal Fourier wavenumber}
\textcolor{comment}{} \textcolor{keywordtype}{int} Fourier\_wavenumber=0;
   \textcolor{comment}{}
\textcolor{comment}{ /// Poisson's ratio Nu}
\textcolor{comment}{} std::complex<double> \hyperlink{namespaceGlobal__Parameters_a373950a959cd784c8f8028099807c2fb}{Nu}(std::complex<double>(0.3,0.0));
\textcolor{comment}{}
\textcolor{comment}{ /// Define the non-dimensional Young's modulus}
\textcolor{comment}{} Vector<std::complex<double> > \hyperlink{namespaceGlobal__Parameters_aa961bcca2115ce9cb37cc8ccb1b90cae}{E}(2,std::complex<double>(1.0,0.0));
\textcolor{comment}{}
\textcolor{comment}{ /// Non-dim square of frequency for solid -- dependent variable!}
\textcolor{comment}{} Vector<std::complex<double> > \hyperlink{namespaceGlobal__Parameters_a91314f7f1cc80c43543948568f50f405}{Omega\_sq}(2,std::complex<double>(100.0,0.0));
\textcolor{comment}{}
\textcolor{comment}{ /// Density ratio: solid to fluid}
\textcolor{comment}{}Vector<double> \hyperlink{namespaceGlobal__Parameters_a517d4c31b8bce6563c2f605266dd9679}{Density\_ratio}(2,1.0);
\textcolor{comment}{}
\textcolor{comment}{ /// Function to update dependent parameter values}
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{namespaceGlobal__Parameters_ae0f9a80fb7510dbfbbef22582da231b7}{update\_parameter\_values}()
 \{
  \hyperlink{namespaceGlobal__Parameters_a91314f7f1cc80c43543948568f50f405}{Omega\_sq}[0]=\hyperlink{namespaceGlobal__Parameters_a517d4c31b8bce6563c2f605266dd9679}{Density\_ratio}[0]*\hyperlink{namespaceGlobal__Parameters_a7814fddf663e56168174a42d2cd6b4c1}{Q};
  \hyperlink{namespaceGlobal__Parameters_a91314f7f1cc80c43543948568f50f405}{Omega\_sq}[1]=\hyperlink{namespaceGlobal__Parameters_a517d4c31b8bce6563c2f605266dd9679}{Density\_ratio}[1]*\hyperlink{namespaceGlobal__Parameters_a7814fddf663e56168174a42d2cd6b4c1}{Q};
 \}
\textcolor{comment}{}
\textcolor{comment}{ /// Uniform pressure}
\textcolor{comment}{} \textcolor{keywordtype}{double} P = 0.1;
\textcolor{comment}{}
\textcolor{comment}{ /// Peakiness parameter for pressure load}
\textcolor{comment}{} \textcolor{keywordtype}{double} Alpha=0.0; 
\textcolor{comment}{}
\textcolor{comment}{ /// Pressure load (real and imag part)}
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{namespaceGlobal__Parameters_a0ddb3a77481b907fbb34f2e8d0a6eb9f}{pressure\_load}(\textcolor{keyword}{const} Vector<double> &x,
                    \textcolor{keyword}{const} Vector<double> &n, 
                    Vector<std::complex<double> >&traction)
 \{
  \textcolor{keywordtype}{double} phi=atan2(x[1],x[0]);
  \textcolor{keywordtype}{double} magnitude=exp(-Alpha*pow(phi-0.25*MathematicalConstants::Pi,2));

  \textcolor{keywordtype}{unsigned} dim = 2;
  \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} i=0;i<dim;i++)
   \{
    traction[i] = complex<double>(-magnitude*P*n[i],magnitude*P*n[i]);
   \}
 \} \textcolor{comment}{// end\_of\_pressure\_load}
\textcolor{comment}{}
\textcolor{comment}{ /// Output directory}
\textcolor{comment}{} \textcolor{keywordtype}{string} \hyperlink{namespaceGlobal__Parameters_a301ab922df72030c660b21328d6caf76}{Directory}=\textcolor{stringliteral}{"RESLT"};
 
\} \textcolor{comment}{//end\_of\_namespace}



\textcolor{comment}{//=============start\_of\_problem\_class===================================}\textcolor{comment}{}
\textcolor{comment}{/// Coated sphere FSI}
\textcolor{comment}{}\textcolor{comment}{//====================================================================== }
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELASTICITY\_ELEMENT, \textcolor{keyword}{class} HELMHOLTZ\_ELEMENT>
\textcolor{keyword}{class }\hyperlink{classCoatedSphereProblem}{CoatedSphereProblem} : \textcolor{keyword}{public} Problem
\{

\textcolor{keyword}{public}:
\textcolor{comment}{}
\textcolor{comment}{ /// Constructor:}
\textcolor{comment}{} \hyperlink{classCoatedSphereProblem}{CoatedSphereProblem}();
 \textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Update function (empty)}
\textcolor{comment}{} \textcolor{keywordtype}{void} actions\_before\_newton\_solve()\{\}
\textcolor{comment}{}
\textcolor{comment}{ /// Update function (empty)}
\textcolor{comment}{} \textcolor{keywordtype}{void} actions\_after\_newton\_solve() \{\}
 \textcolor{comment}{}
\textcolor{comment}{ /// Actions before adapt: Wipe the face meshes}
\textcolor{comment}{} \textcolor{keywordtype}{void} actions\_before\_adapt();
\textcolor{comment}{}
\textcolor{comment}{ /// Actions after adapt: Rebuild the face meshes}
\textcolor{comment}{} \textcolor{keywordtype}{void} actions\_after\_adapt();
\textcolor{comment}{}
\textcolor{comment}{ /// Recompute gamma integral before checking Newton residuals}
\textcolor{comment}{} \textcolor{keywordtype}{void} actions\_before\_newton\_convergence\_check()
  \{
   Helmholtz\_DtN\_mesh\_pt->setup\_gamma();
  \}
  \textcolor{comment}{}
\textcolor{comment}{ /// Doc the solution}
\textcolor{comment}{} \textcolor{keywordtype}{void} doc\_solution(DocInfo& doc\_info);

\textcolor{keyword}{private}:
\textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Create FSI traction elements}
\textcolor{comment}{} \textcolor{keywordtype}{void} create\_fsi\_traction\_elements();
\textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Create Helmholtz FSI flux elements}
\textcolor{comment}{} \textcolor{keywordtype}{void} create\_helmholtz\_fsi\_flux\_elements(); 
\textcolor{comment}{}
\textcolor{comment}{ /// Setup interaction}
\textcolor{comment}{} \textcolor{keywordtype}{void} setup\_interaction();
\textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Create DtN elements on outer boundary}
\textcolor{comment}{} \textcolor{keywordtype}{void} create\_helmholtz\_DtN\_elements();
\textcolor{comment}{}
\textcolor{comment}{ /// Create solid traction elements }
\textcolor{comment}{} \textcolor{keywordtype}{void} create\_solid\_traction\_elements();
\textcolor{comment}{}
\textcolor{comment}{ /// Delete (face) elements in specified mesh }
\textcolor{comment}{} \textcolor{keywordtype}{void} delete\_face\_elements(Mesh* \textcolor{keyword}{const} & boundary\_mesh\_pt);
 
 \textcolor{comment}{// Complete problem setup}
 \textcolor{keywordtype}{void} complete\_problem\_setup();
\textcolor{comment}{}
\textcolor{comment}{ /// Boundary ID of upper symmetry boundary}
\textcolor{comment}{} \textcolor{keywordtype}{unsigned} Upper\_symmetry\_boundary\_id;
\textcolor{comment}{}
\textcolor{comment}{ /// Boundary ID of lower symmetry boundary}
\textcolor{comment}{} \textcolor{keywordtype}{unsigned} Lower\_symmetry\_boundary\_id;
\textcolor{comment}{}
\textcolor{comment}{ /// Boundary ID of upper inner boundary}
\textcolor{comment}{} \textcolor{keywordtype}{unsigned} Upper\_inner\_boundary\_id;
\textcolor{comment}{}
\textcolor{comment}{ /// Boundary ID of lower inner boundary}
\textcolor{comment}{} \textcolor{keywordtype}{unsigned} Lower\_inner\_boundary\_id;
\textcolor{comment}{}
\textcolor{comment}{ /// Boundary ID of outer boundary}
\textcolor{comment}{} \textcolor{keywordtype}{unsigned} Outer\_boundary\_id;
\textcolor{comment}{}
\textcolor{comment}{ /// Boundary ID of rib divider}
\textcolor{comment}{} \textcolor{keywordtype}{unsigned} Rib\_divider\_boundary\_id;
\textcolor{comment}{}
\textcolor{comment}{ /// Boundary ID of outer boundary in Helmholtz mesh}
\textcolor{comment}{} \textcolor{keywordtype}{unsigned} HH\_outer\_boundary\_id;
\textcolor{comment}{}
\textcolor{comment}{ /// Boundary ID of inner boundary in Helmholtz mesh}
\textcolor{comment}{} \textcolor{keywordtype}{unsigned} HH\_inner\_boundary\_id;
\textcolor{comment}{}
\textcolor{comment}{ /// Boundary ID of upper boundary in Helmholtz mesh}
\textcolor{comment}{} \textcolor{keywordtype}{unsigned} HH\_upper\_symmetry\_boundary\_id;
\textcolor{comment}{}
\textcolor{comment}{ /// Boundary ID of lower boundary in Helmholtz mesh}
\textcolor{comment}{} \textcolor{keywordtype}{unsigned} HH\_lower\_symmetry\_boundary\_id;

\textcolor{preprocessor}{#ifdef ADAPTIVE}
\textcolor{comment}{}
\textcolor{comment}{ /// Pointer to solid mesh}
\textcolor{comment}{} RefineableTriangleMesh<ELASTICITY\_ELEMENT>* Solid\_mesh\_pt;

\textcolor{preprocessor}{#else}
\textcolor{comment}{}
\textcolor{comment}{ /// Pointer to solid mesh}
\textcolor{comment}{} TriangleMesh<ELASTICITY\_ELEMENT>* Solid\_mesh\_pt;

\textcolor{preprocessor}{#endif}

\textcolor{comment}{}
\textcolor{comment}{ /// Pointer to mesh of solid traction elements}
\textcolor{comment}{} Mesh* Solid\_traction\_mesh\_pt;
\textcolor{comment}{}
\textcolor{comment}{ /// Pointer to mesh of FSI traction elements}
\textcolor{comment}{} Mesh* FSI\_traction\_mesh\_pt;

\textcolor{preprocessor}{#ifdef ADAPTIVE}
\textcolor{comment}{}
\textcolor{comment}{ /// Pointer to Helmholtz mesh}
\textcolor{comment}{} RefineableTriangleMesh<HELMHOLTZ\_ELEMENT>* Helmholtz\_mesh\_pt;

\textcolor{preprocessor}{#else}
\textcolor{comment}{}
\textcolor{comment}{ /// Pointer to Helmholtz mesh}
\textcolor{comment}{} TriangleMesh<HELMHOLTZ\_ELEMENT>* Helmholtz\_mesh\_pt;

\textcolor{preprocessor}{#endif}
\textcolor{comment}{}
\textcolor{comment}{ /// Pointer to mesh of Helmholtz FSI flux elements}
\textcolor{comment}{} Mesh* Helmholtz\_fsi\_flux\_mesh\_pt;
 \textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Pointer to mesh containing the DtN elements}
\textcolor{comment}{} FourierDecomposedHelmholtzDtNMesh<HELMHOLTZ\_ELEMENT>* Helmholtz\_DtN\_mesh\_pt;
 \textcolor{comment}{}
\textcolor{comment}{ /// Trace file}
\textcolor{comment}{} ofstream Trace\_file;

\};\textcolor{comment}{// end\_of\_problem\_class}


\textcolor{comment}{//===========start\_of\_constructor======================================= }\textcolor{comment}{}
\textcolor{comment}{/// Constructor: }
\textcolor{comment}{}\textcolor{comment}{//====================================================================== }
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELASTICITY\_ELEMENT, \textcolor{keyword}{class} HELMHOLTZ\_ELEMENT>
\hyperlink{classCoatedSphereProblem_ab9c983e7f0bed66f13d59bd65d6d151b}{CoatedSphereProblem<ELASTICITY\_ELEMENT, HELMHOLTZ\_ELEMENT>::}
\hyperlink{classCoatedSphereProblem_ab9c983e7f0bed66f13d59bd65d6d151b}{CoatedSphereProblem}() 
\{

 \textcolor{comment}{// Solid mesh}
 \textcolor{comment}{//-----------}
 \{

  \textcolor{comment}{// Start and end coordinates}
  Vector<double> r\_start(2);
  Vector<double> r\_end(2);
 
  \textcolor{comment}{// Outer radius of hull}
  \textcolor{keywordtype}{double} r\_outer = 1.0;

  \textcolor{comment}{// Inner radius of hull}
  \textcolor{keywordtype}{double} r\_inner = r\_outer-\hyperlink{namespaceGlobal__Parameters_ae3cf8878ede839bffda01f79bbe3e819}{Global\_Parameters::H\_coating};

  \textcolor{comment}{// Thickness of rib}
  \textcolor{keywordtype}{double} rib\_thick=0.05;
 
  \textcolor{comment}{// Depth of rib}
  \textcolor{keywordtype}{double} rib\_depth=0.2;

  \textcolor{comment}{// Total width of T}
  \textcolor{keywordtype}{double} t\_width=0.2;

  \textcolor{comment}{// Thickness of T}
  \textcolor{keywordtype}{double} t\_thick=0.05;

  \textcolor{comment}{// Half-opening angle of rib}
  \textcolor{keywordtype}{double} half\_phi\_rib=asin(0.5*rib\_thick/r\_inner);

  \textcolor{comment}{// Pointer to the closed curve that defines the outer boundary}
  TriangleMeshClosedCurve* closed\_curve\_pt=0;
 
  \textcolor{comment}{// Provide storage for pointers to the parts of the curvilinear boundary}
  Vector<TriangleMeshCurveSection*> curvilinear\_boundary\_pt;

  \textcolor{comment}{// Outer boundary}
  \textcolor{comment}{//---------------}
  Ellipse* outer\_boundary\_circle\_pt = \textcolor{keyword}{new} Ellipse(r\_outer,r\_outer);
  \textcolor{keywordtype}{double} zeta\_start=-0.5*MathematicalConstants::Pi;
  \textcolor{keywordtype}{double} zeta\_end=0.5*MathematicalConstants::Pi;
  \textcolor{keywordtype}{unsigned} nsegment=50;
  \textcolor{keywordtype}{unsigned} boundary\_id=curvilinear\_boundary\_pt.size();
  curvilinear\_boundary\_pt.push\_back(
   \textcolor{keyword}{new} TriangleMeshCurviLine(
    outer\_boundary\_circle\_pt,zeta\_start,zeta\_end,nsegment,boundary\_id));

  \textcolor{comment}{// Remember it}
  Outer\_boundary\_id=boundary\_id;
 

  \textcolor{comment}{// Upper straight line segment on symmetry axis}
  \textcolor{comment}{//---------------------------------------------}
  r\_start[0]=0.0;
  r\_start[1]=r\_outer;
  r\_end[0]=0.0;
  r\_end[1]=r\_inner;
  \hyperlink{classMyStraightLine}{MyStraightLine}* upper\_sym\_pt = \textcolor{keyword}{new} \hyperlink{classMyStraightLine}{MyStraightLine}(r\_start,r\_end);
  zeta\_start=0.0;
  zeta\_end=1.0;
  nsegment=1;
  boundary\_id=curvilinear\_boundary\_pt.size();
  curvilinear\_boundary\_pt.push\_back(
   \textcolor{keyword}{new} TriangleMeshCurviLine(
    upper\_sym\_pt,zeta\_start,zeta\_end,nsegment,boundary\_id));
                                                        
  \textcolor{comment}{// Remember it}
  Upper\_symmetry\_boundary\_id=boundary\_id;
 
  \textcolor{comment}{// Upper part of inner boundary}
  \textcolor{comment}{//-----------------------------}
  Ellipse* upper\_inner\_boundary\_pt = 
   \textcolor{keyword}{new} Ellipse(r\_inner,r\_inner);
  zeta\_start=0.5*MathematicalConstants::Pi;
  zeta\_end=half\_phi\_rib;
  nsegment=20;
  boundary\_id=curvilinear\_boundary\_pt.size();
  curvilinear\_boundary\_pt.push\_back(
   \textcolor{keyword}{new} TriangleMeshCurviLine(
    upper\_inner\_boundary\_pt,
    zeta\_start,zeta\_end,nsegment,boundary\_id));

  \textcolor{comment}{// Remember it}
  Upper\_inner\_boundary\_id=boundary\_id;

  \textcolor{comment}{// Data associated with rib}
  \hyperlink{classMyStraightLine}{MyStraightLine}* upper\_inward\_rib\_pt=0;
  \hyperlink{classMyStraightLine}{MyStraightLine}* lower\_inward\_rib\_pt=0;
  TriangleMeshCurviLine* upper\_inward\_rib\_curviline\_pt=0;
  Vector<TriangleMeshOpenCurve*> inner\_boundary\_pt;
  TriangleMeshCurviLine* lower\_inward\_rib\_curviline\_pt=0;
  Vector<double> rib\_center(2);

  \textcolor{comment}{// Upper half of inward rib}
  \textcolor{comment}{//-------------------------}
  r\_start[0]=r\_inner*cos(half\_phi\_rib);
  r\_start[1]=r\_inner*sin(half\_phi\_rib);
  r\_end[0]=r\_start[0]-rib\_depth;
  r\_end[1]=r\_start[1];
  upper\_inward\_rib\_pt = \textcolor{keyword}{new} \hyperlink{classMyStraightLine}{MyStraightLine}(r\_start,r\_end);
  zeta\_start=0.0;
  zeta\_end=1.0;
  nsegment=1;
  boundary\_id=curvilinear\_boundary\_pt.size();
  upper\_inward\_rib\_curviline\_pt=
   \textcolor{keyword}{new} TriangleMeshCurviLine(
    upper\_inward\_rib\_pt,zeta\_start,zeta\_end,nsegment,boundary\_id);
  curvilinear\_boundary\_pt.push\_back(upper\_inward\_rib\_curviline\_pt);

  \textcolor{comment}{// Vertical upper bit of T}
  \textcolor{comment}{//------------------------}
  r\_start[0]=r\_end[0];
  r\_start[1]=r\_end[1];
  r\_end[0]=r\_start[0];
  r\_end[1]=r\_start[1]+0.5*(t\_width-rib\_thick);
  \hyperlink{classMyStraightLine}{MyStraightLine}* vertical\_upper\_t\_rib\_pt = \textcolor{keyword}{new} \hyperlink{classMyStraightLine}{MyStraightLine}(r\_start,r\_end);
  zeta\_start=0.0;
  zeta\_end=1.0;
  nsegment=1;
  boundary\_id=curvilinear\_boundary\_pt.size();
  curvilinear\_boundary\_pt.push\_back(
   \textcolor{keyword}{new} TriangleMeshCurviLine(
    vertical\_upper\_t\_rib\_pt,zeta\_start,zeta\_end,nsegment,boundary\_id));


  \textcolor{comment}{// Horizontal upper bit of T}
  \textcolor{comment}{//-----------==-------------}
  r\_start[0]=r\_end[0];
  r\_start[1]=r\_end[1];
  r\_end[0]=r\_start[0]-t\_thick;
  r\_end[1]=r\_start[1];
  \hyperlink{classMyStraightLine}{MyStraightLine}* horizontal\_upper\_t\_rib\_pt = \textcolor{keyword}{new} \hyperlink{classMyStraightLine}{MyStraightLine}(r\_start,r\_end)
      ;
  zeta\_start=0.0;
  zeta\_end=1.0;
  nsegment=1;
  boundary\_id=curvilinear\_boundary\_pt.size();
  curvilinear\_boundary\_pt.push\_back(
   \textcolor{keyword}{new} TriangleMeshCurviLine(
    horizontal\_upper\_t\_rib\_pt,zeta\_start,zeta\_end,nsegment,boundary\_id));

  \textcolor{comment}{// Vertical end of rib end}
  \textcolor{comment}{//------------------------}
  r\_start[0]=r\_end[0];
  r\_start[1]=r\_end[1];
  r\_end[0]=r\_start[0];
  r\_end[1]=-r\_start[1];
  \hyperlink{classMyStraightLine}{MyStraightLine}* inner\_vertical\_rib\_pt = \textcolor{keyword}{new} \hyperlink{classMyStraightLine}{MyStraightLine}(r\_start,r\_end);
  zeta\_start=0.0;
  zeta\_end=1.0;
  nsegment=1;
  boundary\_id=curvilinear\_boundary\_pt.size();
  curvilinear\_boundary\_pt.push\_back(
   \textcolor{keyword}{new} TriangleMeshCurviLine(
    inner\_vertical\_rib\_pt,zeta\_start,zeta\_end,nsegment,boundary\_id));
 

  \textcolor{comment}{// Horizontal lower bit of T}
  \textcolor{comment}{//-----------==-------------}
  r\_start[0]=r\_end[0];
  r\_start[1]=r\_end[1];
  r\_end[0]=r\_start[0]+t\_thick;
  r\_end[1]=r\_start[1];
  \hyperlink{classMyStraightLine}{MyStraightLine}* horizontal\_lower\_t\_rib\_pt = \textcolor{keyword}{new} \hyperlink{classMyStraightLine}{MyStraightLine}(r\_start,r\_end)
      ;
  zeta\_start=0.0;
  zeta\_end=1.0;
  nsegment=1;
  boundary\_id=curvilinear\_boundary\_pt.size();
  curvilinear\_boundary\_pt.push\_back(
   \textcolor{keyword}{new} TriangleMeshCurviLine(
    horizontal\_lower\_t\_rib\_pt,zeta\_start,zeta\_end,nsegment,boundary\_id));


  \textcolor{comment}{// Vertical lower bit of T}
  \textcolor{comment}{//------------------------}
  r\_start[0]=r\_end[0];
  r\_start[1]=r\_end[1];
  r\_end[0]=r\_start[0];
  r\_end[1]=r\_start[1]+0.5*(t\_width-rib\_thick);
  \hyperlink{classMyStraightLine}{MyStraightLine}* vertical\_lower\_t\_rib\_pt = \textcolor{keyword}{new} \hyperlink{classMyStraightLine}{MyStraightLine}(r\_start,r\_end);
  zeta\_start=0.0;
  zeta\_end=1.0;
  nsegment=1;
  boundary\_id=curvilinear\_boundary\_pt.size();
  curvilinear\_boundary\_pt.push\_back(
   \textcolor{keyword}{new} TriangleMeshCurviLine(
    vertical\_lower\_t\_rib\_pt,zeta\_start,zeta\_end,nsegment,boundary\_id));


  \textcolor{comment}{// Lower half of inward rib}
  \textcolor{comment}{//-------------------------}
  r\_end[0]=r\_inner*cos(half\_phi\_rib);
  r\_end[1]=-r\_inner*sin(half\_phi\_rib);
  r\_start[0]=r\_end[0]-rib\_depth;
  r\_start[1]=r\_end[1];
  lower\_inward\_rib\_pt = \textcolor{keyword}{new} \hyperlink{classMyStraightLine}{MyStraightLine}(r\_start,r\_end);
  zeta\_start=0.0;
  zeta\_end=1.0;
  nsegment=1;
  boundary\_id=curvilinear\_boundary\_pt.size();
  lower\_inward\_rib\_curviline\_pt=
   \textcolor{keyword}{new} TriangleMeshCurviLine(
    lower\_inward\_rib\_pt,zeta\_start,zeta\_end,nsegment,boundary\_id);
  curvilinear\_boundary\_pt.push\_back(lower\_inward\_rib\_curviline\_pt);


  \textcolor{comment}{// Lower part of inner boundary}
  \textcolor{comment}{//-----------------------------}
  Ellipse* lower\_inner\_boundary\_circle\_pt = \textcolor{keyword}{new} Ellipse(r\_inner,r\_inner);
  zeta\_start=-half\_phi\_rib;
  zeta\_end=-0.5*MathematicalConstants::Pi;
  nsegment=20;
  boundary\_id=curvilinear\_boundary\_pt.size();
  curvilinear\_boundary\_pt.push\_back(
   \textcolor{keyword}{new} TriangleMeshCurviLine(
    lower\_inner\_boundary\_circle\_pt,zeta\_start,zeta\_end,nsegment,boundary\_id)); 
 
  \textcolor{comment}{// Remember it}
  Lower\_inner\_boundary\_id=boundary\_id;

  \textcolor{comment}{// Lower straight line segment on symmetry axis}
  \textcolor{comment}{//---------------------------------------------}
  r\_start[0]=0.0;
  r\_start[1]=-r\_inner;
  r\_end[0]=0.0;
  r\_end[1]=-r\_outer;
  \hyperlink{classMyStraightLine}{MyStraightLine}* lower\_sym\_pt = \textcolor{keyword}{new} \hyperlink{classMyStraightLine}{MyStraightLine}(r\_start,r\_end);
  zeta\_start=0.0;
  zeta\_end=1.0;
  nsegment=1;
  boundary\_id=curvilinear\_boundary\_pt.size();
  curvilinear\_boundary\_pt.push\_back(
   \textcolor{keyword}{new} TriangleMeshCurviLine(
    lower\_sym\_pt,zeta\_start,zeta\_end,nsegment,boundary\_id));
      
  \textcolor{comment}{// Remember it}
  Lower\_symmetry\_boundary\_id=boundary\_id;

  \textcolor{comment}{// Combine to curvilinear boundary}
  \textcolor{comment}{//--------------------------------}
  closed\_curve\_pt=
   \textcolor{keyword}{new} TriangleMeshClosedCurve(curvilinear\_boundary\_pt); 
 
  \textcolor{comment}{// Vertical dividing line across base of T-rib}
  \textcolor{comment}{//--------------------------------------------}
  Vector<TriangleMeshCurveSection*> internal\_polyline\_pt(1);
  r\_start[0]=r\_inner*cos(half\_phi\_rib);
  r\_start[1]=r\_inner*sin(half\_phi\_rib);
  r\_end[0]=r\_inner*cos(half\_phi\_rib);
  r\_end[1]=-r\_inner*sin(half\_phi\_rib);

  Vector<Vector<double> > boundary\_vertices(2);
  boundary\_vertices[0]=r\_start;
  boundary\_vertices[1]=r\_end;
  boundary\_id=100;
  TriangleMeshPolyLine* rib\_divider\_pt=
   \textcolor{keyword}{new} TriangleMeshPolyLine(boundary\_vertices,boundary\_id); 
  internal\_polyline\_pt[0]=rib\_divider\_pt;

  \textcolor{comment}{// Remember it}
  Rib\_divider\_boundary\_id=boundary\_id;

  \textcolor{comment}{// Make connection}
  \textcolor{keywordtype}{double} s\_connect=0.0;
  internal\_polyline\_pt[0]->connect\_initial\_vertex\_to\_curviline(
   upper\_inward\_rib\_curviline\_pt,s\_connect);

  \textcolor{comment}{// Make connection}
  s\_connect=1.0;
  internal\_polyline\_pt[0]->connect\_final\_vertex\_to\_curviline(
   lower\_inward\_rib\_curviline\_pt,s\_connect);

  \textcolor{comment}{// Create open curve that defines internal bondary}
  inner\_boundary\_pt.push\_back(\textcolor{keyword}{new} TriangleMeshOpenCurve(internal\_polyline\_pt));
 
  \textcolor{comment}{// Define coordinates of a point inside the rib}
  rib\_center[0]=r\_inner-rib\_depth;
  rib\_center[1]=0.0;


  \textcolor{comment}{// Now build the mesh}
  \textcolor{comment}{//===================}

  \textcolor{comment}{// Use the TriangleMeshParameters object for helping on the manage of the}
  \textcolor{comment}{// TriangleMesh parameters. The only parameter that needs to take is the}
  \textcolor{comment}{// outer boundary.}
  TriangleMeshParameters triangle\_mesh\_parameters(closed\_curve\_pt);

  \textcolor{comment}{// Target area}
  triangle\_mesh\_parameters.element\_area()=0.2;

  \textcolor{comment}{// Specify the internal open boundary}
  triangle\_mesh\_parameters.internal\_open\_curves\_pt()=inner\_boundary\_pt;

  \textcolor{comment}{// Define the region}
  triangle\_mesh\_parameters.add\_region\_coordinates(1,rib\_center);
 
\textcolor{preprocessor}{#ifdef ADAPTIVE}

  \textcolor{comment}{// Build the mesh}
  Solid\_mesh\_pt=\textcolor{keyword}{new} 
   RefineableTriangleMesh<ELASTICITY\_ELEMENT>(triangle\_mesh\_parameters);

\textcolor{preprocessor}{#else}

  \textcolor{comment}{// Build the mesh}
  Solid\_mesh\_pt=\textcolor{keyword}{new} 
   TriangleMesh<ELASTICITY\_ELEMENT>(triangle\_mesh\_parameters);

\textcolor{preprocessor}{#endif}

 \}
 
 \textcolor{comment}{// Helmholtz mesh}
 \textcolor{comment}{//---------------}
 \{
  \textcolor{comment}{// Start and end coordinates}
  Vector<double> r\_start(2);
  Vector<double> r\_end(2);
 
  \textcolor{comment}{// Inner radius of helmholtz region}
  \textcolor{keywordtype}{double} r\_inner = 1.0;

  \textcolor{comment}{// Outer radius of Helmholtz region}
  \textcolor{keywordtype}{double} r\_outer = \hyperlink{namespaceGlobal__Parameters_a88ded445ecd7bd89701409e68fd0b900}{Global\_Parameters::Outer\_radius};

  \textcolor{comment}{// Pointer to the closed curve that defines the outer boundary}
  TriangleMeshClosedCurve* closed\_curve\_pt=0;
 
  \textcolor{comment}{// Provide storage for pointers to the parts of the curvilinear boundary}
  Vector<TriangleMeshCurveSection*> curvilinear\_boundary\_pt;

  \textcolor{comment}{// Outer boundary}
  \textcolor{comment}{//---------------}
  Ellipse* outer\_boundary\_circle\_pt = \textcolor{keyword}{new} Ellipse(r\_outer,r\_outer);
  \textcolor{keywordtype}{double} zeta\_start=-0.5*MathematicalConstants::Pi;
  \textcolor{keywordtype}{double} zeta\_end=0.5*MathematicalConstants::Pi;
  \textcolor{keywordtype}{unsigned} nsegment=50;
  \textcolor{keywordtype}{unsigned} boundary\_id=curvilinear\_boundary\_pt.size();
  curvilinear\_boundary\_pt.push\_back(
   \textcolor{keyword}{new} TriangleMeshCurviLine(
    outer\_boundary\_circle\_pt,zeta\_start,zeta\_end,nsegment,boundary\_id));
  
  \textcolor{comment}{// Remember it}
  HH\_outer\_boundary\_id=boundary\_id;
  
  
  \textcolor{comment}{// Upper straight line segment on symmetry axis}
  \textcolor{comment}{//---------------------------------------------}
  r\_start[0]=0.0;
  r\_start[1]=r\_outer;
  r\_end[0]=0.0;
  r\_end[1]=r\_inner;
  \hyperlink{classMyStraightLine}{MyStraightLine}* upper\_sym\_pt = \textcolor{keyword}{new} \hyperlink{classMyStraightLine}{MyStraightLine}(r\_start,r\_end);
  zeta\_start=0.0;
  zeta\_end=1.0;
  nsegment=1;
  boundary\_id=curvilinear\_boundary\_pt.size();
  curvilinear\_boundary\_pt.push\_back(
   \textcolor{keyword}{new} TriangleMeshCurviLine(
    upper\_sym\_pt,zeta\_start,zeta\_end,nsegment,boundary\_id));
                                                        
  \textcolor{comment}{// Remember it}
  HH\_upper\_symmetry\_boundary\_id=boundary\_id;
 
  \textcolor{comment}{// Inner boundary}
  \textcolor{comment}{//---------------}
  Ellipse* upper\_inner\_boundary\_pt = 
   \textcolor{keyword}{new} Ellipse(r\_inner,r\_inner);
  zeta\_start=0.5*MathematicalConstants::Pi;
  zeta\_end=-0.5*MathematicalConstants::Pi;
  nsegment=40;
  boundary\_id=curvilinear\_boundary\_pt.size();
  curvilinear\_boundary\_pt.push\_back(
   \textcolor{keyword}{new} TriangleMeshCurviLine(
    upper\_inner\_boundary\_pt,
    zeta\_start,zeta\_end,nsegment,boundary\_id));

  \textcolor{comment}{// Remember it}
  HH\_inner\_boundary\_id=boundary\_id;
  
  \textcolor{comment}{// Lower straight line segment on symmetry axis}
  \textcolor{comment}{//---------------------------------------------}
  r\_start[0]=0.0;
  r\_start[1]=-r\_inner;
  r\_end[0]=0.0;
  r\_end[1]=-r\_outer;
  \hyperlink{classMyStraightLine}{MyStraightLine}* lower\_sym\_pt = \textcolor{keyword}{new} \hyperlink{classMyStraightLine}{MyStraightLine}(r\_start,r\_end);
  zeta\_start=0.0;
  zeta\_end=1.0;
  nsegment=1;
  boundary\_id=curvilinear\_boundary\_pt.size();
  curvilinear\_boundary\_pt.push\_back(
   \textcolor{keyword}{new} TriangleMeshCurviLine(
    lower\_sym\_pt,zeta\_start,zeta\_end,nsegment,boundary\_id));
      
  \textcolor{comment}{// Remember it}
  HH\_lower\_symmetry\_boundary\_id=boundary\_id;

  \textcolor{comment}{// Combine to curvilinear boundary}
  \textcolor{comment}{//--------------------------------}
  closed\_curve\_pt=
   \textcolor{keyword}{new} TriangleMeshClosedCurve(curvilinear\_boundary\_pt); 
  
  \textcolor{comment}{// Now build the mesh}
  \textcolor{comment}{//===================}

  \textcolor{comment}{// Use the TriangleMeshParameters object for helping on the manage of the}
  \textcolor{comment}{// TriangleMesh parameters. The only parameter that needs to take is the}
  \textcolor{comment}{// outer boundary.}
  TriangleMeshParameters triangle\_mesh\_parameters(closed\_curve\_pt);

  \textcolor{comment}{// Target area}
  triangle\_mesh\_parameters.element\_area()=0.2;
 
\textcolor{preprocessor}{#ifdef ADAPTIVE}

  \textcolor{comment}{// Build the mesh}
  Helmholtz\_mesh\_pt=\textcolor{keyword}{new} 
   RefineableTriangleMesh<HELMHOLTZ\_ELEMENT>(triangle\_mesh\_parameters);

\textcolor{preprocessor}{#else}

  \textcolor{comment}{// Build the mesh}
  Helmholtz\_mesh\_pt=\textcolor{keyword}{new} 
   TriangleMesh<HELMHOLTZ\_ELEMENT>(triangle\_mesh\_parameters);

\textcolor{preprocessor}{#endif}

 \}

 \textcolor{comment}{// Create mesh for DtN elements on outer boundary}
 \textcolor{keywordtype}{unsigned} nfourier=20;
 Helmholtz\_DtN\_mesh\_pt=
  \textcolor{keyword}{new} FourierDecomposedHelmholtzDtNMesh<HELMHOLTZ\_ELEMENT>(
   \hyperlink{namespaceGlobal__Parameters_a88ded445ecd7bd89701409e68fd0b900}{Global\_Parameters::Outer\_radius},nfourier);


\textcolor{preprocessor}{#ifdef ADAPTIVE}

 \textcolor{comment}{// Set error estimators}
 Solid\_mesh\_pt->spatial\_error\_estimator\_pt()=\textcolor{keyword}{new} Z2ErrorEstimator;
 Helmholtz\_mesh\_pt->spatial\_error\_estimator\_pt()=\textcolor{keyword}{new} Z2ErrorEstimator;

\textcolor{preprocessor}{#endif}

 \textcolor{comment}{// Output meshes and their boundaries so far so we can double }
 \textcolor{comment}{// check the boundary enumeration}
 Solid\_mesh\_pt->output(\textcolor{stringliteral}{"solid\_mesh.dat"});
 Helmholtz\_mesh\_pt->output(\textcolor{stringliteral}{"helmholtz\_mesh.dat"});
 Solid\_mesh\_pt->output\_boundaries(\textcolor{stringliteral}{"solid\_mesh\_boundary.dat"});
 Helmholtz\_mesh\_pt->output\_boundaries(\textcolor{stringliteral}{"helmholtz\_mesh\_boundary.dat"});

 \textcolor{comment}{// Create FaceElement meshes for boundary conditions}
 \textcolor{comment}{//--------------------------------------------------}
 
 \textcolor{comment}{// Construct the solid traction element mesh}
 Solid\_traction\_mesh\_pt=\textcolor{keyword}{new} Mesh;
 create\_solid\_traction\_elements(); 

 \textcolor{comment}{// Construct the fsi traction element mesh}
 FSI\_traction\_mesh\_pt=\textcolor{keyword}{new} Mesh;
 create\_fsi\_traction\_elements();
 
 \textcolor{comment}{// Construct the Helmholtz fsi flux element mesh}
 Helmholtz\_fsi\_flux\_mesh\_pt=\textcolor{keyword}{new} Mesh;
 create\_helmholtz\_fsi\_flux\_elements();
 
 \textcolor{comment}{// Create DtN elements}
 create\_helmholtz\_DtN\_elements();

 \textcolor{comment}{// Combine sub meshes}
 \textcolor{comment}{//-------------------}
 add\_sub\_mesh(Solid\_mesh\_pt);
 add\_sub\_mesh(Solid\_traction\_mesh\_pt);
 add\_sub\_mesh(FSI\_traction\_mesh\_pt);
 add\_sub\_mesh(Helmholtz\_mesh\_pt);
 add\_sub\_mesh(Helmholtz\_fsi\_flux\_mesh\_pt);
 add\_sub\_mesh(Helmholtz\_DtN\_mesh\_pt); 
 
 \textcolor{comment}{// Build the Problem's global mesh from its various sub-meshes}
 build\_global\_mesh();
 
 \textcolor{comment}{// Complete problem setup}
 complete\_problem\_setup();
 
 \textcolor{comment}{// Setup fluid-structure interaction}
 \textcolor{comment}{//----------------------------------}
 setup\_interaction();

 \textcolor{comment}{// Open trace file}
 \textcolor{keywordtype}{char} filename[100];
 sprintf(filename,\textcolor{stringliteral}{"%s/trace.dat"},\hyperlink{namespaceGlobal__Parameters_a301ab922df72030c660b21328d6caf76}{Global\_Parameters::Directory}.c\_str());
 Trace\_file.open(filename);
  
 \textcolor{comment}{// Setup equation numbering scheme}
 cout <<\textcolor{stringliteral}{"Number of equations: "} << assign\_eqn\_numbers() << std::endl; 

\}\textcolor{comment}{//end\_of\_constructor}


\textcolor{comment}{//=====================start\_of\_actions\_before\_adapt======================}\textcolor{comment}{}
\textcolor{comment}{/// Actions before adapt: Wipe the meshes face elements}
\textcolor{comment}{}\textcolor{comment}{//========================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELASTICITY\_ELEMENT, \textcolor{keyword}{class} HELMHOLTZ\_ELEMENT>
\textcolor{keywordtype}{void} \hyperlink{classCoatedSphereProblem_a0cd5d4eea9d34eefd829f7539c41c998}{CoatedSphereProblem<ELASTICITY\_ELEMENT,HELMHOLTZ\_ELEMENT>::}
\hyperlink{classCoatedSphereProblem_a0cd5d4eea9d34eefd829f7539c41c998}{actions\_before\_adapt}()
\{
 \textcolor{comment}{// Kill the solid traction elements and wipe surface mesh}
 delete\_face\_elements(Solid\_traction\_mesh\_pt);

 \textcolor{comment}{// Kill the fsi traction elements and wipe surface mesh}
 delete\_face\_elements(FSI\_traction\_mesh\_pt);
 
 \textcolor{comment}{// Kill Helmholtz FSI flux elements}
 delete\_face\_elements(Helmholtz\_fsi\_flux\_mesh\_pt);
 
 \textcolor{comment}{// Kill Helmholtz BC elements }
 delete\_face\_elements(Helmholtz\_DtN\_mesh\_pt);
 
 \textcolor{comment}{// Rebuild the Problem's global mesh from its various sub-meshes}
 rebuild\_global\_mesh();

\}\textcolor{comment}{// end of actions\_before\_adapt}



\textcolor{comment}{//=====================start\_of\_actions\_after\_adapt=======================}\textcolor{comment}{}
\textcolor{comment}{///  Actions after adapt: Rebuild the meshes of face elements}
\textcolor{comment}{}\textcolor{comment}{//========================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELASTICITY\_ELEMENT, \textcolor{keyword}{class} HELMHOLTZ\_ELEMENT>
\textcolor{keywordtype}{void} \hyperlink{classCoatedSphereProblem_a77906dadd8ceb1d1d3182f298a0ca2d2}{CoatedSphereProblem<ELASTICITY\_ELEMENT,HELMHOLTZ\_ELEMENT>::}
\hyperlink{classCoatedSphereProblem_a77906dadd8ceb1d1d3182f298a0ca2d2}{actions\_after\_adapt}()
\{
 \textcolor{comment}{// Complete problem setup}
 complete\_problem\_setup(); 

 \textcolor{comment}{// Construct the solid traction elements}
 create\_solid\_traction\_elements(); 

 \textcolor{comment}{// Create fsi traction elements from all elements that are }
 \textcolor{comment}{// adjacent to FSI boundaries and add them to surface meshes}
 create\_fsi\_traction\_elements();
 
 \textcolor{comment}{// Create Helmholtz fsi flux elements}
 create\_helmholtz\_fsi\_flux\_elements();
 
 \textcolor{comment}{// Create DtN elements from all elements that are }
 \textcolor{comment}{// adjacent to the outer boundary of Helmholtz mesh}
 create\_helmholtz\_DtN\_elements();
   
 \textcolor{comment}{// Setup interaction}
 setup\_interaction();
 
 \textcolor{comment}{// Rebuild the Problem's global mesh from its various sub-meshes}
 rebuild\_global\_mesh();
 
\}\textcolor{comment}{// end of actions\_after\_adapt}



\textcolor{comment}{//=====================start\_of\_actions\_after\_adapt=======================}\textcolor{comment}{}
\textcolor{comment}{/// Complete problem setup: Apply boundary conditions and set}
\textcolor{comment}{/// physical properties}
\textcolor{comment}{}\textcolor{comment}{//========================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELASTICITY\_ELEMENT, \textcolor{keyword}{class} HELMHOLTZ\_ELEMENT>
\textcolor{keywordtype}{void} \hyperlink{classCoatedSphereProblem_a7417ba994216c3d817259891176cd392}{CoatedSphereProblem<ELASTICITY\_ELEMENT,HELMHOLTZ\_ELEMENT>::}
\hyperlink{classCoatedSphereProblem_a7417ba994216c3d817259891176cd392}{complete\_problem\_setup}()
\{

 \textcolor{comment}{// Solid boundary conditions:}
 \textcolor{comment}{//---------------------------}
 \textcolor{comment}{// Pin real and imag part of horizontal and azimuthal displacement components }
 \textcolor{comment}{//---------------------------------------------------------------------------}
 \textcolor{comment}{// on vertical boundaries}
 \textcolor{comment}{//-----------------------}
 \{  
  \textcolor{comment}{//Loop over the nodes to pin and assign boundary displacements on }
  \textcolor{comment}{//solid boundary}
  \textcolor{keywordtype}{unsigned} n\_node = Solid\_mesh\_pt->nboundary\_node(Upper\_symmetry\_boundary\_id);
  \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} i=0;i<n\_node;i++)
   \{
    Node* nod\_pt=Solid\_mesh\_pt->boundary\_node\_pt(Upper\_symmetry\_boundary\_id,i);
    
    \textcolor{comment}{// Real part of r-displacement }
    nod\_pt->pin(0);
    nod\_pt->set\_value(0,0.0);
    
    \textcolor{comment}{// Imag part of r-displacement}
    nod\_pt->pin(3);
    nod\_pt->set\_value(3,0.0);

    \textcolor{comment}{// Real part of phi-displacement }
    nod\_pt->pin(2);
    nod\_pt->set\_value(2,0.0);
    
    \textcolor{comment}{// Imag part of phi-displacement}
    nod\_pt->pin(5);
    nod\_pt->set\_value(5,0.0);
   \}
 \}
 \{
  \textcolor{comment}{//Loop over the nodes to pin and assign boundary displacements on }
  \textcolor{comment}{//solid boundary}
  \textcolor{keywordtype}{unsigned} n\_node = Solid\_mesh\_pt->nboundary\_node(Lower\_symmetry\_boundary\_id);
  \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} i=0;i<n\_node;i++)
   \{
    Node* nod\_pt=Solid\_mesh\_pt->boundary\_node\_pt(Lower\_symmetry\_boundary\_id,i);

    \textcolor{comment}{// Real part of r-displacement }
    nod\_pt->pin(0);
    nod\_pt->set\_value(0,0.0);
    
    \textcolor{comment}{// Imag part of r-displacement}
    nod\_pt->pin(3);
    nod\_pt->set\_value(3,0.0);

    \textcolor{comment}{// Real part of phi-displacement }
    nod\_pt->pin(2);
    nod\_pt->set\_value(2,0.0);
    
    \textcolor{comment}{// Imag part of phi-displacement}
    nod\_pt->pin(5);
    nod\_pt->set\_value(5,0.0);
   \}
 \}


 \textcolor{comment}{//Assign the physical properties to the elements}
 \textcolor{comment}{//----------------------------------------------}
 \textcolor{keywordtype}{unsigned} nreg=Solid\_mesh\_pt->nregion();
 \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} r=0;r<nreg;r++)
  \{
   \textcolor{keywordtype}{unsigned} nel=Solid\_mesh\_pt->nregion\_element(r);
   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} e=0;e<nel;e++)
    \{     
     \textcolor{comment}{//Cast to a solid element}
     ELASTICITY\_ELEMENT *el\_pt = 
      \textcolor{keyword}{dynamic\_cast<}ELASTICITY\_ELEMENT*\textcolor{keyword}{>}(Solid\_mesh\_pt->
                                        region\_element\_pt(r,e));
     
     \textcolor{comment}{// Set the pointer to Fourier wavenumber}
     el\_pt->fourier\_wavenumber\_pt() = &\hyperlink{namespaceGlobal__Parameters_ae1198385d90f52c4ed921520ae43a9e7}{Global\_Parameters::Fourier\_wavenumber}
      ;
   
     \textcolor{comment}{// Set the pointer to Poisson's ratio}
     el\_pt->nu\_pt() = &\hyperlink{namespaceGlobal__Parameters_a373950a959cd784c8f8028099807c2fb}{Global\_Parameters::Nu};
      
     \textcolor{comment}{// Square of non-dim frequency}
     el\_pt->omega\_sq\_pt()= &\hyperlink{namespaceGlobal__Parameters_a91314f7f1cc80c43543948568f50f405}{Global\_Parameters::Omega\_sq}[r];

     \textcolor{comment}{// Set the pointer to non-dim Young's modulus}
     el\_pt->youngs\_modulus\_pt() = &\hyperlink{namespaceGlobal__Parameters_aa961bcca2115ce9cb37cc8ccb1b90cae}{Global\_Parameters::E}[r];

    \}
  \}    


 \textcolor{comment}{// Complete the build of all Helmholtz elements so they are fully functional}
 \textcolor{keywordtype}{unsigned} n\_element = Helmholtz\_mesh\_pt->nelement();
 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} i=0;i<n\_element;i++)
  \{
   \textcolor{comment}{// Upcast from GeneralsedElement to the present element}
   HELMHOLTZ\_ELEMENT *el\_pt = \textcolor{keyword}{dynamic\_cast<}HELMHOLTZ\_ELEMENT*\textcolor{keyword}{>}(
    Helmholtz\_mesh\_pt->element\_pt(i));
   
   \textcolor{comment}{//Set the k\_squared pointer}
   el\_pt->k\_squared\_pt()=&\hyperlink{namespaceGlobal__Parameters_a91a3fa265abaf9e724c668ee800ffb29}{Global\_Parameters::K\_squared};
   
   \textcolor{comment}{// Set pointer to Fourier wave number}
   el\_pt->fourier\_wavenumber\_pt()=&\hyperlink{namespaceGlobal__Parameters_ae1198385d90f52c4ed921520ae43a9e7}{Global\_Parameters::Fourier\_wavenumber}
      ;
  \}

\}



\textcolor{comment}{//============start\_of\_delete\_face\_elements================}\textcolor{comment}{}
\textcolor{comment}{/// Delete face elements and wipe the mesh}
\textcolor{comment}{}\textcolor{comment}{//==========================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELASTICITY\_ELEMENT, \textcolor{keyword}{class} HELMHOLTZ\_ELEMENT>
\textcolor{keywordtype}{void} \hyperlink{classCoatedSphereProblem_a1092568f8c12afcefe7cbf56ebbb115c}{CoatedSphereProblem<ELASTICITY\_ELEMENT,HELMHOLTZ\_ELEMENT>::}
\hyperlink{classCoatedSphereProblem_a1092568f8c12afcefe7cbf56ebbb115c}{delete\_face\_elements}(Mesh* \textcolor{keyword}{const} & boundary\_mesh\_pt)
\{
 \textcolor{comment}{// How many surface elements are in the surface mesh}
 \textcolor{keywordtype}{unsigned} n\_element = boundary\_mesh\_pt->nelement();

 \textcolor{comment}{// Loop over the surface elements}
 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} e=0;e<n\_element;e++)
  \{
   \textcolor{comment}{//   Kill surface element}
   \textcolor{keyword}{delete} boundary\_mesh\_pt->element\_pt(e);
  \}
 
 \textcolor{comment}{// Wipe the mesh}
 boundary\_mesh\_pt->flush\_element\_and\_node\_storage();
 
\} \textcolor{comment}{// end of delete\_face\_elements}



\textcolor{comment}{//============start\_of\_create\_outer\_bc\_elements===========================}\textcolor{comment}{}
\textcolor{comment}{/// Create BC elements on outer boundary}
\textcolor{comment}{}\textcolor{comment}{//========================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELASTICITY\_ELEMENT, \textcolor{keyword}{class} HELMHOLTZ\_ELEMENT>
\textcolor{keywordtype}{void} \hyperlink{classCoatedSphereProblem_a867f4ed706f00a73c87c2c862dcf19c3}{CoatedSphereProblem<ELASTICITY\_ELEMENT,HELMHOLTZ\_ELEMENT>::}
\hyperlink{classCoatedSphereProblem_a867f4ed706f00a73c87c2c862dcf19c3}{create\_helmholtz\_DtN\_elements}()
\{
 \textcolor{comment}{// Outer boundary:}
 \textcolor{keywordtype}{unsigned} b=HH\_outer\_boundary\_id;

 \textcolor{comment}{// Loop over the bulk elements adjacent to boundary b?}
 \textcolor{keywordtype}{unsigned} n\_element = Helmholtz\_mesh\_pt->nboundary\_element(b);
 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} e=0;e<n\_element;e++)
  \{
   \textcolor{comment}{// Get pointer to the bulk element that is adjacent to boundary b}
   HELMHOLTZ\_ELEMENT* bulk\_elem\_pt = \textcolor{keyword}{dynamic\_cast<}HELMHOLTZ\_ELEMENT*\textcolor{keyword}{>}(
    Helmholtz\_mesh\_pt->boundary\_element\_pt(b,e));
   
   \textcolor{comment}{//Find the index of the face of element e along boundary b }
   \textcolor{keywordtype}{int} face\_index = Helmholtz\_mesh\_pt->face\_index\_at\_boundary(b,e);
   
   \textcolor{comment}{// Build the corresponding DtN element}
   FourierDecomposedHelmholtzDtNBoundaryElement<HELMHOLTZ\_ELEMENT>* 
    flux\_element\_pt = \textcolor{keyword}{new} 
    FourierDecomposedHelmholtzDtNBoundaryElement<HELMHOLTZ\_ELEMENT>
    (bulk\_elem\_pt,face\_index);
   
   \textcolor{comment}{//Add the flux boundary element to the  helmholtz\_DtN\_mesh}
   Helmholtz\_DtN\_mesh\_pt->add\_element\_pt(flux\_element\_pt);
   
   \textcolor{comment}{// Set pointer to the mesh that contains all the boundary condition}
   \textcolor{comment}{// elements on this boundary}
   flux\_element\_pt->set\_outer\_boundary\_mesh\_pt(Helmholtz\_DtN\_mesh\_pt);
  \}
 
\} \textcolor{comment}{// end\_of\_create\_outer\_bc\_elements}





\textcolor{comment}{//=====================start\_of\_setup\_interaction======================}\textcolor{comment}{}
\textcolor{comment}{/// Setup interaction between two fields}
\textcolor{comment}{}\textcolor{comment}{//========================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELASTICITY\_ELEMENT, \textcolor{keyword}{class} HELMHOLTZ\_ELEMENT>
\textcolor{keywordtype}{void} \hyperlink{classCoatedSphereProblem_aeea43c892871a6c65df992aedc3b3547}{CoatedSphereProblem<ELASTICITY\_ELEMENT,HELMHOLTZ\_ELEMENT>::}
\hyperlink{classCoatedSphereProblem_aeea43c892871a6c65df992aedc3b3547}{setup\_interaction}()
\{

 \textcolor{comment}{// Setup Helmholtz "pressure" load on traction elements}
 \textcolor{keywordtype}{unsigned} boundary\_in\_helmholtz\_mesh=HH\_inner\_boundary\_id;

 \textcolor{comment}{// Doc boundary coordinate for Helmholtz}
 ofstream the\_file;
 the\_file.open(\textcolor{stringliteral}{"boundary\_coordinate\_hh.dat"});
 Helmholtz\_mesh\_pt->Mesh::template doc\_boundary\_coordinates<HELMHOLTZ\_ELEMENT>
  (boundary\_in\_helmholtz\_mesh, the\_file);
 the\_file.close();

 \textcolor{comment}{// Setup interaction}
  Multi\_domain\_functions::setup\_bulk\_elements\_adjacent\_to\_face\_mesh
  <HELMHOLTZ\_ELEMENT,2>
  (\textcolor{keyword}{this},boundary\_in\_helmholtz\_mesh,Helmholtz\_mesh\_pt,FSI\_traction\_mesh\_pt);

 \textcolor{comment}{// Setup Helmholtz flux from normal displacement interaction}
 \textcolor{keywordtype}{unsigned} boundary\_in\_solid\_mesh=Outer\_boundary\_id;

 \textcolor{comment}{// Doc boundary coordinate for solid mesh}
 the\_file.open(\textcolor{stringliteral}{"boundary\_coordinate\_solid.dat"});
 Solid\_mesh\_pt->Mesh::template doc\_boundary\_coordinates<ELASTICITY\_ELEMENT>
  (boundary\_in\_solid\_mesh, the\_file);
 the\_file.close();

 \textcolor{comment}{// Setup interaction}
 Multi\_domain\_functions::setup\_bulk\_elements\_adjacent\_to\_face\_mesh
  <ELASTICITY\_ELEMENT,2>(
   \textcolor{keyword}{this},boundary\_in\_solid\_mesh,Solid\_mesh\_pt,Helmholtz\_fsi\_flux\_mesh\_pt);

\}\textcolor{comment}{// end\_of\_setup\_interaction}





\textcolor{comment}{//============start\_of\_create\_fsi\_traction\_elements======================}\textcolor{comment}{}
\textcolor{comment}{/// Create fsi traction elements }
\textcolor{comment}{}\textcolor{comment}{//=======================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELASTICITY\_ELEMENT, \textcolor{keyword}{class} HELMHOLTZ\_ELEMENT>
\textcolor{keywordtype}{void} \hyperlink{classCoatedSphereProblem_a2d342158b3058cd5392e2de3fd7595da}{CoatedSphereProblem<ELASTICITY\_ELEMENT,HELMHOLTZ\_ELEMENT>::}
\hyperlink{classCoatedSphereProblem_a2d342158b3058cd5392e2de3fd7595da}{create\_fsi\_traction\_elements}()
\{
 \textcolor{comment}{// We're on outer boundary of the solid mesh}
 \textcolor{keywordtype}{unsigned} b=Outer\_boundary\_id;

 \textcolor{comment}{// How many bulk elements are adjacent to boundary b?}
 \textcolor{keywordtype}{unsigned} n\_element = Solid\_mesh\_pt->nboundary\_element(b);
 
 \textcolor{comment}{// Loop over the bulk elements adjacent to boundary b}
 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} e=0;e<n\_element;e++)
  \{
   \textcolor{comment}{// Get pointer to the bulk element that is adjacent to boundary b}
   ELASTICITY\_ELEMENT* bulk\_elem\_pt = \textcolor{keyword}{dynamic\_cast<}ELASTICITY\_ELEMENT*\textcolor{keyword}{>}(
    Solid\_mesh\_pt->boundary\_element\_pt(b,e));
   
   \textcolor{comment}{//Find the index of the face of element e along boundary b}
   \textcolor{keywordtype}{int} face\_index = Solid\_mesh\_pt->face\_index\_at\_boundary(b,e);
   
   \textcolor{comment}{// Create element}
   FourierDecomposedTimeHarmonicLinElastLoadedByHelmholtzPressureBCElement
    <ELASTICITY\_ELEMENT,HELMHOLTZ\_ELEMENT>* el\_pt=
    \textcolor{keyword}{new} FourierDecomposedTimeHarmonicLinElastLoadedByHelmholtzPressureBCElement
    <ELASTICITY\_ELEMENT,HELMHOLTZ\_ELEMENT>(bulk\_elem\_pt,
                                           face\_index);   
   \textcolor{comment}{// Add to mesh}
   FSI\_traction\_mesh\_pt->add\_element\_pt(el\_pt);
   
   \textcolor{comment}{// Associate element with bulk boundary (to allow it to access}
   \textcolor{comment}{// the boundary coordinates in the bulk mesh)}
   el\_pt->set\_boundary\_number\_in\_bulk\_mesh(b); 
   
   \textcolor{comment}{// Set FSI parameter}
   el\_pt->q\_pt()=&\hyperlink{namespaceGlobal__Parameters_a7814fddf663e56168174a42d2cd6b4c1}{Global\_Parameters::Q};
  \}
 
\} \textcolor{comment}{// end\_of\_create\_fsi\_traction\_elements}



\textcolor{comment}{//============start\_of\_create\_helmholtz\_fsi\_flux\_elements================}\textcolor{comment}{}
\textcolor{comment}{/// Create Helmholtz fsi flux elements }
\textcolor{comment}{}\textcolor{comment}{//=======================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELASTICITY\_ELEMENT, \textcolor{keyword}{class} HELMHOLTZ\_ELEMENT>
\textcolor{keywordtype}{void} \hyperlink{classCoatedSphereProblem_a9a301689052eefd53552aadc23ff893b}{CoatedSphereProblem<ELASTICITY\_ELEMENT,HELMHOLTZ\_ELEMENT>::}
\hyperlink{classCoatedSphereProblem_a9a301689052eefd53552aadc23ff893b}{create\_helmholtz\_fsi\_flux\_elements}()
\{
 
 \textcolor{comment}{// Attach to inner boundary of Helmholtz mesh }
 \textcolor{keywordtype}{unsigned} b=HH\_inner\_boundary\_id;

 \textcolor{comment}{// How many bulk elements are adjacent to boundary b?}
 \textcolor{keywordtype}{unsigned} n\_element = Helmholtz\_mesh\_pt->nboundary\_element(b);
 
 \textcolor{comment}{// Loop over the bulk elements adjacent to boundary b}
 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} e=0;e<n\_element;e++)
  \{
   \textcolor{comment}{// Get pointer to the bulk element that is adjacent to boundary b}
   HELMHOLTZ\_ELEMENT* bulk\_elem\_pt = \textcolor{keyword}{dynamic\_cast<}HELMHOLTZ\_ELEMENT*\textcolor{keyword}{>}(
    Helmholtz\_mesh\_pt->boundary\_element\_pt(b,e));
   
   \textcolor{comment}{//Find the index of the face of element e along boundary b}
   \textcolor{keywordtype}{int} face\_index = Helmholtz\_mesh\_pt->face\_index\_at\_boundary(b,e);
   
   \textcolor{comment}{// Create element}
   FourierDecomposedHelmholtzFluxFromNormalDisplacementBCElement
    <HELMHOLTZ\_ELEMENT,ELASTICITY\_ELEMENT>* el\_pt=
    \textcolor{keyword}{new} FourierDecomposedHelmholtzFluxFromNormalDisplacementBCElement
    <HELMHOLTZ\_ELEMENT,ELASTICITY\_ELEMENT>(bulk\_elem\_pt,
                                           face\_index);
   
   \textcolor{comment}{// Add to mesh}
   Helmholtz\_fsi\_flux\_mesh\_pt->add\_element\_pt(el\_pt);
   
   \textcolor{comment}{// Associate element with bulk boundary (to allow it to access}
   \textcolor{comment}{// the boundary coordinates in the bulk mesh)}
   el\_pt->set\_boundary\_number\_in\_bulk\_mesh(b); 
  \}  
  
\} \textcolor{comment}{// end\_of\_create\_helmholtz\_fsi\_flux\_elements}


\textcolor{comment}{//============start\_of\_create\_solid\_traction\_elements====================}\textcolor{comment}{}
\textcolor{comment}{/// Create solid traction elements }
\textcolor{comment}{}\textcolor{comment}{//=======================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELASTICITY\_ELEMENT, \textcolor{keyword}{class} HELMHOLTZ\_ELEMENT>
\textcolor{keywordtype}{void} \hyperlink{classCoatedSphereProblem_a93cb1d435858c7a1835cbd74f7cb5db8}{CoatedSphereProblem<ELASTICITY\_ELEMENT,HELMHOLTZ\_ELEMENT>::}
\hyperlink{classCoatedSphereProblem_a93cb1d435858c7a1835cbd74f7cb5db8}{create\_solid\_traction\_elements}()
\{
 \textcolor{comment}{// Loop over pressure loaded boundaries}
 \textcolor{keywordtype}{unsigned} b=0;
 \textcolor{keywordtype}{unsigned} nb=3;
 \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} i=0;i<nb;i++) 
  \{
   \textcolor{keywordflow}{switch}(i)
    \{
    \textcolor{keywordflow}{case} 0:
     b=Upper\_inner\_boundary\_id;
     \textcolor{keywordflow}{break};
     
    \textcolor{keywordflow}{case} 1:
     b=Lower\_inner\_boundary\_id;
     \textcolor{keywordflow}{break};
     
    \textcolor{keywordflow}{case} 2:
     b=Rib\_divider\_boundary\_id;
     \textcolor{keywordflow}{break};
    \}
   
   \textcolor{comment}{// We're attaching face elements to region 0}
   \textcolor{keywordtype}{unsigned} r=0;
   
   \textcolor{comment}{// How many bulk elements are adjacent to boundary b?}
   \textcolor{keywordtype}{unsigned} n\_element = Solid\_mesh\_pt->nboundary\_element\_in\_region(b,r);
   
   \textcolor{comment}{// Loop over the bulk elements adjacent to boundary b}
   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} e=0;e<n\_element;e++)
    \{
     \textcolor{comment}{// Get pointer to the bulk element that is adjacent to boundary b}
     ELASTICITY\_ELEMENT* bulk\_elem\_pt = \textcolor{keyword}{dynamic\_cast<}ELASTICITY\_ELEMENT*\textcolor{keyword}{>}(
      Solid\_mesh\_pt->boundary\_element\_in\_region\_pt(b,r,e));
     
     \textcolor{comment}{//Find the index of the face of element e along boundary b}
     \textcolor{keywordtype}{int} face\_index = Solid\_mesh\_pt->face\_index\_at\_boundary\_in\_region(b,r,e);
     
     \textcolor{comment}{// Create element}
     TimeHarmonicFourierDecomposedLinearElasticityTractionElement
      <ELASTICITY\_ELEMENT>* el\_pt=
      \textcolor{keyword}{new} TimeHarmonicFourierDecomposedLinearElasticityTractionElement
      <ELASTICITY\_ELEMENT>(bulk\_elem\_pt,face\_index);   
     
     \textcolor{comment}{// Add to mesh}
     Solid\_traction\_mesh\_pt->add\_element\_pt(el\_pt);
     
     \textcolor{comment}{// Associate element with bulk boundary (to allow it to access}
     \textcolor{comment}{// the boundary coordinates in the bulk mesh)}
     el\_pt->set\_boundary\_number\_in\_bulk\_mesh(b); 
     
     \textcolor{comment}{//Set the traction function}
     el\_pt->traction\_fct\_pt() = \hyperlink{namespaceGlobal__Parameters_a0ddb3a77481b907fbb34f2e8d0a6eb9f}{Global\_Parameters::pressure\_load};  
    \}
  \}
\} \textcolor{comment}{// end of create\_traction\_elements}




\textcolor{comment}{//==============start\_of\_doc\_solution===============================}\textcolor{comment}{}
\textcolor{comment}{/// Doc the solution}
\textcolor{comment}{}\textcolor{comment}{//==================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELASTICITY\_ELEMENT, \textcolor{keyword}{class} HELMHOLTZ\_ELEMENT>
\textcolor{keywordtype}{void} \hyperlink{classCoatedSphereProblem_aaeade2a110160c002b2b45954a5a0edc}{CoatedSphereProblem<ELASTICITY\_ELEMENT,HELMHOLTZ\_ELEMENT>::}
\hyperlink{classCoatedSphereProblem_aaeade2a110160c002b2b45954a5a0edc}{doc\_solution}(DocInfo& doc\_info)
\{

 \textcolor{comment}{// Doc parameters}
 oomph\_info << \textcolor{stringliteral}{"Writing result for step "} << doc\_info.number() 
            << \textcolor{stringliteral}{". Parameters: "}<< std::endl;
 oomph\_info << \textcolor{stringliteral}{"Fourier mode number : N = "}
            << \hyperlink{namespaceGlobal__Parameters_ae1198385d90f52c4ed921520ae43a9e7}{Global\_Parameters::Fourier\_wavenumber} << std::endl;
 oomph\_info << \textcolor{stringliteral}{"FSI parameter : Q = "} << \hyperlink{namespaceGlobal__Parameters_a7814fddf663e56168174a42d2cd6b4c1}{Global\_Parameters::Q} << std::endl;
 oomph\_info << \textcolor{stringliteral}{"Fluid outer radius : R = "} << Global\_Parameters::Outer\_radius
            << std::endl;
 oomph\_info << \textcolor{stringliteral}{"Fluid wavenumber : k^2 = "} << \hyperlink{namespaceGlobal__Parameters_a91a3fa265abaf9e724c668ee800ffb29}{Global\_Parameters::K\_squared}
            << std::endl;
 oomph\_info << \textcolor{stringliteral}{"Solid wavenumber : Omega\_sq = "} 
            << \hyperlink{namespaceGlobal__Parameters_a91314f7f1cc80c43543948568f50f405}{Global\_Parameters::Omega\_sq}[0] << std::endl;
 oomph\_info << \textcolor{stringliteral}{"Solid wavenumber : Omega\_sq = "} 
            << \hyperlink{namespaceGlobal__Parameters_a91314f7f1cc80c43543948568f50f405}{Global\_Parameters::Omega\_sq}[1] 
            << std::endl << std::endl; 


 ofstream some\_file,some\_file2;
 \textcolor{keywordtype}{char} filename[100];

 \textcolor{comment}{// Number of plot points}
 \textcolor{keywordtype}{unsigned} n\_plot=5; 

 \textcolor{comment}{// Compute/output the radiated power}
 \textcolor{comment}{//----------------------------------}
 sprintf(filename,\textcolor{stringliteral}{"%s/power%i.dat"},doc\_info.directory().c\_str(),
         doc\_info.number());
 some\_file.open(filename);

 \textcolor{comment}{// Accumulate contribution from elements}
 \textcolor{keywordtype}{double} power=0.0;
 \textcolor{keywordtype}{unsigned} nn\_element=Helmholtz\_DtN\_mesh\_pt->nelement(); 
 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} e=0;e<nn\_element;e++)
  \{
   FourierDecomposedHelmholtzBCElementBase<HELMHOLTZ\_ELEMENT> *el\_pt = 
    \textcolor{keyword}{dynamic\_cast<}FourierDecomposedHelmholtzBCElementBase<HELMHOLTZ\_ELEMENT>*\textcolor{keyword}{>}(
     Helmholtz\_DtN\_mesh\_pt->element\_pt(e)); 
   power += el\_pt->global\_power\_contribution(some\_file);
  \}
 some\_file.close();
 oomph\_info << \textcolor{stringliteral}{"Radiated power: "} << power << std::endl;

 \textcolor{comment}{// Output displacement field}
 \textcolor{comment}{//--------------------------}
 sprintf(filename,\textcolor{stringliteral}{"%s/elast\_soln%i.dat"},doc\_info.directory().c\_str(),
         doc\_info.number());
 some\_file.open(filename);
 Solid\_mesh\_pt->output(some\_file,n\_plot);
 some\_file.close();

 \textcolor{comment}{// Output Helmholtz}
 \textcolor{comment}{//-----------------}
 sprintf(filename,\textcolor{stringliteral}{"%s/helmholtz\_soln%i.dat"},doc\_info.directory().c\_str(),
         doc\_info.number());
 some\_file.open(filename);
 Helmholtz\_mesh\_pt->output(some\_file,n\_plot);
 some\_file.close();


 \textcolor{comment}{// Output fsi traction elements}
 \textcolor{comment}{//----------------------------- }
 sprintf(filename,\textcolor{stringliteral}{"%s/fsi\_traction\_soln%i.dat"},doc\_info.directory().c\_str(),
         doc\_info.number());
 some\_file.open(filename);
 FSI\_traction\_mesh\_pt->output(some\_file,n\_plot);
 some\_file.close();


 \textcolor{comment}{// Output Helmholtz fsi flux elements}
 \textcolor{comment}{//----------------------------------- }
 sprintf(filename,\textcolor{stringliteral}{"%s/fsi\_flux\_bc\_soln%i.dat"},doc\_info.directory().c\_str(),
         doc\_info.number());
 some\_file.open(filename);
 Helmholtz\_fsi\_flux\_mesh\_pt->output(some\_file,n\_plot);
 some\_file.close();

 \textcolor{comment}{// Write trace file}
 Trace\_file << \hyperlink{namespaceGlobal__Parameters_a7814fddf663e56168174a42d2cd6b4c1}{Global\_Parameters::Q} << \textcolor{stringliteral}{" "} 
            << \hyperlink{namespaceGlobal__Parameters_a91a3fa265abaf9e724c668ee800ffb29}{Global\_Parameters::K\_squared} << \textcolor{stringliteral}{" "}
            << \hyperlink{namespaceGlobal__Parameters_a517d4c31b8bce6563c2f605266dd9679}{Global\_Parameters::Density\_ratio}[0] << \textcolor{stringliteral}{" "}
            << \hyperlink{namespaceGlobal__Parameters_a517d4c31b8bce6563c2f605266dd9679}{Global\_Parameters::Density\_ratio}[1] << \textcolor{stringliteral}{" "}
            << \hyperlink{namespaceGlobal__Parameters_a91314f7f1cc80c43543948568f50f405}{Global\_Parameters::Omega\_sq}[0].real() << \textcolor{stringliteral}{" "}
            << \hyperlink{namespaceGlobal__Parameters_a91314f7f1cc80c43543948568f50f405}{Global\_Parameters::Omega\_sq}[1].real() << \textcolor{stringliteral}{" "}
            << power << \textcolor{stringliteral}{" "} 
            << std::endl;
   
 \textcolor{comment}{// Bump up counter}
 doc\_info.number()++;

\} \textcolor{comment}{//end\_of\_doc\_solution}



\textcolor{comment}{//=======start\_of\_main==================================================}\textcolor{comment}{}
\textcolor{comment}{/// Driver for coated sphere loaded by lineared fluid loading}
\textcolor{comment}{}\textcolor{comment}{//======================================================================}
\textcolor{keywordtype}{int} \hyperlink{fourier__decomposed__acoustic__fsi_8cc_a3c04138a5bfe5d72780bb7e82a18e627}{main}(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char} **argv)
\{

 \textcolor{comment}{// Store command line arguments}
 CommandLineArgs::setup(argc,argv);

 \textcolor{comment}{// Define possible command line arguments and parse the ones that}
 \textcolor{comment}{// were actually specified}
 
 \textcolor{comment}{// Output directory}
 CommandLineArgs::specify\_command\_line\_flag(\textcolor{stringliteral}{"--dir"},
                                            &\hyperlink{namespaceGlobal__Parameters_a301ab922df72030c660b21328d6caf76}{Global\_Parameters::Directory});
 
 \textcolor{comment}{// Parameter controlling the sharpness of the pressure load}
 CommandLineArgs::specify\_command\_line\_flag(\textcolor{stringliteral}{"--alpha"},
                                            &\hyperlink{namespaceGlobal__Parameters_afbe27ad463a1fb23cb99d029a9fac731}{Global\_Parameters::Alpha});
 
 \textcolor{comment}{// Parse command line}
 CommandLineArgs::parse\_and\_assign(); 
 
 \textcolor{comment}{// Doc what has actually been specified on the command line}
 CommandLineArgs::doc\_specified\_flags();



 \textcolor{comment}{// Set values for parameter values}
 \hyperlink{namespaceGlobal__Parameters_a7814fddf663e56168174a42d2cd6b4c1}{Global\_Parameters::Q}=5.0; 
 \hyperlink{namespaceGlobal__Parameters_a517d4c31b8bce6563c2f605266dd9679}{Global\_Parameters::Density\_ratio}[0]=0.1; 
 \hyperlink{namespaceGlobal__Parameters_a517d4c31b8bce6563c2f605266dd9679}{Global\_Parameters::Density\_ratio}[1]=0.1; 
 \hyperlink{namespaceGlobal__Parameters_ae0f9a80fb7510dbfbbef22582da231b7}{Global\_Parameters::update\_parameter\_values}();

 \textcolor{comment}{// Update dependent parameters values}
 \hyperlink{namespaceGlobal__Parameters_ae0f9a80fb7510dbfbbef22582da231b7}{Global\_Parameters::update\_parameter\_values}();

 \textcolor{comment}{// Set up doc info}
 DocInfo doc\_info;
 
 \textcolor{comment}{// Set output directory}
 doc\_info.set\_directory(\hyperlink{namespaceGlobal__Parameters_a301ab922df72030c660b21328d6caf76}{Global\_Parameters::Directory});
 
\textcolor{preprocessor}{#ifdef ADAPTIVE}

 \textcolor{comment}{// Set up the problem}
 \hyperlink{classCoatedSphereProblem}{CoatedSphereProblem}<
  ProjectableTimeHarmonicFourierDecomposedLinearElasticityElement
  <TTimeHarmonicFourierDecomposedLinearElasticityElement<3> >,
  ProjectableFourierDecomposedHelmholtzElement
  <TFourierDecomposedHelmholtzElement<3> > > problem;

\textcolor{preprocessor}{#else}

 \textcolor{comment}{// Set up the problem}
 \hyperlink{classCoatedSphereProblem}{CoatedSphereProblem<TTimeHarmonicFourierDecomposedLinearElasticityElement<3>}
      ,
                     TFourierDecomposedHelmholtzElement<3> > problem;

\textcolor{preprocessor}{#endif}


 \textcolor{comment}{//Parameter incrementation}
 \textcolor{keywordtype}{unsigned} nstep=3;
 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} i=0;i<nstep;i++)
  \{

\textcolor{preprocessor}{#ifdef ADAPTIVE}

   \textcolor{comment}{// Solve the problem with Newton's method, allowing}
   \textcolor{comment}{// up to max\_adapt mesh adaptations after every solve.}
   \textcolor{keywordtype}{unsigned} max\_adapt=3;
   problem.newton\_solve(max\_adapt);

\textcolor{preprocessor}{#else}

   \textcolor{comment}{// Solve the problem with Newton's method}
   problem.newton\_solve();

\textcolor{preprocessor}{#endif}

   \textcolor{comment}{// Doc solution}
   problem.\hyperlink{classCoatedSphereProblem_aaeade2a110160c002b2b45954a5a0edc}{doc\_solution}(doc\_info);

   \textcolor{comment}{// Make rib a lot heavier but keep its stiffness}
   \textcolor{keywordflow}{if} (i==0)
    \{
     \hyperlink{namespaceGlobal__Parameters_aa961bcca2115ce9cb37cc8ccb1b90cae}{Global\_Parameters::E}[1]=1.0;
     \hyperlink{namespaceGlobal__Parameters_a517d4c31b8bce6563c2f605266dd9679}{Global\_Parameters::Density\_ratio}[1]=10.0; 
     \hyperlink{namespaceGlobal__Parameters_ae0f9a80fb7510dbfbbef22582da231b7}{Global\_Parameters::update\_parameter\_values}();
    \}

   \textcolor{comment}{// Make rib very soft and inertia-less}
   \textcolor{keywordflow}{if} (i==1)
    \{
     \hyperlink{namespaceGlobal__Parameters_aa961bcca2115ce9cb37cc8ccb1b90cae}{Global\_Parameters::E}[1]=1.0e-16;
     \hyperlink{namespaceGlobal__Parameters_a517d4c31b8bce6563c2f605266dd9679}{Global\_Parameters::Density\_ratio}[1]=0.0; 
     \hyperlink{namespaceGlobal__Parameters_ae0f9a80fb7510dbfbbef22582da231b7}{Global\_Parameters::update\_parameter\_values}();
    \}
  \}

\} \textcolor{comment}{//end\_of\_main}








\end{DoxyCodeInclude}




 

\hypertarget{index_sources}{}\section{Source files for this tutorial}\label{index_sources}

\begin{DoxyItemize}
\item The source files for this tutorial are located in the directory\+:~\newline
~\newline
 \begin{center} \href{../../../../demo_drivers/interaction/fourier_decomposed_acoustic_fsi}{\tt demo\+\_\+drivers/interaction/fourier\+\_\+decomposed\+\_\+acoustic\+\_\+fsi/ } \end{center} ~\newline

\item The driver code is\+: ~\newline
~\newline
 \begin{center} \href{../../../../demo_drivers/interaction/fourier_decomposed_acoustic_fsi/unstructured_fourier_decomposed_acoustic_fsi.cc}{\tt demo\+\_\+drivers/interaction/fourier\+\_\+decomposed\+\_\+acoustic\+\_\+fsi/unstructured\+\_\+fourier\+\_\+decomposed\+\_\+acoustic\+\_\+fsi.\+cc } \end{center} 
\end{DoxyItemize}



 

 \hypertarget{index_pdf}{}\section{P\+D\+F file}\label{index_pdf}
A \href{../latex/refman.pdf}{\tt pdf version} of this document is available. \end{document}
