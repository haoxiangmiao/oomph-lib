 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{cells}
\doxyfigcaption{Steady Convection Rolls\+: contours of temperature and element boundaries for a two-\/dimensional domain heated from below at Ra = 1800 }
\end{DoxyImage}


We study convection of an incompressible Newtonian fluid heated from below in a two-\/dimensional domain of height $ H $ \+: the B\'{e}nard problem. The lower wall is maintained at a temperature $ \theta_{bottom} $ and the upper wall is maintained at a temperature $ \theta_{top} $, where $ \theta_{bottom} > \theta_{top} $. The theory is described \href{../../b_convection/html/index.html}{\tt the non-\/refineable version of the problem. }

In this example, we solve the same physical problem, but using refineable elements. As an alternative to the time-\/stepping procedure adopted previously, we perturb the trivial steady-\/state solution and re-\/solve the steady equations to obtain the steady symmetry-\/broken solution. In what follows, we shall only describe those parts of the code that differ from the non-\/refineable version.



 

\hypertarget{index_main}{}\section{The driver code}\label{index_main}
We start by setting the direction of gravity, and constructing the problem using the new \hyperlink{index_element}{Refineable\+Buoyant\+Q\+Crouzeix\+Raviart\+Elements}, described \href{#element}{\tt below.}

 
\begin{DoxyCodeInclude}
\textcolor{comment}{//===============start\_of\_main========================================}
\textcolor{comment}{/// Driver code for 2D Boussinesq convection problem with }
\textcolor{comment}{}\textcolor{comment}{/// adaptivity.}
\textcolor{comment}{}\textcolor{comment}{//====================================================================}
\textcolor{keywordtype}{int} \hyperlink{boussinesq__convection_8cc_a3c04138a5bfe5d72780bb7e82a18e627}{main}()
\{

 \textcolor{comment}{// Set the direction of gravity}
 \hyperlink{namespaceGlobal__Physical__Variables_a42f4a0aee37dbb36186267931c614053}{Global\_Physical\_Variables::Direction\_of\_gravity}[0] = 0.0;
 \hyperlink{namespaceGlobal__Physical__Variables_a42f4a0aee37dbb36186267931c614053}{Global\_Physical\_Variables::Direction\_of\_gravity}[1] = -1.0;

 \textcolor{comment}{// Create the problem with 2D nine-node refineable elements.}
 \hyperlink{classRefineableConvectionProblem}{RefineableConvectionProblem}<
  RefineableBuoyantQCrouzeixRaviartElement<2> > problem;

\end{DoxyCodeInclude}


As discussed in the \href{../../b_convection/html/index.html}{\tt previous example,} a small perturbation is required to force the solution from the trivial steady state of zero velocity and linear temperature variation. Therefore, we add a small perturbation to the vertical velocity on the upper wall before solving the steady problem, allowing for up to two levels of adaptive mesh refinement.


\begin{DoxyCodeInclude}
 
 \textcolor{comment}{// Apply a perturbation to the upper boundary condition to}
 \textcolor{comment}{// force the solution into the symmetry-broken state.}
 problem.enable\_imperfection();
 
 \textcolor{comment}{//Solve the problem with (up to) two levels of adaptation}
 problem.newton\_solve(2);
 
 \textcolor{comment}{//Document the solution}
 problem.doc\_solution();

\end{DoxyCodeInclude}


Having forced the solution into a non-\/trivial symmetry-\/broken state, we switch off the perturbation and re-\/solve the problem, allowing for another two levels of adaptive refinement. The Newton solver now converges to the unperturbed but symmetry-\/broken solution shown above.


\begin{DoxyCodeInclude}
 
 \textcolor{comment}{// Make the boundary conditions perfect and solve again. }
 \textcolor{comment}{// Now the slightly perturbed symmetry broken state computed}
 \textcolor{comment}{// above is used as the initial condition and the Newton solver}
 \textcolor{comment}{// converges to the symmetry broken solution, even without}
 \textcolor{comment}{// the perturbation}
 problem.disable\_imperfection();
 problem.newton\_solve(2);
 problem.doc\_solution();

\} \textcolor{comment}{// end of main}

\end{DoxyCodeInclude}




 

\hypertarget{index_problem}{}\section{The problem class}\label{index_problem}
The problem class contains the constructor and (empty) destructor, the usual action functions, and an access function to the specific mesh used in this problem.

 
\begin{DoxyCodeInclude}
\textcolor{comment}{//=======start\_of\_problem\_class=======================================}
\textcolor{comment}{/// 2D Convection  problem on rectangular domain, discretised }
\textcolor{comment}{}\textcolor{comment}{/// with refineable elements. The specific type}
\textcolor{comment}{}\textcolor{comment}{/// of element is specified via the template parameter.}
\textcolor{comment}{}\textcolor{comment}{//====================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT> 
\textcolor{keyword}{class }\hyperlink{classRefineableConvectionProblem}{RefineableConvectionProblem} : \textcolor{keyword}{public} Problem
\{

\textcolor{keyword}{public}:
\textcolor{comment}{}
\textcolor{comment}{ ///Constructor}
\textcolor{comment}{} \hyperlink{classRefineableConvectionProblem_a97e661986093402bf55fb6c32b782ddc}{RefineableConvectionProblem}();
\textcolor{comment}{}
\textcolor{comment}{ /// Destructor. Empty}
\textcolor{comment}{} \hyperlink{classRefineableConvectionProblem_a43fc2693230601928578d5b0c6380943}{~RefineableConvectionProblem}() \{\}
\textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Update the problem specs before solve:}
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{classRefineableConvectionProblem_a694f0be87fe09a30d94e92acfce85eee}{actions\_before\_newton\_solve}();
\textcolor{comment}{}
\textcolor{comment}{ /// Update the problem after solve (empty)}
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{classRefineableConvectionProblem_a13bda5e5e75928efa88433902ccab7ee}{actions\_after\_newton\_solve}()\{\}
\textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Overloaded version of the problem's access function to }
\textcolor{comment}{ /// the mesh. Recasts the pointer to the base Mesh object to }
\textcolor{comment}{ /// the actual mesh type.}
\textcolor{comment}{} RectangularQuadMesh<ELEMENT>* \hyperlink{classRefineableConvectionProblem_a837d2412cee6996c78a2d2c5adf720f3}{mesh\_pt}() 
  \{
   \textcolor{keywordflow}{return} \textcolor{keyword}{dynamic\_cast<}RectangularQuadMesh<ELEMENT>*\textcolor{keyword}{>}(
    Problem::mesh\_pt());
  \} \textcolor{comment}{//end of access function to specic mesh}

\end{DoxyCodeInclude}


No specific action is required before the adaptation but following the mesh adaptation exactly one pressure degree of freedom must be pinned in the problem. (Since the domain is enclosed the pressure is only determined up to an arbitrary constant.) The pressure degree of freedom that was pinned before the adaptation may have disappeared during the adaptation, therefore the constraint must be re-\/applied. However, we unpin all pressure degrees of freedom first to ensure that we do not accidentally pin two pressure degrees of freedom.


\begin{DoxyCodeInclude}
\textcolor{comment}{}
\textcolor{comment}{ /// Actions before adapt:(empty)}
\textcolor{comment}{} \textcolor{keywordtype}{void} actions\_before\_adapt() \{\}
\textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Actions after adaptation,}
\textcolor{comment}{ /// Re-pin a single pressure degree of freedom}
\textcolor{comment}{} \textcolor{keywordtype}{void} actions\_after\_adapt()
  \{
   \textcolor{comment}{//Unpin all the pressures to avoid pinning two pressures}
   RefineableNavierStokesEquations<2>::
    unpin\_all\_pressure\_dofs(mesh\_pt()->element\_pt());

   \textcolor{comment}{//Pin the zero-th pressure dof in the zero-th element and set}
   \textcolor{comment}{// its value to zero}
   fix\_pressure(0,0,0.0);
  \}
\textcolor{comment}{}
\textcolor{comment}{ ///Fix pressure in element e at pressure dof pdof and set to pvalue}
\textcolor{comment}{} \textcolor{keywordtype}{void} fix\_pressure(\textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} &e, \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} &pdof, 
                   \textcolor{keyword}{const} \textcolor{keywordtype}{double} &pvalue)
  \{
   \textcolor{comment}{//Cast to specific element and fix pressure}
   \textcolor{keyword}{dynamic\_cast<}ELEMENT*\textcolor{keyword}{>}(mesh\_pt()->element\_pt(e))->
    fix\_pressure(pdof,pvalue);
  \} \textcolor{comment}{// end\_of\_fix\_pressure}

\end{DoxyCodeInclude}


The remaining member functions provide access to the boolean flag that controls the application of the imperfection, and document the solution\+:


\begin{DoxyCodeInclude}
\textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Set the}
\textcolor{comment}{ /// boundary condition on the upper wall to be perturbed slightly}
\textcolor{comment}{ /// to force the solution into the symmetry broken state.}
\textcolor{comment}{} \textcolor{keywordtype}{void} enable\_imperfection() \{Imperfect = \textcolor{keyword}{true};\}
\textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Set the}
\textcolor{comment}{ /// boundary condition on the upper wall to be unperturbed.}
\textcolor{comment}{} \textcolor{keywordtype}{void} disable\_imperfection() \{Imperfect = \textcolor{keyword}{false};\}
 \textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Doc the solution.}
\textcolor{comment}{} \textcolor{keywordtype}{void} doc\_solution();
 
\textcolor{keyword}{private}:
 \textcolor{comment}{}
\textcolor{comment}{ /// DocInfo object}
\textcolor{comment}{} DocInfo Doc\_info;
 \textcolor{comment}{}
\textcolor{comment}{ /// Is the boundary condition imperfect or not}
\textcolor{comment}{} \textcolor{keywordtype}{bool} Imperfect;

\}; \textcolor{comment}{// end of problem class}

\end{DoxyCodeInclude}




 

\hypertarget{index_const}{}\section{The constructor}\label{index_const}
We pass the element type as a template parameter to the problem constructor, which has no arguments. The constructor builds a coarse initial {\ttfamily Refineable\+Rectangular\+Quad\+Mesh}, using $ 9 \times 8 $ elements and allocates a spatial error estimator that is attached to the mesh.

 
\begin{DoxyCodeInclude}
\textcolor{comment}{//=======start\_of\_constructor=============================================}
\textcolor{comment}{/// Constructor for adaptive thermal convection problem}
\textcolor{comment}{}\textcolor{comment}{//========================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT>
\hyperlink{classRefineableConvectionProblem_a97e661986093402bf55fb6c32b782ddc}{RefineableConvectionProblem<ELEMENT>::}
\hyperlink{classRefineableConvectionProblem_a97e661986093402bf55fb6c32b782ddc}{RefineableConvectionProblem}() : Imperfect(false)
\{ 
 \textcolor{comment}{// Set output directory}
 Doc\_info.set\_directory(\textcolor{stringliteral}{"RESLT"});
 
 \textcolor{comment}{// # of elements in x-direction}
 \textcolor{keywordtype}{unsigned} n\_x=9;

 \textcolor{comment}{// # of elements in y-direction}
 \textcolor{keywordtype}{unsigned} n\_y=8;

 \textcolor{comment}{// Domain length in x-direction}
 \textcolor{keywordtype}{double} l\_x=3.0;

 \textcolor{comment}{// Domain length in y-direction}
 \textcolor{keywordtype}{double} l\_y=1.0;
 
 \textcolor{comment}{// Build the mesh}
 RefineableRectangularQuadMesh<ELEMENT>* cast\_mesh\_pt =
  \textcolor{keyword}{new} RefineableRectangularQuadMesh<ELEMENT>(n\_x,n\_y,l\_x,l\_y);

 \textcolor{comment}{//Set the problem's mesh pointer}
 Problem::mesh\_pt() = cast\_mesh\_pt;


 \textcolor{comment}{// Create/set error estimator}
 cast\_mesh\_pt->spatial\_error\_estimator\_pt()=\textcolor{keyword}{new} Z2ErrorEstimator;

 \textcolor{comment}{// Set error targets for adaptive refinement}
 cast\_mesh\_pt->max\_permitted\_error()=0.5e-3; 
 cast\_mesh\_pt->min\_permitted\_error()=0.5e-4; 

\end{DoxyCodeInclude}


Next, the boundary constraints are imposed. We pin all velocities and the temperature on the top and bottom walls and pin only the horizontal velocity on the sidewalls. As discussed above, a single pressure value must be pinned to ensure a unique solution.


\begin{DoxyCodeInclude}
 \textcolor{comment}{// Set the boundary conditions for this problem: All nodes are}
 \textcolor{comment}{// free by default -- only need to pin the ones that have Dirichlet }
 \textcolor{comment}{// conditions here}

 \textcolor{comment}{//Loop over the boundaries}
 \textcolor{keywordtype}{unsigned} num\_bound = mesh\_pt()->nboundary();
 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} ibound=0;ibound<num\_bound;ibound++)
  \{
   \textcolor{comment}{//Set the maximum index to be pinned (all values by default)}
   \textcolor{keywordtype}{unsigned} val\_max=3;
   \textcolor{comment}{//If we are on the side-walls, the v-velocity and temperature}
   \textcolor{comment}{//satisfy natural boundary conditions, so we only pin the}
   \textcolor{comment}{//first value}
   \textcolor{keywordflow}{if}((ibound==1) || (ibound==3)) \{val\_max=1;\}

   \textcolor{comment}{//Loop over the number of nodes on the boundry}
   \textcolor{keywordtype}{unsigned} num\_nod= mesh\_pt()->nboundary\_node(ibound);
   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} inod=0;inod<num\_nod;inod++)
    \{
     \textcolor{comment}{//Loop over the desired values stored at the nodes and pin}
     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} j=0;j<val\_max;j++)
      \{
       mesh\_pt()->boundary\_node\_pt(ibound,inod)->pin(j);
      \}
    \}
  \}
 
 \textcolor{comment}{// Pin the zero-th pressure value in the zero-th element and}
 \textcolor{comment}{// set its value to zero.}
 fix\_pressure(0,0,0.0);

\end{DoxyCodeInclude}


We complete the build of the elements by setting the pointers to the physical parameters and finally assign the equation numbers


\begin{DoxyCodeInclude}
 \textcolor{keywordtype}{unsigned} n\_element = mesh\_pt()->nelement();
 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} i=0;i<n\_element;i++)
  \{
   \textcolor{comment}{// Upcast from GeneralsedElement to the present element}
   ELEMENT *el\_pt = \textcolor{keyword}{dynamic\_cast<}ELEMENT*\textcolor{keyword}{>}(mesh\_pt()->element\_pt(i));

   \textcolor{comment}{// Set the Peclet number}
   el\_pt->pe\_pt() = &\hyperlink{namespaceGlobal__Physical__Variables_ad4cdf142ba50635d62ac4c614f445af7}{Global\_Physical\_Variables::Peclet};

   \textcolor{comment}{// Set the Peclet Strouhal number}
   el\_pt->pe\_st\_pt() = &\hyperlink{namespaceGlobal__Physical__Variables_ad4cdf142ba50635d62ac4c614f445af7}{Global\_Physical\_Variables::Peclet};

   \textcolor{comment}{// Set the Reynolds number (1/Pr in our non-dimensionalisation)}
   el\_pt->re\_pt() = &\hyperlink{namespaceGlobal__Physical__Variables_a87796c9f402e6f90c07cf5ba0db4367e}{Global\_Physical\_Variables::Inverse\_Prandtl};

   \textcolor{comment}{// Set ReSt (also 1/Pr in our non-dimensionalisation)}
   el\_pt->re\_st\_pt() = &\hyperlink{namespaceGlobal__Physical__Variables_a87796c9f402e6f90c07cf5ba0db4367e}{Global\_Physical\_Variables::Inverse\_Prandtl}
      ;

   \textcolor{comment}{// Set the Rayleigh number}
   el\_pt->ra\_pt() = &\hyperlink{namespaceGlobal__Physical__Variables_a637fd2a6a7c5b34ed3288300d8bf84b7}{Global\_Physical\_Variables::Rayleigh};

   \textcolor{comment}{//Set Gravity vector}
   el\_pt->g\_pt() = &\hyperlink{namespaceGlobal__Physical__Variables_a42f4a0aee37dbb36186267931c614053}{Global\_Physical\_Variables::Direction\_of\_gravity}
      ;
  \}

 \textcolor{comment}{// Setup equation numbering scheme}
 cout <<\textcolor{stringliteral}{"Number of equations: "} << assign\_eqn\_numbers() << endl; 

\} \textcolor{comment}{// end of constructor}

\end{DoxyCodeInclude}




 

\hypertarget{index_fix_p}{}\subsection{The function fix\+\_\+pressure(...)}\label{index_fix_p}
This function is a simple wrapper to the element\textquotesingle{}s {\ttfamily fix\+\_\+pressure}(...) function.  
\begin{DoxyCodeInclude}
 \textcolor{comment}{///Fix pressure in element e at pressure dof pdof and set to pvalue}
 \textcolor{keywordtype}{void} fix\_pressure(\textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} &e, \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} &pdof, 
                   \textcolor{keyword}{const} \textcolor{keywordtype}{double} &pvalue)
  \{
   \textcolor{comment}{//Cast to specific element and fix pressure}
   \textcolor{keyword}{dynamic\_cast<}ELEMENT*\textcolor{keyword}{>}(mesh\_pt()->element\_pt(e))->
    fix\_pressure(pdof,pvalue);
  \} \textcolor{comment}{// end\_of\_fix\_pressure}

\end{DoxyCodeInclude}




 

\hypertarget{index_actions_before}{}\subsection{The function actions\+\_\+before\+\_\+newton\+\_\+solve(...)}\label{index_actions_before}
The function is used to set the specific values of the Dirichlet boundary conditions. If the boolean flag {\ttfamily Imperfect} is true then a small mass-\/conserving imperfection is added to the velocity boundary condition on the top wall.

 
\begin{DoxyCodeInclude}
\textcolor{comment}{//===================start\_actions\_before\_newton\_solve===========================}
\textcolor{comment}{/// Update the problem specs before solve: (Re-)set boundary conditions}
\textcolor{comment}{}\textcolor{comment}{/// to include an imperfection (or not) depending on the control flag.}
\textcolor{comment}{}\textcolor{comment}{//========================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT>
\textcolor{keywordtype}{void} \hyperlink{classRefineableConvectionProblem_a694f0be87fe09a30d94e92acfce85eee}{RefineableConvectionProblem<ELEMENT>::actions\_before\_newton\_solve}
      ()
\{
 \textcolor{comment}{// Loop over the boundaries}
 \textcolor{keywordtype}{unsigned} num\_bound = mesh\_pt()->nboundary();
 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} ibound=0;ibound<num\_bound;ibound++)
  \{
   \textcolor{comment}{// Loop over the nodes on boundary }
   \textcolor{keywordtype}{unsigned} num\_nod=mesh\_pt()->nboundary\_node(ibound);
   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} inod=0;inod<num\_nod;inod++)
    \{
     \textcolor{comment}{// Get pointer to node}
     Node* nod\_pt=mesh\_pt()->boundary\_node\_pt(ibound,inod);

     \textcolor{comment}{//Set the number of velocity components}
     \textcolor{keywordtype}{unsigned} vel\_max=2;
     \textcolor{comment}{//If we are on the side walls we only pin the x-velocity.}
     \textcolor{keywordflow}{if}((ibound==1) || (ibound==3)) \{vel\_max = 1;\}
     \textcolor{comment}{//Set the pinned velocities to zero}
     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} j=0;j<vel\_max;j++) \{nod\_pt->set\_value(j,0.0);\}

     \textcolor{comment}{//If we are on the top boundary}
     \textcolor{keywordflow}{if}(ibound==2) 
      \{
       \textcolor{comment}{//Set the temperature to -0.5 (cooled)}
       nod\_pt->set\_value(2,-0.5);
       \textcolor{comment}{//Add small velocity imperfection if desired}
       \textcolor{keywordflow}{if}(Imperfect)
        \{
         \textcolor{comment}{//Read out the x position}
         \textcolor{keywordtype}{double} x = nod\_pt->x(0);
         \textcolor{comment}{//Set a sinusoidal perturbation in the vertical velocity}
         \textcolor{comment}{//This perturbation is mass conserving}
         \textcolor{keywordtype}{double} value = sin(2.0*3.141592654*x/3.0);
         nod\_pt->set\_value(1,value);
        \}
      \}

     \textcolor{comment}{//If we are on the bottom boundary, set the temperature}
     \textcolor{comment}{//to 0.5 (heated)}
     \textcolor{keywordflow}{if}(ibound==0) \{nod\_pt->set\_value(2,0.5);\}
    \}
  \}

\}  \textcolor{comment}{// end of actions before solve}

\end{DoxyCodeInclude}




 

\hypertarget{index_doc}{}\subsection{The function doc\+\_\+solution(...)}\label{index_doc}
This function writes the complete velocity, pressure and temperature fields to a file in the output directory specified in the {\ttfamily Doc\+Info} object.

 
\begin{DoxyCodeInclude}
\textcolor{comment}{//====================start\_of\_doc\_solution===============================}
\textcolor{comment}{/// Doc the solution}
\textcolor{comment}{}\textcolor{comment}{//========================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT>
\textcolor{keywordtype}{void} \hyperlink{classRefineableConvectionProblem_a47efcb3467931e13e12687303135e38b}{RefineableConvectionProblem<ELEMENT>::doc\_solution}()
\{ 
 \textcolor{comment}{//Declare an output stream and filename}
 ofstream some\_file;
 \textcolor{keywordtype}{char} filename[100];

 \textcolor{comment}{// Number of plot points: npts x npts}
 \textcolor{keywordtype}{unsigned} npts=5;

 \textcolor{comment}{// Output solution }
 \textcolor{comment}{//-----------------}
 sprintf(filename,\textcolor{stringliteral}{"%s/soln%i.dat"},Doc\_info.directory().c\_str(),
         Doc\_info.number());
 some\_file.open(filename);
 mesh\_pt()->output(some\_file,npts);
 some\_file.close();

 Doc\_info.number()++;
\} \textcolor{comment}{// end of doc}

\end{DoxyCodeInclude}




 

\hypertarget{index_element}{}\section{Creating the new Refineable\+Bouyant\+Q\+Crouzeix\+Raviart\+Element class}\label{index_element}
As in the \href{../../b_convection/html/index.html}{\tt non-\/refineable version of the problem} we create the refineable element {\ttfamily Refineable\+Buoyant\+Q\+Crouzeix\+Raviart\+Element} by multiple inheritance from the {\ttfamily Refineable\+Q\+Crouzeix\+Raviart\+Element} and {\ttfamily Refineable\+Q\+Advection\+Diffusion\+Element\+:} 

 
\begin{DoxyCodeInclude}
\textcolor{comment}{//============start\_element\_class============================================}
\textcolor{comment}{///A RefineableElement class that solves the }
\textcolor{comment}{}\textcolor{comment}{///Boussinesq approximation of the Navier--Stokes}
\textcolor{comment}{}\textcolor{comment}{///and energy equations by coupling two pre-existing classes. }
\textcolor{comment}{}\textcolor{comment}{///The RefineableQAdvectionDiffusionElement }
\textcolor{comment}{}\textcolor{comment}{///with bi-quadratic interpolation for the}
\textcolor{comment}{}\textcolor{comment}{///scalar variable (temperature) and}
\textcolor{comment}{}\textcolor{comment}{///RefineableQCrouzeixRaviartElement which solves the Navier--Stokes equations}
\textcolor{comment}{}\textcolor{comment}{///using bi-quadratic interpolation for the velocities and a discontinuous}
\textcolor{comment}{}\textcolor{comment}{///bi-linear interpolation for the pressure. Note that we are free to }
\textcolor{comment}{}\textcolor{comment}{///choose the order in which we store the variables at the nodes. In this}
\textcolor{comment}{}\textcolor{comment}{///case we choose to store the variables in the order fluid velocities}
\textcolor{comment}{}\textcolor{comment}{///followed by temperature. We must, therefore, overload the function}
\textcolor{comment}{}\textcolor{comment}{///AdvectionDiffusionEquations<DIM>::u\_index\_adv\_diff() to indicate that}
\textcolor{comment}{}\textcolor{comment}{///the temperature is stored at the DIM-th position not the 0-th. We do not}
\textcolor{comment}{}\textcolor{comment}{///need to overload the corresponding function in the }
\textcolor{comment}{}\textcolor{comment}{///NavierStokesEquations<DIM> class because the velocities are stored}
\textcolor{comment}{}\textcolor{comment}{///first. Finally, we choose to use the flux-recovery calculation from the}
\textcolor{comment}{}\textcolor{comment}{///fluid velocities to provide the error used in the mesh adaptation.}
\textcolor{comment}{}\textcolor{comment}{//==========================================================================}
\textcolor{keyword}{template}<\textcolor{keywordtype}{unsigned} DIM>
\textcolor{keyword}{class }RefineableBuoyantQCrouzeixRaviartElement: 
\textcolor{keyword}{public} \textcolor{keyword}{virtual} RefineableQAdvectionDiffusionElement<DIM,3>,
\textcolor{keyword}{public} \textcolor{keyword}{virtual} RefineableQCrouzeixRaviartElement<DIM>
\{

\end{DoxyCodeInclude}


Many of the additional member functions required in the combined multi-\/physics element are identical to those in the non-\/refineable version\+:
\begin{DoxyItemize}
\item the access function to (the pointer to the) Rayleigh number, {\ttfamily ra\+\_\+pt()},
\item the output functions, {\ttfamily output}(...),
\item the function {\ttfamily required\+\_\+n\+\_\+value}(...) which specifies the number of values required at each node,
\item the function {\ttfamily u\+\_\+index\+\_\+adv\+\_\+diff}(...) which specifies the index at which the temperature is stored within the elements\textquotesingle{} {\ttfamily Nodes},
\item the function {\ttfamily get\+\_\+wind\+\_\+adv\+\_\+diff}(...) which specifies the \char`\"{}wind\char`\"{} in the advection diffusion equations in terms of the Navier-\/\+Stokes velocities,
\item the function {\ttfamily get\+\_\+body\+\_\+force\+\_\+nst}(...) which specifies the body force in the Navier-\/\+Stokes equations in terms of the temperature.
\item the two \char`\"{}fill in\char`\"{} function are implemented as in the non-\/refineable element. The function {\ttfamily fill\+\_\+in\+\_\+contribution\+\_\+to\+\_\+residuals}(...) concatenates the contributions from the two underlying elements; the function {\ttfamily fill\+\_\+in\+\_\+contribution\+\_\+to\+\_\+jacobian}(...) computes the coupled elemental Jacobian matrix by finite-\/differencing.
\end{DoxyItemize}We shall only discuss those additional functions that are required in the refineable version of the combined multi-\/physics element.

Both constituent elements are derived from the {\ttfamily Element\+With\+Z2\+Error\+Estimator} base class and each element provides its own definition of the \char`\"{}\+Z2-\/flux\char`\"{} that is used by the Z2 error estimator to compute elemental error estimates. We must decide on a single error estimator for the combined element. We could base the error estimation entirely on the fluid flow, or the temperature field, but instead we shall choose our single error estimate to be the maximum of the fluid and temperature error estimates. The functions required by the {\ttfamily Z2\+Error\+Estimator} are overloaded to return all the flux terms associated with both the velocity and temperature fields, with the velocity field terms stored first.

 
\begin{DoxyCodeInclude}
 \textcolor{comment}{/// The recovery order is that of the NavierStokes elements.}
 \textcolor{keywordtype}{unsigned} nrecovery\_order() 
  \{\textcolor{keywordflow}{return} RefineableQCrouzeixRaviartElement<DIM>::nrecovery\_order();\}
\textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short The number of Z2 flux terms is the same as that in }
\textcolor{comment}{ /// the fluid element plus that in the advection-diffusion element}
\textcolor{comment}{} \textcolor{keywordtype}{unsigned} num\_Z2\_flux\_terms()
  \{
   \textcolor{keywordflow}{return} (RefineableQCrouzeixRaviartElement<DIM>::num\_Z2\_flux\_terms() +
           RefineableQAdvectionDiffusionElement<DIM,3>::num\_Z2\_flux\_terms());
  \}

\textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Get the Z2 flux by concatenating the fluxes from the fluid and}
\textcolor{comment}{ /// the advection diffusion elements.}
\textcolor{comment}{} \textcolor{keywordtype}{void} get\_Z2\_flux(\textcolor{keyword}{const} Vector<double>& s, Vector<double>& flux)
  \{
   \textcolor{comment}{//Find the number of fluid fluxes}
   \textcolor{keywordtype}{unsigned} n\_fluid\_flux = 
    RefineableQCrouzeixRaviartElement<DIM>::num\_Z2\_flux\_terms();

   \textcolor{comment}{//Fill in the first flux entries as the velocity entries}
   RefineableQCrouzeixRaviartElement<DIM>::get\_Z2\_flux(s,flux);

   \textcolor{comment}{//Find the number of temperature fluxes}
   \textcolor{keywordtype}{unsigned} n\_temp\_flux =  
    RefineableQAdvectionDiffusionElement<DIM,3>::num\_Z2\_flux\_terms();
   Vector<double> temp\_flux(n\_temp\_flux);

   \textcolor{comment}{//Get the temperature flux}
   RefineableQAdvectionDiffusionElement<DIM,3>::get\_Z2\_flux(s,temp\_flux);
   
   \textcolor{comment}{//Add the temperature flux to the end of the flux vector}
   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} i=0;i<n\_temp\_flux;i++)
    \{
     flux[n\_fluid\_flux+i] = temp\_flux[i];
    \}

  \} \textcolor{comment}{//end of get\_Z2\_flux}

\end{DoxyCodeInclude}


The default behaviour of the Z2 error estimator is to combine all components of the flux vector into a single compound flux. In the present multi-\/physics element, we instead define two compound fluxes\+: one corresponding to the combined temperature fluxes and the other to the combined velocity field fluxes. The flux components associated with each compound flux must specified by overloading the function {\ttfamily get\+\_\+\+Z2\+\_\+compound\+\_\+flux\+\_\+indices} which returns a vector of the same length as the number of flux components, containing the index of the compound flux to which the flux component contributes.

 
\begin{DoxyCodeInclude}
 \textcolor{comment}{/// \(\backslash\)short The number of compound fluxes is two (one for the fluid and}
\textcolor{comment}{ /// one for the temperature)}
\textcolor{comment}{} \textcolor{keywordtype}{unsigned} ncompound\_fluxes() \{\textcolor{keywordflow}{return} 2;\}
\textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Fill in which flux components are associated with the fluid}
\textcolor{comment}{ /// measure and which are associated with the temperature measure}
\textcolor{comment}{} \textcolor{keywordtype}{void} get\_Z2\_compound\_flux\_indices(Vector<unsigned> &flux\_index) 
  \{
   \textcolor{comment}{//Find the number of fluid fluxes}
   \textcolor{keywordtype}{unsigned} n\_fluid\_flux = 
    RefineableQCrouzeixRaviartElement<DIM>::num\_Z2\_flux\_terms();
   \textcolor{comment}{//Find the number of temperature fluxes}
   \textcolor{keywordtype}{unsigned} n\_temp\_flux =  
    RefineableQAdvectionDiffusionElement<DIM,3>::num\_Z2\_flux\_terms();

   \textcolor{comment}{//The fluid fluxes are first }
   \textcolor{comment}{//The values of the flux\_index vector are zero on entry, so we}
   \textcolor{comment}{//could omit this line}
   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} i=0;i<n\_fluid\_flux;i++) \{flux\_index[i] = 0;\}

   \textcolor{comment}{//Set the temperature fluxes (the last set of fluxes}
   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} i=0;i<n\_temp\_flux;i++) \{flux\_index[n\_fluid\_flux + i] = 1;\}

  \} \textcolor{comment}{//end of get\_Z2\_compound\_flux\_indices}

\end{DoxyCodeInclude}


The {\ttfamily Z2\+Error\+Estimator} calculates the error estimates for each compound flux. The individual error estimates are then combined to a single error estimate by the function {\ttfamily Z2\+Error\+Estimator\+::get\+\_\+combined\+\_\+error\+\_\+estimate()}. By default the single error estimate is chosen to be the maximum of all calculated error estimates. Alternative user-\/defined functions can be specified via the function pointer {\ttfamily Z2\+Error\+Estimator\+::\+Combined\+Error\+Estimate\+Fct\+Pt\&} {\ttfamily combined\+\_\+error\+\_\+fct\+\_\+pt()}, see \hyperlink{index_comments}{Comments} for a more detailed discussion of this aspect.

The vertex nodes are defined by the underlying geometric element, but require a final overload to prevent ambiguities\+:

 
\begin{DoxyCodeInclude}
 \textcolor{comment}{/// \(\backslash\)short Number of vertex nodes in the element is obtained from the}
\textcolor{comment}{ /// geometric element.}
\textcolor{comment}{} \textcolor{keywordtype}{unsigned} nvertex\_node()\textcolor{keyword}{ const}
\textcolor{keyword}{  }\{\textcolor{keywordflow}{return} QElement<DIM,3>::nvertex\_node();\}

\end{DoxyCodeInclude}


 
\begin{DoxyCodeInclude}
 \textcolor{comment}{/// \(\backslash\)short Pointer to the j-th vertex node in the element,}
\textcolor{comment}{ /// Call the geometric element's function.}
\textcolor{comment}{} Node* vertex\_node\_pt(\textcolor{keyword}{const} \textcolor{keywordtype}{unsigned}& j)\textcolor{keyword}{ const}
\textcolor{keyword}{  }\{\textcolor{keywordflow}{return} QElement<DIM,3>::vertex\_node\_pt(j);\}

\end{DoxyCodeInclude}


The number of continuously interpolated values is {\ttfamily D\+IM} {\ttfamily +} {\ttfamily 1}\+: {\ttfamily D\+IM} velocity components and one temperature.  
\begin{DoxyCodeInclude}
 \textcolor{keywordtype}{unsigned} ncont\_interpolated\_values() const 
  \{\textcolor{keywordflow}{return} DIM+1;\}

\end{DoxyCodeInclude}


The two versions of the {\ttfamily get\+\_\+interpolated\+\_\+values}(...) function must return the continuously interpolated variables at a specified position within the element\+:

 
\begin{DoxyCodeInclude}
 \textcolor{comment}{/// \(\backslash\)short Get the continuously interpolated values at the local coordinate s.}
\textcolor{comment}{ /// We choose to put the fluid velocities first, followed by the}
\textcolor{comment}{}\textcolor{comment}{ /// temperature.}
\textcolor{comment}{} \textcolor{keywordtype}{void} get\_interpolated\_values(\textcolor{keyword}{const} Vector<double>&s,  Vector<double>& values)
  \{
   \textcolor{comment}{//Storage for the fluid velocities}
   Vector<double> nst\_values;

   \textcolor{comment}{//Get the fluid velocities from the fluid element}
   RefineableQCrouzeixRaviartElement<DIM>::
    get\_interpolated\_values(s,nst\_values);

   \textcolor{comment}{//Storage for the temperature}
   Vector<double> advection\_values;

   \textcolor{comment}{//Get the temperature from the advection-diffusion element}
   RefineableQAdvectionDiffusionElement<DIM,3>::
    get\_interpolated\_values(s,advection\_values);
 
   \textcolor{comment}{//Add the fluid velocities to the values vector}
   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} i=0;i<DIM;i++) \{values.push\_back(nst\_values[i]);\}  

   \textcolor{comment}{//Add the concentration to the end}
   values.push\_back(advection\_values[0]);
  \}


 \textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Get all continuously interpolated values at the local }
\textcolor{comment}{ /// coordinate s at time level t (t=0: present; t>0: previous).}
\textcolor{comment}{ /// We choose to put the fluid velocities first, followed by the}
\textcolor{comment}{ /// temperature}
\textcolor{comment}{} \textcolor{keywordtype}{void} get\_interpolated\_values(\textcolor{keyword}{const} \textcolor{keywordtype}{unsigned}& t, \textcolor{keyword}{const} Vector<double>&s,
                              Vector<double>& values)
  \{
   \textcolor{comment}{//Storage for the fluid velocities}
   Vector<double> nst\_values;

   \textcolor{comment}{//Get the fluid velocities from the fluid element}
   RefineableQCrouzeixRaviartElement<DIM>::
    get\_interpolated\_values(t,s,nst\_values);

   \textcolor{comment}{//Storage for the temperature}
   Vector<double> advection\_values;

   \textcolor{comment}{//Get the temperature from the advection-diffusion element}
   RefineableQAdvectionDiffusionElement<DIM,3>::
    get\_interpolated\_values(s,advection\_values);

   \textcolor{comment}{//Add the fluid velocities to the values vector}
   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} i=0;i<DIM;i++) \{values.push\_back(nst\_values[i]);\}   

   \textcolor{comment}{//Add the concentration to the end}
   values.push\_back(advection\_values[0]);

  \} \textcolor{comment}{// end of get\_interpolated\_values}

\end{DoxyCodeInclude}


Finally, the setup and build functions must call the build functions of the two constituent elements. In addition, the pointer to the Rayleigh number must be passed to the sons after refinement.

 
\begin{DoxyCodeInclude}
 \textcolor{comment}{/// \(\backslash\)short The additional hanging node information must be set up}
\textcolor{comment}{ /// for both single-physics elements.}
\textcolor{comment}{} \textcolor{keywordtype}{void} further\_setup\_hanging\_nodes()
  \{
   RefineableQCrouzeixRaviartElement<DIM>::further\_setup\_hanging\_nodes();
   RefineableQAdvectionDiffusionElement<DIM,3>::further\_setup\_hanging\_nodes();
  \}


 \textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Call the rebuild\_from\_sons functions for each of the}
\textcolor{comment}{ /// constituent multi-physics elements.}
\textcolor{comment}{} \textcolor{keywordtype}{void} rebuild\_from\_sons(Mesh* &mesh\_pt) 
  \{
   RefineableQAdvectionDiffusionElement<DIM,3>::rebuild\_from\_sons(mesh\_pt);
   RefineableQCrouzeixRaviartElement<DIM>::rebuild\_from\_sons(mesh\_pt);
  \}
  

\textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Call the underlying single-physics element's further\_build()}
\textcolor{comment}{ /// functions and make sure that the pointer to the Rayleigh number}
\textcolor{comment}{ /// is passed to the sons}
\textcolor{comment}{} \textcolor{keywordtype}{void} further\_build()
  \{
   RefineableQCrouzeixRaviartElement<DIM>::further\_build();
   RefineableQAdvectionDiffusionElement<DIM,3>::further\_build();

   \textcolor{comment}{//Cast the pointer to the father element to the specific}
   \textcolor{comment}{//element type}
   RefineableBuoyantQCrouzeixRaviartElement<DIM>* cast\_father\_element\_pt
    = \textcolor{keyword}{dynamic\_cast<}RefineableBuoyantQCrouzeixRaviartElement<DIM>*\textcolor{keyword}{>}(
     this->father\_element\_pt());

   \textcolor{comment}{//Set the pointer to the Rayleigh number to be the same as that in}
   \textcolor{comment}{//the father}
   this->Ra\_pt = cast\_father\_element\_pt->ra\_pt();
  \} \textcolor{comment}{//end of further build}

\end{DoxyCodeInclude}




 

\hypertarget{index_comm_and_exercises}{}\section{Comments and Exercises}\label{index_comm_and_exercises}
\hypertarget{index_comments}{}\subsection{Comments}\label{index_comments}

\begin{DoxyItemize}
\item {\bfseries Error estimation for multi-\/physics elements}~\newline
~\newline
 The error estimation for the combined multi-\/physics element is performed with the {\ttfamily Z2\+Error\+Estimator} which computes an error estimate based Zienkiewicz and Zhu\textquotesingle{}s flux recovery technique, using the elemental \char`\"{}\+Z2 flux\char`\"{} defined in the pure virtual function {\ttfamily get\+\_\+\+Z2\+\_\+flux}(...). The two constituent elements already provide their own implementation of this function\+: ~\newline
~\newline

\begin{DoxyItemize}
\item In the {\ttfamily Refineable\+Q\+Advection\+Diffusion\+Element} the temperature gradient is used as the flux.~\newline
~\newline

\item In the {\ttfamily Refineable\+Q\+Crouzeix\+Raviart\+Element} the flux is defined by the components of the fluid\textquotesingle{}s rate of strain tensor. ~\newline
~\newline

\end{DoxyItemize}It is not obvious what combination of these flux terms should be used to compute the error estimates for the combined multi-\/physics element. The most general option would be to combine the two flux vectors, possibly using a weighting factor to control the relative importance of the various components. ~\newline
~\newline
 In the example above, we chose an error estimate that was the maximum value of the individual error estimates for the Navier-\/\+Stokes flux and the temperature flux. Refinement will be performed if either of the single-\/physics error estimates are above the chosen thresholds. It is also possible to base the error estimation entirely on the Navier-\/\+Stokes fluxes; an appropriate choice for problems in which the variations in the velocity field are expected to be much more rapid than those in the temperature field. Alternatively, the error estimation could be based exclusively on the temperature field; a choice that would be appropriate for problems with thin thermal boundary layers. The different error estimates can all be specified by user-\/defined functions that combine the vector of compound-\/flux error estimates into a single number. For example, the function 
\begin{DoxyCode}
\textcolor{keywordtype}{double} navier\_stokes\_flux\_error(\textcolor{keyword}{const} Vector<double> &errors)
 \{\textcolor{keywordflow}{return} errors[0];\}
\end{DoxyCode}
 specifies that the combined error estimate is the first of the compound error estimates --- the error estimate for the Navier--Stokes equations. ~\newline
~\newline
 In the current example both fields vary very smoothly, and as a result spatial adaptivity is not really required in this problem. This is why we set a very narrow range of target errors -- if the default targets are used, {\ttfamily oomph-\/lib} refines the mesh uniformly.
\end{DoxyItemize}\hypertarget{index_exercises}{}\subsection{Exercises}\label{index_exercises}

\begin{DoxyEnumerate}
\item Confirm that for a Rayleigh number of $ Ra = 1700 $ the system is stable, i.\+e. it returns to the trivial state, when the perturbation to the vertical velocity on the upper wall is switched off.~\newline
~\newline

\item Re-\/write the multi-\/physics elements so that the temperature is stored {\bfseries before} the fluid velocities. Confirm that the solution is unchanged in this case.~\newline
~\newline

\item Try using {\ttfamily Refineable\+Q\+Taylor\+Hood\+Elements} as the \char`\"{}fluid\char`\"{} element part of the multi-\/physics elements.
\item Change the error estimate to be based entirely on the error in the Navier--Stokes fluxes by using a user-\/defined function. Is there any difference in the refinement pattern?
\end{DoxyEnumerate}

 

\hypertarget{index_sources}{}\section{Source files for this tutorial}\label{index_sources}

\begin{DoxyItemize}
\item The source files for this tutorial are located in the directory\+:~\newline
~\newline
\begin{center} \href{../../../../demo_drivers/multi_physics/boussinesq_convection/}{\tt demo\+\_\+drivers/multi\+\_\+physics/boussinesq\+\_\+convection/ } \end{center} ~\newline

\item The driver code is\+: ~\newline
~\newline
\begin{center} \href{../../../../demo_drivers/multi_physics/boussinesq_convection/boussinesq_convection.cc}{\tt demo\+\_\+drivers/multi\+\_\+physics/boussinesq\+\_\+convection/boussinesq\+\_\+convection.\+cc } \end{center}  ~\newline

\item The source code for the elements is in\+: ~\newline
~\newline
\begin{center} \href{../../../../src/multi_physics/boussinesq_elements.h}{\tt src/multi\+\_\+physics/boussinesq\+\_\+elements.\+h} \end{center} 
\end{DoxyItemize}



 

 \hypertarget{index_pdf}{}\section{P\+D\+F file}\label{index_pdf}
A \href{../latex/refman.pdf}{\tt pdf version} of this document is available. \end{document}
