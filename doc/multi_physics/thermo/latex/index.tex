 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{undef}
\doxyfigcaption{Undeformed configuration of an elastic block. }
\end{DoxyImage}


We consider the uniform steady thermal expansion of an elastic body that is differentially heated. The top surface is heated and the bottom surface is maintained at the reference temperature, which leads to a uniform temperature gradient throughout the material. The material expands more near the upper surface than near the lower surface, deforming the initially rectangular block into an curved configuration.

 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{def}
\doxyfigcaption{Deformed elastica when the top surface is heated and the lower surface is maintained at the reference temperature. The contours indicate the temperature of the body. }
\end{DoxyImage}




 

 \hypertarget{index_main}{}\section{The driver code}\label{index_main}
The driver code for this example is given below\+:


\begin{DoxyCodeInclude}
\textcolor{comment}{//LIC// ====================================================================}
\textcolor{comment}{//LIC// This file forms part of oomph-lib, the object-oriented, }
\textcolor{comment}{//LIC// multi-physics finite-element library, available }
\textcolor{comment}{//LIC// at http://www.oomph-lib.org.}
\textcolor{comment}{//LIC// }
\textcolor{comment}{//LIC//    Version 1.0; svn revision $LastChangedRevision$}
\textcolor{comment}{//LIC//}
\textcolor{comment}{//LIC// $LastChangedDate$}
\textcolor{comment}{//LIC// }
\textcolor{comment}{//LIC// Copyright (C) 2006-2016 Matthias Heil and Andrew Hazel}
\textcolor{comment}{//LIC// }
\textcolor{comment}{//LIC// This library is free software; you can redistribute it and/or}
\textcolor{comment}{//LIC// modify it under the terms of the GNU Lesser General Public}
\textcolor{comment}{//LIC// License as published by the Free Software Foundation; either}
\textcolor{comment}{//LIC// version 2.1 of the License, or (at your option) any later version.}
\textcolor{comment}{//LIC// }
\textcolor{comment}{//LIC// This library is distributed in the hope that it will be useful,}
\textcolor{comment}{//LIC// but WITHOUT ANY WARRANTY; without even the implied warranty of}
\textcolor{comment}{//LIC// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU}
\textcolor{comment}{//LIC// Lesser General Public License for more details.}
\textcolor{comment}{//LIC// }
\textcolor{comment}{//LIC// You should have received a copy of the GNU Lesser General Public}
\textcolor{comment}{//LIC// License along with this library; if not, write to the Free Software}
\textcolor{comment}{//LIC// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA}
\textcolor{comment}{//LIC// 02110-1301  USA.}
\textcolor{comment}{//LIC// }
\textcolor{comment}{//LIC// The authors may be contacted at oomph-lib@maths.man.ac.uk.}
\textcolor{comment}{//LIC// }
\textcolor{comment}{//LIC//====================================================================}
\textcolor{comment}{//Driver for a multi-physics problem that couples the }
\textcolor{comment}{//unsteady heat equation to the equations of large-displacement solid}
\textcolor{comment}{//mechanics}

\textcolor{comment}{//Oomph-lib headers, we require the generic, unsteady heat}
\textcolor{comment}{//and and elements.}
\textcolor{preprocessor}{#include "generic.h"}
\textcolor{preprocessor}{#include "solid.h"}
\textcolor{preprocessor}{#include "unsteady\_heat.h"}

\textcolor{comment}{// The mesh is our standard rectangular quadmesh}
\textcolor{preprocessor}{#include "meshes/rectangular\_quadmesh.h"}

\textcolor{comment}{// Use the oomph and std namespaces }
\textcolor{keyword}{using namespace }\hyperlink{namespaceoomph}{oomph};
\textcolor{keyword}{using namespace }\hyperlink{namespacestd}{std};



\textcolor{comment}{//=====================================================================}\textcolor{comment}{}
\textcolor{comment}{/// A class that solves the equations of steady thermoelasticity by }
\textcolor{comment}{/// combining the UnsteadyHeat and PVD equations into a single element.}
\textcolor{comment}{/// A temperature-dependent growth term is added to the PVD equations by}
\textcolor{comment}{/// overloading the member function get\_istotropic\_growth()}
\textcolor{comment}{}\textcolor{comment}{//======================class definition==============================}
\textcolor{keyword}{template}<\textcolor{keywordtype}{unsigned} DIM>
\textcolor{keyword}{class }\hyperlink{classQThermalPVDElement}{QThermalPVDElement} : \textcolor{keyword}{public} \textcolor{keyword}{virtual} QPVDElement<DIM,3>,
                           \textcolor{keyword}{public} \textcolor{keyword}{virtual} QUnsteadyHeatElement<DIM,3>
\{
\textcolor{keyword}{private}:
\textcolor{comment}{}
\textcolor{comment}{ /// Pointer to a private data member, the thermal expansion coefficient}
\textcolor{comment}{} \textcolor{keywordtype}{double}* Alpha\_pt;
 \textcolor{comment}{}
\textcolor{comment}{ /// The static default value of Alpha}
\textcolor{comment}{} \textcolor{keyword}{static} \textcolor{keywordtype}{double} Default\_Physical\_Constant\_Value;

\textcolor{keyword}{public}:\textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Constructor: call the underlying constructors and }
\textcolor{comment}{ /// initialise the pointer to Alpha to point}
\textcolor{comment}{ /// to the default value of 1.0.}
\textcolor{comment}{} \hyperlink{classQThermalPVDElement}{QThermalPVDElement}() : QPVDElement<DIM,3>(),
                        QUnsteadyHeatElement<DIM,3>() 
  \{
   Alpha\_pt = &Default\_Physical\_Constant\_Value;
  \}
\textcolor{comment}{}
\textcolor{comment}{ ///\(\backslash\)short The required number of values stored at the nodes is the sum of the}
\textcolor{comment}{ ///required values of the two single-physics elements. Note that this step is}
\textcolor{comment}{ ///generic for any multi-physics element of this type.}
\textcolor{comment}{} \textcolor{keywordtype}{unsigned} required\_nvalue(\textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} &n)\textcolor{keyword}{ const}
\textcolor{keyword}{  }\{\textcolor{keywordflow}{return} (QUnsteadyHeatElement<DIM,3>::required\_nvalue(n) +
           QPVDElement<DIM,3>::required\_nvalue(n));\}
\textcolor{comment}{}
\textcolor{comment}{ ///Access function for the thermal expansion coefficient (const version)}
\textcolor{comment}{} \textcolor{keyword}{const} \textcolor{keywordtype}{double} &alpha()\textcolor{keyword}{ const }\{\textcolor{keywordflow}{return} *Alpha\_pt;\}
\textcolor{comment}{}
\textcolor{comment}{ ///Access function for the pointer to the thermal expansion coefficientr}
\textcolor{comment}{} \textcolor{keywordtype}{double}* &alpha\_pt() \{\textcolor{keywordflow}{return} Alpha\_pt;\}
  \textcolor{comment}{}
\textcolor{comment}{ ///  Overload the standard output function with the broken default}
\textcolor{comment}{} \textcolor{keywordtype}{void} output(ostream &outfile) \{FiniteElement::output(outfile);\}
\textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Output function:  }
\textcolor{comment}{ ///  Output x, y, u, v, p, theta at Nplot^DIM plot points}
\textcolor{comment}{} \textcolor{comment}{// Start of output function}
 \textcolor{keywordtype}{void} output(ostream &outfile, \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} &nplot)
  \{
   \textcolor{comment}{//vector of local coordinates}
   Vector<double> s(DIM);
   Vector<double> xi(DIM);
   
   \textcolor{comment}{// Tecplot header info}
   outfile << this->tecplot\_zone\_string(nplot);
   
   \textcolor{comment}{// Loop over plot points}
   \textcolor{keywordtype}{unsigned} num\_plot\_points=this->nplot\_points(nplot);
   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} iplot=0;iplot<num\_plot\_points;iplot++)
    \{
     \textcolor{comment}{// Get local coordinates of plot point}
     this->get\_s\_plot(iplot,nplot,s);
     
     \textcolor{comment}{// Get the Lagrangian coordinate}
     this->interpolated\_xi(s,xi);

     \textcolor{comment}{// Output the position of the plot point}
     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} i=0;i<DIM;i++) 
      \{outfile << this->interpolated\_x(s,i) << \textcolor{stringliteral}{" "};\}

     \textcolor{comment}{// Output the temperature (the advected variable) at the plot point}
     outfile << this->interpolated\_u\_ust\_heat(s) << std::endl;   
    \}
   outfile << std::endl;
   
   \textcolor{comment}{// Write tecplot footer (e.g. FE connectivity lists)}
   this->write\_tecplot\_zone\_footer(outfile,nplot);
  \} \textcolor{comment}{//End of output function}
\textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short C-style output function: Broken default}
\textcolor{comment}{} \textcolor{keywordtype}{void} output(FILE* file\_pt)
  \{FiniteElement::output(file\_pt);\}
\textcolor{comment}{}
\textcolor{comment}{ ///  \(\backslash\)short C-style output function: Broken default}
\textcolor{comment}{} \textcolor{keywordtype}{void} output(FILE* file\_pt, \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} &n\_plot)
  \{FiniteElement::output(file\_pt,n\_plot);\}
\textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Output function for an exact solution: Broken default}
\textcolor{comment}{} \textcolor{keywordtype}{void} output\_fct(ostream &outfile, \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} &Nplot,
                 FiniteElement::SteadyExactSolutionFctPt 
                 exact\_soln\_pt)
  \{FiniteElement::output\_fct(outfile,Nplot,exact\_soln\_pt);\}

\textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Output function for a time-dependent exact solution:}
\textcolor{comment}{ /// Broken default.}
\textcolor{comment}{} \textcolor{keywordtype}{void} output\_fct(ostream &outfile, \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} &Nplot,
                 \textcolor{keyword}{const} \textcolor{keywordtype}{double}& time,
                 FiniteElement::UnsteadyExactSolutionFctPt 
                 exact\_soln\_pt)
  \{
   FiniteElement::
    output\_fct(outfile,Nplot,time,exact\_soln\_pt);
  \}
  \textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Compute norm of solution: use the version in the unsteady heat}
\textcolor{comment}{ /// class }
\textcolor{comment}{} \textcolor{keywordtype}{void} compute\_norm(\textcolor{keywordtype}{double}& el\_norm)
 \{
  QUnsteadyHeatElement<DIM,3>::compute\_norm(el\_norm);
 \}
\textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Validate against exact solution at given time}
\textcolor{comment}{ /// Solution is provided via function pointer.}
\textcolor{comment}{ /// Plot at a given number of plot points and compute L2 error}
\textcolor{comment}{ /// and L2 norm of velocity solution over element}
\textcolor{comment}{ /// Call the broken default}
\textcolor{comment}{} \textcolor{keywordtype}{void} compute\_error(ostream &outfile,
                    FiniteElement::UnsteadyExactSolutionFctPt exact\_soln\_pt,
                    \textcolor{keyword}{const} \textcolor{keywordtype}{double}& time,
                    \textcolor{keywordtype}{double}& error, \textcolor{keywordtype}{double}& norm)
  \{FiniteElement::compute\_error(outfile,exact\_soln\_pt,
                                time,error,norm);\}
 \textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Validate against exact solution.}
\textcolor{comment}{ /// Solution is provided via function pointer.}
\textcolor{comment}{ /// Plot at a given number of plot points and compute L2 error}
\textcolor{comment}{ /// and L2 norm of velocity solution over element}
\textcolor{comment}{ /// Call the broken default}
\textcolor{comment}{} \textcolor{keywordtype}{void} compute\_error(ostream &outfile,
                    FiniteElement::SteadyExactSolutionFctPt exact\_soln\_pt,
                    \textcolor{keywordtype}{double}& error, \textcolor{keywordtype}{double}& norm)
  \{FiniteElement::compute\_error(outfile,exact\_soln\_pt,error,norm);\}
\textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Overload the growth function in the advection-diffusion equations.}
\textcolor{comment}{ /// to be temperature-dependent.}
\textcolor{comment}{} \textcolor{keywordtype}{void} get\_isotropic\_growth(\textcolor{keyword}{const} \textcolor{keywordtype}{unsigned}& ipt, \textcolor{keyword}{const} Vector<double> &s, 
                           \textcolor{keyword}{const} Vector<double>& xi, \textcolor{keywordtype}{double} &gamma)\textcolor{keyword}{ const}
\textcolor{keyword}{ }\{
  \textcolor{comment}{//The growth is the undeformed coefficient plus linear thermal}
  \textcolor{comment}{//expansion}
  gamma = 1.0 + (*Alpha\_pt)*this->interpolated\_u\_ust\_heat(s);
 \}
 \textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Calculate the contribution to the residual vector.}
\textcolor{comment}{ /// We assume that the vector has been initialised to zero}
\textcolor{comment}{ /// before this function is called.}
\textcolor{comment}{} \textcolor{keywordtype}{void} fill\_in\_contribution\_to\_residuals(Vector<double> &residuals)
  \{
   \textcolor{comment}{//Call the residuals of the advection-diffusion eqautions}
   UnsteadyHeatEquations<DIM>::
    fill\_in\_contribution\_to\_residuals(residuals);
   \textcolor{comment}{//Call the residuals of the Navier-Stokes equations}
   PVDEquations<DIM>::
    fill\_in\_contribution\_to\_residuals(residuals);
  \}
\textcolor{comment}{}
\textcolor{comment}{ ///\(\backslash\)short Compute the element's residual Vector and the jacobian matrix}
\textcolor{comment}{ /// We assume that the residuals vector and jacobian matrix have been}
\textcolor{comment}{ /// initialised to zero before calling this function}
\textcolor{comment}{} \textcolor{keywordtype}{void} fill\_in\_contribution\_to\_jacobian(Vector<double> &residuals,
                                       DenseMatrix<double> &jacobian)
  \{
   \textcolor{comment}{//Just call standard finite difference for a SolidFiniteElement so }
   \textcolor{comment}{//that variations in the nodal positions are taken into account}
   SolidFiniteElement::fill\_in\_contribution\_to\_jacobian(residuals,jacobian);
  \}

\};

\textcolor{comment}{//=========================================================================}\textcolor{comment}{}
\textcolor{comment}{/// Set the default physical value to be one}
\textcolor{comment}{}\textcolor{comment}{//=========================================================================}
\textcolor{keyword}{template}<>
\textcolor{keywordtype}{double} QThermalPVDElement<2>::Default\_Physical\_Constant\_Value=1.0;

\textcolor{comment}{//======start\_of\_namespace============================================}\textcolor{comment}{}
\textcolor{comment}{/// Namespace for the physical parameters in the problem}
\textcolor{comment}{}\textcolor{comment}{//====================================================================}
\textcolor{keyword}{namespace }\hyperlink{namespaceGlobal__Physical__Variables}{Global\_Physical\_Variables}
\{\textcolor{comment}{}
\textcolor{comment}{ /// Thermal expansion coefficient }
\textcolor{comment}{} \textcolor{keywordtype}{double} \hyperlink{namespaceGlobal__Physical__Variables_aa2e802ee7cc8e1ac900ba94c3ce86eb7}{Alpha}=0.0;
 \textcolor{comment}{}
\textcolor{comment}{ /// Young's modulus for solid mechanics}
\textcolor{comment}{} \textcolor{keywordtype}{double} \hyperlink{namespaceGlobal__Physical__Variables_a09a019474b7405b35da2437f7779bc7e}{E} = 1.0; \textcolor{comment}{// ADJUST }
\textcolor{comment}{}
\textcolor{comment}{ /// Poisson ratio for solid mechanics}
\textcolor{comment}{} \textcolor{keywordtype}{double} \hyperlink{namespaceGlobal__Physical__Variables_a3962c36313826b19f216f6bbbdd6a477}{Nu} = 0.3; \textcolor{comment}{// ADJUST}
\textcolor{comment}{}
\textcolor{comment}{ /// We need a constitutive law for the solid mechanics}
\textcolor{comment}{} ConstitutiveLaw* \hyperlink{namespaceGlobal__Physical__Variables_a2a37fb040c832ee7a086bb13bb02a100}{Constitutive\_law\_pt};

\} \textcolor{comment}{// end\_of\_namespace}
\textcolor{comment}{}
\textcolor{comment}{//////////////////////////////////////////////////////////////////////}
\textcolor{comment}{//////////////////////////////////////////////////////////////////////}
\textcolor{comment}{//////////////////////////////////////////////////////////////////////}
\textcolor{comment}{}
\textcolor{comment}{//====== start\_of\_problem\_class=======================================}\textcolor{comment}{}
\textcolor{comment}{/// 2D Thermoelasticity problem on rectangular domain, discretised }
\textcolor{comment}{/// with refineable elements. The specific type}
\textcolor{comment}{/// of element is specified via the template parameter.}
\textcolor{comment}{}\textcolor{comment}{//====================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT> 
\textcolor{keyword}{class }\hyperlink{classThermalProblem}{ThermalProblem} : \textcolor{keyword}{public} Problem
\{

\textcolor{keyword}{public}:
\textcolor{comment}{}
\textcolor{comment}{ ///Constructor}
\textcolor{comment}{} \hyperlink{classThermalProblem}{ThermalProblem}();
\textcolor{comment}{}
\textcolor{comment}{ /// Destructor. Empty}
\textcolor{comment}{} ~\hyperlink{classThermalProblem}{ThermalProblem}() \{\}
\textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Update the problem specs before solve (empty)}
\textcolor{comment}{} \textcolor{keywordtype}{void} actions\_before\_newton\_solve() \{\}
\textcolor{comment}{}
\textcolor{comment}{ /// Update the problem after solve (empty)}
\textcolor{comment}{} \textcolor{keywordtype}{void} actions\_after\_newton\_solve()\{\}
\textcolor{comment}{}
\textcolor{comment}{ /// Actions before adapt:(empty)}
\textcolor{comment}{} \textcolor{keywordtype}{void} actions\_before\_adapt()\{\}
 \textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Doc the solution.}
\textcolor{comment}{} \textcolor{keywordtype}{void} doc\_solution();
\textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Overloaded version of the problem's access function to }
\textcolor{comment}{ /// the mesh. Recasts the pointer to the base Mesh object to }
\textcolor{comment}{ /// the actual mesh type.}
\textcolor{comment}{} ElasticRectangularQuadMesh<ELEMENT>* mesh\_pt() 
  \{
   \textcolor{keywordflow}{return} \textcolor{keyword}{dynamic\_cast<}ElasticRectangularQuadMesh<ELEMENT>*\textcolor{keyword}{>}(
    Problem::mesh\_pt());
  \}
 
\textcolor{keyword}{private}:
 \textcolor{comment}{}
\textcolor{comment}{ /// DocInfo object}
\textcolor{comment}{} DocInfo Doc\_info;

\}; \textcolor{comment}{// end of problem class}

\textcolor{comment}{//========================================================================}\textcolor{comment}{}
\textcolor{comment}{/// \(\backslash\)short Constructor for Convection problem}
\textcolor{comment}{}\textcolor{comment}{//========================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT>
\hyperlink{classThermalProblem_a12ad5d383929b1ef4ed29503c5a271b0}{ThermalProblem<ELEMENT>::ThermalProblem}()
\{
 \textcolor{comment}{// Set output directory}
 Doc\_info.set\_directory(\textcolor{stringliteral}{"RESLT"});
 
 \textcolor{comment}{// # of elements in x-direction}
 \textcolor{keywordtype}{unsigned} n\_x=8;

 \textcolor{comment}{// # of elements in y-direction}
 \textcolor{keywordtype}{unsigned} n\_y=8;
 
 \textcolor{comment}{// Domain length in x-direction}
 \textcolor{keywordtype}{double} l\_x=3.0;

 \textcolor{comment}{// Domain length in y-direction}
 \textcolor{keywordtype}{double} l\_y=1.0;

 \textcolor{comment}{// Build a standard rectangular quadmesh}
 Problem::mesh\_pt() = 
  \textcolor{keyword}{new} ElasticRectangularQuadMesh<ELEMENT>(n\_x,n\_y,l\_x,l\_y);

 \textcolor{comment}{// Set the boundary conditions for this problem: All nodes are}
 \textcolor{comment}{// free by default -- only need to pin the ones that have Dirichlet }
 \textcolor{comment}{// conditions here}
 \{
  \textcolor{comment}{//The temperature is prescribed on the lower boundary}
  \textcolor{keywordtype}{unsigned} n\_boundary\_node = mesh\_pt()->nboundary\_node(0);
  \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} n=0;n<n\_boundary\_node;n++)
   \{
    \textcolor{comment}{//Get the pointer to the node}
    Node* nod\_pt = mesh\_pt()->boundary\_node\_pt(0,n);
    \textcolor{comment}{//Pin the temperature at the node }
    nod\_pt->pin(0);
    \textcolor{comment}{//Set the temperature to 0.0 (cooled)}
    nod\_pt->set\_value(0,0.0);
   \}
  
  \textcolor{comment}{//The temperature is prescribed on the upper boundary}
  n\_boundary\_node = mesh\_pt()->nboundary\_node(2);
  \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} n=0;n<n\_boundary\_node;n++)
   \{
    Node* nod\_pt = mesh\_pt()->boundary\_node\_pt(2,n);
    \textcolor{comment}{//Pin the temperature at the node}
    nod\_pt->pin(0);
    \textcolor{comment}{//Set the temperature to 1.0 (heated)}
    nod\_pt->set\_value(0,1.0);
   \}
  
  \textcolor{comment}{//The horizontal-position is fixed on the vertical boundary (symmetry)}
  n\_boundary\_node = mesh\_pt()->nboundary\_node(1);
  \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} n=0;n<n\_boundary\_node;n++)
   \{
    \textcolor{keyword}{static\_cast<}SolidNode*\textcolor{keyword}{>}(mesh\_pt()->boundary\_node\_pt(1,n))->pin\_position(0);
   \}
  
  \textcolor{comment}{//We need to completely fix the lower-right corner of the block to }
  \textcolor{comment}{//prevent vertical rigid-body motions}
  \textcolor{keyword}{static\_cast<}SolidNode*\textcolor{keyword}{>}(mesh\_pt()->boundary\_node\_pt(1,0))->pin\_position(1);
 \}

 \textcolor{comment}{// Complete the build of all elements so they are fully functional }

 \textcolor{comment}{// Loop over the elements to set up element-specific }
 \textcolor{comment}{// things that cannot be handled by the (argument-free!) ELEMENT }
 \textcolor{comment}{// constructor.}
 \textcolor{keywordtype}{unsigned} n\_element = mesh\_pt()->nelement();
 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i=0;i<n\_element;i++)
  \{
   \textcolor{comment}{// Upcast from GeneralsedElement to the present element}
   ELEMENT *el\_pt = \textcolor{keyword}{dynamic\_cast<}ELEMENT*\textcolor{keyword}{>}(mesh\_pt()->element\_pt(i));

   \textcolor{comment}{// Set the coefficient of thermal expansion}
   el\_pt->alpha\_pt() = &\hyperlink{namespaceGlobal__Physical__Variables_aa2e802ee7cc8e1ac900ba94c3ce86eb7}{Global\_Physical\_Variables::Alpha};

   \textcolor{comment}{// Set a constitutive law}
   el\_pt->constitutive\_law\_pt() = 
    \hyperlink{namespaceGlobal__Physical__Variables_a2a37fb040c832ee7a086bb13bb02a100}{Global\_Physical\_Variables::Constitutive\_law\_pt};
  \}

 \textcolor{comment}{// Setup equation numbering scheme}
 cout <<\textcolor{stringliteral}{"Number of equations: "} << assign\_eqn\_numbers() << endl; 

\} \textcolor{comment}{// end of constructor}


\textcolor{comment}{//========================================================================}\textcolor{comment}{}
\textcolor{comment}{/// Doc the solution}
\textcolor{comment}{}\textcolor{comment}{//========================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT>
\textcolor{keywordtype}{void} \hyperlink{classThermalProblem_aa085f248542811385fefe623a9193fd8}{ThermalProblem<ELEMENT>::doc\_solution}()
\{ 
 \textcolor{comment}{//Declare an output stream and filename}
 ofstream some\_file;
 \textcolor{keywordtype}{char} filename[100];

 \textcolor{comment}{// Number of plot points: npts x npts}
 \textcolor{keywordtype}{unsigned} npts=5;

 \textcolor{comment}{// Output solution }
 \textcolor{comment}{//-----------------}
 sprintf(filename,\textcolor{stringliteral}{"%s/soln%i.dat"},Doc\_info.directory().c\_str(),
         Doc\_info.number());
 some\_file.open(filename);
 mesh\_pt()->output(some\_file,npts);
 some\_file.close();

 Doc\_info.number()++;
\} \textcolor{comment}{// end of doc}


\textcolor{comment}{//=====================================================================}\textcolor{comment}{}
\textcolor{comment}{/// Driver code for 2D Thermoelasticity problem}
\textcolor{comment}{}\textcolor{comment}{//====================================================================}
\textcolor{keywordtype}{int} \hyperlink{thermo_8cc_a3c04138a5bfe5d72780bb7e82a18e627}{main}(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char} **argv)
\{

 \textcolor{comment}{// "Big G" Linear constitutive equations:}
 \hyperlink{namespaceGlobal__Physical__Variables_a2a37fb040c832ee7a086bb13bb02a100}{Global\_Physical\_Variables::Constitutive\_law\_pt} = 
  \textcolor{keyword}{new} GeneralisedHookean(&\hyperlink{namespaceGlobal__Physical__Variables_a3962c36313826b19f216f6bbbdd6a477}{Global\_Physical\_Variables::Nu},
                         &\hyperlink{namespaceGlobal__Physical__Variables_a09a019474b7405b35da2437f7779bc7e}{Global\_Physical\_Variables::E});

 \textcolor{comment}{//Construct our problem}
 \hyperlink{classThermalProblem}{ThermalProblem<QThermalPVDElement<2>} > problem;

 \textcolor{comment}{//Number of quasi-steady steps}
 \textcolor{keywordtype}{unsigned} n\_steps = 11;
 \textcolor{comment}{//If we have additional command line arguemnts, take fewer steps}
 \textcolor{keywordflow}{if}(argc > 1) \{n\_steps = 2;\}
 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} i=0;i<n\_steps;i++)
  \{
   \textcolor{comment}{//Increase the thermal expansion coefficient}
   \hyperlink{namespaceGlobal__Physical__Variables_aa2e802ee7cc8e1ac900ba94c3ce86eb7}{Global\_Physical\_Variables::Alpha} = 0.1*i;
   
   \textcolor{comment}{//Perform a single steady newton solve}
   problem.newton\_solve();
   \textcolor{comment}{//Document the solution}
   problem.\hyperlink{classThermalProblem_aa085f248542811385fefe623a9193fd8}{doc\_solution}();
  \}
\} \textcolor{comment}{// end of main}









\end{DoxyCodeInclude}




 

\hypertarget{index_sources}{}\section{Source files for this tutorial}\label{index_sources}

\begin{DoxyItemize}
\item The source files for this tutorial are located in the directory\+:~\newline
~\newline
\begin{center} \href{
../../../../
demo_drivers/multi_physics/thermo/
}{\tt demo\+\_\+drivers/multi\+\_\+physics/thermo/ } \end{center} ~\newline

\item The driver code is\+: ~\newline
~\newline
\begin{center} \href{
../../../../
demo_drivers/multi_physics/thermo/thermo.cc
}{\tt demo\+\_\+drivers/multi\+\_\+physics/thermo/thermo.\+cc } \end{center} 
\end{DoxyItemize}



 

 \hypertarget{index_pdf}{}\section{P\+D\+F file}\label{index_pdf}
A \href{../latex/refman.pdf}{\tt pdf version} of this document is available. \end{document}
