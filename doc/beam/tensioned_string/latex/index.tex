In this document, we discuss the solution of a simple one-\/dimensional solid mechanics problem, using {\ttfamily oomph-\/lib\textquotesingle{}s} Kirchhoff-\/\+Love beam elements\+:

\begin{center} \tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*{1}{|X[-1]}|}
\hline
\begin{center} {\bfseries One-\/dimensional beam problem} \end{center}  Determine the deformation of a pre-\/stressed, pressure-\/loaded elastic beam of length $ L^* $ and wall thickness $ h^* $ . In its undeformed configuration, the beam is subject to an axial (2nd Piola-\/\+Kirchhoff) pre-\/stress of size $ \sigma^*_0 $ . We wish to compute its deformation when it is loaded by a spatially uniform pressure of size $ p^*_{ext} $ .

 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{string_sketch}
\doxyfigcaption{A pre-\/stressed elastic beam under constant pressure loading. }
\end{DoxyImage}
   \\\cline{1-1}
\end{longtabu}
\end{center} 



\hypertarget{index_non_dim}{}\section{Theory and non-\/dimensionalisation}\label{index_non_dim}
{\ttfamily oomph-\/lib\textquotesingle{}s} beam elements are based on geometrically nonlinear Kirchhoff-\/\+Love beam theory with incrementally linear constitutive equations (Young\textquotesingle{}s modulus $ E $ and Poisson\textquotesingle{}s ratio $ \nu $). The equations are implemented in non-\/dimensional form, obtained by non-\/dimensionalising all length on some lengthscale $ {\cal L} $, by scaling the stresses and the applied traction on the beam\textquotesingle{}s effective Young\textquotesingle{}s modulus $ E_{eff} = E/(1-\nu^2) $ and by non-\/dimensionalising time on some timescale $ {\cal T} $ so that the dimensional (identified by an asterisk) and non-\/dimensional variables are related by \[ L^* = {\cal L} \ L, \] \[ h^* = {\cal L} \ h, \] \[ t^* = {\cal T} \ t, \] \[ p_{ext}^* = E_{eff} \ p_{ext}, \] and \[ \sigma_0^* = E_{eff} \ \sigma_0. \] The beam\textquotesingle{}s undeformed shape is parametrised by a non-\/dimensional Lagrangian coordinate $ \xi = \xi^*/{\cal L} $ so that the non-\/dimensional position vector to a material particle on the beam\textquotesingle{}s centreline in the undeformed configuration is given by $ {\bf r}_w(\xi) $ . We denote the unit normal to the beam\textquotesingle{}s undeformed centreline by $ {\bf n} $. The applied traction $ {\bf f} = {\bf f}^*/E_{eff} $ (a force per unit deformed length of the beam) deforms the beam, causing its material particles to be displaced to their new positions $ {\bf R}_w(\xi) $; the unit normal to the beam\textquotesingle{}s deformed centreline is $ {\bf N} $.

The non-\/dimensional form of the principle of virtual displacements that governs the beams deformation is then given by \[ \int_0^{L} \left[ (\sigma_0 + \gamma) \ \delta \gamma + \frac{1}{12} h^2 \kappa \ \delta \kappa - \left(\frac{1}{h} \sqrt{\frac{A}{a}} \ {\bf f} - \Lambda^2 \frac{\partial^2 {\bf R}_w}{\partial t^2} \right) \cdot \delta {\bf R}_w \right] \ \sqrt{a} \ d\xi = 0, \ \ \ \ \ \ \ \ \ (1) \] where \[ a = \frac{\partial {\bf r}_w}{\partial \xi} \cdot \frac{\partial {\bf r}_w}{\partial \xi}, \] and \[ A = \frac{\partial {\bf R}_w}{\partial \xi} \cdot \frac{\partial {\bf R}_w}{\partial \xi}, \] represent the squares of the lengths of infinitesimal material line elements in the undeformed and the deformed configurations, respectively. \[ ds = \sqrt{a} \ d\xi \mbox{\ \ \ \ and \ \ \ } dS = \sqrt{A} \ d\xi. \] $ A $ and $ a $ may be interpreted as the \char`\"{}1x1 metric
tensors\char`\"{} of the beam\textquotesingle{}s centreline, in the deformed and undeformed configurations, respectively. The ratio $ \sqrt{A/a} $ represents the \char`\"{}extension ratio\char`\"{} or the \char`\"{}stretch\char`\"{} of the beam\textquotesingle{}s centreline.

We represent the curvature of the beam\textquotesingle{}s centreline before and after the deformation by \[ b = {\bf n} \cdot \frac{\partial^2 {\bf r}_w}{d\xi^2} \] and \[ B = {\bf N} \cdot \frac{\partial^2 {\bf R}_w}{d\xi^2} \] respectively. The (\char`\"{}1x1\char`\"{}) strain and and bending \char`\"{}tensors\char`\"{} $ \gamma $ and $ \kappa $ are then given by \[ \gamma = \frac{1}{2}\left(A-a\right) \mbox{\ \ \ and \ \ \ } \kappa = - \left( B-b \right). \] Finally, \[ \Lambda = \frac{{\cal L}}{{\cal T}} \sqrt{\frac{\rho}{E_{eff}}} \] is the ratio of the natural timescale of the beam\textquotesingle{}s in-\/plane extensional oscillations, \[ {\cal T}_{natural} = {\cal L} \sqrt{\frac{\rho}{E_{eff}}}, \] to the timescale $ {\cal T}$ used in the non-\/dimensionalisation of the equations. $ \Lambda^2 $ may be interpreted as the non-\/dimensional wall density, therefore $ \Lambda=0 $ corresponds to the case without wall inertia.

\label{index_hermite}%
\Hypertarget{index_hermite}%
{\ttfamily oomph-\/lib\textquotesingle{}s} {\ttfamily Hermite\+Beam\+Element} provides a discretisation of the variational principle (1) with one-\/dimensional, isoparametric, two-\/node Hermite solid mechanics elements. In these elements, the Eulerian positions of the nodes, accessible via {\ttfamily Node\+::x}(...), are regarded as unknowns, and Hermite interpolation is used to interpolate the position between the nodes, so that the Eulerian position of material points within an element is given by \[ x_i(s) = \sum_{j=1}^2 \sum_{k=1}^2 X_{ijk} \ \psi_{jk}(s) \mbox{\ \ \ for $i=1,2$}, \ \ \ \ \ \ \ \ (2) \] where $ s \in [-1,1] $ is the element\textquotesingle{}s 1D local coordinate. The functions $ \psi_{jk}(s) $ are the one-\/dimensional Hermite shape functions \[ \psi_{11}(s) = \frac{1}{4}\left(s^3 - 3s + 2\right), \] \[ \psi_{12}(s) = \frac{1}{4}\left(s^3 - s^2 - s +1 \right), \] \[ \psi_{21}(s) = \frac{1}{4}\left(2 + 3 s - s^3\right), \] \[ \psi_{22}(s) = \frac{1}{4}\left(s^3 + s^2 -s -1 \right). \] They have the property that
\begin{DoxyItemize}
\item $ \psi_{j1} = 1 $ at node $ j $ and $ \psi_{j1} = 0 $ at the other node. Furthermore, $ d\psi_{j1}/ds = 0 $ at both nodes.
\item $ d\psi_{j2}/ds = 1 $ at node $ j $ and $ d\psi_{j2}/ds = 0 $ at the other node. Furthermore, $ \psi_{j2} = 0 $ at both nodes.
\end{DoxyItemize}The mapping (2) therefore provide an independent interpolation for the position and its derivative with respect to the local coordinate $ s $. As a result we have two types of (generalised) nodal coordinates\+:
\begin{DoxyItemize}
\item $ X_{ij1} $ represents the $ i $-\/th coordinate of the element\textquotesingle{}s local node $ j $.
\item $ X_{ij2} $ represents the derivative of $ i $-\/th coordinate with respect to the local coordinate $ s $, evaluated at the element\textquotesingle{}s local node $ j $.
\end{DoxyItemize}This representation ensures the $ C^1 $ continuity of the wall shape, required by the variational principle (1) which contains second derivatives of $ {\bf R}_w $. Physically, the inter-\/element continuity of the slope is enforced by the beam\textquotesingle{}s nonzero bending stiffness.

\label{index_solid_bound}%
\Hypertarget{index_solid_bound}%
The two \char`\"{}types\char`\"{} of \char`\"{}generalised\char`\"{} positional degrees of freedom are accessible via the function {\ttfamily Node\+::x\+\_\+gen(k,i)}, where {\ttfamily Node\+::x\+\_\+gen(0,i)} $ \equiv $ {\ttfamily Node\+::x(i)}. The two types of positional degrees of freedom correspond to the two types of boundary conditions (pinned and clamped) that can be applied at the ends of the beam. Mathematically, the number of boundary conditions reflects the fact that the Euler-\/\+Lagrange equations of the variational principle are of fourth-\/order.

The nodes of solid mechanics elements are {\ttfamily Solid\+Nodes}, a generalisation of the basic {\ttfamily Node} class that allows the nodal positions to be treated as unknowns. Its member function {\ttfamily Solid\+Node\+::pin\+\_\+position}(...) allows the application of boundary conditions for the (generalised) nodal positions. The table below lists several common boundary conditions and their application\+: \tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*{3}{|X[-1]}|}
\hline
Boundary condition  &Mathematical condition  &Implementation   \\\cline{1-3}
{\bfseries Pinned\+:}   &$ {\bf R}_w \cdot {\bf e}_x = const. $ ~\newline
 $ {\bf R}_w \cdot {\bf e}_y = const. $  &{\ttfamily Solid\+Node\+::pin\+\_\+position(0)};~\newline
 {\ttfamily Solid\+Node\+::pin\+\_\+position(1)}; ~\newline
 ~\newline
or, equivalently, ~\newline
 ~\newline
{\ttfamily Solid\+Node\+::pin\+\_\+position(0,0)};~\newline
 {\ttfamily Solid\+Node\+::pin\+\_\+position(0,1)}; ~\newline
  \\\cline{1-3}
{\bfseries Pinned, sliding in the x-\/direction\+:}   &$ {\bf R}_w \cdot {\bf e}_y = const. $  &{\ttfamily Solid\+Node\+::pin\+\_\+position(1)}; ~\newline
 ~\newline
or, equivalently, ~\newline
 ~\newline
{\ttfamily Solid\+Node\+::pin\+\_\+position(0,1)}; ~\newline
  \\\cline{1-3}
{\bfseries Pinned, sliding in the y-\/direction\+:}   &$ {\bf R}_w \cdot {\bf e}_x = const. $  &{\ttfamily Solid\+Node\+::pin\+\_\+position(0)}; ~\newline
 ~\newline
or, equivalently, ~\newline
 ~\newline
{\ttfamily Solid\+Node\+::pin\+\_\+position(0,0)}; ~\newline
  \\\cline{1-3}
{\bfseries Clamped\+:}   &$ {\bf R}_w \cdot {\bf e}_x = const. $~\newline
 $ {\bf R}_w \cdot {\bf e}_y = const. $ ~\newline
 $ d({\bf R}_w \cdot {\bf e}_y)/d\xi = 0. $  &{\ttfamily Solid\+Node\+::pin\+\_\+position(0)}; ~\newline
 {\ttfamily Solid\+Node\+::pin\+\_\+position(1)}; ~\newline
 {\ttfamily Solid\+Node\+::pin\+\_\+position(1,1)}; ~\newline
 ~\newline
or, equivalently, ~\newline
 ~\newline
{\ttfamily Solid\+Node\+::pin\+\_\+position(0,0)}; ~\newline
 {\ttfamily Solid\+Node\+::pin\+\_\+position(0,1)}; ~\newline
 {\ttfamily Solid\+Node\+::pin\+\_\+position(1,1)}; ~\newline
  \\\cline{1-3}
{\bfseries Clamped, sliding in the y-\/direction~\newline
(symmetry boundary condition!)}   &$ {\bf R}_w \cdot {\bf e}_x = const. $~\newline
 $ d({\bf R}_w \cdot {\bf e}_y)/d\xi = 0. $  &{\ttfamily Solid\+Node\+::pin\+\_\+position(0)}; ~\newline
 {\ttfamily Solid\+Node\+::pin\+\_\+position(1,1)}; ~\newline
 ~\newline
or, equivalently, ~\newline
 ~\newline
{\ttfamily Solid\+Node\+::pin\+\_\+position(0,0)}; ~\newline
 {\ttfamily Solid\+Node\+::pin\+\_\+position(1,1)}; ~\newline
  \\\cline{1-3}
\end{longtabu}


The {\ttfamily Hermite\+Beam\+Element} provides default values for all non-\/dimensional physical parameters\+:
\begin{DoxyItemize}
\item the non-\/dimensional 2nd Piola Kirchhoff pre-\/stress $ \sigma_0 $ is zero.
\item the non-\/dimensional beam thickness $ h $ is 1/20.
\item the timescale ratio $ \Lambda^2 $ is 1.
\item the non-\/dimensional traction vector $ {\bf f} $ evaluates to zero.
\end{DoxyItemize}These values can be over-\/written via suitable access functions. \mbox{[}Time-\/dependent computations also require the specification of a timestepper for the elements. This is demonstrated in \href{../../../beam/unsteady_ring/html/index.html}{\tt another example.}\mbox{]} The \char`\"{}user\char`\"{} must specify\+:
\begin{DoxyItemize}
\item the undeformed wall shape $ {\bf r}_w(\xi) $ as a {\ttfamily Geom\+Object} -- see the \href{../../../poisson/fish_poisson2/html/index.html}{\tt earlier example} for a discussion of {\ttfamily oomph-\/lib\textquotesingle{}s} geometric objects.
\end{DoxyItemize}

\hypertarget{index_results}{}\section{Results}\label{index_results}
The animation shown below illustrates the deformation of the beam under increasing pressure. An increase in pressure initially deflects the beam vertically downwards. The pressure acts as a \char`\"{}follower
load\char`\"{} since it always acts in the direction normal to the deformed beam. This causes the beam to deform into an approximately circular shape whose radius increases rapidly.

 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{string_animation}
\doxyfigcaption{Deformation of a pre-\/stressed elastic beam under constant pressure loading. }
\end{DoxyImage}




\hypertarget{index_approx}{}\section{An approximate analytical solution}\label{index_approx}
Before discussing the details of the numerical solution, we will derive an approximate analytical solution of the problem. The analytical solution will be useful to validate the computational results, and the derivation will allow us to discuss certain aspects of the theory in more detail.

We start by parametrising the beam\textquotesingle{}s undeformed shape as \[ {\bf r}_w(\xi) = \left( \begin{array}{c} \xi \\ 0 \end{array} \right) \mbox{ \ \ \ \ where $\xi \in [0,L].$} \] The 1x1 \char`\"{}metric tensor\char`\"{} associated with this parametrisation is given by \[ a = \frac{{\bf r}_w(\xi)}{d\xi} \cdot \frac{{\bf r}_w(\xi)}{d\xi} = 1, \] consistent with the fact that the Lagrangian coordinate $ \xi $ is the arclength along the beam\textquotesingle{}s undeformed centreline.

If the beam is thin (so that $ h \ll 1 $) bending effects will be confined to thin boundary layers near its ends. The beam will therefore behave (approximately) like a \char`\"{}string under tension\char`\"{} and its deformed shape will be an arc of a circle. All material line elements will be stretched by the same amount so that the tension is spatially uniform. The position vector to the material particles on the beam\textquotesingle{}s deformed centreline is therefore given by \[ {\bf R}_w(\xi) = \left( \begin{array}{c} \frac{1}{2}\left(1+\frac{\sin(-\alpha/2+\alpha\xi/L)} {\sin(\alpha/2)}\right) \\ \frac{\cos(-\alpha/2+\alpha\xi/L)-\cos(\alpha/2)} {2\sin(\alpha/2)} \end{array} \right) \mbox{ \ \ \ \ where $\xi \in [0,L].$} \ \ \ \ \ \ \ \ \ (3) \] (See the \hyperlink{index_comments}{Exercises and Comments} for a more detailed discussion of this analytical solution.) Here $ \alpha $ is the opening angle of the circular arc as shown in this sketch\+:

 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{string}
\doxyfigcaption{Sketch illustrating the approximate analytical solution for the problem. }
\end{DoxyImage}


This deformation generates a uniform stretch of \[ \frac{dS}{ds} = \sqrt{\frac{A}{a}} = \frac{1}{2} \frac{\alpha}{\sin(\alpha/2)}, \] corresponding to a uniform strain \[ \gamma = \frac{1}{2}\left(\frac{1}{4}\frac{\alpha^2}{\sin^2(\alpha/2)} - 1 \right). \] The incremental Hooke\textquotesingle{}s law predicts a linear relation between the (2nd Piola Kirchhoff) stress, $ \sigma $, and the (Green) strain, $ \gamma $, so that \[ \sigma = \sigma_0 + \gamma, \] where $ \sigma_0 $ is the axial pre-\/stress that acts in the undeformed configuration.

An elementary force balance shows that the pressure $ p_{ext} $ required to deform the beam into the shape specified by (3), is given by \char`\"{}\+Laplace\textquotesingle{}s law\char`\"{} \[ p_{ext} =\frac{{\tt T}}{R} \] where \[ R = \frac{L}{2 \sin(\alpha/2)} \] is the radius of the circular arc, and the axial tension $ {\tt T} $ is given by \[ {\tt T} = h \ (\sigma_0 + \gamma) \ \left|\frac{d{\bf R}_w}{d\xi}\right| = h \ (\sigma_0 + \gamma) \ \sqrt{A}. \] In this expression we have used the fact that the 2nd Piola Kirchhoff stress $ \sigma $ decomposes the (physical) stress vector into the vector $ d{\bf R}_w/d\xi $. This vector is tangent to the deformed centreline but not necessarily a unit vector.

The pressure required to deform the beam into a circular arc with opening angle $ \alpha $ is therefore given by \[ p_{ext} = \frac{\alpha h}{L} \ \left(\sigma_0 + \frac{1}{2}\left(\frac{1}{4}\frac{\alpha^2}{\sin^2(\alpha/2)} - 1 \right) \right). \]

To facilitate comparisons with the numerical solutions, we determine the opening angle $ \alpha $ as a function of the vertical displacement $ d $ of the beam\textquotesingle{}s midpoint by determining the auxiliary angle $ \beta $ from \[ \tan\beta = \frac{2d}{L}. \] The opening angle then follows from \[ \tan\left(\frac{\alpha}{2}\right) = \tan(\pi - 2\beta) = - \tan 2\beta = \frac{2\tan\beta}{\tan^{2}\beta -1}. \]

Here is a comparison between the computed and analytically predicted values for the pressure $ p_{ext} $, required to deflect the beam\textquotesingle{}s midpoint by the specified displacement, $ d $.

 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{trace}
\doxyfigcaption{Comparison between the computed and analytical solutions. }
\end{DoxyImage}


\tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*{1}{|X[-1]}|}
\hline
\begin{center}{\bfseries Comment\+: Geometric and constitutive nonlinearities}\end{center}  The comparison between the computational results and the analytical predictions is very satisfying but is important to realise that the agreement only validates the numerical solution, not the physical model. {\ttfamily oomph-\/lib\textquotesingle{}s} {\ttfamily Hermite\+Beam\+Element} is based on a {\bfseries geometrically} {\bfseries nonlinear} theory, implying that the kinematics of the deformation are captured exactly for arbitrarily large displacements and rotations. However, the use of {\bfseries incrementally} {\bfseries linear} {\bfseries constitutive} {\bfseries equations} in the variational principle (1) can only be justified if the strain is small. This is clearly not the case for the deformations shown above. The combination of geometric nonlinearity with linear constitutive equations can, however, be justified in applications in which the beam undergoes large displacements with little extension of its centreline. This typically occurs in stability problems, such as the \href{../../steady_ring/html/index.html}{\tt buckling of a circular ring under external pressure}, considered in \href{../../steady_ring/html/index.html}{\tt another example}.

\\\cline{1-1}
\end{longtabu}




 

\hypertarget{index_global}{}\section{Global parameters and functions}\label{index_global}
The namespace {\ttfamily \hyperlink{namespaceGlobal__Physical__Variables}{Global\+\_\+\+Physical\+\_\+\+Variables}} contains the dimensionless beam thickness, $ h $, the dimensionless pre-\/stress, $ \sigma_{0} $, and the pressure load, $ p_{ext} $, as well as the function {\ttfamily \hyperlink{namespaceGlobal__Physical__Variables_a321267e1efb30b5d586302509354fb07}{Global\+\_\+\+Physical\+\_\+\+Variables\+::load()}} which computes the load vector in the form required by the {\ttfamily Hermite\+Beam\+Elements}. (The function\textquotesingle{}s arguments allow the load vector to be a function of the Lagrangian and Eulerian coordinates, and the unit normal to the deformed beam, $ {\bf N} $.)

 
\begin{DoxyCodeInclude}
\textcolor{comment}{//========start\_of\_namespace========================}
\textcolor{comment}{/// Namespace for physical parameters}
\textcolor{comment}{}\textcolor{comment}{//==================================================}
\textcolor{keyword}{namespace }\hyperlink{namespaceGlobal__Physical__Variables}{Global\_Physical\_Variables}
\{\textcolor{comment}{}
\textcolor{comment}{ /// Non-dimensional thickness}
\textcolor{comment}{} \textcolor{keywordtype}{double} \hyperlink{namespaceGlobal__Physical__Variables_af6e07423e22c0991084d9a2f43727805}{H};
\textcolor{comment}{}
\textcolor{comment}{ /// 2nd Piola Kirchhoff pre-stress}
\textcolor{comment}{} \textcolor{keywordtype}{double} \hyperlink{namespaceGlobal__Physical__Variables_a417dc688a70c4f06ef0faed047068ba2}{Sigma0};
\textcolor{comment}{}
\textcolor{comment}{ /// Pressure load}
\textcolor{comment}{} \textcolor{keywordtype}{double} \hyperlink{namespaceGlobal__Physical__Variables_a0406c0cbd463d1df2458fe5de98a00eb}{P\_ext};
\textcolor{comment}{}
\textcolor{comment}{ /// Load function: Apply a constant external pressure to the beam}
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{namespaceGlobal__Physical__Variables_a321267e1efb30b5d586302509354fb07}{load}(\textcolor{keyword}{const} Vector<double>& xi, \textcolor{keyword}{const} Vector<double> &x,
           \textcolor{keyword}{const} Vector<double>& N, Vector<double>& \hyperlink{namespaceGlobal__Physical__Variables_a321267e1efb30b5d586302509354fb07}{load})
 \{
  \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} i=0;i<2;i++) \{load[i] = -P\_ext*N[i];\}
 \}

\} \textcolor{comment}{// end of namespace}

\end{DoxyCodeInclude}




 

\hypertarget{index_main}{}\section{The driver code}\label{index_main}
The main code is very short. The physical parameters $ h $, $ \sigma_{0} $ and $ L $ are initialised and the problem is constructed using 10 elements. Following the usual self-\/test, we call the function \hyperlink{classElasticBeamProblem_a2da3cb02ce953da67fb27742e20774a5}{Elastic\+Beam\+Problem\+::parameter\+\_\+study()} to compute the deformation of the beam for a range of external pressures.

 
\begin{DoxyCodeInclude}
\textcolor{comment}{//========start\_of\_main================================================}
\textcolor{comment}{/// Driver for beam (string under tension) test problem }
\textcolor{comment}{}\textcolor{comment}{//=====================================================================}
\textcolor{keywordtype}{int} \hyperlink{tensioned__string_8cc_ae66f6b31b5ad750f1fe042a706a4e3d4}{main}()
\{

 \textcolor{comment}{// Set the non-dimensional thickness }
 \hyperlink{namespaceGlobal__Physical__Variables_af6e07423e22c0991084d9a2f43727805}{Global\_Physical\_Variables::H}=0.01; 
 
 \textcolor{comment}{// Set the 2nd Piola Kirchhoff prestress}
 \hyperlink{namespaceGlobal__Physical__Variables_a417dc688a70c4f06ef0faed047068ba2}{Global\_Physical\_Variables::Sigma0}=0.1; 
 
 \textcolor{comment}{// Set the length of domain}
 \textcolor{keywordtype}{double} L = 10.0;

 \textcolor{comment}{// Number of elements (choose an even number if you want the control point }
 \textcolor{comment}{// to be located at the centre of the beam)}
 \textcolor{keywordtype}{unsigned} n\_element = 10;

 \textcolor{comment}{// Construst the problem}
 \hyperlink{classElasticBeamProblem}{ElasticBeamProblem} problem(n\_element,L);

 \textcolor{comment}{// Check that we're ready to go:}
 cout << \textcolor{stringliteral}{"\(\backslash\)n\(\backslash\)n\(\backslash\)nProblem self-test "};
 \textcolor{keywordflow}{if} (problem.self\_test()==0) 
  \{
   cout << \textcolor{stringliteral}{"passed: Problem can be solved."} << std::endl;
  \}
 \textcolor{keywordflow}{else} 
  \{
   \textcolor{keywordflow}{throw} OomphLibError(\textcolor{stringliteral}{"Self test failed"},
                       OOMPH\_CURRENT\_FUNCTION,
                       OOMPH\_EXCEPTION\_LOCATION);
  \}

 \textcolor{comment}{// Conduct parameter study}
 problem.parameter\_study();

\} \textcolor{comment}{// end of main}

\end{DoxyCodeInclude}




 

\hypertarget{index_problem}{}\section{The problem class}\label{index_problem}
The problem class has five member functions, only two of which are non-\/trivial\+:
\begin{DoxyItemize}
\item the problem constructor, {\ttfamily \hyperlink{classElasticBeamProblem}{Elastic\+Beam\+Problem}}(...), whose arguments specify the number of elements and the beam\textquotesingle{}s undeformed length.
\item the function {\ttfamily parameter\+\_\+study()}, which computes the beam\textquotesingle{}s deformation for a range of external pressures.
\end{DoxyItemize}

In the present problem, the functions {\ttfamily Problem\+::actions\+\_\+before\+\_\+newton\+\_\+solve()} and {\ttfamily Problem\+::actions\+\_\+after\+\_\+newton\+\_\+solve()} are not required, so remain empty. The function {\ttfamily \hyperlink{classElasticBeamProblem_ae7d14ba8bec2325a82cbeed0c1b29910}{Elastic\+Beam\+Problem\+::mesh\+\_\+pt()}} overloads the (virtual) function {\ttfamily Problem\+::mesh\+\_\+pt()} to return a pointer to the specific mesh used in this problem. This avoids explicit re-\/casts when member functions of the specific mesh need to be accessed.

The class also includes three private data members which store a pointer to a node at which the displacement is documented, the length of the domain, and a pointer to the geometric object that specifies the beam\textquotesingle{}s undeformed shape.

 
\begin{DoxyCodeInclude}
\textcolor{comment}{//======start\_of\_problem\_class==========================================}
\textcolor{comment}{/// Beam problem object}
\textcolor{comment}{}\textcolor{comment}{//======================================================================}
\textcolor{keyword}{class }\hyperlink{classElasticBeamProblem}{ElasticBeamProblem} : \textcolor{keyword}{public} Problem
\{
\textcolor{keyword}{public}:
 \textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Constructor: The arguments are the number of elements, }
\textcolor{comment}{ /// the length of domain}
\textcolor{comment}{} \hyperlink{classElasticBeamProblem_a1c62c2a14c9a5528a649700d16dac2ea}{ElasticBeamProblem}(\textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} &n\_elem, \textcolor{keyword}{const} \textcolor{keywordtype}{double} &length);
 \textcolor{comment}{}
\textcolor{comment}{ /// Conduct a parameter study}
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{classElasticBeamProblem_a2da3cb02ce953da67fb27742e20774a5}{parameter\_study}();
 \textcolor{comment}{}
\textcolor{comment}{ /// Return pointer to the mesh}
\textcolor{comment}{} OneDLagrangianMesh<HermiteBeamElement>* \hyperlink{classElasticBeamProblem_ae7d14ba8bec2325a82cbeed0c1b29910}{mesh\_pt}() 
  \{\textcolor{keywordflow}{return} \textcolor{keyword}{dynamic\_cast<}OneDLagrangianMesh<HermiteBeamElement>*\textcolor{keyword}{>}
    (Problem::mesh\_pt());\}
\textcolor{comment}{}
\textcolor{comment}{ /// No actions need to be performed after a solve}
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{classElasticBeamProblem_a30dde8d0101a3d3994965d6e560cb585}{actions\_after\_newton\_solve}() \{\}
\textcolor{comment}{}
\textcolor{comment}{ /// No actions need to be performed before a solve}
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{classElasticBeamProblem_a5b534c11d9b1d54123bf587aad5f98f6}{actions\_before\_newton\_solve}() \{\}

\textcolor{keyword}{private}:
\textcolor{comment}{}
\textcolor{comment}{ /// Pointer to the node whose displacement is documented}
\textcolor{comment}{} Node* \hyperlink{classElasticBeamProblem_a9c96cab7e71243e51f7c4040a84cdd5d}{Doc\_node\_pt};
\textcolor{comment}{}
\textcolor{comment}{ /// Length of domain (in terms of the Lagrangian coordinates)}
\textcolor{comment}{} \textcolor{keywordtype}{double} \hyperlink{classElasticBeamProblem_aa68b1c77e0aa1571fe956d62bd8cf096}{Length};
\textcolor{comment}{}
\textcolor{comment}{ /// Pointer to geometric object that represents the beam's undeformed shape}
\textcolor{comment}{} GeomObject* \hyperlink{classElasticBeamProblem_a134a789cae77ab61a3e32bd93b28e1fa}{Undef\_beam\_pt};

\}; \textcolor{comment}{// end of problem class}

\end{DoxyCodeInclude}




 

\hypertarget{index_constructor}{}\section{The Problem constructor}\label{index_constructor}
We start by creating the undeformed centreline of the beam as a {\ttfamily Straight\+Line}, one of {\ttfamily oomph-\/lib\textquotesingle{}s} standard geometric objects.


\begin{DoxyCodeInclude}
\textcolor{comment}{//=============start\_of\_constructor=====================================}
\textcolor{comment}{/// Constructor for elastic beam problem}
\textcolor{comment}{}\textcolor{comment}{//======================================================================}
\hyperlink{classElasticBeamProblem_a1c62c2a14c9a5528a649700d16dac2ea}{ElasticBeamProblem::ElasticBeamProblem}(\textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} &n\_elem,
                                       \textcolor{keyword}{const} \textcolor{keywordtype}{double} &length) : Length(length)
\{
 \textcolor{comment}{// Set the undeformed beam to be a straight line at y=0}
 Undef\_beam\_pt=\textcolor{keyword}{new} StraightLine(0.0); 

\end{DoxyCodeInclude}


We then construct the a one-\/dimensional Lagrangian mesh in two-\/dimensional space, using the previously-\/constructed geometric object to set the initial positions of the nodes.


\begin{DoxyCodeInclude}
 \textcolor{comment}{// Create the (Lagrangian!) mesh, using the geometric object}
 \textcolor{comment}{// Undef\_beam\_pt to specify the initial (Eulerian) position of the}
 \textcolor{comment}{// nodes.}
 Problem::mesh\_pt() = 
  \textcolor{keyword}{new} OneDLagrangianMesh<HermiteBeamElement>(n\_elem,length,Undef\_beam\_pt);

\end{DoxyCodeInclude}


The {\ttfamily One\+D\+Lagrangian\+Mesh} is a {\ttfamily Solid\+Mesh} whose constituent nodes are {\ttfamily Solid\+Nodes}. These nodes store not only their (variable) 2D Eulerian position, accessible via {\ttfamily Solid\+Node\+::x}(...), but also their (fixed) 1D Lagrangian coordinates, accessible via {\ttfamily Solid\+Node\+::xi}(...). The {\ttfamily One\+D\+Lagrangian\+Mesh} constructor assigns the nodes\textquotesingle{} Lagrangian coordinate, $ \xi $, by spacing them evenly in the range $ \xi \in [0,L] $. The {\ttfamily Geom\+Object} pointed to by {\ttfamily Undef\+\_\+beam\+\_\+pt}, provides a parametrisation of the beam\textquotesingle{}s undeformed shape in the form $ {\bf r}(\xi) $, and this is used to determine the nodes\textquotesingle{}s initial Eulerian position.

Next we pin the nodal positions on both boundaries


\begin{DoxyCodeInclude}
 \textcolor{comment}{// Set the boundary conditions: Each end of the beam is fixed in space}
 \textcolor{comment}{// Loop over the boundaries (ends of the beam)}
 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} b=0;b<2;b++)
  \{
   \textcolor{comment}{// Pin displacements in both x and y directions}
   \textcolor{comment}{// [Note: The mesh\_pt() function has been overloaded}
   \textcolor{comment}{//  to return a pointer to the actual mesh, rather than}
   \textcolor{comment}{//  a pointer to the Mesh base class. The current mesh is derived}
   \textcolor{comment}{//  from the SolidMesh class. In such meshes, all access functions}
   \textcolor{comment}{//  to the nodes, such as boundary\_node\_pt(...), are overloaded}
   \textcolor{comment}{//  to return pointers to SolidNodes (whose position can be}
   \textcolor{comment}{//  pinned) rather than "normal" Nodes.]}
   mesh\_pt()->boundary\_node\_pt(b,0)->pin\_position(0); 
   mesh\_pt()->boundary\_node\_pt(b,0)->pin\_position(1); 
  \}

\end{DoxyCodeInclude}


We then loop over the elements and set the pointers to the physical parameters (the pre-\/stress and the thickness), the function pointer to the load vector, and the pointer to the geometric object that specifies the undeformed beam shape. 
\begin{DoxyCodeInclude}
 \textcolor{comment}{//Loop over the elements to set physical parameters etc.}
 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} e=0;e<n\_element;e++)
  \{
   \textcolor{comment}{// Upcast to the specific element type}
   HermiteBeamElement *elem\_pt = 
    \textcolor{keyword}{dynamic\_cast<}HermiteBeamElement*\textcolor{keyword}{>}(mesh\_pt()->element\_pt(e));
   
   \textcolor{comment}{// Set physical parameters for each element:}
   elem\_pt->sigma0\_pt() = &\hyperlink{namespaceGlobal__Physical__Variables_a417dc688a70c4f06ef0faed047068ba2}{Global\_Physical\_Variables::Sigma0};
   elem\_pt->h\_pt() = &\hyperlink{namespaceGlobal__Physical__Variables_af6e07423e22c0991084d9a2f43727805}{Global\_Physical\_Variables::H};

   \textcolor{comment}{// Set the load Vector for each element}
   elem\_pt->load\_vector\_fct\_pt() = &\hyperlink{namespaceGlobal__Physical__Variables_a321267e1efb30b5d586302509354fb07}{Global\_Physical\_Variables::load};

   \textcolor{comment}{// Set the undeformed shape for each element}
   elem\_pt->undeformed\_beam\_pt() = Undef\_beam\_pt;
  \} \textcolor{comment}{// end of loop over elements}

\end{DoxyCodeInclude}


We choose a node near the centre of the beam to monitor the displacements. (If the total number of nodes is even, the control node will not be located at the beam\textquotesingle{}s exact centre; its vertical displacement will therefore differ from the analytical solution that we output in {\ttfamily doc\+\_\+solution}(...) -- in this case we issue a suitable warning.) 
\begin{DoxyCodeInclude}
 \textcolor{comment}{// Choose node at which displacement is documented (halfway along -- provided}
 \textcolor{comment}{// we have an odd number of nodes; complain if this is not the}
 \textcolor{comment}{// case because the comparison with the exact solution will be wrong }
 \textcolor{comment}{// otherwise!)}
 \textcolor{keywordtype}{unsigned} n\_nod=mesh\_pt()->nnode();
 \textcolor{keywordflow}{if} (n\_nod%2!=1)
  \{
   cout << \textcolor{stringliteral}{"Warning: Even number of nodes "} << n\_nod << std::endl;
   cout << \textcolor{stringliteral}{"Comparison with exact solution will be misleading..."} << std::endl;
  \}
 Doc\_node\_pt=mesh\_pt()->node\_pt((n\_nod+1)/2-1);

\end{DoxyCodeInclude}


Finally, we assign the equation numbers 
\begin{DoxyCodeInclude}
 \textcolor{comment}{// Assign the global and local equation numbers}
 cout << \textcolor{stringliteral}{"# of dofs "} << assign\_eqn\_numbers() << std::endl;

\} \textcolor{comment}{// end of constructor}

\end{DoxyCodeInclude}




 

\hypertarget{index_param}{}\section{The Parameter Study}\label{index_param}
The function \hyperlink{classElasticBeamProblem_a2da3cb02ce953da67fb27742e20774a5}{Elastic\+Beam\+Problem\+::parameter\+\_\+study()} is used to perform a parameter study, computing the beam\textquotesingle{}s deformation for a range of external pressures. During the solution of this particular problem, the maximum residual in the Newton iteration can be greater than the default maximum value of 10.\+0. We increase the default value by assigning a (much) larger value to {\ttfamily Problem\+::\+Max\+\_\+residuals}.

Next, we choose the increment in the control parameter (the external pressure), set its initial value and open an output file that will contain the value of the external pressure, the mid-\/point displacement and external pressure computed from the analytical solution. We also create an output stream and a string that will be used to write the complete solution for each value of the external pressure.

In the loop, we increment the external pressure $ P_{ext} $, solve the problem, calculate the analytical prediction for the pressure that is required to achieve the computed deformation, plot the solution and write the pressure, the displacement and exact pressure to the trace file.


\begin{DoxyCodeInclude}
\textcolor{comment}{//=======start\_of\_parameter\_study==========================================}
\textcolor{comment}{/// Solver loop to perform parameter study}
\textcolor{comment}{}\textcolor{comment}{//=========================================================================}
\textcolor{keywordtype}{void} \hyperlink{classElasticBeamProblem_a2da3cb02ce953da67fb27742e20774a5}{ElasticBeamProblem::parameter\_study}()
\{
 \textcolor{comment}{// Over-ride the default maximum value for the residuals}
 Problem::Max\_residuals = 1.0e10;
 
 \textcolor{comment}{// Set the increments in control parameters}
 \textcolor{keywordtype}{double} pext\_increment = 0.001;
 
 \textcolor{comment}{// Set initial values for control parameters }
 \hyperlink{namespaceGlobal__Physical__Variables_a0406c0cbd463d1df2458fe5de98a00eb}{Global\_Physical\_Variables::P\_ext} = 0.0 - pext\_increment;
 
 \textcolor{comment}{// Create label for output}
 DocInfo doc\_info;
 
 \textcolor{comment}{// Set output directory -- this function checks if the output}
 \textcolor{comment}{// directory exists and issues a warning if it doesn't.}
 doc\_info.set\_directory(\textcolor{stringliteral}{"RESLT"});
 
 \textcolor{comment}{// Open a trace file}
 ofstream trace(\textcolor{stringliteral}{"RESLT/trace\_beam.dat"});
 
 \textcolor{comment}{// Write a header for the trace file}
 trace << 
  \textcolor{stringliteral}{"VARIABLES=\(\backslash\)"p\_e\_x\_t\(\backslash\)",\(\backslash\)"d\(\backslash\)""} << 
  \textcolor{stringliteral}{", \(\backslash\)"p\_e\_x\_t\_(\_e\_x\_a\_c\_t\_)\(\backslash\)""} << std::endl;
 
 \textcolor{comment}{// Output file stream used for writing results}
 ofstream file;
 \textcolor{comment}{// String used for the filename}
 \textcolor{keywordtype}{char} filename[100]; 

 \textcolor{comment}{// Loop over parameter increments}
 \textcolor{keywordtype}{unsigned} nstep=10;
 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} i=1;i<=nstep;i++)
  \{
   \textcolor{comment}{// Increment pressure}
   \hyperlink{namespaceGlobal__Physical__Variables_a0406c0cbd463d1df2458fe5de98a00eb}{Global\_Physical\_Variables::P\_ext} += pext\_increment;
   
   \textcolor{comment}{// Solve the system}
   newton\_solve();
    
   \textcolor{comment}{// Calculate exact solution for `string under tension' (applicable for}
   \textcolor{comment}{// small wall thickness and pinned ends)}

   \textcolor{comment}{// The tangent of the angle beta}
   \textcolor{keywordtype}{double} tanbeta =-2.0*\hyperlink{classElasticBeamProblem_a9c96cab7e71243e51f7c4040a84cdd5d}{Doc\_node\_pt}->x(1)/\hyperlink{classElasticBeamProblem_aa68b1c77e0aa1571fe956d62bd8cf096}{Length};

   \textcolor{keywordtype}{double} exact\_pressure = 0.0;
   \textcolor{comment}{//If the beam has deformed, calculate the pressure required}
   \textcolor{keywordflow}{if}(tanbeta!=0)
    \{
      
      \textcolor{comment}{//Calculate the opening angle alpha}
      \textcolor{keywordtype}{double} alpha = 2.0*atan(2.0*tanbeta/(1.0-tanbeta*tanbeta));

      \textcolor{comment}{// Jump back onto the main branch if alpha>180 degrees}
      \textcolor{keywordflow}{if} (alpha<0) alpha+=2.0*MathematicalConstants::Pi;

     \textcolor{comment}{// Green strain:}
     \textcolor{keywordtype}{double} gamma=0.5*(0.25*alpha*alpha/(sin(0.5*alpha)*sin(0.5*alpha))-1.0);

     \textcolor{comment}{//Calculate the exact pressure}
     exact\_pressure=\hyperlink{namespaceGlobal__Physical__Variables_af6e07423e22c0991084d9a2f43727805}{Global\_Physical\_Variables::H}*
      (\hyperlink{namespaceGlobal__Physical__Variables_a417dc688a70c4f06ef0faed047068ba2}{Global\_Physical\_Variables::Sigma0}+gamma)*alpha/
      \hyperlink{classElasticBeamProblem_aa68b1c77e0aa1571fe956d62bd8cf096}{Length};
    \} 
   
   \textcolor{comment}{// Document the solution}
   sprintf(filename,\textcolor{stringliteral}{"RESLT/beam%i.dat"},i);
   file.open(filename);
   \hyperlink{classElasticBeamProblem_ae7d14ba8bec2325a82cbeed0c1b29910}{mesh\_pt}()->output(file,5);
   file.close();
   
   \textcolor{comment}{// Write trace file: Pressure, displacement and exact solution}
   \textcolor{comment}{// (for string under tension)}
   trace << \hyperlink{namespaceGlobal__Physical__Variables_a0406c0cbd463d1df2458fe5de98a00eb}{Global\_Physical\_Variables::P\_ext}  << \textcolor{stringliteral}{" "} 
         << abs(\hyperlink{classElasticBeamProblem_a9c96cab7e71243e51f7c4040a84cdd5d}{Doc\_node\_pt}->x(1))
         << \textcolor{stringliteral}{" "} << exact\_pressure 
         << std::endl;
  \}
 
\} \textcolor{comment}{// end of parameter study}

\end{DoxyCodeInclude}




 

\hypertarget{index_comments}{}\section{Exercises and Comments}\label{index_comments}

\begin{DoxyEnumerate}
\item Modify the code so that one end of the beam is no longer fixed in space. What happens? Why?
\item Increase the bending effects by increasing the beam\textquotesingle{}s thickness to $ h=0.1 $, say, and by \char`\"{}clamping\char`\"{} its ends, so that $ d({\bf R}_w(\xi)\cdot {\bf e}_y)/d\xi = 0 $ at $ \xi=0 $ and $ \xi=L $. This condition can be enforced by pinning the \char`\"{}type 1\char`\"{} (slope) positional degree of freedom in the vertical (1) direction at both ends; this requires the insertion of the statement 
\begin{DoxyCode}
mesh\_pt()->boundary\_node\_pt(b,0)->pin\_position(1,1); 
\end{DoxyCode}
 in the loop in the {\ttfamily Problem} constructor. You will have to adjust the number of elements to fully resolve the bending boundary layers.
\item {\ttfamily oomph-\/lib\textquotesingle{}s} default\label{index_newton_cust}%
\Hypertarget{index_newton_cust}%
nonlinear solver, {\ttfamily Problem\+::newton\+\_\+solve}(...), provides an implementation of the Newton method, which has the attractive feature that it converges quadratically -- provided a good initial guess for the solution is available. Good initial guesses can often (usually?) be generated by computing the solution via a sequence of substeps, as in the above example where we started with a known solution (the undeformed beam -- the exact solution for $ p_{ext} = p_{ext}^{(0)} =0 $ ) and used it as the initial guess for the solution at a small external pressure, $ p_{ext}^{(1)} $. When the Newton method converged, we used the computed solution as the initial guess for the solution at a slightly larger pressure, $ p_{ext}^{(2)} $, etc. If the increase in the load (or some other control parameter) is too large, the Newton method will diverge. To avoid unnecessary computations, the Newton iteration is terminated if\+:
\begin{DoxyItemize}
\item the number of iterations exceeds {\ttfamily Problem\+::\+Max\+\_\+newton\+\_\+iterations} (which has a default value of 10)
\item the residual exceeds {\ttfamily Problem\+::\+Max\+\_\+residuals} (which has a default value of 10.\+0)
\end{DoxyItemize}The Newton method continues until the maximum residual has been reduced to {\ttfamily Problem\+::\+Newton\+\_\+solver\+\_\+tolerance}, which has a default value of $ 10^{-8} $. ~\newline
~\newline
 All three values are protected data members of the {\ttfamily Problem} base class and can therefore be changed in any specific {\ttfamily Problem}. For instance, in the problem considered above, the undeformed beam provides a poor approximation of its equilibrium shape at the first pressure value. The Newton method still converges (very slowly initially, then quadratically as it approaches the exact solution), even though the initial maximum residual has a relatively large value of 19.\+6. Here are some exercises that explore the convergence characteristics of the Newton method\+:
\begin{DoxyEnumerate}
\item Experiment with the Newton solver and find the largest value for the load increment, {\ttfamily pext\+\_\+increment}, for which the Newton method still converges.
\item Explain why the Newton method converges very slowly for small values of $ p_{ext} $ and much more rapidly at larger values, even though the load increment, {\ttfamily pext\+\_\+increment}, remains constant.
\item Compare the solutions for different values of {\ttfamily Problem\+::\+Newton\+\_\+solver\+\_\+tolerance}. Is the default value $ 10^{-8} $ adequate? Reduce it to $ 10^{-12} $ and $ 10^{-18} $. What do you observe?
\end{DoxyEnumerate}
\end{DoxyEnumerate}



 

\hypertarget{index_sources}{}\section{Source files for this tutorial}\label{index_sources}

\begin{DoxyItemize}
\item The source files for this tutorial are located in the directory\+: \begin{center} \href{
../../../../
demo_drivers/beam/tensioned_string/
}{\tt demo\+\_\+drivers/beam/tensioned\+\_\+string/ } \end{center} 
\item The driver code is\+: \begin{center} \href{
../../../../
demo_drivers/beam/tensioned_string/tensioned_string.cc
}{\tt demo\+\_\+drivers/beam/tensioned\+\_\+string/tensioned\+\_\+string.\+cc } \end{center} 
\end{DoxyItemize}

 

 \hypertarget{index_pdf}{}\section{P\+D\+F file}\label{index_pdf}
A \href{../latex/refman.pdf}{\tt pdf version} of this document is available. \end{document}
