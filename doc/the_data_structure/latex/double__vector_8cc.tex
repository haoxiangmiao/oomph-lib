\hypertarget{double__vector_8cc}{}\section{double\+\_\+vector.\+cc File Reference}
\label{double__vector_8cc}\index{double\+\_\+vector.\+cc@{double\+\_\+vector.\+cc}}
\subsection*{Namespaces}
\begin{DoxyCompactItemize}
\item 
 \hyperlink{namespaceoomph}{oomph}
\item 
 \hyperlink{namespaceoomph_1_1DoubleVectorHelpers}{oomph\+::\+Double\+Vector\+Helpers}
\begin{DoxyCompactList}\small\item\em Namespace for helper functions for Double\+Vectors. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
std\+::ostream \& \hyperlink{namespaceoomph_aa7525c5465ee2c4398c37072773f2299}{oomph\+::operator$<$$<$} (std\+::ostream \&out, const Double\+Vector \&v)
\begin{DoxyCompactList}\small\item\em output operator \end{DoxyCompactList}\item 
void \hyperlink{namespaceoomph_1_1DoubleVectorHelpers_ae5259ed3ae48ad417c743de0166884f8}{oomph\+::\+Double\+Vector\+Helpers\+::concatenate} (const Vector$<$ Double\+Vector $\ast$$>$ \&in\+\_\+vector\+\_\+pt, Double\+Vector \&out\+\_\+vector)
\begin{DoxyCompactList}\small\item\em Concatenate Double\+Vectors. Takes a \hyperlink{classoomph_1_1Vector}{Vector} of Double\+Vectors. If the out vector is built, we will not build a new distribution. Otherwise we build a uniform distribution. \end{DoxyCompactList}\item 
void \hyperlink{namespaceoomph_1_1DoubleVectorHelpers_ae2e2b5728675ea85a48158f5d93f6593}{oomph\+::\+Double\+Vector\+Helpers\+::concatenate} (Vector$<$ Double\+Vector $>$ \&in\+\_\+vector, Double\+Vector \&out\+\_\+vector)
\begin{DoxyCompactList}\small\item\em Wrapper around the other concatenate(...) function. Be careful with \hyperlink{classoomph_1_1Vector}{Vector} of vectors. If the Double\+Vectors are resized, there could be reallocation of memory. If we wanted to use the function which takes a \hyperlink{classoomph_1_1Vector}{Vector} of pointers to Double\+Vectors, we would either have to invoke new and remember to delete, or create a temporary \hyperlink{classoomph_1_1Vector}{Vector} to store pointers to the \hyperlink{classoomph_1_1DoubleVector}{Double\+Vector} objects. This wrapper is meant to make life easier for the user by avoiding calls to new/delete A\+ND without creating a temporary vector of pointers to Double\+Vectors. If we had C++ 11, this would be so much nicer since we can use smart pointers which will delete themselves, so we do not have to remember to delete! \end{DoxyCompactList}\item 
void \hyperlink{namespaceoomph_1_1DoubleVectorHelpers_aa6675e6e16aa28b54245bb85b3e918ee}{oomph\+::\+Double\+Vector\+Helpers\+::split} (const Double\+Vector \&in\+\_\+vector, Vector$<$ Double\+Vector $\ast$$>$ \&out\+\_\+vector\+\_\+pt)
\begin{DoxyCompactList}\small\item\em Split a \hyperlink{classoomph_1_1DoubleVector}{Double\+Vector} into the out Double\+Vectors. Let vec\+\_\+A be the in \hyperlink{classoomph_1_1Vector}{Vector}, and let vec\+\_\+B and vec\+\_\+C be the out vectors. Then the splitting of vec\+\_\+A is depicted below\+: vec\+\_\+A\+: \mbox{[}a0 (on p0) a1\mbox{]} (on p0) \mbox{[}a2 (on p1) a3\mbox{]} (on p1) \end{DoxyCompactList}\item 
void \hyperlink{namespaceoomph_1_1DoubleVectorHelpers_a111654d0a7b7bfaae9cdd8101c8005ca}{oomph\+::\+Double\+Vector\+Helpers\+::split} (const Double\+Vector \&in\+\_\+vector, Vector$<$ Double\+Vector $>$ \&out\+\_\+vector)
\begin{DoxyCompactList}\small\item\em Wrapper around the other split(...) function. Be careful with \hyperlink{classoomph_1_1Vector}{Vector} of vectors. If the Double\+Vectors are resized, there could be reallocation of memory. If we wanted to use the function which takes a \hyperlink{classoomph_1_1Vector}{Vector} of pointers to Double\+Vectors, we would either have to invoke new and remember to delete, or create a temporary \hyperlink{classoomph_1_1Vector}{Vector} to store pointers to the \hyperlink{classoomph_1_1DoubleVector}{Double\+Vector} objects. This wrapper is meant to make life easier for the user by avoiding calls to new/delete A\+ND without creating a temporary vector of pointers to Double\+Vectors. If we had C++ 11, this would be so much nicer since we can use smart pointers which will delete themselves, so we do not have to remember to delete! \end{DoxyCompactList}\item 
void \hyperlink{namespaceoomph_1_1DoubleVectorHelpers_ac69d6979ffbf4987684c0e025d107947}{oomph\+::\+Double\+Vector\+Helpers\+::concatenate\+\_\+without\+\_\+communication} (const Vector$<$ Double\+Vector $\ast$$>$ \&in\+\_\+vector\+\_\+pt, Double\+Vector \&out\+\_\+vector)
\begin{DoxyCompactList}\small\item\em Concatenate Double\+Vectors. Takes a \hyperlink{classoomph_1_1Vector}{Vector} of Double\+Vectors. If the out vector is built, we will not build a new distribution. Otherwise a new distribution will be built using Linear\+Algebra\+Distribution\+::concatenate(...). \end{DoxyCompactList}\item 
void \hyperlink{namespaceoomph_1_1DoubleVectorHelpers_a568db46f65c1d234ac6f96ab54fafe60}{oomph\+::\+Double\+Vector\+Helpers\+::concatenate\+\_\+without\+\_\+communication} (Vector$<$ Double\+Vector $>$ \&in\+\_\+vector, Double\+Vector \&out\+\_\+vector)
\begin{DoxyCompactList}\small\item\em Wrapper around the other concatenate\+\_\+without\+\_\+communication(...) function. Be careful with \hyperlink{classoomph_1_1Vector}{Vector} of vectors. If the Double\+Vectors are resized, there could be reallocation of memory. If we wanted to use the function which takes a \hyperlink{classoomph_1_1Vector}{Vector} of pointers to Double\+Vectors, we would either have to invoke new and remember to delete, or create a temporary \hyperlink{classoomph_1_1Vector}{Vector} to store pointers to the \hyperlink{classoomph_1_1DoubleVector}{Double\+Vector} objects. This wrapper is meant to make life easier for the user by avoiding calls to new/delete A\+ND without creating a temporary vector of pointers to Double\+Vectors. If we had C++ 11, this would be so much nicer since we can use smart pointers which will delete themselves, so we do not have to remember to delete! \end{DoxyCompactList}\item 
void \hyperlink{namespaceoomph_1_1DoubleVectorHelpers_ab983914eb27cc57a2184bca42e9a77a0}{oomph\+::\+Double\+Vector\+Helpers\+::split\+\_\+without\+\_\+communication} (const Double\+Vector \&in\+\_\+vector, Vector$<$ Double\+Vector $\ast$$>$ \&out\+\_\+vector\+\_\+pt)
\begin{DoxyCompactList}\small\item\em Split a \hyperlink{classoomph_1_1DoubleVector}{Double\+Vector} into the out Double\+Vectors. \hyperlink{classoomph_1_1Data}{Data} stays on its current processor, no data is sent between processors. This results in our vectors which are a permutation of the in vector. \end{DoxyCompactList}\item 
void \hyperlink{namespaceoomph_1_1DoubleVectorHelpers_a66afcc493558424fb89f26bc23dd5bf2}{oomph\+::\+Double\+Vector\+Helpers\+::split\+\_\+without\+\_\+communication} (const Double\+Vector \&in\+\_\+vector, Vector$<$ Double\+Vector $>$ \&out\+\_\+vector)
\begin{DoxyCompactList}\small\item\em Wrapper around the other split\+\_\+without\+\_\+communication(...) function. Be careful with \hyperlink{classoomph_1_1Vector}{Vector} of vectors. If the Double\+Vectors are resized, there could be reallocation of memory. If we wanted to use the function which takes a \hyperlink{classoomph_1_1Vector}{Vector} of pointers to Double\+Vectors, we would either have to invoke new and remember to delete, or create a temporary \hyperlink{classoomph_1_1Vector}{Vector} to store pointers to the \hyperlink{classoomph_1_1DoubleVector}{Double\+Vector} objects. This wrapper is meant to make life easier for the user by avoiding calls to new/delete A\+ND without creating a temporary vector of pointers to Double\+Vectors. If we had C++ 11, this would be so much nicer since we can use smart pointers which will delete themselves, so we do not have to remember to delete! \end{DoxyCompactList}\end{DoxyCompactItemize}
