\hypertarget{namespaceoomph_1_1LinearAlgebraDistributionHelpers}{}\section{oomph\+:\+:Linear\+Algebra\+Distribution\+Helpers Namespace Reference}
\label{namespaceoomph_1_1LinearAlgebraDistributionHelpers}\index{oomph\+::\+Linear\+Algebra\+Distribution\+Helpers@{oomph\+::\+Linear\+Algebra\+Distribution\+Helpers}}


Namespace for helper functions for Linear\+Algebra\+Distributions.  


\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{namespaceoomph_1_1LinearAlgebraDistributionHelpers_ad3ba423fba64e7db91e9155efa7df5d0}{concatenate} (const \hyperlink{classoomph_1_1Vector}{Vector}$<$ \hyperlink{classoomph_1_1LinearAlgebraDistribution}{Linear\+Algebra\+Distribution} $\ast$$>$ \&in\+\_\+distribution\+\_\+pt, \hyperlink{classoomph_1_1LinearAlgebraDistribution}{Linear\+Algebra\+Distribution} \&out\+\_\+distribution)
\begin{DoxyCompactList}\small\item\em Takes a vector of \hyperlink{classoomph_1_1LinearAlgebraDistribution}{Linear\+Algebra\+Distribution} objects and concatenates them such that the nrow\+\_\+local of the out\+\_\+distribution is the sum of the nrow\+\_\+local of all the in\+\_\+distributions and the number of global rows of the out\+\_\+distribution is the sum of the number of global rows of all the in\+\_\+distributions. This results in a permutation of the rows in the out\+\_\+distribution. Think of this in terms of Double\+Vectors, if we have Double\+Vectors with distributions A and B, distributed across two processors (p0 and p1), A\+: \mbox{[}a0\mbox{]} (on p0) B\+: \mbox{[}b0\mbox{]} (on p0) \mbox{[}a1\mbox{]} (on p1) \mbox{[}b1\mbox{]} (on P1),. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
Namespace for helper functions for Linear\+Algebra\+Distributions. 

\subsection{Function Documentation}
\mbox{\Hypertarget{namespaceoomph_1_1LinearAlgebraDistributionHelpers_ad3ba423fba64e7db91e9155efa7df5d0}\label{namespaceoomph_1_1LinearAlgebraDistributionHelpers_ad3ba423fba64e7db91e9155efa7df5d0}} 
\index{oomph\+::\+Linear\+Algebra\+Distribution\+Helpers@{oomph\+::\+Linear\+Algebra\+Distribution\+Helpers}!concatenate@{concatenate}}
\index{concatenate@{concatenate}!oomph\+::\+Linear\+Algebra\+Distribution\+Helpers@{oomph\+::\+Linear\+Algebra\+Distribution\+Helpers}}
\subsubsection{\texorpdfstring{concatenate()}{concatenate()}}
{\footnotesize\ttfamily void oomph\+::\+Linear\+Algebra\+Distribution\+Helpers\+::concatenate (\begin{DoxyParamCaption}\item[{const \hyperlink{classoomph_1_1Vector}{Vector}$<$ \hyperlink{classoomph_1_1LinearAlgebraDistribution}{Linear\+Algebra\+Distribution} $\ast$$>$ \&}]{in\+\_\+distribution\+\_\+pt,  }\item[{\hyperlink{classoomph_1_1LinearAlgebraDistribution}{Linear\+Algebra\+Distribution} \&}]{out\+\_\+distribution }\end{DoxyParamCaption})}



Takes a vector of \hyperlink{classoomph_1_1LinearAlgebraDistribution}{Linear\+Algebra\+Distribution} objects and concatenates them such that the nrow\+\_\+local of the out\+\_\+distribution is the sum of the nrow\+\_\+local of all the in\+\_\+distributions and the number of global rows of the out\+\_\+distribution is the sum of the number of global rows of all the in\+\_\+distributions. This results in a permutation of the rows in the out\+\_\+distribution. Think of this in terms of Double\+Vectors, if we have Double\+Vectors with distributions A and B, distributed across two processors (p0 and p1), A\+: \mbox{[}a0\mbox{]} (on p0) B\+: \mbox{[}b0\mbox{]} (on p0) \mbox{[}a1\mbox{]} (on p1) \mbox{[}b1\mbox{]} (on P1),. 

then the out\+\_\+distribution is \mbox{[}a0 (on p0) b0\mbox{]} (on p0) \mbox{[}a1 (on p1) b1\mbox{]} (on p1),

as opposed to \mbox{[}a0 (on p0) a1\mbox{]} (on p0) \mbox{[}b0 (on p1) b1\mbox{]} (on p1).

Note (1)\+: The out\+\_\+distribution may not be uniformly distributed even if the in\+\_\+distributions are uniform distributions. Try this out with two distributions of global rows 3 and 5, uniformly distributed across two processors. Compare this against a distribution of global row 8 distributed across two processors.

Note (2)\+: There is no equivalent function which takes a \hyperlink{classoomph_1_1Vector}{Vector} of \hyperlink{classoomph_1_1LinearAlgebraDistribution}{Linear\+Algebra\+Distribution} objects (as opposed to pointers), there should not be one since we do not want to invoke the assignment operator when creating the \hyperlink{classoomph_1_1Vector}{Vector} of \hyperlink{classoomph_1_1LinearAlgebraDistribution}{Linear\+Algebra\+Distribution} objects. 

Definition at line 367 of file linear\+\_\+algebra\+\_\+distribution.\+cc.



References oomph\+::\+Linear\+Algebra\+Distribution\+::build(), oomph\+::\+Linear\+Algebra\+Distribution\+::built(), and oomph\+::\+Linear\+Algebra\+Distribution\+::distributed().



Referenced by oomph\+::\+Block\+Preconditioner$<$ C\+R\+Double\+Matrix $>$\+::block\+\_\+setup(), oomph\+::\+Double\+Vector\+Helpers\+::concatenate\+\_\+without\+\_\+communication(), oomph\+::\+C\+R\+Double\+Matrix\+Helpers\+::concatenate\+\_\+without\+\_\+communication(), oomph\+::\+Block\+Preconditioner$<$ C\+R\+Double\+Matrix $>$\+::get\+\_\+concatenated\+\_\+block(), oomph\+::\+Block\+Preconditioner$<$ C\+R\+Double\+Matrix $>$\+::get\+\_\+concatenated\+\_\+block\+\_\+vector(), oomph\+::\+Block\+Preconditioner$<$ C\+R\+Double\+Matrix $>$\+::return\+\_\+concatenated\+\_\+block\+\_\+vector(), oomph\+::\+Block\+Preconditioner$<$ C\+R\+Double\+Matrix $>$\+::setup\+\_\+matrix\+\_\+vector\+\_\+product(), and oomph\+::\+Double\+Vector\+Helpers\+::split\+\_\+without\+\_\+communication().

