Detailed documentation to be written. Here\textquotesingle{}s a plot of the result and the already fairly well documented driver code...

 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{elastic_fish}
\doxyfigcaption{Adaptive solution of Poisson\textquotesingle{}s equation in a fish-\/shaped domain for various `widths\textquotesingle{} of the domain. }
\end{DoxyImage}


 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{trace}
\doxyfigcaption{Solution of Poisson\textquotesingle{}s equation at a control node as a function of the `width\textquotesingle{} of the domain. }
\end{DoxyImage}



\begin{DoxyCodeInclude}
\textcolor{comment}{//LIC// ====================================================================}
\textcolor{comment}{//LIC// This file forms part of oomph-lib, the object-oriented, }
\textcolor{comment}{//LIC// multi-physics finite-element library, available }
\textcolor{comment}{//LIC// at http://www.oomph-lib.org.}
\textcolor{comment}{//LIC// }
\textcolor{comment}{//LIC//    Version 1.0; svn revision $LastChangedRevision$}
\textcolor{comment}{//LIC//}
\textcolor{comment}{//LIC// $LastChangedDate$}
\textcolor{comment}{//LIC// }
\textcolor{comment}{//LIC// Copyright (C) 2006-2016 Matthias Heil and Andrew Hazel}
\textcolor{comment}{//LIC// }
\textcolor{comment}{//LIC// This library is free software; you can redistribute it and/or}
\textcolor{comment}{//LIC// modify it under the terms of the GNU Lesser General Public}
\textcolor{comment}{//LIC// License as published by the Free Software Foundation; either}
\textcolor{comment}{//LIC// version 2.1 of the License, or (at your option) any later version.}
\textcolor{comment}{//LIC// }
\textcolor{comment}{//LIC// This library is distributed in the hope that it will be useful,}
\textcolor{comment}{//LIC// but WITHOUT ANY WARRANTY; without even the implied warranty of}
\textcolor{comment}{//LIC// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU}
\textcolor{comment}{//LIC// Lesser General Public License for more details.}
\textcolor{comment}{//LIC// }
\textcolor{comment}{//LIC// You should have received a copy of the GNU Lesser General Public}
\textcolor{comment}{//LIC// License along with this library; if not, write to the Free Software}
\textcolor{comment}{//LIC// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA}
\textcolor{comment}{//LIC// 02110-1301  USA.}
\textcolor{comment}{//LIC// }
\textcolor{comment}{//LIC// The authors may be contacted at oomph-lib@maths.man.ac.uk.}
\textcolor{comment}{//LIC// }
\textcolor{comment}{//LIC//====================================================================}
\textcolor{comment}{// Driver for solution of "free boundary" 2D Poisson equation in }
\textcolor{comment}{// fish-shaped domain with adaptivity}

 
\textcolor{comment}{// Generic oomph-lib headers}
\textcolor{preprocessor}{#include "generic.h"}

\textcolor{comment}{// The Poisson equations}
\textcolor{preprocessor}{#include "poisson.h"}

\textcolor{comment}{// The fish mesh }
\textcolor{preprocessor}{#include "meshes/fish\_mesh.h"}

\textcolor{comment}{// Circle as generalised element:}
\textcolor{preprocessor}{#include "\hyperlink{circle__as__generalised__element_8h}{circle\_as\_generalised\_element.h}"}

\textcolor{keyword}{using namespace }\hyperlink{namespacestd}{std};

\textcolor{keyword}{using namespace }\hyperlink{namespaceoomph}{oomph};
\textcolor{comment}{}
\textcolor{comment}{///////////////////////////////////////////////////////////////////////}
\textcolor{comment}{///////////////////////////////////////////////////////////////////////}
\textcolor{comment}{///////////////////////////////////////////////////////////////////////}
\textcolor{comment}{}


\textcolor{comment}{//====================================================================}\textcolor{comment}{}
\textcolor{comment}{/// Namespace for const source term in Poisson equation}
\textcolor{comment}{}\textcolor{comment}{//====================================================================}
\textcolor{keyword}{namespace }\hyperlink{namespaceConstSourceForPoisson}{ConstSourceForPoisson}
\{\textcolor{comment}{}
\textcolor{comment}{ /// Strength of source function: default value 1.0}
\textcolor{comment}{} \textcolor{keywordtype}{double} \hyperlink{namespaceConstSourceForPoisson_add351c5acab2561d68d1fc9ec3d5fc5e}{Strength}=1.0;
\textcolor{comment}{}
\textcolor{comment}{/// Const source function}
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{namespaceConstSourceForPoisson_a40ef79083874b58ed42b4df2ca0f4c10}{get\_source}(\textcolor{keyword}{const} Vector<double>& x, \textcolor{keywordtype}{double}& source)
 \{
  source = -Strength*(1.0+x[0]*x[1]);
 \}
 
\}

\textcolor{comment}{}
\textcolor{comment}{////////////////////////////////////////////////////////////////////////}
\textcolor{comment}{////////////////////////////////////////////////////////////////////////}
\textcolor{comment}{////////////////////////////////////////////////////////////////////////}
\textcolor{comment}{}


\textcolor{comment}{//====================================================================}\textcolor{comment}{}
\textcolor{comment}{/// Refineable Poisson problem in deformable fish-shaped domain.}
\textcolor{comment}{/// Template parameter identify the elements.}
\textcolor{comment}{}\textcolor{comment}{//====================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT>
\textcolor{keyword}{class }\hyperlink{classRefineableFishPoissonProblem}{RefineableFishPoissonProblem} : \textcolor{keyword}{public} Problem
\{

\textcolor{keyword}{public}:
\textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short  Constructor: Bool flag specifies if position of fish back is}
\textcolor{comment}{ /// prescribed or computed from the coupled problem. String specifies}
\textcolor{comment}{ /// output directory.}
\textcolor{comment}{} \hyperlink{classRefineableFishPoissonProblem}{RefineableFishPoissonProblem}(
  \textcolor{keyword}{const} \textcolor{keywordtype}{bool}& fix\_position, \textcolor{keyword}{const} \textcolor{keywordtype}{string}& directory\_name,
  \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned}& i\_case);
  \textcolor{comment}{}
\textcolor{comment}{ /// Destructor}
\textcolor{comment}{} \textcolor{keyword}{virtual} ~\hyperlink{classRefineableFishPoissonProblem}{RefineableFishPoissonProblem}();
\textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Update after Newton step: Update mesh in response to }
\textcolor{comment}{ /// possible changes in the wall shape}
\textcolor{comment}{} \textcolor{keywordtype}{void} actions\_before\_newton\_convergence\_check()
  \{
   fish\_mesh\_pt()->node\_update();
  \}
\textcolor{comment}{}
\textcolor{comment}{ /// Update the problem specs after solve (empty)}
\textcolor{comment}{} \textcolor{keywordtype}{void} actions\_after\_newton\_solve()\{\}
  \textcolor{comment}{}
\textcolor{comment}{ /// Update the problem specs before solve: Update mesh}
\textcolor{comment}{} \textcolor{keywordtype}{void} actions\_before\_newton\_solve() 
  \{
   fish\_mesh\_pt()->node\_update();
  \}

 \textcolor{comment}{//Access function for the fish mesh}
 AlgebraicRefineableFishMesh<ELEMENT>* fish\_mesh\_pt() 
  \{
   \textcolor{keywordflow}{return} Fish\_mesh\_pt;
  \}
\textcolor{comment}{}
\textcolor{comment}{ /// Return value of the "load" on the elastically supported ring}
\textcolor{comment}{} \textcolor{keywordtype}{double}& load()
  \{
   \textcolor{keywordflow}{return} *Load\_pt->value\_pt(0);
  \}

\textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Return value of the vertical displacement of the ring that}
\textcolor{comment}{ /// represents the fish's back}
\textcolor{comment}{} \textcolor{keywordtype}{double}& y\_c()
  \{
   \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}\hyperlink{classoomph_1_1ElasticallySupportedRingElement}{ElasticallySupportedRingElement}*\textcolor{keyword}{>}(fish\_mesh\_pt()->
                                                        fish\_back\_pt())->y\_c();
  \}
\textcolor{comment}{}
\textcolor{comment}{ /// Doc the solution}
\textcolor{comment}{} \textcolor{keywordtype}{void} doc\_solution();
\textcolor{comment}{}
\textcolor{comment}{ /// Access to DocInfo object}
\textcolor{comment}{} DocInfo& doc\_info() \{\textcolor{keywordflow}{return} Doc\_info;\}

\textcolor{keyword}{private}:
 \textcolor{comment}{}
\textcolor{comment}{ /// Helper fct to set method for evaluation of shape derivs}
\textcolor{comment}{} \textcolor{keywordtype}{void} set\_shape\_deriv\_method()
  \{
   
   \textcolor{keywordtype}{bool} done=\textcolor{keyword}{false};

   \textcolor{comment}{//Loop over elements and set pointers to source function}
   \textcolor{keywordtype}{unsigned} n\_element = fish\_mesh\_pt()->nelement();
   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} i=0;i<n\_element;i++)
    \{
     \textcolor{comment}{// Upcast from FiniteElement to the present element}
     ELEMENT *el\_pt = \textcolor{keyword}{dynamic\_cast<}ELEMENT*\textcolor{keyword}{>}(fish\_mesh\_pt()->element\_pt(i));
     
     \textcolor{comment}{// Direct FD}
     \textcolor{keywordflow}{if} (Case\_id==0)
      \{
       el\_pt->evaluate\_shape\_derivs\_by\_direct\_fd();       
       \textcolor{keywordflow}{if} (!done) std::cout << \textcolor{stringliteral}{"\(\backslash\)n\(\backslash\)n [CR residuals] Direct FD"} << std::endl;
      \}
     \textcolor{comment}{// Chain rule with/without FD}
     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ( (Case\_id==1) ||  (Case\_id==2) )
      \{
       \textcolor{comment}{// It's broken but let's call it anyway to keep self-test alive}
       \textcolor{keywordtype}{bool} i\_know\_what\_i\_am\_doing=\textcolor{keyword}{true};
       el\_pt->evaluate\_shape\_derivs\_by\_chain\_rule(i\_know\_what\_i\_am\_doing);
       \textcolor{keywordflow}{if} (Case\_id==1)
        \{
         el\_pt->enable\_always\_evaluate\_dresidual\_dnodal\_coordinates\_by\_fd();
         \textcolor{keywordflow}{if} (!done) std::cout << \textcolor{stringliteral}{"\(\backslash\)n\(\backslash\)n [CR residuals] Chain rule and FD"} 
                              << std::endl;
        \}
       \textcolor{keywordflow}{else}
        \{
         el\_pt->disable\_always\_evaluate\_dresidual\_dnodal\_coordinates\_by\_fd();
         \textcolor{keywordflow}{if} (!done) std::cout << \textcolor{stringliteral}{"\(\backslash\)n\(\backslash\)n [CR residuals] Chain rule and analytic"} 
                              << std::endl;
        \}
      \}
     \textcolor{comment}{// Fastest with/without FD}
     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ( (Case\_id==3) ||  (Case\_id==4) )
      \{
       \textcolor{comment}{// It's broken but let's call it anyway to keep self-test alive}
       \textcolor{keywordtype}{bool} i\_know\_what\_i\_am\_doing=\textcolor{keyword}{true};
       el\_pt->evaluate\_shape\_derivs\_by\_fastest\_method(i\_know\_what\_i\_am\_doing);
       \textcolor{keywordflow}{if} (Case\_id==3)
        \{
         el\_pt->enable\_always\_evaluate\_dresidual\_dnodal\_coordinates\_by\_fd();
         \textcolor{keywordflow}{if} (!done) std::cout << \textcolor{stringliteral}{"\(\backslash\)n\(\backslash\)n [CR residuals] Fastest and FD"} 
                              << std::endl;
        \}
       \textcolor{keywordflow}{else}
        \{
         el\_pt->disable\_always\_evaluate\_dresidual\_dnodal\_coordinates\_by\_fd();
         \textcolor{keywordflow}{if} (!done) std::cout << \textcolor{stringliteral}{"\(\backslash\)n\(\backslash\)n [CR residuals] Fastest and analytic"} 
                              << std::endl;
         
        \}
      \}
     done=\textcolor{keyword}{true};
    \}
   
  \}
 \textcolor{comment}{}
\textcolor{comment}{ /// Node at which the solution of the Poisson equation is documented}
\textcolor{comment}{} Node* Doc\_node\_pt;
\textcolor{comment}{}
\textcolor{comment}{ /// Trace file}
\textcolor{comment}{} ofstream Trace\_file;
\textcolor{comment}{}
\textcolor{comment}{ /// Pointer to fish mesh}
\textcolor{comment}{} AlgebraicRefineableFishMesh<ELEMENT>* Fish\_mesh\_pt;
\textcolor{comment}{}
\textcolor{comment}{ /// Pointer to single-element mesh that stores the GeneralisedElement}
\textcolor{comment}{ /// that represents the fish back}
\textcolor{comment}{} Mesh* Fish\_back\_mesh\_pt;
\textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Pointer to data item that stores the "load" on the fish back}
\textcolor{comment}{} Data* Load\_pt;
\textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Is the position of the fish back prescribed?}
\textcolor{comment}{} \textcolor{keywordtype}{bool} Fix\_position;
\textcolor{comment}{}
\textcolor{comment}{ /// Doc info object}
\textcolor{comment}{} DocInfo Doc\_info;
\textcolor{comment}{}
\textcolor{comment}{ /// Case id}
\textcolor{comment}{} \textcolor{keywordtype}{unsigned} Case\_id;

\};





\textcolor{comment}{//========================================================================}\textcolor{comment}{}
\textcolor{comment}{/// Constructor for adaptive Poisson problem in deformable fish-shaped}
\textcolor{comment}{/// domain. Pass flag if position of fish back is fixed, and the output}
\textcolor{comment}{/// directory. }
\textcolor{comment}{}\textcolor{comment}{//========================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT>
\hyperlink{classRefineableFishPoissonProblem_a2585d906fab348e09bfb9b4c111ac161}{RefineableFishPoissonProblem<ELEMENT>::RefineableFishPoissonProblem}
      (
 \textcolor{keyword}{const} \textcolor{keywordtype}{bool}& fix\_position, \textcolor{keyword}{const} \textcolor{keywordtype}{string}& directory\_name,
 \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned}& i\_case) : Fix\_position(fix\_position), Case\_id(i\_case)
\{ 


 \textcolor{comment}{// Set output directory}
 Doc\_info.set\_directory(directory\_name); 
 
 \textcolor{comment}{// Initialise step number}
 Doc\_info.number()=0;
 
 \textcolor{comment}{// Open trace file}
 \textcolor{keywordtype}{char} filename[100];
 sprintf(filename,\textcolor{stringliteral}{"%s/trace.dat"},directory\_name.c\_str());
 Trace\_file.open(filename);

 Trace\_file 
  << \textcolor{stringliteral}{"VARIABLES=\(\backslash\)"load\(\backslash\)",\(\backslash\)"y<sub>circle</sub>\(\backslash\)",\(\backslash\)"u<sub>control</sub>\(\backslash\)""}
  << std::endl;

 \textcolor{comment}{// Set coordinates and radius for the circle that will become the fish back}
 \textcolor{keywordtype}{double} x\_c=0.5;
 \textcolor{keywordtype}{double} y\_c=0.0;
 \textcolor{keywordtype}{double} r\_back=1.0;

 \textcolor{comment}{// Build geometric element that will become the fish back}
 GeomObject* fish\_back\_pt=\textcolor{keyword}{new} \hyperlink{classoomph_1_1ElasticallySupportedRingElement}{ElasticallySupportedRingElement}(x\_c,y\_c,r\_back
      );

 \textcolor{comment}{// Build fish mesh with geometric object that specifies the fish back }
 Fish\_mesh\_pt=\textcolor{keyword}{new} AlgebraicRefineableFishMesh<ELEMENT>(fish\_back\_pt);

 \textcolor{comment}{// Add the fish mesh to the problem's collection of submeshes:}
 add\_sub\_mesh(Fish\_mesh\_pt);

 \textcolor{comment}{// Build mesh that will store only the geometric wall element}
 Fish\_back\_mesh\_pt=\textcolor{keyword}{new} Mesh;

 \textcolor{comment}{// So far, the mesh is completely empty. Let's add the }
 \textcolor{comment}{// one (and only!) GeneralisedElement which represents the shape}
 \textcolor{comment}{// of the fish's back to it:}
 Fish\_back\_mesh\_pt->add\_element\_pt(dynamic\_cast<GeneralisedElement*>(
                                    Fish\_mesh\_pt->fish\_back\_pt()));

 \textcolor{comment}{// Add the fish back mesh to the problem's collection of submeshes:}
 add\_sub\_mesh(Fish\_back\_mesh\_pt);

 \textcolor{comment}{// Now build global mesh from the submeshes}
 build\_global\_mesh();

 
 \textcolor{comment}{// Create/set error estimator}
 fish\_mesh\_pt()->spatial\_error\_estimator\_pt()=\textcolor{keyword}{new} Z2ErrorEstimator;
  
 \textcolor{comment}{// Choose a node at which the solution is documented: Choose}
 \textcolor{comment}{// the central node that is shared by all four elements in}
 \textcolor{comment}{// the base mesh because it exists at all refinement levels.}
 
 \textcolor{comment}{// How many nodes does element 0 have?}
 \textcolor{keywordtype}{unsigned} nnod=fish\_mesh\_pt()->finite\_element\_pt(0)->nnode();

 \textcolor{comment}{// The central node is the last node in element 0:}
 Doc\_node\_pt=fish\_mesh\_pt()->finite\_element\_pt(0)->node\_pt(nnod-1);

 \textcolor{comment}{// Doc}
 cout << std::endl <<  \textcolor{stringliteral}{"Control node is located at: "} 
      << Doc\_node\_pt->x(0) << \textcolor{stringliteral}{" "} << Doc\_node\_pt->x(1) 
      << std::endl << std::endl;

 \textcolor{comment}{// Position of fish back is prescribed}
 \textcolor{keywordflow}{if} (Fix\_position)
  \{
   \textcolor{comment}{// Create the load data object}
   Load\_pt=\textcolor{keyword}{new} Data(1);
   
   \textcolor{comment}{// Pin the prescribed load}
   Load\_pt->pin(0);

   \textcolor{comment}{// Pin the vertical displacement}
   \textcolor{keyword}{dynamic\_cast<}\hyperlink{classoomph_1_1ElasticallySupportedRingElement}{ElasticallySupportedRingElement}*\textcolor{keyword}{>}(
    Fish\_mesh\_pt->fish\_back\_pt())->pin\_yc();
  \}
 \textcolor{comment}{// Coupled problem: The position of the fish back is determined}
 \textcolor{comment}{// via the solution of the Poisson equation: The solution at}
 \textcolor{comment}{// the control node acts as the load for the displacement of the}
 \textcolor{comment}{// fish back}
 \textcolor{keywordflow}{else}
  \{   
   \textcolor{comment}{// Use the solution (value 0) at the control node as the load}
   \textcolor{comment}{// that acts on the ring. [Note: Node == Data by inheritance]}
   Load\_pt=Doc\_node\_pt;
  \}


 \textcolor{comment}{// Set the pointer to the Data object that specifies the }
 \textcolor{comment}{// load on the fish's back}
 \textcolor{keyword}{dynamic\_cast<}\hyperlink{classoomph_1_1ElasticallySupportedRingElement}{ElasticallySupportedRingElement}*\textcolor{keyword}{>}(Fish\_mesh\_pt->fish\_back\_pt()
      )->
  set\_load\_pt(Load\_pt);
 

 \textcolor{comment}{// Set the boundary conditions for this problem: All nodes are}
 \textcolor{comment}{// free by default -- just pin the ones that have Dirichlet conditions}
 \textcolor{comment}{// here. }
 \textcolor{keywordtype}{unsigned} num\_bound = fish\_mesh\_pt()->nboundary();
 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} ibound=0;ibound<num\_bound;ibound++)
  \{
   \textcolor{keywordtype}{unsigned} num\_nod= fish\_mesh\_pt()->nboundary\_node(ibound);
   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} inod=0;inod<num\_nod;inod++)
    \{
     fish\_mesh\_pt()->boundary\_node\_pt(ibound,inod)->pin(0); 
    \}
  \}


 \textcolor{comment}{// Set homogeneous boundary conditions on all boundaries }
 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} ibound=0;ibound<num\_bound;ibound++)
  \{
   \textcolor{comment}{// Loop over the nodes on boundary}
   \textcolor{keywordtype}{unsigned} num\_nod=fish\_mesh\_pt()->nboundary\_node(ibound);
   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} inod=0;inod<num\_nod;inod++)
    \{
     fish\_mesh\_pt()->boundary\_node\_pt(ibound,inod)->set\_value(0,0.0);
    \}
  \}
 \textcolor{comment}{}
\textcolor{comment}{ /// Loop over elements and set pointers to source function}
\textcolor{comment}{} \textcolor{keywordtype}{unsigned} n\_element = fish\_mesh\_pt()->nelement();
 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} i=0;i<n\_element;i++)
  \{
   \textcolor{comment}{// Upcast from FiniteElement to the present element}
   ELEMENT *el\_pt = \textcolor{keyword}{dynamic\_cast<}ELEMENT*\textcolor{keyword}{>}(fish\_mesh\_pt()->element\_pt(i));
   
   \textcolor{comment}{//Set the source function pointer}
   el\_pt->source\_fct\_pt() = &\hyperlink{namespaceConstSourceForPoisson_a40ef79083874b58ed42b4df2ca0f4c10}{ConstSourceForPoisson::get\_source};
  \}

 \textcolor{comment}{// Set shape derivative method}
 set\_shape\_deriv\_method();

 \textcolor{comment}{// Do equation numbering}
 cout <<\textcolor{stringliteral}{"Number of equations: "} << assign\_eqn\_numbers() << std::endl; 

\}



\textcolor{comment}{//========================================================================}\textcolor{comment}{}
\textcolor{comment}{/// Destructor for Poisson problem in deformable fish-shaped domain.}
\textcolor{comment}{}\textcolor{comment}{//========================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT>
\hyperlink{classRefineableFishPoissonProblem_a7039a3409520850908940927b91af9ab}{RefineableFishPoissonProblem<ELEMENT>::~RefineableFishPoissonProblem}
      ()
\{ 
 \textcolor{comment}{// Close trace file}
 Trace\_file.close();

\}




\textcolor{comment}{//========================================================================}\textcolor{comment}{}
\textcolor{comment}{/// Doc the solution in tecplot format.}
\textcolor{comment}{}\textcolor{comment}{//========================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT>
\textcolor{keywordtype}{void} \hyperlink{classRefineableFishPoissonProblem_a6db25ff0bd3014aa531d9f0e8b385beb}{RefineableFishPoissonProblem<ELEMENT>::doc\_solution}
      ()
\{ 

 ofstream some\_file;
 \textcolor{keywordtype}{char} filename[100];

 \textcolor{comment}{// Number of plot points in each coordinate direction.}
 \textcolor{keywordtype}{unsigned} npts;
 npts=5; 


 \textcolor{comment}{// Output solution }
 \textcolor{keywordflow}{if} (Case\_id!=0)
  \{
   sprintf(filename,\textcolor{stringliteral}{"%s/soln\_%i\_%i.dat"},Doc\_info.directory().c\_str(),
           Case\_id,Doc\_info.number());
  \}
 \textcolor{keywordflow}{else}
  \{
   sprintf(filename,\textcolor{stringliteral}{"%s/soln%i.dat"},Doc\_info.directory().c\_str(),
           Doc\_info.number());
  \}
 some\_file.open(filename);
 fish\_mesh\_pt()->output(some\_file,npts);
 some\_file.close();

 \textcolor{comment}{// Write "load", vertical position of the fish back, and solution at }
 \textcolor{comment}{// control node to trace file}
 Trace\_file 
  << \textcolor{keyword}{static\_cast<}\hyperlink{classoomph_1_1ElasticallySupportedRingElement}{ElasticallySupportedRingElement}*\textcolor{keyword}{>}(fish\_mesh\_pt()->
                                          fish\_back\_pt())->load()
  << \textcolor{stringliteral}{" "}
  << \textcolor{keyword}{static\_cast<}\hyperlink{classoomph_1_1ElasticallySupportedRingElement}{ElasticallySupportedRingElement}*\textcolor{keyword}{>}(fish\_mesh\_pt()->
                                          fish\_back\_pt())->y\_c()
  << \textcolor{stringliteral}{" "} << Doc\_node\_pt->value(0) << std::endl;
\}

 




\textcolor{comment}{}
\textcolor{comment}{////////////////////////////////////////////////////////////////////////}
\textcolor{comment}{////////////////////////////////////////////////////////////////////////}
\textcolor{comment}{////////////////////////////////////////////////////////////////////////}
\textcolor{comment}{}




\textcolor{comment}{//========================================================================}\textcolor{comment}{}
\textcolor{comment}{/// Demonstrate how to solve 2D Poisson problem in deformable}
\textcolor{comment}{/// fish-shaped domain with mesh adaptation.}
\textcolor{comment}{}\textcolor{comment}{//========================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT>
\textcolor{keywordtype}{void} \hyperlink{algebraic__free__boundary__poisson_8cc_abb923e967929c29b3a4fa1693604952a}{demo\_fish\_poisson}(\textcolor{keyword}{const} \textcolor{keywordtype}{string}& directory\_name)
\{

 \textcolor{comment}{// Set up the problem with prescribed displacement of fish back}
 \textcolor{keywordtype}{bool} fix\_position=\textcolor{keyword}{true};
 \hyperlink{classRefineableFishPoissonProblem}{RefineableFishPoissonProblem<ELEMENT>} problem(fix\_position,
      directory\_name,0);

 \textcolor{comment}{// Doc refinement targets}
 problem.fish\_mesh\_pt()->doc\_adaptivity\_targets(cout);
  
 \textcolor{comment}{// Do some uniform mesh refinement first}
 \textcolor{comment}{//--------------------------------------}
 problem.refine\_uniformly();
 problem.refine\_uniformly(); 

 \textcolor{comment}{// Initial value for the vertical displacement of the fish's back}
 problem.y\_c()=-0.3;

 \textcolor{comment}{// Loop for different fish shapes}
 \textcolor{comment}{//-------------------------------}

 \textcolor{comment}{// Number of steps}
 \textcolor{keywordtype}{unsigned} nstep=5;

 \textcolor{comment}{// Increment in displacement}
 \textcolor{keywordtype}{double} dyc=0.6/double(nstep-1);

 \textcolor{comment}{// Valiation: Just do one step}
 \textcolor{keywordflow}{if} (CommandLineArgs::Argc>1) nstep=1;
 
 \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} istep=0;istep<nstep;istep++)
  \{    
   \textcolor{comment}{// Solve/doc}
   \textcolor{keywordtype}{unsigned} max\_solve=2; 
   problem.newton\_solve(max\_solve);
   problem.doc\_solution();
   
   \textcolor{comment}{//Increment counter for solutions }
   problem.doc\_info().number()++;    
   
   \textcolor{comment}{// Change vertical displacement}
   problem.y\_c()+=dyc;
  \} 
\}


\textcolor{comment}{//========================================================================}\textcolor{comment}{}
\textcolor{comment}{/// Demonstrate how to solve "elastic" 2D Poisson problem in deformable}
\textcolor{comment}{/// fish-shaped domain with mesh adaptation.}
\textcolor{comment}{}\textcolor{comment}{//========================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT>
\textcolor{keywordtype}{void} \hyperlink{algebraic__free__boundary__poisson_8cc_a28565f965d7ffb7f92f3773a6333023b}{demo\_elastic\_fish\_poisson}(\textcolor{keyword}{const} \textcolor{keywordtype}{string}& directory\_name)
\{

 \textcolor{comment}{// Loop over all cases}
 \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} i\_case=0;i\_case<5;i\_case++)
  \textcolor{comment}{//unsigned i\_case=1;}
  \{
   std::cout << \textcolor{stringliteral}{"[CR residuals] "} << std::endl;
   std::cout << \textcolor{stringliteral}{"[CR residuals]=================================================="} 
             << std::endl;
   std::cout << \textcolor{stringliteral}{"[CR residuals] "} << std::endl;
   \textcolor{comment}{//Set up the problem with "elastic" fish back}
   \textcolor{keywordtype}{bool} fix\_position=\textcolor{keyword}{false};
   \hyperlink{classRefineableFishPoissonProblem}{RefineableFishPoissonProblem<ELEMENT>} problem(fix\_position,
                                                 directory\_name,
                                                 i\_case);
   
   \textcolor{comment}{// Doc refinement targets}
   problem.fish\_mesh\_pt()->doc\_adaptivity\_targets(cout);
   
   \textcolor{comment}{// Do some uniform mesh refinement first}
   \textcolor{comment}{//--------------------------------------}
   problem.refine\_uniformly();
   problem.refine\_uniformly();
   
   
   \textcolor{comment}{// Initial value for load on fish back}
   problem.load()=0.0;
   
   \textcolor{comment}{// Solve/doc}
   \textcolor{keywordtype}{unsigned} max\_solve=2; 
   problem.newton\_solve(max\_solve);
   problem.doc\_solution();
  \}


\}





\textcolor{comment}{//========================================================================}\textcolor{comment}{}
\textcolor{comment}{/// Driver for "elastic" fish poisson solver with adaptation.}
\textcolor{comment}{/// If there are any command line arguments, we regard this as a }
\textcolor{comment}{/// validation run and perform only a single step.}
\textcolor{comment}{}\textcolor{comment}{//========================================================================}
\textcolor{keywordtype}{int} \hyperlink{algebraic__free__boundary__poisson_8cc_a0ddf1224851353fc92bfbff6f499fa97}{main}(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char}* argv[]) 
\{
 \textcolor{comment}{// Store command line arguments}
 CommandLineArgs::setup(argc,argv);

 \textcolor{comment}{// Shorthand for element type}
  \textcolor{keyword}{typedef} AlgebraicElement<RefineableQPoissonElement<2,3> > ELEMENT;

  \textcolor{comment}{// Compute solution of Poisson equation in various domains}
  demo\_fish\_poisson<ELEMENT>(\textcolor{stringliteral}{"RESLT"});

  \textcolor{comment}{// Compute "elastic" coupled solution directly}
  demo\_elastic\_fish\_poisson<ELEMENT>(\textcolor{stringliteral}{"RESLT\_coupled"}); 

\}


\end{DoxyCodeInclude}




 

 \hypertarget{index_pdf}{}\section{P\+D\+F file}\label{index_pdf}
A \href{../latex/refman.pdf}{\tt pdf version} of this document is available. \end{document}
