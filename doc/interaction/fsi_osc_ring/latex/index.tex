Our first \char`\"{}real\char`\"{} fluid-\/structure interaction problem\+: We study the finite-\/\+Reynolds number internal flow generated by the motion of an oscillating elastic ring and compare the results against asymptotic predictions.


\begin{DoxyCodeInclude}
\textcolor{comment}{//LIC// ====================================================================}
\textcolor{comment}{//LIC// This file forms part of oomph-lib, the object-oriented, }
\textcolor{comment}{//LIC// multi-physics finite-element library, available }
\textcolor{comment}{//LIC// at http://www.oomph-lib.org.}
\textcolor{comment}{//LIC// }
\textcolor{comment}{//LIC//    Version 1.0; svn revision $LastChangedRevision$}
\textcolor{comment}{//LIC//}
\textcolor{comment}{//LIC// $LastChangedDate$}
\textcolor{comment}{//LIC// }
\textcolor{comment}{//LIC// Copyright (C) 2006-2016 Matthias Heil and Andrew Hazel}
\textcolor{comment}{//LIC// }
\textcolor{comment}{//LIC// This library is free software; you can redistribute it and/or}
\textcolor{comment}{//LIC// modify it under the terms of the GNU Lesser General Public}
\textcolor{comment}{//LIC// License as published by the Free Software Foundation; either}
\textcolor{comment}{//LIC// version 2.1 of the License, or (at your option) any later version.}
\textcolor{comment}{//LIC// }
\textcolor{comment}{//LIC// This library is distributed in the hope that it will be useful,}
\textcolor{comment}{//LIC// but WITHOUT ANY WARRANTY; without even the implied warranty of}
\textcolor{comment}{//LIC// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU}
\textcolor{comment}{//LIC// Lesser General Public License for more details.}
\textcolor{comment}{//LIC// }
\textcolor{comment}{//LIC// You should have received a copy of the GNU Lesser General Public}
\textcolor{comment}{//LIC// License along with this library; if not, write to the Free Software}
\textcolor{comment}{//LIC// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA}
\textcolor{comment}{//LIC// 02110-1301  USA.}
\textcolor{comment}{//LIC// }
\textcolor{comment}{//LIC// The authors may be contacted at oomph-lib@maths.man.ac.uk.}
\textcolor{comment}{//LIC// }
\textcolor{comment}{//LIC//====================================================================}
\textcolor{comment}{// Driver for 2D Navier Stokes flow interacting with an elastic ring}

\textcolor{comment}{// Oomph-lib include files}
\textcolor{preprocessor}{#include "generic.h"}
\textcolor{preprocessor}{#include "navier\_stokes.h"}
\textcolor{preprocessor}{#include "beam.h"}

\textcolor{comment}{//Need to include templated meshes, so that all functions}
\textcolor{comment}{//are instantiated for our particular element types.}
\textcolor{preprocessor}{#include "meshes/quarter\_circle\_sector\_mesh.h"}
\textcolor{preprocessor}{#include "meshes/one\_d\_lagrangian\_mesh.h"}

\textcolor{keyword}{using namespace }\hyperlink{namespacestd}{std};

\textcolor{keyword}{using namespace }\hyperlink{namespaceoomph}{oomph};

\textcolor{comment}{//===========================================================================}\textcolor{comment}{}
\textcolor{comment}{/// Namespace for physical parameters}
\textcolor{comment}{}\textcolor{comment}{//===========================================================================}
\textcolor{keyword}{namespace }\hyperlink{namespaceGlobal__Physical__Variables}{Global\_Physical\_Variables}
\{

 \textcolor{comment}{// Independent parameters:}
 \textcolor{comment}{//------------------------}
\textcolor{comment}{}
\textcolor{comment}{ /// Square of Womersly number (a frequency parameter)}
\textcolor{comment}{} \textcolor{keywordtype}{double} Alpha\_sq=50.0;
\textcolor{comment}{}
\textcolor{comment}{ /// Density ratio of the solid and the fluid}
\textcolor{comment}{} \textcolor{keywordtype}{double} Density\_ratio=1.0; 
\textcolor{comment}{}
\textcolor{comment}{ /// External Pressure}
\textcolor{comment}{} \textcolor{keywordtype}{double} Pext=0.0;
\textcolor{comment}{}
\textcolor{comment}{ /// Poisson ratio}
\textcolor{comment}{} \textcolor{keywordtype}{double} Nu=0.49;
\textcolor{comment}{}
\textcolor{comment}{ /// Nondimensional thickness of the beam }
\textcolor{comment}{} \textcolor{keywordtype}{double} H=0.05;
\textcolor{comment}{}
\textcolor{comment}{ /// Perturbation pressure}
\textcolor{comment}{} \textcolor{keywordtype}{double} Pcos=0.0;


 \textcolor{comment}{// Dependent parameters:}
 \textcolor{comment}{//----------------------}
\textcolor{comment}{}
\textcolor{comment}{ /// Reynolds number}
\textcolor{comment}{} \textcolor{keywordtype}{double} \hyperlink{namespaceGlobal__Physical__Variables_ab814e627d2eb5bc50318879d19ab16b9}{Re};
\textcolor{comment}{}
\textcolor{comment}{ /// Reynolds x Strouhal number}
\textcolor{comment}{} \textcolor{keywordtype}{double} \hyperlink{namespaceGlobal__Physical__Variables_a085ee4bf968ffdd01a41b8c41864f907}{ReSt};
 \textcolor{comment}{}
\textcolor{comment}{ /// Timescale ratio (non-dimensation density)}
\textcolor{comment}{} \textcolor{keywordtype}{double} \hyperlink{namespaceGlobal__Physical__Variables_a6fe17557ceb32dd353827fba60408363}{Lambda\_sq};
\textcolor{comment}{}
\textcolor{comment}{ /// Stress ratio}
\textcolor{comment}{} \textcolor{keywordtype}{double} \hyperlink{namespaceGlobal__Physical__Variables_a66cb7ecda9ba0cd72367dd697f154545}{Q};
\textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Set the parameters that are used in the code as a function}
\textcolor{comment}{ /// of the Womersley number, the density ratio and H}
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{namespaceGlobal__Physical__Variables_a5928252d8e7440b329065c223926d4d2}{set\_params}()
 \{
  cout << \textcolor{stringliteral}{"\(\backslash\)n\(\backslash\)n======================================================"} <<std::endl;
  cout << \textcolor{stringliteral}{"\(\backslash\)nSetting parameters. \(\backslash\)n\(\backslash\)n"};
  cout << \textcolor{stringliteral}{"Prescribed: Square of Womersley number: Alpha\_sq = "} 
       << Alpha\_sq << std::endl;  
  cout << \textcolor{stringliteral}{"            Density ratio:         Density\_ratio = "} 
       << Density\_ratio << std::endl;
  cout << \textcolor{stringliteral}{"            Wall thickness:                    H = "} 
       << H << std::endl;
  cout << \textcolor{stringliteral}{"            Poisson ratio:                    Nu = "} 
       << Nu << std::endl;
  cout << \textcolor{stringliteral}{"            Pressure perturbation:          Pcos = "} 
       << Pcos << std::endl;


  Q=1.0/12.0*pow(H,3)/\hyperlink{namespaceGlobal__Physical__Variables_a056817f9a80034eff75fcf94c44b08cd}{Alpha\_sq};
  cout << \textcolor{stringliteral}{"\(\backslash\)nDependent:  Stress ratio:                      Q = "} 
       << Q << std::endl;

  Lambda\_sq=1.0/12.0*pow(H,3)*\hyperlink{namespaceGlobal__Physical__Variables_af5163137c5b98c6ebb942973cba4e297}{Density\_ratio};
  cout << \textcolor{stringliteral}{"            Timescale ratio:           Lambda\_sq = "} 
       << Lambda\_sq << std::endl;

  Re=\hyperlink{namespaceGlobal__Physical__Variables_a056817f9a80034eff75fcf94c44b08cd}{Alpha\_sq};
  cout << \textcolor{stringliteral}{"            Reynolds number:                  Re = "} 
       << Re << std::endl;

  ReSt=\hyperlink{namespaceGlobal__Physical__Variables_ab814e627d2eb5bc50318879d19ab16b9}{Re};
  cout << \textcolor{stringliteral}{"           Womersley number:                ReSt = "} 
       << ReSt << std::endl;
  cout << \textcolor{stringliteral}{"\(\backslash\)n======================================================\(\backslash\)n\(\backslash\)n"} 
       <<std::endl;

 \}
\textcolor{comment}{}
\textcolor{comment}{ /// Non-FSI load function, a constant external pressure plus}
\textcolor{comment}{ /// a (small) sinusoidal perturbation of wavenumber two.}
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{namespaceGlobal__Physical__Variables_aa08c246eac99f59be33ef4a6ee924990}{pcos\_load}(\textcolor{keyword}{const} Vector<double>& xi, \textcolor{keyword}{const} Vector<double> &x,
                \textcolor{keyword}{const} Vector<double>& N, Vector<double>& load)
 \{
  \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} i=0;i<2;i++) 
   \{load[i] = (Pext - Pcos*cos(2.0*xi[0]))*N[i];\}
 \}

\}


\textcolor{comment}{//======================================================================}\textcolor{comment}{}
\textcolor{comment}{/// FSI Ring problem: a fluid-structure interaction problem in which}
\textcolor{comment}{/// a viscous fluid bounded by an initially circular beam is set into motion}
\textcolor{comment}{/// by a small sinusoidal perturbation of the beam (the domain boundary).}
\textcolor{comment}{}\textcolor{comment}{//======================================================================}
\textcolor{keyword}{class }\hyperlink{classFSIRingProblem}{FSIRingProblem} : \textcolor{keyword}{public} Problem
\{\textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short There are very few element types that will work for this problem.}
\textcolor{comment}{ /// Rather than passing the element type as a template parameter to the}
\textcolor{comment}{ /// problem, we choose instead to use a typedef to specify the}
\textcolor{comment}{ /// particular element fluid used.}
\textcolor{comment}{} \textcolor{keyword}{typedef} AlgebraicElement<RefineableQCrouzeixRaviartElement<2> > FLUID\_ELEMENT;
\textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Typedef to specify the solid element used}
\textcolor{comment}{} \textcolor{keyword}{typedef} FSIHermiteBeamElement SOLID\_ELEMENT;

\textcolor{keyword}{public}:
\textcolor{comment}{}
\textcolor{comment}{ /// Constructor: Number of elements in wall mesh, amplitude of the}
\textcolor{comment}{ /// initial wall deformation, amplitude of pcos perturbation and its duration.}
\textcolor{comment}{} \hyperlink{classFSIRingProblem}{FSIRingProblem}(\textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} &nelement\_wall,
                \textcolor{keyword}{const} \textcolor{keywordtype}{double}& eps\_ampl, \textcolor{keyword}{const} \textcolor{keywordtype}{double}& pcos\_initial,
                \textcolor{keyword}{const} \textcolor{keywordtype}{double}& pcos\_duration);
\textcolor{comment}{}
\textcolor{comment}{ /// Update after solve (empty)}
\textcolor{comment}{} \textcolor{keywordtype}{void} actions\_after\_newton\_solve() \{\}
\textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Update before solve (empty)}
\textcolor{comment}{} \textcolor{keywordtype}{void} actions\_before\_newton\_solve() \{\}
\textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Update the problem specs before checking Newton}
\textcolor{comment}{ /// convergence}
\textcolor{comment}{} \textcolor{keywordtype}{void} actions\_before\_newton\_convergence\_check() 
 \{
  \textcolor{comment}{// Update the fluid mesh -- auxiliary update function for algebraic}
  \textcolor{comment}{// nodes automatically updates no slip condition.}
  Fluid\_mesh\_pt->node\_update(); 
 \}
\textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Update the problem specs after adaptation:}
\textcolor{comment}{} \textcolor{keywordtype}{void} actions\_after\_adapt() 
  \{
   \textcolor{comment}{// The functions used to update the no slip boundary conditions }
   \textcolor{comment}{// must be set on any new nodes that have been created during the }
   \textcolor{comment}{// mesh adaptation process. }
   \textcolor{comment}{// There is no mechanism by which auxiliary update functions }
   \textcolor{comment}{// are copied to newly created nodes.}
   \textcolor{comment}{// (because, unlike boundary conditions, they don't occur exclusively }
   \textcolor{comment}{//  at boundaries)}

   \textcolor{comment}{// The no-slip boundary is boundary 1 of the mesh}
   \textcolor{comment}{// Loop over the nodes on this boundary and reset the auxilliary}
   \textcolor{comment}{// node update function}
   \textcolor{keywordtype}{unsigned} n\_node = Fluid\_mesh\_pt->nboundary\_node(1);
   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} n=0;n<n\_node;n++)
    \{
     Fluid\_mesh\_pt->boundary\_node\_pt(1,n)->set\_auxiliary\_node\_update\_fct\_pt(
      FSI\_functions::apply\_no\_slip\_on\_moving\_wall); 
    \}

   \textcolor{comment}{// (Re-)setup fsi: Work out which fluid dofs affect wall elements}
   \textcolor{comment}{// the correspondance between wall dofs and fluid elements is handled}
   \textcolor{comment}{// during the remeshing, but the "reverse" association must be done}
   \textcolor{comment}{// separately.}
   \textcolor{comment}{// We need to set up the interaction every time because the fluid element}
   \textcolor{comment}{// adjacent to a given solid element's integration point may have changed}
   \textcolor{comment}{// We pass the boundary between the fluid and solid meshes and pointers}
   \textcolor{comment}{// to the meshes. The interaction boundary is boundary 1 of the 2D }
   \textcolor{comment}{// fluid mesh.}
   FSI\_functions::setup\_fluid\_load\_info\_for\_solid\_elements<FLUID\_ELEMENT,2>
    (\textcolor{keyword}{this},1,Fluid\_mesh\_pt,Wall\_mesh\_pt);
  \}
\textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Doc solution: Pass number of timestep, i (we append to tracefile}
\textcolor{comment}{ /// after every timestep but do a full doc only at certain intervals),}
\textcolor{comment}{ /// DocInfo object and tracefile}
\textcolor{comment}{} \textcolor{keywordtype}{void} doc\_solution(\textcolor{keyword}{const} \textcolor{keywordtype}{unsigned}& i, DocInfo& doc\_info, ofstream& trace\_file);
\textcolor{comment}{}
\textcolor{comment}{ /// Do dynamic run}
\textcolor{comment}{} \textcolor{keywordtype}{void} dynamic\_run();

\textcolor{keyword}{private}:
\textcolor{comment}{}
\textcolor{comment}{ /// Setup initial condition for both domains}
\textcolor{comment}{} \textcolor{keywordtype}{void} set\_initial\_condition();
\textcolor{comment}{}
\textcolor{comment}{ /// Setup initial condition for wall}
\textcolor{comment}{} \textcolor{keywordtype}{void} set\_wall\_initial\_condition();
\textcolor{comment}{}
\textcolor{comment}{ /// Setup initial condition for fluid}
\textcolor{comment}{} \textcolor{keywordtype}{void} set\_fluid\_initial\_condition();
\textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Element used for documenting displacement}
\textcolor{comment}{} SOLID\_ELEMENT* Doc\_displacement\_elem\_pt;
\textcolor{comment}{}
\textcolor{comment}{ /// Pointer to wall mesh}
\textcolor{comment}{} OneDLagrangianMesh<SOLID\_ELEMENT> *Wall\_mesh\_pt;
\textcolor{comment}{}
\textcolor{comment}{ /// Pointer to fluid mesh}
\textcolor{comment}{} AlgebraicRefineableQuarterCircleSectorMesh<FLUID\_ELEMENT> *Fluid\_mesh\_pt;
\textcolor{comment}{}
\textcolor{comment}{ /// Pointer to geometric object that represents the undeformed wall shape}
\textcolor{comment}{} GeomObject* Undef\_geom\_pt;
\textcolor{comment}{}
\textcolor{comment}{ /// Pointer to wall timestepper}
\textcolor{comment}{} Newmark<2>* Wall\_time\_stepper\_pt;
\textcolor{comment}{}
\textcolor{comment}{ /// Pointer to fluid timestepper}
\textcolor{comment}{} BDF<2>* Fluid\_time\_stepper\_pt;
\textcolor{comment}{}
\textcolor{comment}{ /// Pointer to node on coarsest mesh on which velocity is traced}
\textcolor{comment}{} Node* Veloc\_trace\_node\_pt;
\textcolor{comment}{}
\textcolor{comment}{ /// Amplitude of initial deformation}
\textcolor{comment}{} \textcolor{keywordtype}{double} Eps\_ampl;
\textcolor{comment}{}
\textcolor{comment}{ /// Initial pcos }
\textcolor{comment}{} \textcolor{keywordtype}{double} Pcos\_initial;
\textcolor{comment}{}
\textcolor{comment}{ /// Duration of initial pcos}
\textcolor{comment}{} \textcolor{keywordtype}{double} Pcos\_duration;

\};


\textcolor{comment}{//===============================================================}\textcolor{comment}{}
\textcolor{comment}{/// Setup initial condition: When we're done here, all variables}
\textcolor{comment}{/// represent the state at the initial time.}
\textcolor{comment}{}\textcolor{comment}{//===============================================================}
\textcolor{keywordtype}{void} \hyperlink{classFSIRingProblem_a309ea4c79fbae58020d94bf2c2318169}{FSIRingProblem::set\_initial\_condition}()
\{ 

 cout << \textcolor{stringliteral}{"Setting wall ic"} << std::endl;
 set\_wall\_initial\_condition();

 cout << \textcolor{stringliteral}{"Setting fluid ic"} << std::endl;
 set\_fluid\_initial\_condition();

\}


\textcolor{comment}{//===============================================================}\textcolor{comment}{}
\textcolor{comment}{/// Setup initial condition for fluid: Impulsive start}
\textcolor{comment}{}\textcolor{comment}{//===============================================================}
\textcolor{keywordtype}{void} \hyperlink{classFSIRingProblem_ad397e4e3b92845240dd6a996856f33e7}{FSIRingProblem::set\_fluid\_initial\_condition}()
\{

 \textcolor{comment}{// Update fluid domain: Careful!!! This also applies the no slip conditions}
 \textcolor{comment}{// on all nodes on the wall! Since the wall might have moved since}
 \textcolor{comment}{// we created the mesh; we're therefore imposing a nonzero}
 \textcolor{comment}{// velocity on these nodes. Must wipe this afterwards (done}
 \textcolor{comment}{// by setting *all* velocities to zero) otherwise we get}
 \textcolor{comment}{// an impulsive start from a very bizarre initial velocity}
 \textcolor{comment}{// field! [Yes, it took me a while to figure this out...]}
 Fluid\_mesh\_pt->node\_update();

 \textcolor{comment}{// Assign initial values for the velocities; }
 \textcolor{comment}{// pressures don't carry a time history and can be left alone.}

 \textcolor{comment}{//Find number of nodes in fluid mesh}
 \textcolor{keywordtype}{unsigned} n\_node = Fluid\_mesh\_pt->nnode();

 \textcolor{comment}{// Loop over the nodes to set initial guess everywhere}
 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} n=0;n<n\_node;n++)
  \{
   \textcolor{comment}{// Loop over velocity directions: Impulsive initial start from}
   \textcolor{comment}{// zero velocity!}
   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} i=0;i<2;i++)
    \{
     Fluid\_mesh\_pt->node\_pt(n)->set\_value(i,0.0);
    \}
  \}

 \textcolor{comment}{// Do an impulsive start with the assigned velocity field }
 Fluid\_mesh\_pt->assign\_initial\_values\_impulsive();

\}


\textcolor{comment}{//===============================================================}\textcolor{comment}{}
\textcolor{comment}{/// Setup initial condition: Impulsive start either from}
\textcolor{comment}{/// deformed or undeformed wall shape.}
\textcolor{comment}{}\textcolor{comment}{//===============================================================}
\textcolor{keywordtype}{void} \hyperlink{classFSIRingProblem_a5f987c1b22dc306cf7d26be7fa74e322}{FSIRingProblem::set\_wall\_initial\_condition}()
\{ 

 \textcolor{comment}{// Geometric object that specifies the initial conditions:}
 \textcolor{comment}{// A ring that is bucked in a 2-lobed mode}
 GeomObject* ic\_geom\_object\_pt=
  \textcolor{keyword}{new} PseudoBucklingRing(Eps\_ampl,\hyperlink{namespaceGlobal__Physical__Variables_af6e07423e22c0991084d9a2f43727805}{Global\_Physical\_Variables::H},2,2,
                         Wall\_time\_stepper\_pt); 
 
 \textcolor{comment}{// Assign period of oscillation of the geometric object}
 \textcolor{keyword}{static\_cast<}PseudoBucklingRing*\textcolor{keyword}{>}(ic\_geom\_object\_pt)->set\_T(1.0);
 
 \textcolor{comment}{//Set initial time (to deform wall into max. amplitude)}
 \textcolor{keywordtype}{double} time=0.25;
 
 \textcolor{comment}{// Assign initial radius of the object}
 \textcolor{keyword}{static\_cast<}PseudoBucklingRing*\textcolor{keyword}{>}(ic\_geom\_object\_pt)->set\_R\_0(1.00); 
 
 \textcolor{comment}{// Setup object that specifies the initial conditions:}
 SolidInitialCondition* IC\_pt = \textcolor{keyword}{new} SolidInitialCondition(ic\_geom\_object\_pt);
 
 \textcolor{comment}{// Assign values of positional data of all elements on wall mesh}
 \textcolor{comment}{// so that the wall deforms into the shape specified by IC object.}
 SolidMesh::Solid\_IC\_problem.set\_static\_initial\_condition(
  \textcolor{keyword}{this},Wall\_mesh\_pt,IC\_pt,time);
 
\}


\textcolor{comment}{//========================================================================}\textcolor{comment}{}
\textcolor{comment}{/// Document solution: Pass number of timestep, i; we append to trace file}
\textcolor{comment}{/// at every timestep and do a full doc only after a certain number}
\textcolor{comment}{/// of steps.}
\textcolor{comment}{}\textcolor{comment}{//========================================================================}
\textcolor{keywordtype}{void} \hyperlink{classFSIRingProblem_a686782b9af582b68e55c288e1fe4660e}{FSIRingProblem::doc\_solution}(\textcolor{keyword}{const} \textcolor{keywordtype}{unsigned}& i,
  DocInfo& doc\_info, ofstream& trace\_file)
\{ 

  \textcolor{comment}{// Full doc every nskip steps}
  \textcolor{keywordtype}{unsigned} nskip=1; \textcolor{comment}{// ADJUST}
  
  \textcolor{comment}{// If we at an integer multiple of nskip, full documentation.}
  \textcolor{keywordflow}{if} (i%nskip==0)
   \{
    doc\_info.enable\_doc();
    cout << \textcolor{stringliteral}{"Full doc step "} <<  doc\_info.number()
         << \textcolor{stringliteral}{" for time "} << time\_stepper\_pt()->time\_pt()->time() << std::endl;
   \}
  \textcolor{comment}{//Otherwise, just output the trace file}
  \textcolor{keywordflow}{else}
   \{
    doc\_info.disable\_doc();
    cout << \textcolor{stringliteral}{"Only trace for time "} 
         << time\_stepper\_pt()->time\_pt()->time() << std::endl;
   \}
  
    
  \textcolor{comment}{// If we are at a full documentation step, output the fluid solution}
  \textcolor{keywordflow}{if} (doc\_info.is\_doc\_enabled())
   \{
    \textcolor{comment}{//Variables used in the output file.}
    ofstream some\_file; \textcolor{keywordtype}{char} filename[100];
    \textcolor{comment}{//Construct the output filename from the doc\_info number and the}
    \textcolor{comment}{//output directory}
    sprintf(filename,\textcolor{stringliteral}{"%s/soln%i.dat"},doc\_info.directory().c\_str(),
            doc\_info.number());
    \textcolor{comment}{//Open the output file}
    some\_file.open(filename);\textcolor{comment}{}
\textcolor{comment}{    ///Output the solution using 5x5 plot points }
\textcolor{comment}{}    Fluid\_mesh\_pt->output(some\_file,5);
    \textcolor{comment}{//Close the output file}
    some\_file.close();
   \} 
 
  \textcolor{comment}{//Temporary vector to give the local coordinate at which to document}
  \textcolor{comment}{//the wall displacment}
  Vector<double> s(1,1.0);
  \textcolor{comment}{// Write to the trace file: }
  trace\_file << time\_pt()->time()  
   \textcolor{comment}{//Document the displacement at the end of the the chosen element}
             << \textcolor{stringliteral}{" "} << Doc\_displacement\_elem\_pt->interpolated\_x(s,1) 
             << \textcolor{stringliteral}{" "} << Veloc\_trace\_node\_pt->x(0)  
             << \textcolor{stringliteral}{" "} << Veloc\_trace\_node\_pt->x(1)  
             << \textcolor{stringliteral}{" "} << Veloc\_trace\_node\_pt->value(0)  
             << \textcolor{stringliteral}{" "} << Veloc\_trace\_node\_pt->value(1)  
             << \textcolor{stringliteral}{" "} << Fluid\_mesh\_pt->nelement() 
             << \textcolor{stringliteral}{" "} << ndof() 
             << \textcolor{stringliteral}{" "} << Fluid\_mesh\_pt->nrefinement\_overruled() 
             << \textcolor{stringliteral}{" "} << Fluid\_mesh\_pt->max\_error()  
             << \textcolor{stringliteral}{" "} << Fluid\_mesh\_pt->min\_error() 
             << \textcolor{stringliteral}{" "} << Fluid\_mesh\_pt->max\_permitted\_error()  
             << \textcolor{stringliteral}{" "} << Fluid\_mesh\_pt->min\_permitted\_error()  
             << \textcolor{stringliteral}{" "} << Fluid\_mesh\_pt->max\_keep\_unrefined();

  \textcolor{comment}{// Output the number of the corresponding full documentation  }
  \textcolor{comment}{// file number (or -1 if no full doc was made)}
  \textcolor{keywordflow}{if} (doc\_info.is\_doc\_enabled()) 
   \{trace\_file << \textcolor{stringliteral}{" "} <<doc\_info.number()  << \textcolor{stringliteral}{" "};\}
  \textcolor{keywordflow}{else} \{trace\_file << \textcolor{stringliteral}{" "} <<-1  << \textcolor{stringliteral}{" "};\}
  
  \textcolor{comment}{//End the trace file}
  trace\_file << std::endl;
  
  \textcolor{comment}{// Increment counter for full doc}
  \textcolor{keywordflow}{if} (doc\_info.is\_doc\_enabled()) \{doc\_info.number()++;\}
\}

\textcolor{comment}{//======================================================================}\textcolor{comment}{}
\textcolor{comment}{/// Constructor for FSI ring problem. Pass number of wall elements}
\textcolor{comment}{/// and length of wall (in Lagrangian coordinates)  amplitude of }
\textcolor{comment}{/// initial deformation, pcos perturbation and duration.}
\textcolor{comment}{}\textcolor{comment}{//======================================================================}
\hyperlink{classFSIRingProblem_a8f4969c6397bebe8afa2b9285ec908e6}{FSIRingProblem::FSIRingProblem}(\textcolor{keyword}{const} \textcolor{keywordtype}{unsigned}& N,
                \textcolor{keyword}{const} \textcolor{keywordtype}{double}& eps\_ampl, \textcolor{keyword}{const} \textcolor{keywordtype}{double}& pcos\_initial,
                \textcolor{keyword}{const} \textcolor{keywordtype}{double}& pcos\_duration) : 
 Eps\_ampl(eps\_ampl), Pcos\_initial(pcos\_initial), 
 Pcos\_duration(pcos\_duration)
\{
 \textcolor{comment}{//----------------------------------------------------------- }
 \textcolor{comment}{// Create timesteppers}
 \textcolor{comment}{//-----------------------------------------------------------}
 
 \textcolor{comment}{// Allocate the wall timestepper and add it to the problem's vector}
 \textcolor{comment}{// of timesteppers}
 Wall\_time\_stepper\_pt = \textcolor{keyword}{new} Newmark<2>;
 add\_time\_stepper\_pt(Wall\_time\_stepper\_pt);

 \textcolor{comment}{// Allocate the fluid timestepper and add it to the problem's Vector}
 \textcolor{comment}{// of timesteppers}
 Fluid\_time\_stepper\_pt = \textcolor{keyword}{new} BDF<2>;
 add\_time\_stepper\_pt(Fluid\_time\_stepper\_pt);

 \textcolor{comment}{//----------------------------------------------------------}
 \textcolor{comment}{// Create the wall mesh}
 \textcolor{comment}{//----------------------------------------------------------}

 \textcolor{comment}{// Undeformed wall is an elliptical ring}
 Undef\_geom\_pt = \textcolor{keyword}{new} Ellipse(1.0,1.0); 

 \textcolor{comment}{//Length of wall in Lagrangian coordinates}
 \textcolor{keywordtype}{double} L = 2.0*atan(1.0);

 \textcolor{comment}{//Now create the (Lagrangian!) mesh}
 Wall\_mesh\_pt = \textcolor{keyword}{new} 
  OneDLagrangianMesh<SOLID\_ELEMENT>(\hyperlink{namespaceoomph_1_1SarahBL_a3f2e6fdba588e1883d317f6e0cd7f32f}{N},L,Undef\_geom\_pt,Wall\_time\_stepper\_pt);

 \textcolor{comment}{//----------------------------------------------------------}
 \textcolor{comment}{// Set the boundary conditions for wall mesh (problem)}
 \textcolor{comment}{//----------------------------------------------------------}
 
 \textcolor{comment}{// Bottom boundary: (Boundary 0)}
 \textcolor{comment}{// No vertical displacement}
 Wall\_mesh\_pt->boundary\_node\_pt(0,0)->pin\_position(1);
 \textcolor{comment}{// Zero slope: Pin type 1 dof for displacement direction 0 }
 Wall\_mesh\_pt->boundary\_node\_pt(0,0)->pin\_position(1,0);
 
 \textcolor{comment}{// Top boundary: (Boundary 1)}
 \textcolor{comment}{// No horizontal displacement}
 Wall\_mesh\_pt->boundary\_node\_pt(1,0)->pin\_position(0);
 \textcolor{comment}{// Zero slope: Pin type 1 dof for displacement direction 1}
 Wall\_mesh\_pt->boundary\_node\_pt(1,0)->pin\_position(1,1);


 \textcolor{comment}{//-----------------------------------------------------------}
 \textcolor{comment}{// Create the fluid mesh:}
 \textcolor{comment}{//-----------------------------------------------------------}

 \textcolor{comment}{// Fluid mesh is suspended from wall between the following Lagrangian}
 \textcolor{comment}{// coordinates:}
 \textcolor{keywordtype}{double} xi\_lo=0.0;
 \textcolor{keywordtype}{double} xi\_hi=L;

 \textcolor{comment}{// Fractional position of dividing line for two outer blocks in mesh}
 \textcolor{keywordtype}{double} fract\_mid=0.5;
 
 \textcolor{comment}{//Create a geometric object that represents the wall geometry from the}
 \textcolor{comment}{//wall mesh (one Lagrangian, two Eulerian coordinates).}
 MeshAsGeomObject *wall\_mesh\_as\_geometric\_object\_pt
  = \textcolor{keyword}{new} MeshAsGeomObject(Wall\_mesh\_pt);

 \textcolor{comment}{// Build fluid mesh using the wall mesh as a geometric object}
 Fluid\_mesh\_pt = \textcolor{keyword}{new} AlgebraicRefineableQuarterCircleSectorMesh<FLUID\_ELEMENT >
  (wall\_mesh\_as\_geometric\_object\_pt,
   xi\_lo,fract\_mid,xi\_hi,Fluid\_time\_stepper\_pt);

 \textcolor{comment}{// Set the error estimator}
 Z2ErrorEstimator* error\_estimator\_pt=\textcolor{keyword}{new} Z2ErrorEstimator;
 Fluid\_mesh\_pt->spatial\_error\_estimator\_pt()=error\_estimator\_pt;
  
 \textcolor{comment}{// Extract pointer to node at center of mesh}
 \textcolor{keywordtype}{unsigned} nnode=Fluid\_mesh\_pt->finite\_element\_pt(0)->nnode();
 Veloc\_trace\_node\_pt=Fluid\_mesh\_pt->finite\_element\_pt(0)->node\_pt(nnode-1);
 
 \textcolor{comment}{//-------------------------------------------------------}
 \textcolor{comment}{// Set the fluid boundary conditions}
 \textcolor{comment}{//-------------------------------------------------------}

 \textcolor{comment}{// Bottom boundary (boundary 0): }
 \{
  \textcolor{keywordtype}{unsigned} n\_node = Fluid\_mesh\_pt->nboundary\_node(0);
  \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} n=0;n<n\_node;n++)
   \{
    \textcolor{comment}{// Pin vertical velocity}
    Fluid\_mesh\_pt->boundary\_node\_pt(0,n)->pin(1);
   \}
 \}
            
 \textcolor{comment}{// Ring boundary (boundary 1): }
 \textcolor{comment}{// No slip; this also implies that the velocity needs}
 \textcolor{comment}{// to be updated in response to wall motion}
 \{
  \textcolor{keywordtype}{unsigned} n\_node = Fluid\_mesh\_pt->nboundary\_node(1);
  \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} n=0;n<n\_node;n++)
   \{
    \textcolor{comment}{// Which node are we dealing with?}
    Node* node\_pt=Fluid\_mesh\_pt->boundary\_node\_pt(1,n);

     \textcolor{comment}{// Set auxiliary update function pointer}
    node\_pt->set\_auxiliary\_node\_update\_fct\_pt(
     FSI\_functions::apply\_no\_slip\_on\_moving\_wall);
    
    \textcolor{comment}{// Pin both velocities}
    \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} i=0;i<2;i++) \{node\_pt->pin(i);\}
   \}
 \}

 \textcolor{comment}{// Left boundary (boundary 2):}
  \{
   \textcolor{keywordtype}{unsigned} n\_node = Fluid\_mesh\_pt->nboundary\_node(2);
   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} n=0;n<n\_node;n++)
    \{
     \textcolor{comment}{// Pin horizontal velocity}
       Fluid\_mesh\_pt->boundary\_node\_pt(2,n)->pin(0);
    \}
  \}


 \textcolor{comment}{//--------------------------------------------------------}
 \textcolor{comment}{// Add the submeshes and build global mesh}
 \textcolor{comment}{// -------------------------------------------------------}

 \textcolor{comment}{// Wall mesh}
 add\_sub\_mesh(Wall\_mesh\_pt);

 \textcolor{comment}{//Fluid mesh}
 add\_sub\_mesh(Fluid\_mesh\_pt);

 \textcolor{comment}{// Combine all submeshes into a single Mesh}
 build\_global\_mesh();
 

 \textcolor{comment}{//----------------------------------------------------------}
 \textcolor{comment}{// Finish problem setup}
 \textcolor{comment}{// ---------------------------------------------------------}

 \textcolor{comment}{//Find number of elements in fluid mesh}
 \textcolor{keywordtype}{unsigned} n\_element = Fluid\_mesh\_pt->nelement();

 \textcolor{comment}{// Loop over the fluid elements to set up element-specific }
 \textcolor{comment}{// things that cannot be handled by constructor}
 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} e=0;e<n\_element;e++)
  \{
   \textcolor{comment}{// Upcast from FiniteElement to the present element}
   FLUID\_ELEMENT *el\_pt 
    = \textcolor{keyword}{dynamic\_cast<}FLUID\_ELEMENT*\textcolor{keyword}{>}(Fluid\_mesh\_pt->element\_pt(e));

   \textcolor{comment}{//Set the Reynolds number, etc}
   el\_pt->re\_pt() = &\hyperlink{namespaceGlobal__Physical__Variables_ab814e627d2eb5bc50318879d19ab16b9}{Global\_Physical\_Variables::Re};
   el\_pt->re\_st\_pt() = &\hyperlink{namespaceGlobal__Physical__Variables_a085ee4bf968ffdd01a41b8c41864f907}{Global\_Physical\_Variables::ReSt};


   el\_pt->evaluate\_shape\_derivs\_by\_direct\_fd();       

\textcolor{comment}{//   el\_pt->evaluate\_shape\_derivs\_by\_chain\_rule();}
\textcolor{comment}{//   el\_pt->enable\_always\_evaluate\_dresidual\_dnodal\_coordinates\_by\_fd();}

\textcolor{comment}{//    if (e==0)}
\textcolor{comment}{//     \{}
\textcolor{comment}{//      el\_pt->disable\_always\_evaluate\_dresidual\_dnodal\_coordinates\_by\_fd();}
\textcolor{comment}{//     \}}
\textcolor{comment}{//    else}
\textcolor{comment}{//     \{}
\textcolor{comment}{//      el\_pt->enable\_always\_evaluate\_dresidual\_dnodal\_coordinates\_by\_fd();}
\textcolor{comment}{//     \}}

   \textcolor{comment}{//el\_pt->evaluate\_shape\_derivs\_by\_direct\_fd();       }

  \}
 
 
 \textcolor{comment}{//Loop over the solid elements to set physical parameters etc.}
 \textcolor{keywordtype}{unsigned} n\_wall\_element = Wall\_mesh\_pt->nelement();
 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} e=0;e<n\_wall\_element;e++)
  \{
   \textcolor{comment}{//Cast to proper element type}
   SOLID\_ELEMENT *el\_pt = \textcolor{keyword}{dynamic\_cast<}SOLID\_ELEMENT*\textcolor{keyword}{>}(
    Wall\_mesh\_pt->element\_pt(e));
   
   \textcolor{comment}{//Set physical parameters for each element:}
   el\_pt->h\_pt() = &\hyperlink{namespaceGlobal__Physical__Variables_af6e07423e22c0991084d9a2f43727805}{Global\_Physical\_Variables::H};
   el\_pt->lambda\_sq\_pt() = &\hyperlink{namespaceGlobal__Physical__Variables_a6fe17557ceb32dd353827fba60408363}{Global\_Physical\_Variables::Lambda\_sq};
   
   \textcolor{comment}{//Function that specifies the external load Vector}
   el\_pt->load\_vector\_fct\_pt() = &\hyperlink{namespaceGlobal__Physical__Variables_aa08c246eac99f59be33ef4a6ee924990}{Global\_Physical\_Variables::pcos\_load};

   \textcolor{comment}{// Function that specifies the load ratios}
   el\_pt->q\_pt() = &\hyperlink{namespaceGlobal__Physical__Variables_a66cb7ecda9ba0cd72367dd697f154545}{Global\_Physical\_Variables::Q};

   \textcolor{comment}{//Assign the undeformed beam shape}
   el\_pt->undeformed\_beam\_pt() = Undef\_geom\_pt;
  \}
 
 \textcolor{comment}{// Establish control displacment: (even if no displacement control is applied}
 \textcolor{comment}{// we still want to doc the displacement at the same point)}

 \textcolor{comment}{// Choose element: (This is the last one)}
 Doc\_displacement\_elem\_pt = \textcolor{keyword}{dynamic\_cast<}SOLID\_ELEMENT*\textcolor{keyword}{>}(
  Wall\_mesh\_pt->element\_pt(n\_wall\_element-1));
  
 \textcolor{comment}{// Setup fsi: Work out which fluid dofs affect the wall elements}
 \textcolor{comment}{// the correspondance between wall dofs and fluid elements is handled}
 \textcolor{comment}{// during the remeshing, but the "reverse" association must be done}
 \textcolor{comment}{// separately.}
 \textcolor{comment}{// We pass the boundary between the fluid and solid meshes and pointers}
 \textcolor{comment}{// to the meshes. The interaction boundary is boundary 1 of the }
 \textcolor{comment}{// 2D fluid mesh.}
 FSI\_functions::setup\_fluid\_load\_info\_for\_solid\_elements<FLUID\_ELEMENT,2>
  (\textcolor{keyword}{this},1,Fluid\_mesh\_pt,Wall\_mesh\_pt);

 \textcolor{comment}{// Do equation numbering}
 cout << \textcolor{stringliteral}{"# of dofs "} << assign\_eqn\_numbers() << std::endl;
 
\}


\textcolor{comment}{//=========================================================================}\textcolor{comment}{}
\textcolor{comment}{/// Solver loop to perform unsteady run}
\textcolor{comment}{}\textcolor{comment}{//=========================================================================}
\textcolor{keywordtype}{void} \hyperlink{classFSIRingProblem_acbb3bc5cd6d16cfee7a2f19a3b984ce7}{FSIRingProblem::dynamic\_run}()
\{
 \textcolor{comment}{// Setup documentation}
 \textcolor{comment}{//---------------------------------------------------------------}
\textcolor{comment}{}
\textcolor{comment}{ /// Label for output}
\textcolor{comment}{} DocInfo doc\_info;

 \textcolor{comment}{// Output directory}
 doc\_info.set\_directory(\textcolor{stringliteral}{"RESLT"});

 \textcolor{comment}{// Step number}
 doc\_info.number()=0;

 \textcolor{comment}{//Open a trace file}
 ofstream trace\_file(\textcolor{stringliteral}{"RESLT/trace\_ring.dat"});
 
 \textcolor{comment}{// Write header for trace file}
 trace\_file << \textcolor{stringliteral}{"VARIABLES=\(\backslash\)"time\(\backslash\)",\(\backslash\)"V\_c\_t\_r\_l\(\backslash\)""};
 trace\_file << \textcolor{stringliteral}{",\(\backslash\)"x<sub>1</sub><sup>(track)</sup>\(\backslash\)""};
 trace\_file << \textcolor{stringliteral}{",\(\backslash\)"x<sub>2</sub><sup>(track)</sup>\(\backslash\)""};
 trace\_file << \textcolor{stringliteral}{",\(\backslash\)"u<sub>1</sub><sup>(track)</sup>\(\backslash\)""};
 trace\_file << \textcolor{stringliteral}{",\(\backslash\)"u<sub>2</sub><sup>(track)</sup>\(\backslash\)""};
 trace\_file << \textcolor{stringliteral}{",\(\backslash\)"N<sub>element</sub>\(\backslash\)""};
 trace\_file << \textcolor{stringliteral}{",\(\backslash\)"N<sub>dof</sub>\(\backslash\)""};
 trace\_file << \textcolor{stringliteral}{",\(\backslash\)"# of under-refined elements\(\backslash\)""};
 trace\_file << \textcolor{stringliteral}{",\(\backslash\)"max. error\(\backslash\)""};
 trace\_file << \textcolor{stringliteral}{",\(\backslash\)"min. error\(\backslash\)""};
 trace\_file << \textcolor{stringliteral}{",\(\backslash\)"max. permitted error\(\backslash\)""};
 trace\_file << \textcolor{stringliteral}{",\(\backslash\)"min. permitted error\(\backslash\)""};
 trace\_file << \textcolor{stringliteral}{",\(\backslash\)"max. permitted # of unrefined elements\(\backslash\)""};
 trace\_file << \textcolor{stringliteral}{",\(\backslash\)"doc number\(\backslash\)""};
 trace\_file << std::endl;
 

 \textcolor{comment}{// Initialise timestepping}
 \textcolor{comment}{// -------------------------------------------------------------}

 \textcolor{comment}{// Number of steps}
 \textcolor{keywordtype}{unsigned} nstep=300;

 \textcolor{comment}{// Nontrivial command line input: validation: only do three steps}
 \textcolor{keywordflow}{if} (CommandLineArgs::Argc>1)
  \{
   nstep=1;
   cout << \textcolor{stringliteral}{"Only doing nstep steps for validation: "} << nstep << std::endl;
  \}

 \textcolor{comment}{// Set initial timestep}
 \textcolor{keywordtype}{double} dt=0.004; 

 \textcolor{comment}{// Set initial value for dt  -- also assigns weights to the timesteppers}
 initialise\_dt(dt);

 \textcolor{comment}{// Set physical parameters}
 \textcolor{comment}{//---------------------------------------------------------}
 \textcolor{keyword}{using namespace }\hyperlink{namespaceGlobal__Physical__Variables}{Global\_Physical\_Variables};

 \textcolor{comment}{// Set Womersley number}
 Alpha\_sq=100.0; \textcolor{comment}{// 50.0; // ADJUST}

 \textcolor{comment}{// Set density ratio}
 Density\_ratio=10.0; \textcolor{comment}{// 0.0; ADJUST}

 \textcolor{comment}{// Wall thickness}
 H=1.0/20.0;

 \textcolor{comment}{// Set external pressure}
 Pext=0.0;
 \textcolor{comment}{}
\textcolor{comment}{ /// Perturbation pressure}
\textcolor{comment}{} Pcos=Pcos\_initial;

 \textcolor{comment}{// Assign/doc corresponding computational parameters}
 \hyperlink{namespaceGlobal__Physical__Variables_a5928252d8e7440b329065c223926d4d2}{set\_params}();


 \textcolor{comment}{// Refine uniformly and assign initial conditions}
 \textcolor{comment}{//--------------------------------------------------------------}

 \textcolor{comment}{// Refine the problem uniformly }
 refine\_uniformly();
 refine\_uniformly();

 \textcolor{comment}{// This sets up the solution at the initial time}
 set\_initial\_condition();

 \textcolor{comment}{// Set targets for spatial adptivity}
 \textcolor{comment}{//---------------------------------------------------------------}

 \textcolor{comment}{// Max. and min. error for adaptive refinement/unrefinement}
 Fluid\_mesh\_pt->max\_permitted\_error()=1.0e-2; 
 Fluid\_mesh\_pt->min\_permitted\_error()=1.0e-3; 

 \textcolor{comment}{// Don't allow refinement to drop under given level}
 Fluid\_mesh\_pt->min\_refinement\_level()=2;

 \textcolor{comment}{// Don't allow refinement beyond given level }
 Fluid\_mesh\_pt->max\_refinement\_level()=6; 

 \textcolor{comment}{// Don't bother adapting the mesh if no refinement is required}
 \textcolor{comment}{// and if less than ... elements are to be merged.}
 Fluid\_mesh\_pt->max\_keep\_unrefined()=20;

 \textcolor{comment}{// Doc refinement targets}
 Fluid\_mesh\_pt->doc\_adaptivity\_targets(cout);


 \textcolor{comment}{// Do the timestepping}
 \textcolor{comment}{//----------------------------------------------------------------}

 \textcolor{comment}{// Reset initial conditions after refinement for first step only}
 \textcolor{keywordtype}{bool} first=\textcolor{keyword}{true};

 \textcolor{comment}{//Output initial data}
 doc\_solution(0,doc\_info,trace\_file);


\textcolor{comment}{//  \{}
\textcolor{comment}{//   unsigned nel=Fluid\_mesh\_pt->nelement();}
\textcolor{comment}{//   for (unsigned e=0;e<nel;e++)}
\textcolor{comment}{//    \{}
\textcolor{comment}{//     std::cout << "\(\backslash\)n\(\backslash\)nEl: " << e << std::endl << std::endl; }
\textcolor{comment}{//     FiniteElement* el\_pt=Fluid\_mesh\_pt->finite\_element\_pt(e);}
\textcolor{comment}{//     unsigned n\_dof=el\_pt->ndof();}
\textcolor{comment}{//     Vector<double> residuals(n\_dof);}
\textcolor{comment}{//     DenseDoubleMatrix jacobian(n\_dof,n\_dof);}
\textcolor{comment}{//     el\_pt->get\_jacobian(residuals,jacobian);}
\textcolor{comment}{//    \}}
\textcolor{comment}{//   exit(0);}
\textcolor{comment}{//  \}}

 \textcolor{comment}{// Time integration loop}
 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} i=1;i<=nstep;i++)
  \{
   \textcolor{comment}{// Switch doc off during solve}
   doc\_info.disable\_doc();

   \textcolor{comment}{// Solve}
   \textcolor{keywordtype}{unsigned} max\_adapt=1; 
   unsteady\_newton\_solve(dt,max\_adapt,first);

   \textcolor{comment}{// Now we've done the first step}
   first=\textcolor{keyword}{false};
   
   \textcolor{comment}{// Doc solution}
   doc\_solution(i,doc\_info,trace\_file);
   \textcolor{comment}{}
\textcolor{comment}{   /// Switch off perturbation pressure}
\textcolor{comment}{}   \textcolor{keywordflow}{if} (time\_pt()->time()>Pcos\_duration) \{Pcos=0.0;\}
   
  \}

\}


\textcolor{comment}{//=====================================================================}\textcolor{comment}{}
\textcolor{comment}{/// Driver for fsi ring test problem }
\textcolor{comment}{}\textcolor{comment}{//=====================================================================}
\textcolor{keywordtype}{int} \hyperlink{fsi__osc__ring_8cc_a0ddf1224851353fc92bfbff6f499fa97}{main}(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char}* argv[])
\{

 \textcolor{comment}{// Store command line arguments}
 CommandLineArgs::setup(argc,argv);
 
 \textcolor{comment}{// Number of elements}
 \textcolor{keywordtype}{unsigned} nelem = 13; 
\textcolor{comment}{}
\textcolor{comment}{ /// Perturbation pressure }
\textcolor{comment}{} \textcolor{keywordtype}{double} pcos\_initial=1.0e-6; \textcolor{comment}{// ADJUST }
\textcolor{comment}{}
\textcolor{comment}{ /// Duration of initial pcos perturbation}
\textcolor{comment}{} \textcolor{keywordtype}{double} pcos\_duration=0.3; \textcolor{comment}{// ADJUST}
\textcolor{comment}{}
\textcolor{comment}{ /// Amplitude of initial deformation}
\textcolor{comment}{} \textcolor{keywordtype}{double} eps\_ampl=0.0; \textcolor{comment}{// ADJUST}

 \textcolor{comment}{//Set up the problem}
 \hyperlink{classFSIRingProblem}{FSIRingProblem} problem(nelem,eps\_ampl,pcos\_initial,pcos\_duration);

 \textcolor{comment}{// Do parameter study}
 problem.dynamic\_run();

\}






\end{DoxyCodeInclude}




 

 \hypertarget{index_pdf}{}\section{P\+D\+F file}\label{index_pdf}
A \href{../latex/refman.pdf}{\tt pdf version} of this document is available. \end{document}
