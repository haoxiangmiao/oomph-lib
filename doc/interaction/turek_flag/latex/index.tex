In this example we consider the flow in a 2D channel past a cylinder with an attached elastic \char`\"{}flag\char`\"{}. This is the F\+SI benchmark problem proposed by Turek \& Hron, \begin{center} "Proposal for Numerical Benchmarking of Fluid-\/\+Structure Interaction between an Elastic Object and a Laminar Incompressible Flow\char`\"{}, S. Turek \& J. Hron, pp. 371-\/385. In\+: 
\char`\"{}Fluid-\/\+Structure Interaction" Springer Lecture Notes in Computational Science and Engineering {\bfseries 53}. Ed. H.-\/J. Bungartz \& M. Schaefer. Springer Verlag 2006. \end{center} 

The problem combines the two single-\/physics problems of ~\newline
~\newline

\begin{DoxyItemize}
\item \href{../../../navier_stokes/turek_flag_non_fsi/html/index.html}{\tt Flow past a cylinder with a \char`\"{}flag\char`\"{} whose motion is prescribed.} ~\newline
~\newline

\item \href{../../../solid/airy_cantilever/html/index.html}{\tt The deformation of a finite-\/thickness cantilever beam (modelled as a 2D solid), loaded by surface tractions.} ~\newline
~\newline

\end{DoxyItemize}This is our first example problem that involves the coupling between a fluid and \char`\"{}proper\char`\"{} solid (rather than beam structure) and also includes both fluid and wall inertia.

The problem presented here was used as one of the test cases for {\ttfamily oomph-\/lib\textquotesingle{}s} F\+SI preconditioner; see ~\newline
~\newline
 \begin{center} \href{http://www.maths.man.ac.uk/~mheil/oomph_lib_additional_material/HeilHazelBoyleCompMech/HeilHazelBoyleCompMech.pdf}{\tt Heil, M., Hazel, A.\+L. \& Boyle, J. (2008)\+: Solvers for large-\/displacement fluid-\/structure interaction problems\+: Segregated vs. monolithic approaches. Computational Mechanics.} \end{center} 

~\newline
~\newline
In this tutorial we concentrate on the problem formulation. The application of the preconditioner is discussed \href{../../../preconditioners/fsi/html/index.html}{\tt elsewhere} -- the required source code is contained in the \href{../../../../demo_drivers/interaction/turek_flag/turek_flag.cc}{\tt driver code.}



 

\hypertarget{index_the_problem}{}\section{The Problem}\label{index_the_problem}
The figure below shows a sketch of the problem\+: A 2D channel of height $ H^*$ and length $ L^* $ conveys fluid of density $ \rho_f $ and dynamic viscosity $ \mu $ and contains a cylinder of diameter $ d^* $, centred at $ (X^*_c, Y^*_c) $ to which a linearly elastic \char`\"{}flag\char`\"{} of thickness $ H^*_{flag}$ and length $ L^*_{flag} $ is attached. Steady Poiseuille flow with average velocity $ U^* $ is imposed at the left end of the channel while we assume the outflow to be parallel and axially traction-\/free. We model the flag as a linearly elastic Hookean solid with elastic modulus $ E^* $, density $ \rho_s $ and Poisson\textquotesingle{}s ratio $ \nu. $

 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{turek_flag_dim}
\doxyfigcaption{Sketch of the problem in dimensional variables. }
\end{DoxyImage}


We non-\/dimensionalise all length and coordinates on the diameter of the cylinder, $ d^* $, the velocities on the mean velocity, $ U^* $, and the fluid pressure on the viscous scale. To facilitate comparisons with Turek \& Hron\textquotesingle{}s dimensional benchmark data (particularly for the period of the self-\/excited oscillations), we use a timescale of $ T^* = 1 \ \mbox{sec} $ to non-\/dimensionalise time. The fluid flow is then governed by the non-\/dimensional Navier-\/\+Stokes equations \[ Re \left( St \frac{\partial u_i}{\partial t} + u_j \frac{\partial u_i}{\partial x_j} \right) = - \frac{\partial p}{\partial x_i} + \frac{\partial }{\partial x_j} \left[ \left( \frac{\partial u_i}{\partial x_j} + \frac{\partial u_j}{\partial x_i} \right) \right], \] where $ Re = \rho U^* H_0^* / \mu $ and $ St = d^* / (U^* T^*) $, and \begin{center} \[ \frac{\partial u_i}{\partial x_i} = 0, \] \end{center}  subject to parabolic inflow \begin{center} \[ {\bf u} = 6 x_2 (1-x_2) {\bf e}_1 \] \end{center}  at the inflow cross-\/section; parallel, axially-\/traction-\/free outflow at the outlet; and no-\/slip on the stationary channel walls and the surface of the cylinder, $ {\bf u} = {\bf 0} $. The no-\/slip condition on the moving flag is \begin{center} \[ {\bf u} = St \ \frac{\partial {\bf R}_w(\xi_{[top,tip,bottom]},t)}{\partial t} \ \ \ \ \ \ \ \ \ \ \ \ \ \ (1) \] \end{center}  where $ \xi_{[top,tip,bottom]} $ are Lagrangian coordinates parametrising the three faces of the flag.

We describe the deformation of the elastic flag by the non-\/dimensional position vector $ {\bf R}(\xi^1, \xi^2, t) $ which is determined by the principle of virtual displacements \[ \int_{v} \left\{ \sigma^{ij} \ \delta \gamma_{ij} - \left( {\bf f} - \Lambda^2 \frac{\partial^2 {\bf R}}{\partial t^{2}} \right) \cdot \delta {\bf R} \right\} \ dv -\oint_{A_{tract}} {\bf t} \cdot \delta {\bf R} \ dA =0, \ \ \ \ \ \ \ \ (2) \] where all solid stresses and tractions have been non-\/dimensionalised on Young\textquotesingle{}s modulus, $ E^* $; see the \href{../../../solid/solid_theory/html/index.html}{\tt Solid Mechanics Tutorial} for details. The solid mechanics timescale ratio (the ratio of the timescale $ T^* $ chosen to non-\/dimensionalise time, to the intrinsic timescale of the solid) can be expressed in terms of the Reynolds and Strouhal numbers, the density ratio, and the F\+SI interaction parameter as \[ \Lambda^2 = \left( \frac{d^*}{T^*} \sqrt{\frac{\rho_s}{E^*}} \right)^2 = St^2 \left( \frac{\rho_s}{\rho_f} \right) Re \ Q. \]

Here is a sketch of the non-\/dimensional version of the problem\+:

 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{turek_flag}
\doxyfigcaption{Sketch of the fluid problem in dimensionless variables, showing the Lagrangian coordinates that parametrise the three faces of the flag. }
\end{DoxyImage}




 

\hypertarget{index_parameters}{}\section{Parameter values for the benchmark problems}\label{index_parameters}
The (dimensional) parameter values given in Turek \& Hron\textquotesingle{}s benchmark correspond to the following non-\/dimensional parameters\+:\hypertarget{index_geom}{}\subsection{Geometry}\label{index_geom}

\begin{DoxyItemize}
\item Cylinder diameter $ d = 1 $
\item Centre of cylinder $ X_c = Y_c = 2 $
\item Channel length $ L= 25 $
\item Channel width $ H = 4.1 $
\item Thickness of the undeformed flag $ H_{flag} = 0.2 $
\item Right end of undeformed flag $ x_{tip} = 6 $
\end{DoxyItemize}\hypertarget{index_nd_params}{}\subsection{Non-\/dimensional parameters}\label{index_nd_params}
The three F\+SI test cases correspond to the following non-\/dimensional parameters\+:

\tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*{6}{|X[-1]}|}
\hline
\PBS\centering ..  &\PBS\centering $ Re = U^* d^* \rho_f/\mu $  &\PBS\centering $ St = d^* /(U^* T^*) $  &\PBS\centering $ Q = \mu U^* / (E^* d^*) $  &\PBS\centering $ \rho_s/\rho_f $  &\PBS\centering $ \Lambda^2 = (d^* /T^* \sqrt{\rho_s/E^*})^2 = St^2 (\rho_s/\rho_f) Re \ Q $   \\\cline{1-6}
\PBS\centering {\bfseries F\+S\+I1}  &\PBS\centering $ 20 $  &\PBS\centering $ 0.5 $  &\PBS\centering $ 1.429 \times 10^{-6} $  &\PBS\centering $ 1 $  &\PBS\centering $ 7.145 \times 10^{-6} $   \\\cline{1-6}
\PBS\centering {\bfseries F\+S\+I2}  &\PBS\centering $ 100 $  &\PBS\centering $ 0.1 $  &\PBS\centering $ 7.143 \times 10^{-6} $  &\PBS\centering $ 10 $  &\PBS\centering $ 7.143 \times 10^{-6} $   \\\cline{1-6}
\PBS\centering {\bfseries F\+S\+I3}  &\PBS\centering $ 200 $  &\PBS\centering $ 0.05 $  &\PBS\centering $ 3.571 \times 10^{-6} $  &\PBS\centering $ 1 $  &\PBS\centering $ 1.786 \times 10^{-6} $   \\\cline{1-6}
\end{longtabu}




 

\hypertarget{index_results}{}\section{Results}\label{index_results}
The test cases F\+S\+I2 and F\+S\+I3 are the most interesting because the system develops large-\/amplitude self-\/excited oscillations\hypertarget{index_fsi2_results}{}\subsection{F\+S\+I2}\label{index_fsi2_results}
Following an initial transient period the system settles into large-\/amplitude self-\/excited oscillations during which the oscillating flag generates a regular vortex pattern that is advected along the channel. This is illustrated in the figure below which shows a snapshot of the flow field (pressure contours and instantaneous streamlines) at $ t=6.04. $

 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{fsi2_flow605_cropped}
\doxyfigcaption{Snapshot of the flow field (instantaneous streamlines and pressure contours) }
\end{DoxyImage}


The constantly adapted mesh contains and average of 65,000 degrees of freedom. A relatively large timestep of $ \Delta t = 0.01 $ -- corresponding to about 50 timesteps per period of the oscillation -- was used in this computation. With this discretisation the system settles into oscillations with a period of $ \approx 0.52 $ and an amplitude of the tip-\/displacement of $ 0.01 \pm 0.83. $

 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{fsi2_trace_cropped}
\doxyfigcaption{Time trace of the tip displacement. }
\end{DoxyImage}
\hypertarget{index_fsi3_results}{}\subsection{F\+S\+I3}\label{index_fsi3_results}
The figures below shows the corresponding results for the case F\+S\+I3 in which the fluid and solid densities are equal and the Reynolds number twice as large as in the F\+S\+I2 case. The system performs oscillations of much higher frequency and smaller amplitude. This is illustrated in the figure below which shows a snapshot of the flow field (pressure contours and instantaneous streamlines) at $ t=3.615. $

 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{fsi3_flow724_cropped}
\doxyfigcaption{Snapshot of the flow field (instantaneous streamlines and pressure contours) }
\end{DoxyImage}


This computation was performed with a timestep of $ \Delta t = 0.005 $ and resulted in oscillations with a period of $ \approx 0.19 $ and an amplitude of the tip-\/displacement of $ 0.01 \pm 0.36. $

The increase in frequency and Reynolds number leads to the development of thinner boundary and shear layers which require a finer spatial resolution, involving an average of 84,000 degrees of freedom.

 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{fsi3_trace_cropped}
\doxyfigcaption{Time trace of the tip displacement. }
\end{DoxyImage}




 

\hypertarget{index_overview}{}\section{Overview of the driver code}\label{index_overview}
Since the driver code is somewhat lengthy we start by providing a brief overview of the main steps in the {\ttfamily Problem} construction\+:
\begin{DoxyEnumerate}
\item We start by discretising the flag with 2D solid elements, as in the corresponding \href{../../../solid/airy_cantilever/html/index.html}{\tt single-\/physics solid mechanics example.} ~\newline
~\newline

\item Next we attach {\ttfamily F\+S\+I\+Solid\+Traction\+Elements} to the three solid mesh boundaries that are exposed to the fluid traction. These elements are used to compute and impose the fluid traction onto the solid elements, using the flow field from the adjacent fluid elements. ~\newline
~\newline

\item We now combine the three sets of {\ttfamily F\+S\+I\+Solid\+Traction\+Elements} into three individual (sub-\/)meshes and convert these to {\ttfamily Geom\+Objects}, using the {\ttfamily Mesh\+As\+Geom\+Object} class. ~\newline
~\newline

\item The {\ttfamily Geom\+Object} representation of the three surface meshes is then passed to the constructor of the fluid mesh. The \href{../../../interaction/fsi_collapsible_channel_algebraic/html/index.html}{\tt algebraic node-\/update methodology} provided in the {\ttfamily Algebraic\+Mesh} base class is used to update its nodal positions in response to the motion of its bounding {\ttfamily Geom\+Objects}. ~\newline
~\newline

\item Finally, we use the helper function {\ttfamily F\+S\+I\+\_\+functions\+::setup\+\_\+fluid\+\_\+load\+\_\+info\+\_\+for\+\_\+solid\+\_\+elements}(...) to set up the fluid-\/structure interaction -- this function determines which fluid elements are adjacent to the Gauss points in the {\ttfamily F\+S\+I\+Solid\+Traction\+Elements} that apply the fluid traction to the solid. ~\newline
~\newline

\item Done! ~\newline
~\newline

\end{DoxyEnumerate}

 

\hypertarget{index_parameters}{}\section{Parameter values for the benchmark problems}\label{index_parameters}
As usual, We use a namespace to define the (many) global parameters, using default assignments for the F\+S\+I1 test case.

 
\begin{DoxyCodeInclude}
\textcolor{comment}{//=====start\_of\_global\_parameters=================================}
\textcolor{comment}{/// Global variables}
\textcolor{comment}{}\textcolor{comment}{//================================================================}
\textcolor{keyword}{namespace }\hyperlink{namespaceGlobal__Parameters}{Global\_Parameters}
\{
\textcolor{comment}{}
\textcolor{comment}{ /// Default case ID}
\textcolor{comment}{} \textcolor{keywordtype}{string} Case\_ID=\textcolor{stringliteral}{"FSI1"};
\textcolor{comment}{}
\textcolor{comment}{ /// Reynolds number (default assignment for FSI1 test case)}
\textcolor{comment}{} \textcolor{keywordtype}{double} Re=20.0; 
\textcolor{comment}{}
\textcolor{comment}{ /// Strouhal number (default assignment for FSI1 test case)}
\textcolor{comment}{} \textcolor{keywordtype}{double} St=0.5;
\textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Product of Reynolds and Strouhal numbers (default}
\textcolor{comment}{ /// assignment for FSI1 test case)}
\textcolor{comment}{} \textcolor{keywordtype}{double} ReSt=10.0;
\textcolor{comment}{}
\textcolor{comment}{ /// FSI parameter (default assignment for FSI1 test case)}
\textcolor{comment}{} \textcolor{keywordtype}{double} Q=1.429e-6;
 \textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Density ratio (solid to fluid; default assignment for FSI1}
\textcolor{comment}{ /// test case)}
\textcolor{comment}{} \textcolor{keywordtype}{double} Density\_ratio=1.0; 
\textcolor{comment}{}
\textcolor{comment}{ /// Height of flag}
\textcolor{comment}{} \textcolor{keywordtype}{double} H=0.2;
 \textcolor{comment}{}
\textcolor{comment}{ /// x position of centre of cylinder}
\textcolor{comment}{} \textcolor{keywordtype}{double} Centre\_x=2.0;
\textcolor{comment}{}
\textcolor{comment}{ /// y position of centre of cylinder}
\textcolor{comment}{} \textcolor{keywordtype}{double} Centre\_y=2.0;
\textcolor{comment}{}
\textcolor{comment}{ /// Radius of cylinder}
\textcolor{comment}{} \textcolor{keywordtype}{double} Radius=0.5;
\textcolor{comment}{}
\textcolor{comment}{ /// Pointer to constitutive law}
\textcolor{comment}{} ConstitutiveLaw* Constitutive\_law\_pt=0;
\textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Timescale ratio for solid (dependent parameter}
\textcolor{comment}{ /// assigned in set\_parameters())}
\textcolor{comment}{} \textcolor{keywordtype}{double} Lambda\_sq=0.0;
\textcolor{comment}{}
\textcolor{comment}{ /// Timestep}
\textcolor{comment}{} \textcolor{keywordtype}{double} Dt=0.1;
\textcolor{comment}{}
\textcolor{comment}{ /// Ignore fluid (default assignment for FSI1 test case)}
\textcolor{comment}{} \textcolor{keywordtype}{bool} Ignore\_fluid\_loading=\textcolor{keyword}{false};
\textcolor{comment}{}
\textcolor{comment}{ /// Elastic modulus}
\textcolor{comment}{} \textcolor{keywordtype}{double} E=1.0;
\textcolor{comment}{}
\textcolor{comment}{ /// Poisson's ratio}
\textcolor{comment}{} \textcolor{keywordtype}{double} Nu=0.4; 

\end{DoxyCodeInclude}


We also include a gravitational body force for the solid. (This is only used for the solid mechanics test cases, C\+S\+M1 and C\+S\+M2, which will not be discussed here.)


\begin{DoxyCodeInclude}
\textcolor{comment}{}
\textcolor{comment}{ /// Non-dim gravity (default assignment for FSI1 test case)}
\textcolor{comment}{} \textcolor{keywordtype}{double} Gravity=0.0; 
\textcolor{comment}{}
\textcolor{comment}{ /// Non-dimensional gravity as body force}
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{namespaceGlobal__Parameters_a200109847bf4cc26da4d00e8d68d569e}{gravity}(\textcolor{keyword}{const} \textcolor{keywordtype}{double}& time, 
              \textcolor{keyword}{const} Vector<double> &xi,
              Vector<double> &b)
 \{
  b[0]=0.0;
  b[1]=-\hyperlink{namespaceGlobal__Parameters_a335000b5db4206486a116ae0468d2d0c}{Gravity};
 \}

\end{DoxyCodeInclude}


The domain geometry and flow field are fairly complex and it is difficult to construct a good initial guess for the Newton iteration. To ensure its convergence at the beginning of the simulation we therefore employ the method suggested by Turek \& Hron\+: We start the flow from rest and ramp up the inflow profile from zero to its maximum value. The parameters for the time-\/dependent increase in the influx are defined here\+:


\begin{DoxyCodeInclude}
 \textcolor{comment}{}
\textcolor{comment}{ /// Period for ramping up in flux}
\textcolor{comment}{} \textcolor{keywordtype}{double} Ramp\_period=2.0;
 \textcolor{comment}{}
\textcolor{comment}{ /// Min. flux }
\textcolor{comment}{} \textcolor{keywordtype}{double} Min\_flux=0.0; 
 \textcolor{comment}{}
\textcolor{comment}{ /// Max. flux}
\textcolor{comment}{} \textcolor{keywordtype}{double} Max\_flux=1.0;
\textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Flux increases between Min\_flux and Max\_flux over }
\textcolor{comment}{ /// period Ramp\_period}
\textcolor{comment}{} \textcolor{keywordtype}{double} \hyperlink{namespaceGlobal__Parameters_a536aa5314a6cdb36af852e9513351d55}{flux}(\textcolor{keyword}{const} \textcolor{keywordtype}{double}& t)
 \{    
  \textcolor{keywordflow}{if} (t<Ramp\_period)
   \{
    \textcolor{keywordflow}{return} Min\_flux+(Max\_flux-\hyperlink{namespaceGlobal__Parameters_a5aabde2d31d07e5d0a84f6ff02c263dc}{Min\_flux})*
     0.5*(1.0-cos(MathematicalConstants::Pi*t/Ramp\_period));
   \}
  \textcolor{keywordflow}{else}
   \{
    \textcolor{keywordflow}{return} \hyperlink{namespaceGlobal__Parameters_a13f0d5d16393d21bbc904aea5cff4ea4}{Max\_flux};
   \}
 \} \textcolor{comment}{// end of specification of ramped influx}

\end{DoxyCodeInclude}


Finally, we provide a helper function that assigns the parameters for the various test cases, depending on their ID (\char`\"{}\+F\+S\+I1\char`\"{}, \char`\"{}\+F\+S\+I2\char`\"{}, \char`\"{}\+F\+S\+I3\char`\"{}, \char`\"{}\+C\+S\+M1\char`\"{} or \char`\"{}\+C\+S\+M2\char`\"{}). Here is the assignment for the case F\+S\+I1\+:


\begin{DoxyCodeInclude}
 
\textcolor{comment}{}
\textcolor{comment}{ /// Set parameters for the various test cases}
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{namespaceGlobal__Parameters_a8c333f9041cad78d5c0160a8e2c169f5}{set\_parameters}(\textcolor{keyword}{const} \textcolor{keywordtype}{string}& case\_id)
 \{

  \textcolor{comment}{// Remember which case we're dealing with}
  Case\_ID=case\_id;

  \textcolor{comment}{// Setup independent parameters depending on test case}
  \textcolor{keywordflow}{if} (case\_id==\textcolor{stringliteral}{"FSI1"})
   \{
    \textcolor{comment}{// Reynolds number based on diameter of cylinder}
    Re=20.0;

    \textcolor{comment}{// Strouhal number based on timescale of one second}
    St=0.5;

    \textcolor{comment}{// Womersley number}
    ReSt=Re*\hyperlink{namespaceGlobal__Parameters_af1af40a0df651e86bc1be273fafa98da}{St};

    \textcolor{comment}{// FSI parameter}
    Q=1.429e-6;
    
    \textcolor{comment}{// Timestep -- aiming for about 40 steps per period}
    Dt=0.1;

    \textcolor{comment}{// Density ratio}
    Density\_ratio=1.0;

    \textcolor{comment}{// Gravity}
    Gravity=0.0;
    
    \textcolor{comment}{// Max. flux}
    Max\_flux=1.0;

    \textcolor{comment}{// Ignore fluid}
    Ignore\_fluid\_loading=\textcolor{keyword}{false};
 
    \textcolor{comment}{// Compute dependent parameters}
    
    \textcolor{comment}{// Timescale ratio for solid }
    Lambda\_sq=Re*Q*Density\_ratio*St*\hyperlink{namespaceGlobal__Parameters_af1af40a0df651e86bc1be273fafa98da}{St};
  \}

\end{DoxyCodeInclude}


In the interest of brevity we omit the listings of the assignments for the other cases. Finally, we select the length of the time interval over which the influx is ramped up from zero to its maximum value to be equal to 20 timesteps, create a constitutive equation for the solid, and document the parameter values used in the simulation\+:


\begin{DoxyCodeInclude}
  \textcolor{comment}{// Ramp period (20 timesteps)}
  Ramp\_period=Dt*20.0;

  \textcolor{comment}{// "Big G" Linear constitutive equations:}
  Constitutive\_law\_pt = \textcolor{keyword}{new} GeneralisedHookean(&Nu,&E);
  
  \textcolor{comment}{// Doc}
  oomph\_info << std::endl;
  oomph\_info << \textcolor{stringliteral}{"-------------------------------------------"} 
             << std::endl;
  oomph\_info << \textcolor{stringliteral}{"Case: "} << case\_id << std::endl;
  oomph\_info << \textcolor{stringliteral}{"Re            = "} << Re << std::endl;
  oomph\_info << \textcolor{stringliteral}{"St            = "} << St << std::endl;
  oomph\_info << \textcolor{stringliteral}{"ReSt          = "} << ReSt << std::endl;
  oomph\_info << \textcolor{stringliteral}{"Q             = "} << Q << std::endl;
  oomph\_info << \textcolor{stringliteral}{"Dt            = "} << Dt << std::endl;
  oomph\_info << \textcolor{stringliteral}{"Ramp\_period   = "} << Ramp\_period << std::endl;
  oomph\_info << \textcolor{stringliteral}{"Max\_flux      = "} << Max\_flux << std::endl;
  oomph\_info << \textcolor{stringliteral}{"Density\_ratio = "} << Density\_ratio << std::endl;
  oomph\_info << \textcolor{stringliteral}{"Lambda\_sq     = "} << Lambda\_sq << std::endl;
  oomph\_info << \textcolor{stringliteral}{"Gravity       = "} << Gravity << std::endl;
  oomph\_info << \textcolor{stringliteral}{"Ignore fluid  = "} << Ignore\_fluid\_loading<< std::endl;
  oomph\_info << \textcolor{stringliteral}{"-------------------------------------------"}
             << std::endl << std::endl;
 \}

\}\textcolor{comment}{// end\_of\_namespace}

\end{DoxyCodeInclude}




 

\hypertarget{index_driver}{}\section{The driver code}\label{index_driver}
The driver code has the usual structure, though in this case we use the command line arguments to indicate which case (F\+S\+I1, F\+S\+I2, F\+S\+I3, C\+S\+M1 or C\+S\+M2) to run. The absence of a command line argument is interpreted as the code being run as part of {\ttfamily oomph-\/lib\textquotesingle{}s} self-\/test procedure in which case we perform a computation with the parameter values for case F\+S\+I1 and perform only a few timesteps.


\begin{DoxyCodeInclude}
\textcolor{comment}{//=======start\_of\_main==================================================}
\textcolor{comment}{/// Driver }
\textcolor{comment}{}\textcolor{comment}{//======================================================================}
\textcolor{keywordtype}{int} \hyperlink{turek__flag_8cc_a0ddf1224851353fc92bfbff6f499fa97}{main}(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char}* argv[])
\{
 \textcolor{comment}{// Store command line arguments}
 CommandLineArgs::setup(argc,argv);

 \textcolor{comment}{// Get case id as string}
 \textcolor{keywordtype}{string} case\_id=\textcolor{stringliteral}{"FSI1"};
 \textcolor{keywordflow}{if} (CommandLineArgs::Argc==1)
  \{
   oomph\_info << \textcolor{stringliteral}{"No command line arguments; running self-test FSI1"} 
              << std::endl;
  \}
 \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (CommandLineArgs::Argc==2)
  \{
   case\_id=CommandLineArgs::Argv[1];
  \}
 \textcolor{keywordflow}{else}
  \{
   oomph\_info << \textcolor{stringliteral}{"Wrong number of command line arguments"} << std::endl;
   oomph\_info << \textcolor{stringliteral}{"Enter none (for default) or one (namely the case id"} 
              << std::endl;
   oomph\_info << \textcolor{stringliteral}{"which should be one of: FSI1, FSI2, FSI3, CSM1"} 
              << std::endl;
  \} 
 std::cout << \textcolor{stringliteral}{"Running case "} << case\_id << std::endl;

\end{DoxyCodeInclude}


We set up the global parameter values, create a {\ttfamily Doc\+Info} object and trace file to record the output, and build the problem.


\begin{DoxyCodeInclude}

 \textcolor{comment}{// Setup parameters for case identified by command line}
 \textcolor{comment}{// argument}
 \hyperlink{namespaceGlobal__Parameters_a8c333f9041cad78d5c0160a8e2c169f5}{Global\_Parameters::set\_parameters}(case\_id);

 \textcolor{comment}{// Prepare output}
 DocInfo doc\_info;
 ofstream trace\_file; 
 doc\_info.set\_directory(\textcolor{stringliteral}{"RESLT"});
 trace\_file.open(\textcolor{stringliteral}{"RESLT/trace.dat"});
 
 \textcolor{comment}{// Length and height of domain}
 \textcolor{keywordtype}{double} length=25.0;
 \textcolor{keywordtype}{double} height=4.1;

 \textcolor{comment}{//Set up the problem}
 \hyperlink{classTurekProblem}{TurekProblem<AlgebraicElement<RefineableQTaylorHoodElement<2>}
       >,
  RefineableQPVDElement<2,3> > problem(length, height);

\end{DoxyCodeInclude}


Next, we choose the number of timesteps (using a smaller number for a validation run, and for the case F\+S\+I1 in which the system rapidly approaches a steady state) and initialise the time-\/stepping for an impulsive start from the zero flow solution.


\begin{DoxyCodeInclude}

 \textcolor{comment}{// Default number of timesteps}
 \textcolor{keywordtype}{unsigned} nstep=4000;
 \textcolor{keywordflow}{if} (\hyperlink{namespaceGlobal__Parameters_a887474a9be53363806b4de417f660dba}{Global\_Parameters::Case\_ID}==\textcolor{stringliteral}{"FSI1"})
  \{
   std::cout << \textcolor{stringliteral}{"Reducing number of steps for FSI1 "} << std::endl;
   nstep=400;
  \}

 \textcolor{keywordflow}{if} (CommandLineArgs::Argc==1)
  \{
   std::cout << \textcolor{stringliteral}{"Reducing number of steps for validation "} << std::endl;
   nstep=2;
  \}

 \textcolor{comment}{//Timestep: }
 \textcolor{keywordtype}{double} dt=\hyperlink{namespaceGlobal__Parameters_ab29c9f716872de235c78e62bce2c4109}{Global\_Parameters::Dt};

 \textcolor{comment}{// Initialise timestep }
 problem.initialise\_dt(dt);

 \textcolor{comment}{// Impulsive start}
 problem.assign\_initial\_values\_impulsive(dt);

\end{DoxyCodeInclude}


Finally, we document the initial condition and start the time-\/stepping procedure, setting the {\ttfamily first} flag to {\ttfamily false} because we have not specified an analytical expression for the initial conditions that could be re-\/assigned after the mesh adaptation when computing the first timestep.


\begin{DoxyCodeInclude}

 \textcolor{comment}{// Doc the initial condition}
 problem.doc\_solution(doc\_info,trace\_file);
 doc\_info.number()++; 
 
 \textcolor{comment}{// Don't re-set the initial conditions when adapting during first}
 \textcolor{comment}{// timestep}
 \textcolor{keywordtype}{bool} first = \textcolor{keyword}{false};
 
 \textcolor{comment}{// Max number of adaptation for time-stepping}
 \textcolor{keywordtype}{unsigned} max\_adapt=1;
 
 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} i=0;i<nstep;i++)
  \{ 
  \textcolor{comment}{// Solve the problem}
  problem.unsteady\_newton\_solve(dt,max\_adapt,first); 
  
  \textcolor{comment}{// Output the solution}
  problem.doc\_solution(doc\_info,trace\_file);
  
  \textcolor{comment}{// Step number}
  doc\_info.number()++;
 \}
 
 trace\_file.close(); 

\}\textcolor{comment}{//end of main}

\end{DoxyCodeInclude}




 

\hypertarget{index_problem}{}\section{The Problem class}\label{index_problem}
The {\ttfamily Problem} class contains the usual member functions, such as access functions to the various meshes. Because the nodal positions are updated by an algebraic node-\/update procedure, the function {\ttfamily actions\+\_\+before\+\_\+newton\+\_\+convergence\+\_\+check()} is employed to update the nodal positions in response to changes in the (solid) variables during the Newton iteration. The function {\ttfamily actions\+\_\+before\+\_\+implicit\+\_\+timestep()} is used to adjust the influx during the start-\/up period.

 
\begin{DoxyCodeInclude}
\textcolor{comment}{//====start\_of\_problem\_class=========================================== }
\textcolor{comment}{/// Problem class}
\textcolor{comment}{}\textcolor{comment}{//====================================================================== }
\textcolor{keyword}{template}< \textcolor{keyword}{class} FLUID\_ELEMENT,\textcolor{keyword}{class} SOLID\_ELEMENT >
\textcolor{keyword}{class }\hyperlink{classTurekProblem}{TurekProblem} : \textcolor{keyword}{public} Problem
\{

\textcolor{keyword}{public}:
\textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Constructor: Pass length and height of domain}
\textcolor{comment}{} \hyperlink{classTurekProblem_a69f6624fd854393f0c0e5303603ec749}{TurekProblem}(\textcolor{keyword}{const} \textcolor{keywordtype}{double} &length, \textcolor{keyword}{const} \textcolor{keywordtype}{double} &height);
 \textcolor{comment}{}
\textcolor{comment}{ /// Access function for the fluid mesh }
\textcolor{comment}{} RefineableAlgebraicCylinderWithFlagMesh<FLUID\_ELEMENT>* \hyperlink{classTurekProblem_a0fc23b86efec256cb7f4450a928f7999}{fluid\_mesh\_pt}() 
  \{ \textcolor{keywordflow}{return} \hyperlink{classTurekProblem_a18a0daace5dc50db4b93879e4a600e6a}{Fluid\_mesh\_pt};\}
\textcolor{comment}{}
\textcolor{comment}{ /// Access function for the solid mesh}
\textcolor{comment}{} ElasticRefineableRectangularQuadMesh<SOLID\_ELEMENT>*& \hyperlink{classTurekProblem_a89430ae6d87a85a83e23e14e0b0d72b7}{solid\_mesh\_pt}() 
  \{\textcolor{keywordflow}{return} \hyperlink{classTurekProblem_a1a449088ae3cc96ade1c58979294afed}{Solid\_mesh\_pt};\} 
\textcolor{comment}{}
\textcolor{comment}{ /// Access function for the i-th mesh of FSI traction elements}
\textcolor{comment}{} SolidMesh*& \hyperlink{classTurekProblem_a93a4b3d4e598a499631e00cfa701ee3c}{traction\_mesh\_pt}(\textcolor{keyword}{const} \textcolor{keywordtype}{unsigned}& i)
  \{\textcolor{keywordflow}{return} \hyperlink{classTurekProblem_a0b8588d0f133ffb9a281c5747786f95f}{Traction\_mesh\_pt}[i];\} 
 \textcolor{comment}{}
\textcolor{comment}{ /// Actions after adapt: Re-setup the fsi lookup scheme}
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{classTurekProblem_a39df0332d7606a5befe89bb0e581184b}{actions\_after\_adapt}();
\textcolor{comment}{}
\textcolor{comment}{ /// Doc the solution}
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{classTurekProblem_a2cf0eb1610b4c3a7cdbd3c7948cdd46e}{doc\_solution}(DocInfo& doc\_info, ofstream& trace\_file);
\textcolor{comment}{}
\textcolor{comment}{ /// Update function (empty)}
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{classTurekProblem_ae97d3bad44e12274168e883c966b3983}{actions\_after\_newton\_solve}() \{\}
\textcolor{comment}{}
\textcolor{comment}{ /// Update function (empty)}
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{classTurekProblem_a889518fdaf0c4215e21981afbfc669bd}{actions\_before\_newton\_solve}()\{\}
\textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Update the (enslaved) fluid node positions following the}
\textcolor{comment}{ /// update of the solid variables before performing Newton convergence}
\textcolor{comment}{ /// check}
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{classTurekProblem_aa896171b1a817ca35cba9b723bb15ed2}{actions\_before\_newton\_convergence\_check}();
\textcolor{comment}{}
\textcolor{comment}{ /// Update the time-dependent influx}
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{classTurekProblem_a4ad226ceec27cb3c3ea4d1ecfd4e573f}{actions\_before\_implicit\_timestep}();

\textcolor{keyword}{private}:
\textcolor{comment}{}
\textcolor{comment}{ /// Create FSI traction elements}
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{classTurekProblem_ad460a2e860c9425297cf70ee125de10b}{create\_fsi\_traction\_elements}();
\textcolor{comment}{}
\textcolor{comment}{ /// Pointer to solid mesh}
\textcolor{comment}{} ElasticRefineableRectangularQuadMesh<SOLID\_ELEMENT>* \hyperlink{classTurekProblem_a1a449088ae3cc96ade1c58979294afed}{Solid\_mesh\_pt};
\textcolor{comment}{}
\textcolor{comment}{ ///Pointer to fluid mesh}
\textcolor{comment}{} RefineableAlgebraicCylinderWithFlagMesh<FLUID\_ELEMENT>* \hyperlink{classTurekProblem_a18a0daace5dc50db4b93879e4a600e6a}{Fluid\_mesh\_pt};
\textcolor{comment}{}
\textcolor{comment}{ /// Vector of pointers to mesh of FSI traction elements}
\textcolor{comment}{} Vector<SolidMesh*> \hyperlink{classTurekProblem_a0b8588d0f133ffb9a281c5747786f95f}{Traction\_mesh\_pt};
\textcolor{comment}{}
\textcolor{comment}{ /// Combined mesh of traction elements -- only used for documentation}
\textcolor{comment}{} SolidMesh* \hyperlink{classTurekProblem_ac61477b19dfaaba6fb2c7a5c72240ac6}{Combined\_traction\_mesh\_pt};
\textcolor{comment}{}
\textcolor{comment}{ /// Overall height of domain}
\textcolor{comment}{} \textcolor{keywordtype}{double} \hyperlink{classTurekProblem_a24d68af05e815f7164e30f53ce7357ce}{Domain\_height};
\textcolor{comment}{}
\textcolor{comment}{ /// Overall length of domain}
\textcolor{comment}{} \textcolor{keywordtype}{double} \hyperlink{classTurekProblem_aff485942ff327ccfcafd3608910ef635}{Domain\_length};
\textcolor{comment}{}
\textcolor{comment}{ /// Pointer to solid control node}
\textcolor{comment}{} Node* \hyperlink{classTurekProblem_ad65b9a2f833ed9bae3520980c76d1f2f}{Solid\_control\_node\_pt};
\textcolor{comment}{}
\textcolor{comment}{ /// Pointer to fluid control node}
\textcolor{comment}{} Node* \hyperlink{classTurekProblem_a3d297a52fffd79bb7083fd57c2574fff}{Fluid\_control\_node\_pt};
 
\};\textcolor{comment}{// end\_of\_problem\_class}

\end{DoxyCodeInclude}




 

\hypertarget{index_constructor}{}\section{The problem constructor}\label{index_constructor}
We start by building the solid mesh, using an initial discretisation with 20 x 2 elements in the x-\/ and y-\/directions. (The length of the flag is determined such that it emanates from its intersection with the cylinder and ends at x=6; The {\ttfamily origin} vector shifts the \char`\"{}lower left\char`\"{} vertex of the solid mesh so that its centreline is aligned with the cylinder.)


\begin{DoxyCodeInclude}
\textcolor{comment}{//=====start\_of\_constructor============================================= }
\textcolor{comment}{/// Constructor: Pass length and height of domain}
\textcolor{comment}{}\textcolor{comment}{//====================================================================== }
\textcolor{keyword}{template}< \textcolor{keyword}{class} FLUID\_ELEMENT,\textcolor{keyword}{class} SOLID\_ELEMENT >
\hyperlink{classTurekProblem_a69f6624fd854393f0c0e5303603ec749}{TurekProblem<FLUID\_ELEMENT,SOLID\_ELEMENT>::}
\hyperlink{classTurekProblem_a69f6624fd854393f0c0e5303603ec749}{TurekProblem}(\textcolor{keyword}{const} \textcolor{keywordtype}{double} &length,
             \textcolor{keyword}{const} \textcolor{keywordtype}{double} &height) :  Domain\_height(height),
                                      Domain\_length(length)
 
\{
 \textcolor{comment}{// Increase max. number of iterations in Newton solver to}
 \textcolor{comment}{// accomodate possible poor initial guesses}
 Max\_newton\_iterations=20;
 Max\_residuals=1.0e4;

 \textcolor{comment}{// Build solid mesh}
 \textcolor{comment}{//------------------}

 \textcolor{comment}{// # of elements in x-direction}
 \textcolor{keywordtype}{unsigned} n\_x=20;

 \textcolor{comment}{// # of elements in y-direction}
 \textcolor{keywordtype}{unsigned} n\_y=2;

 \textcolor{comment}{// Domain length in y-direction }
 \textcolor{keywordtype}{double} l\_y=\hyperlink{namespaceGlobal__Parameters_ab360628e7830e43e355ce5768f6d6a6c}{Global\_Parameters::H};

 \textcolor{comment}{// Create the flag timestepper (consistent with BDF<2> for fluid)}
 Newmark<2>* flag\_time\_stepper\_pt=\textcolor{keyword}{new} Newmark<2>;
 add\_time\_stepper\_pt(flag\_time\_stepper\_pt); 
\textcolor{comment}{}
\textcolor{comment}{ /// Left point on centreline of flag so that the top and bottom}
\textcolor{comment}{ /// vertices merge with the cylinder.}
\textcolor{comment}{} Vector<double> origin(2);
 origin[0]=Global\_Parameters::Centre\_x+
  Global\_Parameters::Radius*
  sqrt(1.0-Global\_Parameters::H*Global\_Parameters::H/
       (4.0*Global\_Parameters::Radius*Global\_Parameters::Radius));
 origin[1]=Global\_Parameters::Centre\_y-0.5*l\_y;

 \textcolor{comment}{// Set length of flag so that endpoint actually stretches all the}
 \textcolor{comment}{// way to x=6:}
 \textcolor{keywordtype}{double} l\_x=6.0-origin[0];

 \textcolor{comment}{//Now create the mesh}
 solid\_mesh\_pt() = \textcolor{keyword}{new} ElasticRefineableRectangularQuadMesh<SOLID\_ELEMENT>(
  n\_x,n\_y,l\_x,l\_y,origin,flag\_time\_stepper\_pt);

\end{DoxyCodeInclude}


We create an error estimator for the solid mesh and identify a control node at the tip of the flag to track its motion.


\begin{DoxyCodeInclude}
 
 \textcolor{comment}{// Set error estimator for the solid mesh}
 Z2ErrorEstimator* solid\_error\_estimator\_pt=\textcolor{keyword}{new} Z2ErrorEstimator;
 solid\_mesh\_pt()->spatial\_error\_estimator\_pt()=solid\_error\_estimator\_pt;


 \textcolor{comment}{// Element that contains the control point}
 FiniteElement* el\_pt=solid\_mesh\_pt()->finite\_element\_pt(n\_x*n\_y/2-1);

 \textcolor{comment}{// How many nodes does it have?}
 \textcolor{keywordtype}{unsigned} nnod=el\_pt->nnode();

 \textcolor{comment}{// Get the control node}
 Solid\_control\_node\_pt=el\_pt->node\_pt(nnod-1);

 std::cout << \textcolor{stringliteral}{"Coordinates of solid control point "} 
           << Solid\_control\_node\_pt->x(0) << \textcolor{stringliteral}{" "} 
           << Solid\_control\_node\_pt->x(1) << \textcolor{stringliteral}{" "} << std::endl;

\end{DoxyCodeInclude}


Finally, we perform one uniform mesh refinement and disable any further mesh adaptation.


\begin{DoxyCodeInclude}

 \textcolor{comment}{// Refine the mesh uniformly}
 solid\_mesh\_pt()->refine\_uniformly();

 \textcolor{comment}{//Do not allow the solid mesh to be refined again}
 solid\_mesh\_pt()->disable\_adaptation();

\end{DoxyCodeInclude}


Next, we attach {\ttfamily F\+S\+I\+Solid\+Traction\+Elements} to the boundaries of the solid mesh that are exposed to the fluid. We complete their build by specifying which boundary of the bulk mesh they are attached to, as this information is required when setting up the fluid-\/structure interaction; see \hyperlink{index_com_ex}{Further comments and exercises}.


\begin{DoxyCodeInclude}


 \textcolor{comment}{// Build mesh of solid traction elements that apply the fluid}
 \textcolor{comment}{//------------------------------------------------------------}
 \textcolor{comment}{// traction to the solid elements}
 \textcolor{comment}{//-------------------------------}

 \textcolor{comment}{// Create storage for Meshes of FSI traction elements at the bottom}
 \textcolor{comment}{// top and left boundaries of the flag}
 Traction\_mesh\_pt.resize(3);
 
 \textcolor{comment}{// Now construct the traction element meshes}
 Traction\_mesh\_pt[0]=\textcolor{keyword}{new} SolidMesh;
 Traction\_mesh\_pt[1]=\textcolor{keyword}{new} SolidMesh;
 Traction\_mesh\_pt[2]=\textcolor{keyword}{new} SolidMesh;

 \textcolor{comment}{// Build the FSI traction elements}
 create\_fsi\_traction\_elements();

 \textcolor{comment}{// Loop over traction elements, pass the FSI parameter and tell them }
 \textcolor{comment}{// the boundary number in the bulk solid mesh -- this is required so }
 \textcolor{comment}{// they can get access to the boundary coordinates!}
 \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} bound=0;bound<3;bound++)
  \{
   \textcolor{keywordtype}{unsigned} n\_face\_element = Traction\_mesh\_pt[bound]->nelement();
   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} e=0;e<n\_face\_element;e++)
    \{
     \textcolor{comment}{//Cast the element pointer and specify boundary number}
     FSISolidTractionElement<SOLID\_ELEMENT,2>* elem\_pt=
     \textcolor{keyword}{dynamic\_cast<}FSISolidTractionElement<SOLID\_ELEMENT,2>*\textcolor{keyword}{>}
      (Traction\_mesh\_pt[bound]->element\_pt(e));

     \textcolor{comment}{// Specify boundary number}
     elem\_pt->set\_boundary\_number\_in\_bulk\_mesh(bound);

     \textcolor{comment}{// Function that specifies the load ratios}
     elem\_pt->q\_pt() = &\hyperlink{namespaceGlobal__Parameters_a7814fddf663e56168174a42d2cd6b4c1}{Global\_Parameters::Q};
    
    \}
  \} \textcolor{comment}{// build of FSISolidTractionElements is complete}

\end{DoxyCodeInclude}


Finally, we create {\ttfamily Geom\+Object} representations of the three surface meshes of {\ttfamily F\+S\+I\+Solid\+Traction\+Elements}. We will use these to represent the curvilinear, moving boundaries of the fluid mesh.


\begin{DoxyCodeInclude}


 \textcolor{comment}{// Turn the three meshes of FSI traction elements into compound}
 \textcolor{comment}{// geometric objects (one Lagrangian, two Eulerian coordinates)}
 \textcolor{comment}{// that determine the boundary of the fluid mesh}
 MeshAsGeomObject*
  bottom\_flag\_pt=
  \textcolor{keyword}{new} MeshAsGeomObject
  (Traction\_mesh\_pt[0]);
 
 MeshAsGeomObject* tip\_flag\_pt=
  \textcolor{keyword}{new} MeshAsGeomObject
  (Traction\_mesh\_pt[1]);
 
 MeshAsGeomObject* top\_flag\_pt=
  \textcolor{keyword}{new} MeshAsGeomObject
  (Traction\_mesh\_pt[2]);

\end{DoxyCodeInclude}


The final mesh to be built is the fluid mesh whose constructor requires pointers to the four {\ttfamily Geom\+Objects} that represent the cylinder and three fluid-\/loaded faces of the flag, respectively. We represent the cylinder by a {\ttfamily Circle} object\+:


\begin{DoxyCodeInclude}


 \textcolor{comment}{// Build fluid mesh}
 \textcolor{comment}{//-----------------}

 \textcolor{comment}{//Create a new Circle object as the central cylinder}
 Circle* cylinder\_pt = \textcolor{keyword}{new} Circle(Global\_Parameters::Centre\_x,
                                  Global\_Parameters::Centre\_y,
                                  Global\_Parameters::Radius);

\end{DoxyCodeInclude}


We build the mesh and identify a control node (a node at the upstream face of the cylinder), before creating an error estimator and performing one uniform mesh refinement.


\begin{DoxyCodeInclude}

 \textcolor{comment}{// Allocate the fluid timestepper}
 BDF<2>* fluid\_time\_stepper\_pt=\textcolor{keyword}{new} BDF<2>;
 add\_time\_stepper\_pt(fluid\_time\_stepper\_pt);
 
 \textcolor{comment}{// Build fluid mesh}
 Fluid\_mesh\_pt=
  \textcolor{keyword}{new} RefineableAlgebraicCylinderWithFlagMesh<FLUID\_ELEMENT>
  (cylinder\_pt, 
   top\_flag\_pt,
   bottom\_flag\_pt,
   tip\_flag\_pt,
   length, height, 
   l\_x,\hyperlink{namespaceGlobal__Parameters_ab360628e7830e43e355ce5768f6d6a6c}{Global\_Parameters::H},
   \hyperlink{namespaceGlobal__Parameters_a0f0247cc83ba202413b50e7b4b7fceb0}{Global\_Parameters::Centre\_x},
   \hyperlink{namespaceGlobal__Parameters_af41282d812fdff4867e3d8c825886290}{Global\_Parameters::Centre\_y},
   \hyperlink{namespaceGlobal__Parameters_a126c1e491ef187867b6b7bfb52b476ad}{Global\_Parameters::Radius},
   fluid\_time\_stepper\_pt);
 

 \textcolor{comment}{// I happen to have found out by inspection that}
 \textcolor{comment}{// node 5 in the hand-coded fluid mesh is at the }
 \textcolor{comment}{// upstream tip of the cylinder}
 Fluid\_control\_node\_pt=Fluid\_mesh\_pt->node\_pt(5);

 \textcolor{comment}{// Set error estimator for the fluid mesh}
 Z2ErrorEstimator* fluid\_error\_estimator\_pt=\textcolor{keyword}{new} Z2ErrorEstimator;
 fluid\_mesh\_pt()->spatial\_error\_estimator\_pt()=fluid\_error\_estimator\_pt;

 \textcolor{comment}{// Refine uniformly}
 Fluid\_mesh\_pt->refine\_uniformly();

\end{DoxyCodeInclude}


We now add the various meshes to the {\ttfamily Problem\textquotesingle{}s} collection of sub-\/meshes and combine them to a global mesh


\begin{DoxyCodeInclude}


 \textcolor{comment}{// Build combined global mesh}
 \textcolor{comment}{//---------------------------}

 \textcolor{comment}{// Add Solid mesh the problem's collection of submeshes}
 add\_sub\_mesh(solid\_mesh\_pt());

 \textcolor{comment}{// Add traction sub-meshes}
 \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} i=0;i<3;i++)
  \{
   add\_sub\_mesh(traction\_mesh\_pt(i));
  \}

 \textcolor{comment}{// Add fluid mesh}
 add\_sub\_mesh(fluid\_mesh\_pt());
 
 \textcolor{comment}{// Build combined "global" mesh}
 build\_global\_mesh();

\end{DoxyCodeInclude}


The application of boundary conditions for the solid are straightforward\+: All displacements of the flag\textquotesingle{}s left end (mesh boundary 3) are suppressed; the other faces are free. Strictly speaking, the pinning of the redundant solid pressure nodes is superfluous since the {\ttfamily Refineable\+Q\+P\+V\+D\+Element} used for the discretisation of the flag employ a displacement-\/based formulation, but it is good practise to perform this step anyway to \char`\"{}future-\/proof\char`\"{} the code for the use of other element types.


\begin{DoxyCodeInclude}
 


 \textcolor{comment}{// Apply solid boundary conditons}
 \textcolor{comment}{//-------------------------------}
 
 \textcolor{comment}{//Solid mesh: Pin the left boundary (boundary 3) in both directions}
 \textcolor{keywordtype}{unsigned} n\_side = mesh\_pt()->nboundary\_node(3);
 
 \textcolor{comment}{//Loop over the nodes}
 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} i=0;i<n\_side;i++)
  \{
   solid\_mesh\_pt()->boundary\_node\_pt(3,i)->pin\_position(0);
   solid\_mesh\_pt()->boundary\_node\_pt(3,i)->pin\_position(1);
  \}
 
 \textcolor{comment}{// Pin the redundant solid pressures (if any)}
 PVDEquationsBase<2>::pin\_redundant\_nodal\_solid\_pressures(
  solid\_mesh\_pt()->element\_pt());

\end{DoxyCodeInclude}


The fluid has Dirichlet boundary conditions (prescribed velocity) everywhere apart from the outflow where only the horizontal velocity is unknown.


\begin{DoxyCodeInclude}
 
 \textcolor{comment}{// Apply fluid boundary conditions}
 \textcolor{comment}{//--------------------------------}
 
 \textcolor{comment}{//Fluid mesh: Horizontal, traction-free outflow; pinned elsewhere}
 \textcolor{keywordtype}{unsigned} num\_bound = fluid\_mesh\_pt()->nboundary();
 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} ibound=0;ibound<num\_bound;ibound++)
  \{
   \textcolor{keywordtype}{unsigned} num\_nod= fluid\_mesh\_pt()->nboundary\_node(ibound);
   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} inod=0;inod<num\_nod;inod++)
    \{
     \textcolor{comment}{// Parallel, axially traction free outflow at downstream end}
     \textcolor{keywordflow}{if} (ibound != 1)
      \{
       fluid\_mesh\_pt()->boundary\_node\_pt(ibound,inod)->pin(0);
       fluid\_mesh\_pt()->boundary\_node\_pt(ibound,inod)->pin(1);
      \}
     \textcolor{keywordflow}{else}
      \{
       fluid\_mesh\_pt()->boundary\_node\_pt(ibound,inod)->pin(1);
      \}
    \}
  \}\textcolor{comment}{//end\_of\_pin}
 
 \textcolor{comment}{// Pin redundant pressure dofs in fluid mesh}
 RefineableNavierStokesEquations<2>::
  pin\_redundant\_nodal\_pressures(fluid\_mesh\_pt()->element\_pt());

\end{DoxyCodeInclude}


We impose a parabolic inflow profile with the current value of the influx at the inlet (fluid mesh boundary 3).


\begin{DoxyCodeInclude}


 \textcolor{comment}{// Apply boundary conditions for fluid}
 \textcolor{comment}{//-------------------------------------}

 \textcolor{comment}{// Impose parabolic flow along boundary 3}
 \textcolor{comment}{// Current flow rate}
 \textcolor{keywordtype}{double} t=0.0;
 \textcolor{keywordtype}{double} ampl=\hyperlink{namespaceGlobal__Parameters_a536aa5314a6cdb36af852e9513351d55}{Global\_Parameters::flux}(t);
 \textcolor{keywordtype}{unsigned} ibound=3; 
 \textcolor{keywordtype}{unsigned} num\_nod= Fluid\_mesh\_pt->nboundary\_node(ibound);
 \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} inod=0;inod<num\_nod;inod++)
  \{
   \textcolor{keywordtype}{double} ycoord = Fluid\_mesh\_pt->boundary\_node\_pt(ibound,inod)->x(1); 
   \textcolor{keywordtype}{double} uy = ampl*6.0*ycoord/Domain\_height*(1.0-ycoord/Domain\_height);
   Fluid\_mesh\_pt->boundary\_node\_pt(ibound,inod)->set\_value(0,uy);
   Fluid\_mesh\_pt->boundary\_node\_pt(ibound,inod)->set\_value(1,0.0);    
  \}

\end{DoxyCodeInclude}


We complete the build of the solid elements by passing them the pointer to the constitutive equation, the gravity vector and the timescale ratio\+:


\begin{DoxyCodeInclude}
 

 \textcolor{comment}{// Complete build of solid elements}
 \textcolor{comment}{//---------------------------------}

 \textcolor{comment}{//Pass problem parameters to solid elements}
 \textcolor{keywordtype}{unsigned}  n\_element =solid\_mesh\_pt()->nelement();
 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} i=0;i<n\_element;i++)
  \{
   \textcolor{comment}{//Cast to a solid element}
   SOLID\_ELEMENT *el\_pt = \textcolor{keyword}{dynamic\_cast<}SOLID\_ELEMENT*\textcolor{keyword}{>}(
    solid\_mesh\_pt()->element\_pt(i));
   
   \textcolor{comment}{// Set the constitutive law}
   el\_pt->constitutive\_law\_pt() =
    \hyperlink{namespaceGlobal__Parameters_adbd1f040f375c96fe56b3f475f7dbec2}{Global\_Parameters::Constitutive\_law\_pt};
   
   \textcolor{comment}{//Set the body force}
   el\_pt->body\_force\_fct\_pt() = \hyperlink{namespaceGlobal__Parameters_a200109847bf4cc26da4d00e8d68d569e}{Global\_Parameters::gravity};

   \textcolor{comment}{// Timescale ratio for solid}
   el\_pt->lambda\_sq\_pt() = &\hyperlink{namespaceGlobal__Parameters_a3e3428638f89f970fcf2148b0bab1465}{Global\_Parameters::Lambda\_sq};
  \}

\end{DoxyCodeInclude}


The fluid elements require pointers to the Reynolds and Womersley (product of Reynolds and Strouhal) numbers\+:


\begin{DoxyCodeInclude}
 
 

 \textcolor{comment}{// Complete build of fluid elements}
 \textcolor{comment}{//---------------------------------}

 \textcolor{comment}{// Set physical parameters in the fluid mesh}
 \textcolor{keywordtype}{unsigned} nelem=fluid\_mesh\_pt()->nelement();
 \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} e=0;e<nelem;e++)
  \{
   \textcolor{comment}{// Upcast from GeneralisedElement to the present element}
   FLUID\_ELEMENT* el\_pt = \textcolor{keyword}{dynamic\_cast<}FLUID\_ELEMENT*\textcolor{keyword}{>}
    (fluid\_mesh\_pt()->element\_pt(e));
   
   \textcolor{comment}{//Set the Reynolds number}
   el\_pt->re\_pt() = &\hyperlink{namespaceGlobal__Parameters_a9d72e94a9305c6a310940a6a427ebe06}{Global\_Parameters::Re};   
   
   \textcolor{comment}{//Set the Womersley number}
   el\_pt->re\_st\_pt() = &\hyperlink{namespaceGlobal__Parameters_a7a59a32365e87566069e458dc83bd18a}{Global\_Parameters::ReSt};
   
  \}\textcolor{comment}{//end\_of\_loop}

\end{DoxyCodeInclude}


Setting up the fluid-\/structure interaction is done from \char`\"{}both\char`\"{} sides" of the fluid-\/solid interface\+: First we ensure that the no-\/slip condition is automatically applied to all fluid nodes that are located on the three faces of the flag (mesh boundaries 5, 6 and 7). This is done by passing the function pointer to the {\ttfamily F\+S\+I\+\_\+functions\+::apply\+\_\+no\+\_\+slip\+\_\+on\+\_\+moving\+\_\+wall()} function to the relevant fluid nodes (\href{../../../navier_stokes/osc_ellipse/html/index.html}{\tt recall} that the auxiliary node update functions are automatically executed whenever the position of a node is updated by the algebraic node update). Since the no-\/slip condition (1) involves the Strouhal number (which, in the current problem, is not equal to the default value of {\ttfamily F\+S\+I\+\_\+functions\+::\+Strouhal\+\_\+for\+\_\+no\+\_\+slip=1.\+0}), we overwrite the default assignment with the actual Strouhal number in the problem.


\begin{DoxyCodeInclude}



 \textcolor{comment}{// Setup FSI}
 \textcolor{comment}{//----------}
 
 \textcolor{comment}{// Pass Strouhal number to the helper function that automatically applies}
 \textcolor{comment}{// the no-slip condition}
 FSI\_functions::Strouhal\_for\_no\_slip=\hyperlink{namespaceGlobal__Parameters_af1af40a0df651e86bc1be273fafa98da}{Global\_Parameters::St};

 \textcolor{comment}{// The velocity of the fluid nodes on the wall (fluid mesh boundary 5,6,7)}
 \textcolor{comment}{// is set by the wall motion -- hence the no-slip condition must be}
 \textcolor{comment}{// re-applied whenever a node update is performed for these nodes. }
 \textcolor{comment}{// Such tasks may be performed automatically by the auxiliary node update }
 \textcolor{comment}{// function specified by a function pointer:}
 \textcolor{keywordflow}{if} (!\hyperlink{namespaceGlobal__Parameters_aac13d615d2acd78d22a3137ffd62f7aa}{Global\_Parameters::Ignore\_fluid\_loading})
  \{
   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} ibound=5;ibound<8;ibound++ )
    \{ 
     \textcolor{keywordtype}{unsigned} num\_nod= Fluid\_mesh\_pt->nboundary\_node(ibound);
     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} inod=0;inod<num\_nod;inod++)
      \{   
       Fluid\_mesh\_pt->boundary\_node\_pt(ibound, inod)->
        set\_auxiliary\_node\_update\_fct\_pt(
         FSI\_functions::apply\_no\_slip\_on\_moving\_wall);
      \}
    \} \textcolor{comment}{// done automatic application of no-slip}

\end{DoxyCodeInclude}


Next, we set up the lookup schemes required by the {\ttfamily F\+S\+I\+Solid\+Traction\+Elements} to establish which fluid elements affect the traction onto the solid\+:


\begin{DoxyCodeInclude}
  
   \textcolor{comment}{// Work out which fluid dofs affect the residuals of the wall elements:}
   \textcolor{comment}{// We pass the boundary between the fluid and solid meshes and }
   \textcolor{comment}{// pointers to the meshes. The interaction boundary are boundaries 5,6,7}
   \textcolor{comment}{// of the 2D fluid mesh.}
   FSI\_functions::setup\_fluid\_load\_info\_for\_solid\_elements<FLUID\_ELEMENT,2>
    (\textcolor{keyword}{this},5,Fluid\_mesh\_pt,Traction\_mesh\_pt[0]);  
   
   FSI\_functions::setup\_fluid\_load\_info\_for\_solid\_elements<FLUID\_ELEMENT,2>
    (\textcolor{keyword}{this},6,Fluid\_mesh\_pt,Traction\_mesh\_pt[2]);  
   
   FSI\_functions::setup\_fluid\_load\_info\_for\_solid\_elements<FLUID\_ELEMENT,2>
    (\textcolor{keyword}{this},7,Fluid\_mesh\_pt,Traction\_mesh\_pt[1]); 
  \} 

\end{DoxyCodeInclude}


All interactions have now been specified and we conclude by assigning the equation numbers


\begin{DoxyCodeInclude}
 \textcolor{comment}{// Assign equation numbers}
 cout << assign\_eqn\_numbers() << std::endl; 


\}\textcolor{comment}{//end\_of\_constructor}

\end{DoxyCodeInclude}




 

\hypertarget{index_set_traction}{}\section{Create traction elements}\label{index_set_traction}
This is a helper function that attaches {\ttfamily F\+S\+I\+Solid\+Traction\+Element} to the solid elements that are exposed to the fluid traction. We store the elements in three distinct sub-\/meshes -- one for each face. (Yet another mesh, pointed to by {\ttfamily Combined\+\_\+traction\+\_\+mesh\+\_\+pt}, is created for post-\/processing purposes.)


\begin{DoxyCodeInclude}
\textcolor{comment}{//============start\_of\_create\_traction\_elements==============================}
\textcolor{comment}{/// Create FSI traction elements }
\textcolor{comment}{}\textcolor{comment}{//=======================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} FLUID\_ELEMENT,\textcolor{keyword}{class} SOLID\_ELEMENT >
\textcolor{keywordtype}{void} \hyperlink{classTurekProblem_ad460a2e860c9425297cf70ee125de10b}{TurekProblem<FLUID\_ELEMENT,SOLID\_ELEMENT>::create\_fsi\_traction\_elements}
      ()
\{

 \textcolor{comment}{// Container to collect all nodes in the traction meshes}
 std::set<SolidNode*> all\_nodes;

 \textcolor{comment}{// Traction elements are located on boundaries 0-2:}
 \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} b=0;b<3;b++)
  \{
   \textcolor{comment}{// How many bulk elements are adjacent to boundary b?}
   \textcolor{keywordtype}{unsigned} n\_element = solid\_mesh\_pt()->nboundary\_element(b);
   
   \textcolor{comment}{// Loop over the bulk elements adjacent to boundary b?}
   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} e=0;e<n\_element;e++)
    \{
     \textcolor{comment}{// Get pointer to the bulk element that is adjacent to boundary b}
     SOLID\_ELEMENT* bulk\_elem\_pt = \textcolor{keyword}{dynamic\_cast<}SOLID\_ELEMENT*\textcolor{keyword}{>}(
      solid\_mesh\_pt()->boundary\_element\_pt(b,e));
     
     \textcolor{comment}{//What is the index of the face of the element e along boundary b}
     \textcolor{keywordtype}{int} face\_index = solid\_mesh\_pt()->face\_index\_at\_boundary(b,e);
          
     \textcolor{comment}{// Create new element and add to mesh}
     Traction\_mesh\_pt[b]->add\_element\_pt(
      \textcolor{keyword}{new} FSISolidTractionElement<SOLID\_ELEMENT,2>(bulk\_elem\_pt,face\_index));
     
    \} \textcolor{comment}{//end of loop over bulk elements adjacent to boundary b}

   \textcolor{comment}{// Identify unique nodes}
   \textcolor{keywordtype}{unsigned} nnod=solid\_mesh\_pt()->nboundary\_node(b);
   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} j=0;j<nnod;j++)
    \{
     all\_nodes.insert(solid\_mesh\_pt()->boundary\_node\_pt(b,j));
    \}
  \}

 \textcolor{comment}{// Build combined mesh of fsi traction elements}
 Combined\_traction\_mesh\_pt=\textcolor{keyword}{new} SolidMesh(Traction\_mesh\_pt);
 
 \textcolor{comment}{// Stick nodes into combined traction mesh}
 \textcolor{keywordflow}{for} (std::set<SolidNode*>::iterator it=all\_nodes.begin();
      it!=all\_nodes.end();it++)
  \{
   Combined\_traction\_mesh\_pt->add\_node\_pt(*it);
  \}

\} \textcolor{comment}{// end of create\_traction\_elements}

\end{DoxyCodeInclude}




 

 \hypertarget{index_check}{}\section{Actions before Newton convergence check}\label{index_check}
The algebraic node-\/update procedure updates the positions in response to changes in the solid displacements but this is not done automatically when the Newton solver updates the solid mechanics degrees of freedom. We therefore force a node-\/update before the Newton convergence check.

 
\begin{DoxyCodeInclude}
\textcolor{comment}{//====start\_of\_actions\_before\_newton\_convergence\_check===================}
\textcolor{comment}{/// Update the (enslaved) fluid node positions following the}
\textcolor{comment}{}\textcolor{comment}{/// update of the solid variables}
\textcolor{comment}{}\textcolor{comment}{//=======================================================================}
\textcolor{keyword}{template} <\textcolor{keyword}{class} FLUID\_ELEMENT,\textcolor{keyword}{class} SOLID\_ELEMENT> 
\textcolor{keywordtype}{void} \hyperlink{classTurekProblem_aa896171b1a817ca35cba9b723bb15ed2}{TurekProblem<FLUID\_ELEMENT,SOLID\_ELEMENT>}
\hyperlink{classTurekProblem_aa896171b1a817ca35cba9b723bb15ed2}{::actions\_before\_newton\_convergence\_check} ()
\{
 fluid\_mesh\_pt()->node\_update();
\}

\end{DoxyCodeInclude}




 

\hypertarget{index_timestep}{}\section{Actions before the timestep}\label{index_timestep}
Before each timestep we update the inflow profile for all fluid nodes on mesh boundary 3.


\begin{DoxyCodeInclude}
\textcolor{comment}{//===== start\_of\_actions\_before\_implicit\_timestep=========================}
\textcolor{comment}{/// Actions before implicit timestep: Update inflow profile}
\textcolor{comment}{}\textcolor{comment}{//========================================================================}
\textcolor{keyword}{template} <\textcolor{keyword}{class} FLUID\_ELEMENT,\textcolor{keyword}{class} SOLID\_ELEMENT> 
\textcolor{keywordtype}{void} \hyperlink{classTurekProblem_a4ad226ceec27cb3c3ea4d1ecfd4e573f}{TurekProblem<FLUID\_ELEMENT,SOLID\_ELEMENT>::}
\hyperlink{classTurekProblem_a4ad226ceec27cb3c3ea4d1ecfd4e573f}{actions\_before\_implicit\_timestep}()
\{
 \textcolor{comment}{// Current time}
 \textcolor{keywordtype}{double} t=time\_pt()->time();
 
 \textcolor{comment}{// Amplitude of flow}
 \textcolor{keywordtype}{double} ampl=\hyperlink{namespaceGlobal__Parameters_a536aa5314a6cdb36af852e9513351d55}{Global\_Parameters::flux}(t);
 
 \textcolor{comment}{// Update parabolic flow along boundary 3}
 \textcolor{keywordtype}{unsigned} ibound=3; 
 \textcolor{keywordtype}{unsigned} num\_nod= Fluid\_mesh\_pt->nboundary\_node(ibound);
 \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} inod=0;inod<num\_nod;inod++)
  \{
   \textcolor{keywordtype}{double} ycoord = Fluid\_mesh\_pt->boundary\_node\_pt(ibound,inod)->x(1); 
   \textcolor{keywordtype}{double} uy = ampl*6.0*ycoord/Domain\_height*(1.0-ycoord/Domain\_height);
   Fluid\_mesh\_pt->boundary\_node\_pt(ibound,inod)->set\_value(0,uy);
   Fluid\_mesh\_pt->boundary\_node\_pt(ibound,inod)->set\_value(1,0.0);    
  \}

\} \textcolor{comment}{//end\_of\_actions\_before\_implicit\_timestep}

\end{DoxyCodeInclude}




 

\hypertarget{index_after_adapt}{}\section{Actions after adapt}\label{index_after_adapt}
After each adaptation, we unpin and re-\/pin all redundant pressures degrees of freedom. This is necessary because their \char`\"{}redundant-\/ness\char`\"{} may have been altered by changes in the refinement pattern; see \href{../../../navier_stokes/adaptive_driven_cavity/html/index.html}{\tt another tutorial} for details. We ensure the automatic application of the no-\/slip condition on fluid nodes that are located on the faces of the flag, and re-\/setup the F\+SI lookup scheme that tells {\ttfamily F\+S\+I\+Solid\+Traction\+Elements} which fluid elements are located next to their Gauss points.


\begin{DoxyCodeInclude}
\textcolor{comment}{//=====================start\_of\_actions\_after\_adapt=======================}
\textcolor{comment}{///  Actions after adapt: Re-setup FSI}
\textcolor{comment}{}\textcolor{comment}{//========================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} FLUID\_ELEMENT,\textcolor{keyword}{class} SOLID\_ELEMENT >
\textcolor{keywordtype}{void} \hyperlink{classTurekProblem_a39df0332d7606a5befe89bb0e581184b}{TurekProblem<FLUID\_ELEMENT,SOLID\_ELEMENT>::actions\_after\_adapt}
      ()
\{
 \textcolor{comment}{// Unpin all pressure dofs}
 RefineableNavierStokesEquations<2>::
  unpin\_all\_pressure\_dofs(fluid\_mesh\_pt()->element\_pt());
 
 \textcolor{comment}{// Pin redundant pressure dofs}
 RefineableNavierStokesEquations<2>::
  pin\_redundant\_nodal\_pressures(fluid\_mesh\_pt()->element\_pt());

 \textcolor{comment}{// Unpin all solid pressure dofs}
 PVDEquationsBase<2>::
  unpin\_all\_solid\_pressure\_dofs(solid\_mesh\_pt()->element\_pt());
 
 \textcolor{comment}{// Pin the redundant solid pressures (if any)}
 PVDEquationsBase<2>::pin\_redundant\_nodal\_solid\_pressures(
  solid\_mesh\_pt()->element\_pt());


 \textcolor{comment}{// The velocity of the fluid nodes on the wall (fluid mesh boundary 5,6,7)}
 \textcolor{comment}{// is set by the wall motion -- hence the no-slip condition must be}
 \textcolor{comment}{// re-applied whenever a node update is performed for these nodes. }
 \textcolor{comment}{// Such tasks may be performed automatically by the auxiliary node update }
 \textcolor{comment}{// function specified by a function pointer:}
 \textcolor{keywordflow}{if} (!\hyperlink{namespaceGlobal__Parameters_aac13d615d2acd78d22a3137ffd62f7aa}{Global\_Parameters::Ignore\_fluid\_loading})
  \{
   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} ibound=5;ibound<8;ibound++ )
    \{ 
     \textcolor{keywordtype}{unsigned} num\_nod= Fluid\_mesh\_pt->nboundary\_node(ibound);
     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} inod=0;inod<num\_nod;inod++)
      \{   
       Fluid\_mesh\_pt->boundary\_node\_pt(ibound, inod)->
        set\_auxiliary\_node\_update\_fct\_pt(
         FSI\_functions::apply\_no\_slip\_on\_moving\_wall);
      \}
    \}
 

   \textcolor{comment}{// Re-setup the fluid load information for fsi solid traction elements}
   FSI\_functions::setup\_fluid\_load\_info\_for\_solid\_elements<FLUID\_ELEMENT,2>
    (\textcolor{keyword}{this},5,Fluid\_mesh\_pt,Traction\_mesh\_pt[0]); 
   
   FSI\_functions::setup\_fluid\_load\_info\_for\_solid\_elements<FLUID\_ELEMENT,2>
    (\textcolor{keyword}{this},6,Fluid\_mesh\_pt,Traction\_mesh\_pt[2]); 
   
   FSI\_functions::setup\_fluid\_load\_info\_for\_solid\_elements<FLUID\_ELEMENT,2>
    (\textcolor{keyword}{this},7,Fluid\_mesh\_pt,Traction\_mesh\_pt[1]); 
  \}

 
\}\textcolor{comment}{// end of actions\_after\_adapt}

\end{DoxyCodeInclude}




 

\hypertarget{index_doc}{}\section{Post-\/processing}\label{index_doc}
The function {\ttfamily doc\+\_\+solution}(...) produces the output for the fluid, solid and traction meshes and writes selected data to the trace file.


\begin{DoxyCodeInclude}
\textcolor{comment}{//=====start\_of\_doc\_solution========================================}
\textcolor{comment}{/// Doc the solution}
\textcolor{comment}{}\textcolor{comment}{//==================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} FLUID\_ELEMENT,\textcolor{keyword}{class} SOLID\_ELEMENT >
\textcolor{keywordtype}{void} \hyperlink{classTurekProblem_a2cf0eb1610b4c3a7cdbd3c7948cdd46e}{TurekProblem<FLUID\_ELEMENT,SOLID\_ELEMENT>::doc\_solution}
      (
 DocInfo& doc\_info, ofstream& trace\_file)
\{
 
\textcolor{comment}{//  FSI\_functions::doc\_fsi<AlgebraicNode>(Fluid\_mesh\_pt,}
\textcolor{comment}{//                                        Combined\_traction\_mesh\_pt,}
\textcolor{comment}{//                                        doc\_info);}

\textcolor{comment}{//  pause("done");}

 ofstream some\_file;
 \textcolor{keywordtype}{char} filename[100];

 \textcolor{comment}{// Number of plot points}
 \textcolor{keywordtype}{unsigned} n\_plot = 5; 

 \textcolor{comment}{// Output solid solution}
 sprintf(filename,\textcolor{stringliteral}{"%s/solid\_soln%i.dat"},doc\_info.directory().c\_str(),
         doc\_info.number());
 some\_file.open(filename);
 solid\_mesh\_pt()->output(some\_file,n\_plot);
 some\_file.close();
 
 \textcolor{comment}{// Output fluid solution}
 sprintf(filename,\textcolor{stringliteral}{"%s/soln%i.dat"},doc\_info.directory().c\_str(),
         doc\_info.number());
 some\_file.open(filename);
 fluid\_mesh\_pt()->output(some\_file,n\_plot);
 some\_file.close();


\textcolor{comment}{//Output the traction}
 sprintf(filename,\textcolor{stringliteral}{"%s/traction%i.dat"},doc\_info.directory().c\_str(),
         doc\_info.number());
 some\_file.open(filename);
\textcolor{comment}{// Loop over the traction meshes}
 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} i=0;i<3;i++)
  \{
   \textcolor{comment}{// Loop over the element in traction\_mesh\_pt}
   \textcolor{keywordtype}{unsigned} n\_element = Traction\_mesh\_pt[i]->nelement();
   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} e=0;e<n\_element;e++)
    \{
     FSISolidTractionElement<SOLID\_ELEMENT,2>* el\_pt = 
      \textcolor{keyword}{dynamic\_cast<}FSISolidTractionElement<SOLID\_ELEMENT,2>* \textcolor{keyword}{>} (
       Traction\_mesh\_pt[i]->element\_pt(e) );
     
     el\_pt->output(some\_file,5);
    \}
  \}
 some\_file.close();  


 \textcolor{comment}{// Write trace (we're only using Taylor Hood elements so we know that}
 \textcolor{comment}{// the pressure is the third value at the fluid control node...}
 trace\_file << time\_pt()->time() << \textcolor{stringliteral}{" "} 
            << Solid\_control\_node\_pt->x(0) << \textcolor{stringliteral}{" "} 
            << Solid\_control\_node\_pt->x(1) << \textcolor{stringliteral}{" "} 
            << Fluid\_control\_node\_pt->value(2) << \textcolor{stringliteral}{" "}
            << \hyperlink{namespaceGlobal__Parameters_a536aa5314a6cdb36af852e9513351d55}{Global\_Parameters::flux}(time\_pt()->time()) << \textcolor{stringliteral}{" "} 
            << std::endl;
 
 cout << \textcolor{stringliteral}{"Doced solution for step "} 
      << doc\_info.number() 
      << std::endl << std::endl << std::endl;

\}\textcolor{comment}{//end\_of\_doc\_solution}

\end{DoxyCodeInclude}




 

\hypertarget{index_com_ex}{}\section{Further comments and exercises}\label{index_com_ex}

\begin{DoxyItemize}
\item When completing the build of the {\ttfamily F\+S\+I\+Solid\+Traction\+Elements} (the elements that apply the fluid traction to the solid elements that are exposed to the fluid) we specified the number of the solid mesh boundary they are located on, using ~\newline
~\newline

\begin{DoxyCode}
elem\_pt->set\_boundary\_number\_in\_bulk\_mesh(bound);
\end{DoxyCode}
 ~\newline
 This information is required when setting up the fluid-\/structure interaction because the {\ttfamily Mesh\+As\+Geom\+Object} representation of the mesh of {\ttfamily F\+S\+I\+Solid\+Traction\+Elements} is parametrised by the boundary coordinate in the solid mesh. Explore the details of the implementation by commenting out the relevant line of code and use the debugger to find out how and where the code fails. {\bfseries Note\+:} Since this step is somewhat subtle and therefore easily forgotten, the {\ttfamily F\+S\+I\+Solid\+Traction\+Elements} issue an explicit warning if the bulk boundary number has not been set -- but only if the the library is compiled in P\+A\+R\+A\+N\+O\+ID mode. ~\newline
~\newline

\item When comparing our results against those in Turek \& Hron\textquotesingle{}s benchmark, we only focused on the period and amplitude of the fully-\/developed self-\/excited oscillations. The benchmark data also provides data on the time-\/dependent variations of the drag and lift coefficients. Design suitable {\ttfamily Face\+Elements} (to be attached to the faces of the Navier-\/\+Stokes elements that are adjacent to the flag or the cylinder) to compute these quantities. The \href{../../../the_data_structure/html/classoomph_1_1NavierStokesSurfacePowerElement.html}{\tt {\ttfamily Navier\+Stokes\+Surface\+Power\+Elements}} should provide a good basis for these.
\end{DoxyItemize}



 

\hypertarget{index_ackn}{}\section{Acknowledgements}\label{index_ackn}

\begin{DoxyItemize}
\item This code was originally developed by Stefan Kollmannsberger and his students Iason Papaioannou and Orkun Oezkan Doenmez. It was completed by Floraine Cordier.
\end{DoxyItemize}



 

\hypertarget{index_sources}{}\section{Source files for this tutorial}\label{index_sources}

\begin{DoxyItemize}
\item The source files for this tutorial are located in the directory\+:~\newline
~\newline
\begin{center} \href{../../../../demo_drivers/interaction/turek_flag/}{\tt demo\+\_\+drivers/interaction/turek\+\_\+flag/ } \end{center} ~\newline

\item The driver code is\+: ~\newline
~\newline
\begin{center} \href{../../../../demo_drivers/interaction/turek_flag/turek_flag.cc}{\tt demo\+\_\+drivers/interaction/turek\+\_\+flag/turek\+\_\+flag.\+cc } \end{center} 
\end{DoxyItemize}



 

 \hypertarget{index_pdf}{}\section{P\+D\+F file}\label{index_pdf}
A \href{../latex/refman.pdf}{\tt pdf version} of this document is available. \end{document}
