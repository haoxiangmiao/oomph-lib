This is a very simple fluid-\/structure interaction problem\+: We study the finite-\/\+Reynolds number internal flow generated by an oscillating ring. The wall motion only has a single degree of freedom\+: The ring\textquotesingle{}s average radius, which needs to be adjusted to conserve mass. \mbox{[}This is a warm-\/up problem for the full fluid structure interaction problem discussed in the next example\mbox{]}. We compare the predictions for the flow field against asymptotic results.

The nodal positions in the fluid domain is updated by {\ttfamily Macro\+Elements}.


\begin{DoxyCodeInclude}
\textcolor{comment}{//LIC// ====================================================================}
\textcolor{comment}{//LIC// This file forms part of oomph-lib, the object-oriented, }
\textcolor{comment}{//LIC// multi-physics finite-element library, available }
\textcolor{comment}{//LIC// at http://www.oomph-lib.org.}
\textcolor{comment}{//LIC// }
\textcolor{comment}{//LIC//    Version 1.0; svn revision $LastChangedRevision$}
\textcolor{comment}{//LIC//}
\textcolor{comment}{//LIC// $LastChangedDate$}
\textcolor{comment}{//LIC// }
\textcolor{comment}{//LIC// Copyright (C) 2006-2016 Matthias Heil and Andrew Hazel}
\textcolor{comment}{//LIC// }
\textcolor{comment}{//LIC// This library is free software; you can redistribute it and/or}
\textcolor{comment}{//LIC// modify it under the terms of the GNU Lesser General Public}
\textcolor{comment}{//LIC// License as published by the Free Software Foundation; either}
\textcolor{comment}{//LIC// version 2.1 of the License, or (at your option) any later version.}
\textcolor{comment}{//LIC// }
\textcolor{comment}{//LIC// This library is distributed in the hope that it will be useful,}
\textcolor{comment}{//LIC// but WITHOUT ANY WARRANTY; without even the implied warranty of}
\textcolor{comment}{//LIC// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU}
\textcolor{comment}{//LIC// Lesser General Public License for more details.}
\textcolor{comment}{//LIC// }
\textcolor{comment}{//LIC// You should have received a copy of the GNU Lesser General Public}
\textcolor{comment}{//LIC// License along with this library; if not, write to the Free Software}
\textcolor{comment}{//LIC// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA}
\textcolor{comment}{//LIC// 02110-1301  USA.}
\textcolor{comment}{//LIC// }
\textcolor{comment}{//LIC// The authors may be contacted at oomph-lib@maths.man.ac.uk.}
\textcolor{comment}{//LIC// }
\textcolor{comment}{//LIC//====================================================================}
\textcolor{comment}{// Driver for 2D Navier Stokes flow, driven by oscillating ring}
\textcolor{comment}{// with pseudo-elasticity: The mean radius of ring is adjusted to}
\textcolor{comment}{// allow conservation of volume (area).}

\textcolor{comment}{// Oomph-lib includes}
\textcolor{preprocessor}{#include "generic.h"}
\textcolor{preprocessor}{#include "navier\_stokes.h"}

\textcolor{comment}{//Need to instantiate templated mesh}
\textcolor{preprocessor}{#include "meshes/quarter\_circle\_sector\_mesh.h"}

\textcolor{comment}{//Include namespace containing Sarah's asymptotics }
\textcolor{preprocessor}{#include "\hyperlink{osc__ring__sarah__asymptotics_8h}{osc\_ring\_sarah\_asymptotics.h}"}


\textcolor{keyword}{using namespace }\hyperlink{namespacestd}{std};

\textcolor{keyword}{using namespace }\hyperlink{namespaceoomph}{oomph};

\textcolor{keyword}{using namespace }\hyperlink{namespaceMathematicalConstants}{MathematicalConstants};

  
\textcolor{comment}{}
\textcolor{comment}{////////////////////////////////////////////////////////////////////////}
\textcolor{comment}{////////////////////////////////////////////////////////////////////////}
\textcolor{comment}{////////////////////////////////////////////////////////////////////////}
\textcolor{comment}{}  

\textcolor{comment}{//==================================================}\textcolor{comment}{}
\textcolor{comment}{/// Namespace for physical parameters}
\textcolor{comment}{}\textcolor{comment}{//==================================================}
\textcolor{keyword}{namespace }\hyperlink{namespaceGlobal__Physical__Variables}{Global\_Physical\_Variables}
\{
\textcolor{comment}{}
\textcolor{comment}{ /// Reynolds number}
\textcolor{comment}{} \textcolor{keywordtype}{double} \hyperlink{namespaceGlobal__Physical__Variables_ab814e627d2eb5bc50318879d19ab16b9}{Re}=100.0;  \textcolor{comment}{// ADJUST\_PRIORITY }
\textcolor{comment}{}
\textcolor{comment}{ /// Reynolds x Strouhal number}
\textcolor{comment}{} \textcolor{keywordtype}{double} \hyperlink{namespaceGlobal__Physical__Variables_a085ee4bf968ffdd01a41b8c41864f907}{ReSt}=100.0; \textcolor{comment}{// ADJUST\_PRIORITY }

\}



\textcolor{comment}{}
\textcolor{comment}{////////////////////////////////////////////////////////////////////////}
\textcolor{comment}{////////////////////////////////////////////////////////////////////////}
\textcolor{comment}{////////////////////////////////////////////////////////////////////////}
\textcolor{comment}{}

\textcolor{comment}{//====================================================================}\textcolor{comment}{}
\textcolor{comment}{/// Driver for oscillating ring problem: Wall performs oscillations}
\textcolor{comment}{/// that resemble eigenmodes of freely oscillating ring and drives}
\textcolor{comment}{/// viscous fluid flow. Mean radius of wall is adjustable and}
\textcolor{comment}{/// responds to a pressure value in the fluid to allow for}
\textcolor{comment}{/// mass conservation. }
\textcolor{comment}{}\textcolor{comment}{//====================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT>
\textcolor{keyword}{class }\hyperlink{classOscRingNStProblem}{OscRingNStProblem} : \textcolor{keyword}{public} Problem
\{

\textcolor{keyword}{public}:
\textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Constructor: Pass timestep and function pointer to the }
\textcolor{comment}{ /// solution that provides the initial conditions for the fluid}
\textcolor{comment}{} \hyperlink{classOscRingNStProblem}{OscRingNStProblem}(\textcolor{keyword}{const} \textcolor{keywordtype}{double}& dt,
                   FiniteElement::UnsteadyExactSolutionFctPt IC\_fct\_pt);
\textcolor{comment}{}
\textcolor{comment}{ /// Destructor (empty)}
\textcolor{comment}{} ~\hyperlink{classOscRingNStProblem}{OscRingNStProblem}()\{\}
\textcolor{comment}{}
\textcolor{comment}{ /// Get pointer to wall as geometric object}
\textcolor{comment}{} GeomObject* wall\_pt()
  \{
   \textcolor{keywordflow}{return} Wall\_pt;
  \}
\textcolor{comment}{}
\textcolor{comment}{ /// Update after solve (empty)}
\textcolor{comment}{} \textcolor{keywordtype}{void} actions\_after\_newton\_solve()\{\}
\textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Update the problem specs before solve (empty)}
\textcolor{comment}{} \textcolor{keywordtype}{void} actions\_before\_newton\_solve()\{\}
\textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Update the problem specs before checking Newton}
\textcolor{comment}{ /// convergence: Update the fluid mesh and re-set velocity}
\textcolor{comment}{ ///  boundary conditions -- no slip velocity on the wall means}
\textcolor{comment}{ /// that the velocity on the wall is enslaved.}
\textcolor{comment}{} \textcolor{keywordtype}{void} actions\_before\_newton\_convergence\_check() 
 \{
  \textcolor{comment}{// Update the fluid mesh -- auxiliary update function for algebraic}
  \textcolor{comment}{// nodes automatically updates no slip condition.}
  fluid\_mesh\_pt()->node\_update(); 
 \}

\textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Update the problem specs after adaptation:}
\textcolor{comment}{ /// Set auxiliary update function that applies no slip on all }
\textcolor{comment}{ /// boundary nodes and choose fluid pressure dof that drives}
\textcolor{comment}{ /// the wall deformation}
\textcolor{comment}{} \textcolor{keywordtype}{void} actions\_after\_adapt() 
  \{
   \textcolor{comment}{// Ring boundary: No slip; this also implies that the velocity needs}
   \textcolor{comment}{// to be updated in response to wall motion. This needs to be reset}
   \textcolor{comment}{// every time the mesh is changed -- there's no mechanism by which}
   \textcolor{comment}{// auxiliary update functions are copied to newly created nodes.}
   \textcolor{comment}{// (that's because unlike boundary conditions, they don't }
   \textcolor{comment}{// occur exclusively at boundaries)}
   \textcolor{keywordtype}{unsigned} ibound=1;
   \{
    \textcolor{keywordtype}{unsigned} num\_nod= fluid\_mesh\_pt()->nboundary\_node(ibound);
    \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} inod=0;inod<num\_nod;inod++)
     \{
      fluid\_mesh\_pt()->boundary\_node\_pt(ibound,inod)->
       set\_auxiliary\_node\_update\_fct\_pt(
        FSI\_functions::apply\_no\_slip\_on\_moving\_wall); 
     \}
   \}
   
   \textcolor{comment}{// Set the reference pressure as the constant pressure in element 0}
   \textcolor{keyword}{dynamic\_cast<}PseudoBucklingRingElement*\textcolor{keyword}{>}(Wall\_pt)
    ->set\_reference\_pressure\_pt(fluid\_mesh\_pt()->element\_pt(0)
                                ->internal\_data\_pt(0));
  \}
   \textcolor{comment}{}
\textcolor{comment}{ /// Run the time integration for ntsteps steps}
\textcolor{comment}{} \textcolor{keywordtype}{void} unsteady\_run(\textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} &ntsteps, \textcolor{keyword}{const} \textcolor{keywordtype}{bool}& restarted,
                   DocInfo& doc\_info);
\textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Set initial condition (incl previous timesteps) according}
\textcolor{comment}{ /// to specified function. }
\textcolor{comment}{} \textcolor{keywordtype}{void} set\_initial\_condition();
 \textcolor{comment}{}
\textcolor{comment}{ /// Doc the solution}
\textcolor{comment}{} \textcolor{keywordtype}{void} doc\_solution(DocInfo& doc\_info);
\textcolor{comment}{}
\textcolor{comment}{ /// Access function for the fluid mesh}
\textcolor{comment}{} MacroElementNodeUpdateRefineableQuarterCircleSectorMesh<ELEMENT>* fluid\_mesh\_pt()
  \{
   \textcolor{keywordflow}{return} Fluid\_mesh\_pt; 
  \}
 \textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Dump problem data.}
\textcolor{comment}{} \textcolor{keywordtype}{void} dump\_it(ofstream& dump\_file, DocInfo doc\_info);
\textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Read problem data.}
\textcolor{comment}{} \textcolor{keywordtype}{void} restart(ifstream& restart\_file);

\textcolor{keyword}{private}:
\textcolor{comment}{}
\textcolor{comment}{ /// Write header for trace file}
\textcolor{comment}{} \textcolor{keywordtype}{void} write\_trace\_file\_header();
\textcolor{comment}{}
\textcolor{comment}{ /// Function pointer to set the intial condition}
\textcolor{comment}{} FiniteElement::UnsteadyExactSolutionFctPt IC\_Fct\_pt;
\textcolor{comment}{}
\textcolor{comment}{ /// Pointer to wall}
\textcolor{comment}{} GeomObject* Wall\_pt;
\textcolor{comment}{}
\textcolor{comment}{ /// Pointer to fluid mesh}
\textcolor{comment}{} MacroElementNodeUpdateRefineableQuarterCircleSectorMesh<ELEMENT>* Fluid\_mesh\_pt;
\textcolor{comment}{}
\textcolor{comment}{ /// Pointer to wall mesh (contains only a single GeneralisedElement)}
\textcolor{comment}{} Mesh* Wall\_mesh\_pt;
\textcolor{comment}{}
\textcolor{comment}{ /// Trace file}
\textcolor{comment}{} ofstream Trace\_file;
\textcolor{comment}{}
\textcolor{comment}{ /// Pointer to node on coarsest mesh on which velocity is traced}
\textcolor{comment}{} Node* Veloc\_trace\_node\_pt;
\textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Pointer to node in symmetry plane on coarsest mesh at }
\textcolor{comment}{ /// which velocity is traced}
\textcolor{comment}{} Node* Sarah\_veloc\_trace\_node\_pt;

\};


\textcolor{comment}{//========================================================================}\textcolor{comment}{}
\textcolor{comment}{/// Constructor: Pass (constant) timestep and function pointer to the solution }
\textcolor{comment}{/// that provides the initial conditions for the fluid.}
\textcolor{comment}{}\textcolor{comment}{//========================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT>
\hyperlink{classOscRingNStProblem_acd5f633c43eb4cfb43c45361ecf85e6b}{OscRingNStProblem<ELEMENT>::OscRingNStProblem}(\textcolor{keyword}{const} \textcolor{keywordtype}{double}& dt
      , 
FiniteElement::UnsteadyExactSolutionFctPt IC\_fct\_pt) : IC\_Fct\_pt(IC\_fct\_pt)
\{ 

 \textcolor{comment}{// Period of oscillation}
 \textcolor{keywordtype}{double} T=1.0;

 \textcolor{comment}{//Allocate the timestepper}
 add\_time\_stepper\_pt(\textcolor{keyword}{new} BDF<4>);

 \textcolor{comment}{// Initialise timestep -- also sets the weights for all timesteppers}
 \textcolor{comment}{// in the problem.}
 initialise\_dt(dt);

 \textcolor{comment}{// Parameters for pseudo-buckling ring }
 \textcolor{keywordtype}{double} eps\_buckl=0.1;  \textcolor{comment}{// ADJUST\_PRIORITY }
 \textcolor{keywordtype}{double} ampl\_ratio=-0.5;  \textcolor{comment}{// ADJUST\_PRIORITY }
 \textcolor{keywordtype}{unsigned} n\_buckl=2; \textcolor{comment}{// ADJUST\_PRIORITY }
 \textcolor{keywordtype}{double} r\_0=1.0;
 
 \textcolor{comment}{// Build wall geometric element}
 Wall\_pt=\textcolor{keyword}{new} PseudoBucklingRingElement(eps\_buckl,ampl\_ratio,n\_buckl,r\_0,T,
                                       time\_stepper\_pt());

 \textcolor{comment}{// Fluid mesh is suspended from wall between these two Lagrangian}
 \textcolor{comment}{// coordinates:}
 \textcolor{keywordtype}{double} xi\_lo=0.0;
 \textcolor{keywordtype}{double} xi\_hi=2.0*atan(1.0);

 \textcolor{comment}{// Fractional position of dividing line for two outer blocks in fluid mesh}
 \textcolor{keywordtype}{double} fract\_mid=0.5;

 \textcolor{comment}{// Build fluid mesh}
 Fluid\_mesh\_pt=\textcolor{keyword}{new} MacroElementNodeUpdateRefineableQuarterCircleSectorMesh<ELEMENT>(
  Wall\_pt,xi\_lo,fract\_mid,xi\_hi,time\_stepper\_pt());

 \textcolor{comment}{// Set error estimator}
 Z2ErrorEstimator* error\_estimator\_pt=\textcolor{keyword}{new} Z2ErrorEstimator;
 Fluid\_mesh\_pt->spatial\_error\_estimator\_pt()=error\_estimator\_pt;
  
 \textcolor{comment}{// Fluid mesh is first sub-mesh}
 add\_sub\_mesh(Fluid\_mesh\_pt);

 \textcolor{comment}{// Build wall mesh }
 Wall\_mesh\_pt=\textcolor{keyword}{new} Mesh;

 \textcolor{comment}{// Wall mesh is completely empty: Add Wall element in its GeneralisedElement}
 \textcolor{comment}{// incarnation}
 Wall\_mesh\_pt->add\_element\_pt(dynamic\_cast<GeneralisedElement*>(Wall\_pt));

 \textcolor{comment}{// Wall mesh is second sub-mesh}
 add\_sub\_mesh(Wall\_mesh\_pt);

 \textcolor{comment}{// Combine all submeshes into a single Mesh}
 build\_global\_mesh();

 \textcolor{comment}{// Extract pointer to node at center of mesh (this node exists}
 \textcolor{comment}{// at all refinement levels and can be used to doc continuous timetrace}
 \textcolor{comment}{// of velocities)}
 \textcolor{keywordtype}{unsigned} nnode=fluid\_mesh\_pt()->finite\_element\_pt(0)->nnode();
 Veloc\_trace\_node\_pt=fluid\_mesh\_pt()->finite\_element\_pt(0)->node\_pt(nnode-1);

 \textcolor{comment}{//  Extract pointer to node in symmetry plane (this node exists}
 \textcolor{comment}{// at all refinement levels and can be used to doc continuous timetrace}
 \textcolor{comment}{// of velocities)}
 \textcolor{keywordtype}{unsigned} nnode\_1d=\textcolor{keyword}{dynamic\_cast<}ELEMENT*\textcolor{keyword}{>}(
  fluid\_mesh\_pt()->finite\_element\_pt(0))->nnode\_1d();
 Sarah\_veloc\_trace\_node\_pt=fluid\_mesh\_pt()->
  finite\_element\_pt(0)->node\_pt(nnode\_1d-1);

 \textcolor{comment}{// The "pseudo-elastic" wall element is "loaded" by a pressure.}
 \textcolor{comment}{// Use the "constant" pressure component in Crouzeix Raviart}
 \textcolor{comment}{// fluid element as that pressure. }
 \textcolor{keyword}{dynamic\_cast<}PseudoBucklingRingElement*\textcolor{keyword}{>}(Wall\_pt)
  ->set\_reference\_pressure\_pt(fluid\_mesh\_pt()->element\_pt(0)
                              ->internal\_data\_pt(0));


 \textcolor{comment}{// Set the boundary conditions for this problem:}
 \textcolor{comment}{//----------------------------------------------}

 \textcolor{comment}{// All nodes are free by default -- just pin the ones that have }
 \textcolor{comment}{// Dirichlet conditions here. }
 
 \textcolor{comment}{// Bottom boundary: }
 \textcolor{keywordtype}{unsigned} ibound=0;
  \{
   \textcolor{keywordtype}{unsigned} num\_nod= fluid\_mesh\_pt()->nboundary\_node(ibound);
   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} inod=0;inod<num\_nod;inod++)
    \{
     \textcolor{comment}{// Pin vertical velocity}
     \{
       fluid\_mesh\_pt()->boundary\_node\_pt(ibound,inod)->pin(1); 
     \}
    \}
  \}
  
 \textcolor{comment}{// Ring boundary: No slip; this also implies that the velocity needs}
 \textcolor{comment}{// to be updated in response to wall motion}
 ibound=1;
  \{
   \textcolor{keywordtype}{unsigned} num\_nod=fluid\_mesh\_pt()->nboundary\_node(ibound);
   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} inod=0;inod<num\_nod;inod++)
    \{
     \textcolor{comment}{// Which node are we dealing with?}
     Node* node\_pt=fluid\_mesh\_pt()->boundary\_node\_pt(ibound,inod);

     \textcolor{comment}{// Set auxiliary update function pointer to apply no-slip condition}
     \textcolor{comment}{// to velocities whenever nodal position is updated}
     node\_pt->set\_auxiliary\_node\_update\_fct\_pt(
      FSI\_functions::apply\_no\_slip\_on\_moving\_wall);
     
     \textcolor{comment}{// Pin both velocities}
     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} i=0;i<2;i++)
      \{
       node\_pt->pin(i); 
      \}
    \}
  \}
                        
 \textcolor{comment}{// Left boundary:}
 ibound=2;
  \{
   \textcolor{keywordtype}{unsigned} num\_nod=fluid\_mesh\_pt()->nboundary\_node(ibound);
   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} inod=0;inod<num\_nod;inod++)
    \{
     \textcolor{comment}{// Pin horizontal velocity}
      \{
       fluid\_mesh\_pt()->boundary\_node\_pt(ibound,inod)->pin(0);
      \}
    \}
  \}


 \textcolor{comment}{// Complete the build of all elements so they are fully functional}
 \textcolor{comment}{//----------------------------------------------------------------}

 \textcolor{comment}{//Find number of elements in mesh}
 \textcolor{keywordtype}{unsigned} n\_element = fluid\_mesh\_pt()->nelement();

 \textcolor{comment}{// Loop over the elements to set up element-specific }
 \textcolor{comment}{// things that cannot be handled by constructor}
 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} i=0;i<n\_element;i++)
  \{
   \textcolor{comment}{// Upcast from FiniteElement to the present element}
   ELEMENT *el\_pt = \textcolor{keyword}{dynamic\_cast<}ELEMENT*\textcolor{keyword}{>}(fluid\_mesh\_pt()->element\_pt(i));

   \textcolor{comment}{//Set the Reynolds number, etc}
   el\_pt->re\_pt() = &\hyperlink{namespaceGlobal__Physical__Variables_ab814e627d2eb5bc50318879d19ab16b9}{Global\_Physical\_Variables::Re};
   el\_pt->re\_st\_pt() = &\hyperlink{namespaceGlobal__Physical__Variables_a085ee4bf968ffdd01a41b8c41864f907}{Global\_Physical\_Variables::ReSt};

  \}

 \textcolor{comment}{//Attach the boundary conditions to the mesh}
 cout <<\textcolor{stringliteral}{"Number of equations: "} << assign\_eqn\_numbers() << std::endl; 
 

 \textcolor{comment}{// Set parameters for Sarah's asymptotic solution}
 \textcolor{comment}{//-----------------------------------------------}

 \textcolor{comment}{// Amplitude of the oscillation}
 \hyperlink{namespaceoomph_1_1SarahBL_a21bfe7e71f0baa62022d1ecc9bd175de}{SarahBL::epsilon}=\textcolor{keyword}{static\_cast<}PseudoBucklingRingElement*\textcolor{keyword}{>}(Wall\_pt)->
  eps\_buckl();

 \textcolor{comment}{// Womersley number is the same as square root of Reynolds number}
 \hyperlink{namespaceoomph_1_1SarahBL_ab07de8eb877306afdc10ba4a17c6406b}{SarahBL::alpha}=sqrt(\hyperlink{namespaceGlobal__Physical__Variables_ab814e627d2eb5bc50318879d19ab16b9}{Global\_Physical\_Variables::Re});

 \textcolor{comment}{// Amplitude ratio}
 \hyperlink{namespaceoomph_1_1SarahBL_a5b48abf91ca062e8bfeab87f1d4a9499}{SarahBL::A}=\textcolor{keyword}{static\_cast<}PseudoBucklingRingElement*\textcolor{keyword}{>}(Wall\_pt)->ampl\_ratio();

 \textcolor{comment}{// Buckling wavenumber}
 \hyperlink{namespaceoomph_1_1SarahBL_a3f2e6fdba588e1883d317f6e0cd7f32f}{SarahBL::N}=\textcolor{keyword}{static\_cast<}PseudoBucklingRingElement*\textcolor{keyword}{>}(Wall\_pt)->n\_buckl\_float();

 \textcolor{comment}{// Frequency of oscillation (period is one)}
 \hyperlink{namespaceoomph_1_1SarahBL_a370241de5869d0f53fc7cd17858bfbfe}{SarahBL::Omega}=2.0*MathematicalConstants::Pi;

\}





\textcolor{comment}{//========================================================================}\textcolor{comment}{}
\textcolor{comment}{/// Set initial condition: Assign previous and current values}
\textcolor{comment}{/// of the velocity from the velocity field specified via}
\textcolor{comment}{/// the function pointer.}
\textcolor{comment}{///}
\textcolor{comment}{/// Values are assigned so that the velocities and accelerations}
\textcolor{comment}{/// are correct for current time.}
\textcolor{comment}{}\textcolor{comment}{//========================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT>
\textcolor{keywordtype}{void} \hyperlink{classOscRingNStProblem_ab1f2083699d00da4b7f6116e10792e86}{OscRingNStProblem<ELEMENT>::set\_initial\_condition}()
\{ 

 \textcolor{comment}{// Elastic wall: We're starting from a given initial state in which}
 \textcolor{comment}{// the wall is undeformed. If set\_initial\_condition() is called again}
 \textcolor{comment}{// after mesh refinement for first timestep, this needs to be reset.}
 \textcolor{keyword}{dynamic\_cast<}PseudoBucklingRingElement*\textcolor{keyword}{>}(Wall\_pt)->set\_R\_0(1.0); 

 \textcolor{comment}{// Backup time in global timestepper}
 \textcolor{keywordtype}{double} backed\_up\_time=time\_pt()->time();
         
 \textcolor{comment}{// Past history for velocities needs to be established for t=time0-deltat, ...}
 \textcolor{comment}{// Then provide current values (at t=time0) which will also form}
 \textcolor{comment}{// the initial guess for first solve at t=time0+deltat}

 \textcolor{comment}{// Vector of exact solution values (includes pressure)}
 Vector<double> soln(3);
 Vector<double> x(2);

 \textcolor{comment}{//Find number of nodes in mesh}
 \textcolor{keywordtype}{unsigned} num\_nod = fluid\_mesh\_pt()->nnode();

 \textcolor{comment}{// Get continuous times at previous timesteps}
 \textcolor{keywordtype}{int} nprev\_steps=time\_stepper\_pt()->nprev\_values();
 Vector<double> prev\_time(nprev\_steps+1);
 \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} itime=nprev\_steps;itime>=0;itime--)
  \{
   prev\_time[itime]=time\_pt()->time(\textcolor{keywordtype}{unsigned}(itime));
  \}

 \textcolor{comment}{// Loop over current & previous timesteps (in outer loop because}
 \textcolor{comment}{// the mesh might also move)}
 \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} itime=nprev\_steps;itime>=0;itime--)
  \{
   \textcolor{keywordtype}{double} time=prev\_time[itime];
   
   \textcolor{comment}{// Set global time (because this is how the geometric object refers }
   \textcolor{comment}{// to continous time }
   time\_pt()->time()=time;
   
   cout << \textcolor{stringliteral}{"setting IC at time ="} << time << std::endl;
   
   \textcolor{comment}{// Update the fluid mesh for this value of the continuous time}
   \textcolor{comment}{// (The wall object reads the continous time from the same}
   \textcolor{comment}{// global time object)}
   fluid\_mesh\_pt()->node\_update(); 
   
   \textcolor{comment}{// Loop over the nodes to set initial guess everywhere}
   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} jnod=0;jnod<num\_nod;jnod++)
    \{
     
     \textcolor{comment}{// Get nodal coordinates}
     x[0]=fluid\_mesh\_pt()->node\_pt(jnod)->x(0);
     x[1]=fluid\_mesh\_pt()->node\_pt(jnod)->x(1);

     \textcolor{comment}{// Get intial solution}
     (*IC\_Fct\_pt)(time,x,soln);
     
     \textcolor{comment}{// Loop over velocity directions (velocities are in soln[0] and soln[1]).}
     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} i=0;i<2;i++)
      \{
       fluid\_mesh\_pt()->node\_pt(jnod)->set\_value(itime,i,soln[i]);
      \}
     
     \textcolor{comment}{// Loop over coordinate directions}
     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} i=0;i<2;i++)
      \{
       fluid\_mesh\_pt()->node\_pt(jnod)->x(itime,i)=x[i];
      \}
    \} 
  \}

 \textcolor{comment}{// Reset backed up time for global timestepper}
 time\_pt()->time()=backed\_up\_time;

\}





\textcolor{comment}{//========================================================================}\textcolor{comment}{}
\textcolor{comment}{/// Doc the solution}
\textcolor{comment}{///}
\textcolor{comment}{}\textcolor{comment}{//========================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT>
\textcolor{keywordtype}{void} \hyperlink{classOscRingNStProblem_a7de5df21c2179db1c97cc83332dcc82c}{OscRingNStProblem<ELEMENT>::doc\_solution}(DocInfo& doc\_info)
\{ 

 cout << \textcolor{stringliteral}{"Doc-ing step "} <<  doc\_info.number()
      << \textcolor{stringliteral}{" for time "} << time\_stepper\_pt()->time\_pt()->time() << std::endl;

 ofstream some\_file;
 \textcolor{keywordtype}{char} filename[100];

 \textcolor{comment}{// Number of plot points}
 \textcolor{keywordtype}{unsigned} npts;
 npts=5; 


 \textcolor{comment}{// Output solution on fluid mesh}
 \textcolor{comment}{//-------------------------------}
 sprintf(filename,\textcolor{stringliteral}{"%s/soln%i.dat"},doc\_info.directory().c\_str(),
         doc\_info.number());
 \textcolor{comment}{//some\_file.precision(20);}
 some\_file.open(filename);
 \textcolor{keywordtype}{unsigned} nelem=fluid\_mesh\_pt()->nelement();
 \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} ielem=0;ielem<nelem;ielem++)
  \{
   \textcolor{keyword}{dynamic\_cast<}ELEMENT*\textcolor{keyword}{>}(fluid\_mesh\_pt()->element\_pt(ielem))->
    full\_output(some\_file,npts);
  \}
 some\_file.close();
  

 \textcolor{comment}{// Plot wall posn}
 \textcolor{comment}{//---------------}
 sprintf(filename,\textcolor{stringliteral}{"%s/Wall%i.dat"},doc\_info.directory().c\_str(),
         doc\_info.number());
 some\_file.open(filename);
 
 \textcolor{keywordtype}{unsigned} nplot=100;
 Vector<double > xi\_wall(1);
 Vector<double > r\_wall(2);
  \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} iplot=0;iplot<nplot;iplot++)
   \{
    xi\_wall[0]=0.5*Pi*double(iplot)/double(nplot-1);
    Wall\_pt->position(xi\_wall,r\_wall);
    some\_file << r\_wall[0] << \textcolor{stringliteral}{" "} << r\_wall[1] << std::endl;
   \}
  some\_file.close();


 \textcolor{comment}{// Doc Sarah's asymptotic solution }
 \textcolor{comment}{//--------------------------------}
 sprintf(filename,\textcolor{stringliteral}{"%s/exact\_soln%i.dat"},doc\_info.directory().c\_str(),
         doc\_info.number());
 some\_file.open(filename);
 fluid\_mesh\_pt()->output\_fct(some\_file,npts,
                       time\_stepper\_pt()->time\_pt()->time(), 
                       \hyperlink{namespaceoomph_1_1SarahBL_a80c7c03073f6436ace00d2b2c5bfa501}{SarahBL::full\_exact\_soln});
 some\_file.close();




 \textcolor{comment}{// Get position of control point}
 \textcolor{comment}{//------------------------------}
 Vector<double> r(2);
 Vector<double> xi(1);
 xi[0]=MathematicalConstants::Pi/2.0;
 wall\_pt()->position(xi,r);



 \textcolor{comment}{// Get total volume (area) of computational domain, energies and average}
 \textcolor{comment}{//----------------------------------------------------------------------}
 \textcolor{comment}{// pressure}
 \textcolor{comment}{//---------}
 \textcolor{keywordtype}{double} area=0.0;
 \textcolor{keywordtype}{double} press\_int=0.0;
 \textcolor{keywordtype}{double} diss=0.0;
 \textcolor{keywordtype}{double} kin\_en=0.0;
 nelem=fluid\_mesh\_pt()->nelement();

 \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} ielem=0;ielem<nelem;ielem++)
  \{
   area+=fluid\_mesh\_pt()->finite\_element\_pt(ielem)->size();
   press\_int+=\textcolor{keyword}{dynamic\_cast<}ELEMENT*\textcolor{keyword}{>}(fluid\_mesh\_pt()->element\_pt(ielem))
    ->pressure\_integral();
   diss+=\textcolor{keyword}{dynamic\_cast<}ELEMENT*\textcolor{keyword}{>}(fluid\_mesh\_pt()->element\_pt(ielem))->
    dissipation();
   kin\_en+=\textcolor{keyword}{dynamic\_cast<}ELEMENT*\textcolor{keyword}{>}(fluid\_mesh\_pt()->element\_pt(ielem))->
    kin\_energy();
  \}

 \textcolor{comment}{// Total kinetic energy in entire domain}
 \textcolor{keywordtype}{double} global\_kin=4.0*kin\_en;

 \textcolor{comment}{// Max/min refinement level}
 \textcolor{keywordtype}{unsigned} min\_level;
 \textcolor{keywordtype}{unsigned} max\_level;
 fluid\_mesh\_pt()->get\_refinement\_levels(min\_level,max\_level);


 \textcolor{comment}{// Total dissipation for quarter domain}
 \textcolor{keywordtype}{double} time=time\_pt()->time();
 \textcolor{keywordtype}{double} diss\_asympt=\hyperlink{namespaceoomph_1_1SarahBL_abcbefc8bfea90a749dcb6961d9d5c0a0}{SarahBL::Total\_Diss\_sarah}(time)/4.0;

 \textcolor{comment}{// Asymptotic predictions for velocities at control point}
 Vector<double> x\_sarah(2);
 Vector<double> soln\_sarah(3);
 x\_sarah[0]=Sarah\_veloc\_trace\_node\_pt->x(0);
 x\_sarah[1]=Sarah\_veloc\_trace\_node\_pt->x(1);
 \hyperlink{namespaceoomph_1_1SarahBL_aa198aa1de07bb9a2eac422ed63010bc4}{SarahBL::exact\_soln}(time,x\_sarah,soln\_sarah);

 \textcolor{comment}{// Doc}
 Trace\_file << time\_pt()->time() 
            << \textcolor{stringliteral}{" "} << r[1]
            << \textcolor{stringliteral}{" "} << global\_kin 
            << \textcolor{stringliteral}{" "} << \hyperlink{namespaceoomph_1_1SarahBL_a3cb8715d5fa21d7dbff8151e90df4200}{SarahBL::Kin\_energy\_sarah}(time\_pt()->time()) 
            << \textcolor{stringliteral}{" "} << \textcolor{keyword}{static\_cast<}PseudoBucklingRingElement*\textcolor{keyword}{>}(Wall\_pt)->r\_0()
            << \textcolor{stringliteral}{" "} << area  
            << \textcolor{stringliteral}{" "} << press\_int/area 
            << \textcolor{stringliteral}{" "} << diss  
            << \textcolor{stringliteral}{" "} << diss\_asympt
            << \textcolor{stringliteral}{" "} << Veloc\_trace\_node\_pt->x(0)
            << \textcolor{stringliteral}{" "} << Veloc\_trace\_node\_pt->x(1) 
            << \textcolor{stringliteral}{" "} << Veloc\_trace\_node\_pt->value(0)
            << \textcolor{stringliteral}{" "} << Veloc\_trace\_node\_pt->value(1) 
            << \textcolor{stringliteral}{" "} << fluid\_mesh\_pt()->nelement() 
            << \textcolor{stringliteral}{" "} << ndof()
            << \textcolor{stringliteral}{" "} << min\_level 
            << \textcolor{stringliteral}{" "} << max\_level
            << \textcolor{stringliteral}{" "} << fluid\_mesh\_pt()->nrefinement\_overruled() 
            << \textcolor{stringliteral}{" "} << fluid\_mesh\_pt()->max\_error()  
            << \textcolor{stringliteral}{" "} << fluid\_mesh\_pt()->min\_error()  
            << \textcolor{stringliteral}{" "} << fluid\_mesh\_pt()->max\_permitted\_error() 
            << \textcolor{stringliteral}{" "} << fluid\_mesh\_pt()->min\_permitted\_error() 
            << \textcolor{stringliteral}{" "} << fluid\_mesh\_pt()->max\_keep\_unrefined()
            << \textcolor{stringliteral}{" "} << doc\_info.number()
            << \textcolor{stringliteral}{" "} << Sarah\_veloc\_trace\_node\_pt->x(0) 
            << \textcolor{stringliteral}{" "} << Sarah\_veloc\_trace\_node\_pt->x(1) 
            << \textcolor{stringliteral}{" "} << Sarah\_veloc\_trace\_node\_pt->value(0) 
            << \textcolor{stringliteral}{" "} << Sarah\_veloc\_trace\_node\_pt->value(1)
            << \textcolor{stringliteral}{" "} << x\_sarah[0]
            << \textcolor{stringliteral}{" "} << x\_sarah[1]
            << \textcolor{stringliteral}{" "} << soln\_sarah[0]
            << \textcolor{stringliteral}{" "} << soln\_sarah[1]
            << \textcolor{stringliteral}{" "} 
            << \textcolor{keyword}{static\_cast<}PseudoBucklingRingElement*\textcolor{keyword}{>}(Wall\_pt)->r\_0()-1.0
            << std::endl;


 \textcolor{comment}{// Output fluid solution on coarse-ish mesh }
 \textcolor{comment}{//-----------------------------------------}

 \textcolor{comment}{// Extract all elements from quadtree representation}
 Vector<Tree*> all\_element\_pt;
 fluid\_mesh\_pt()->forest\_pt()->
  stick\_all\_tree\_nodes\_into\_vector(all\_element\_pt);

 \textcolor{comment}{// Build a coarse mesh}
 Mesh* coarse\_mesh\_pt = \textcolor{keyword}{new} Mesh();

 \textcolor{comment}{//Loop over all elements and check if their refinement level is}
 \textcolor{comment}{//equal to the mesh's minimum refinement level}
 nelem=all\_element\_pt.size();
 \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} ielem=0;ielem<nelem;ielem++)
  \{
   Tree* el\_pt=all\_element\_pt[ielem];
   \textcolor{keywordflow}{if} (el\_pt->level()==min\_level)
    \{
     coarse\_mesh\_pt->add\_element\_pt(el\_pt->object\_pt());
    \}
  \}

 \textcolor{comment}{// Output fluid solution on coarse mesh}
 sprintf(filename,\textcolor{stringliteral}{"%s/coarse\_soln%i.dat"},doc\_info.directory().c\_str(),
         doc\_info.number());
 some\_file.open(filename);
 nelem=coarse\_mesh\_pt->nelement();
 \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} ielem=0;ielem<nelem;ielem++)
  \{
   \textcolor{keyword}{dynamic\_cast<}ELEMENT*\textcolor{keyword}{>}(coarse\_mesh\_pt->element\_pt(ielem))->
    full\_output(some\_file,npts);
  \}
 some\_file.close();

 \textcolor{comment}{// Write restart file}
 sprintf(filename,\textcolor{stringliteral}{"%s/restart%i.dat"},doc\_info.directory().c\_str(),
         doc\_info.number());
 some\_file.open(filename);
 dump\_it(some\_file,doc\_info);
 some\_file.close();

\}






\textcolor{comment}{//========================================================================}\textcolor{comment}{}
\textcolor{comment}{/// Dump the solution}
\textcolor{comment}{}\textcolor{comment}{//========================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT>
\textcolor{keywordtype}{void} \hyperlink{classOscRingNStProblem_af32f94658174188b1f029446161755b2}{OscRingNStProblem<ELEMENT>::dump\_it}(ofstream& dump\_file,DocInfo 
      doc\_info)
\{

 \textcolor{comment}{// Dump refinement status of mesh}
 \textcolor{comment}{//fluid\_mesh\_pt()->dump\_refinement(dump\_file);}

 \textcolor{comment}{// Call generic dump()}
 Problem::dump(dump\_file);
  
\}



\textcolor{comment}{//========================================================================}\textcolor{comment}{}
\textcolor{comment}{/// Read solution from disk}
\textcolor{comment}{}\textcolor{comment}{//========================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT>
\textcolor{keywordtype}{void} \hyperlink{classOscRingNStProblem_a0cf01737b8d53213d644413e84251d0f}{OscRingNStProblem<ELEMENT>::restart}(ifstream& restart\_file)
\{
 \textcolor{comment}{// Refine fluid mesh according to the instructions in restart file}
 \textcolor{comment}{//fluid\_mesh\_pt()->refine(restart\_file);}

 \textcolor{comment}{// Rebuild the global mesh}
 \textcolor{comment}{//rebuild\_global\_mesh();}

 \textcolor{comment}{// Read generic problem data}
 Problem::read(restart\_file);

\textcolor{comment}{//   // Complete build of all elements so they are fully functional}
\textcolor{comment}{//  finish\_problem\_setup();}
 
 \textcolor{comment}{//Assign equation numbers}
 \textcolor{comment}{//cout <<"\(\backslash\)nNumber of equations: " << assign\_eqn\_numbers() }
 \textcolor{comment}{//     << std::endl<< std::endl; }
\}



\textcolor{comment}{//========================================================================}\textcolor{comment}{}
\textcolor{comment}{/// Driver for timestepping the problem: Fixed timestep but }
\textcolor{comment}{/// guaranteed spatial accuracy. Beautiful, innit?}
\textcolor{comment}{///}
\textcolor{comment}{}\textcolor{comment}{//========================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT>
\textcolor{keywordtype}{void} \hyperlink{classOscRingNStProblem_a00e957fb6a313a9c1de784d0fa3a7a36}{OscRingNStProblem<ELEMENT>::unsteady\_run}(\textcolor{keyword}{const} \textcolor{keywordtype}{unsigned}& 
      ntsteps,
                                              \textcolor{keyword}{const} \textcolor{keywordtype}{bool}& restarted,
                                              DocInfo& doc\_info)
\{ 

 \textcolor{comment}{// Open trace file}
 \textcolor{keywordtype}{char} filename[100];   
 sprintf(filename,\textcolor{stringliteral}{"%s/trace.dat"},doc\_info.directory().c\_str());
 Trace\_file.open(filename);

 \textcolor{comment}{// Max. number of adaptations per solve}
 \textcolor{keywordtype}{unsigned} max\_adapt;

 \textcolor{comment}{// Max. number of adaptations per solve}
 \textcolor{keywordflow}{if} (restarted)
  \{
   max\_adapt=0;
  \}
 \textcolor{keywordflow}{else}
  \{
   max\_adapt=1; 
  \}
 
 \textcolor{comment}{// Max. and min. error for adaptive refinement/unrefinement}
 fluid\_mesh\_pt()->max\_permitted\_error()=  0.5e-2;   
 fluid\_mesh\_pt()->min\_permitted\_error()=  0.5e-3;  

 \textcolor{comment}{// Don't allow refinement to drop under given level}
 fluid\_mesh\_pt()->min\_refinement\_level()=2;

 \textcolor{comment}{// Don't allow refinement beyond given level }
 fluid\_mesh\_pt()->max\_refinement\_level()=6; 

 \textcolor{comment}{// Don't bother adapting the mesh if no refinement is required}
 \textcolor{comment}{// and if less than ... elements are to be merged.}
 fluid\_mesh\_pt()->max\_keep\_unrefined()=20;


 \textcolor{comment}{// Get max/min refinement levels in mesh}
 \textcolor{keywordtype}{unsigned} min\_refinement\_level;
 \textcolor{keywordtype}{unsigned} max\_refinement\_level;
 fluid\_mesh\_pt()->get\_refinement\_levels(min\_refinement\_level,
                                        max\_refinement\_level);

 cout << \textcolor{stringliteral}{"\(\backslash\)n Initial mesh: min/max refinement levels: "} 
      << min\_refinement\_level << \textcolor{stringliteral}{" "} << max\_refinement\_level << std::endl << std::endl;

 \textcolor{comment}{// Doc refinement targets}
 fluid\_mesh\_pt()->doc\_adaptivity\_targets(cout);

 \textcolor{comment}{// Write header for trace file}
 write\_trace\_file\_header();

 \textcolor{comment}{// Doc initial condition}
 doc\_solution(doc\_info);
 doc\_info.number()++;

 \textcolor{comment}{// Switch off doc during solve}
 doc\_info.disable\_doc();

 \textcolor{comment}{// If we set first to true, then initial guess will be re-assigned}
 \textcolor{comment}{// after mesh adaptation. Don't want this if we've done a restart.}
 \textcolor{keywordtype}{bool} first;
 \textcolor{keywordtype}{bool} shift;
 \textcolor{keywordflow}{if} (restarted)
  \{
   first=\textcolor{keyword}{false};
   shift=\textcolor{keyword}{false};
   \textcolor{comment}{// Move time back by dt to make sure we're re-solving the read-in solution}
   time\_pt()->time()-=time\_pt()->dt();
  \}
 \textcolor{keywordflow}{else}
  \{
   first=\textcolor{keyword}{true};
   shift=\textcolor{keyword}{true};
  \}
 
 \textcolor{comment}{//Take the first fixed timestep with specified tolerance for Newton solver}
 \textcolor{keywordtype}{double} dt=time\_pt()->dt();
 unsteady\_newton\_solve(dt,max\_adapt,first,shift);

 \textcolor{comment}{// Switch doc back on}
 doc\_info.enable\_doc();

 \textcolor{comment}{// Doc initial solution}
 doc\_solution(doc\_info);
 doc\_info.number()++;

 \textcolor{comment}{// Now do normal run; allow for one mesh adaptation per timestep}
 max\_adapt=1; 

 \textcolor{comment}{//Loop over the remaining timesteps}
 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} t=2;t<=ntsteps;t++)
  \{

   \textcolor{comment}{// Switch off doc during solve}
   doc\_info.disable\_doc();

   \textcolor{comment}{//Take fixed timestep}
   first=\textcolor{keyword}{false};
   unsteady\_newton\_solve(dt,max\_adapt,first);

   \textcolor{comment}{// Switch doc back on}
   doc\_info.enable\_doc();

   \textcolor{comment}{// Doc solution}
   \textcolor{comment}{//if (icount%10==0)}
    \{
     doc\_solution(doc\_info);
     doc\_info.number()++;
    \}
  \}

 \textcolor{comment}{// Close trace file}
 Trace\_file.close();

\}




\textcolor{comment}{//========================================================================}\textcolor{comment}{}
\textcolor{comment}{/// Write trace file header}
\textcolor{comment}{}\textcolor{comment}{//========================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT>
\textcolor{keywordtype}{void} \hyperlink{classOscRingNStProblem_a96e12e5bb761d765ebe9065b9990112f}{OscRingNStProblem<ELEMENT>::write\_trace\_file\_header}
      ()
\{

 \textcolor{comment}{// Doc parameters in trace file}
 Trace\_file << \textcolor{stringliteral}{"# err\_max "} << fluid\_mesh\_pt()->max\_permitted\_error() << std::endl;
 Trace\_file << \textcolor{stringliteral}{"# err\_min "} << fluid\_mesh\_pt()->min\_permitted\_error() << std::endl;
 Trace\_file << \textcolor{stringliteral}{"# Re "} << \hyperlink{namespaceGlobal__Physical__Variables_ab814e627d2eb5bc50318879d19ab16b9}{Global\_Physical\_Variables::Re} << std::endl;
 Trace\_file << \textcolor{stringliteral}{"# St "} << \hyperlink{namespaceGlobal__Physical__Variables_a085ee4bf968ffdd01a41b8c41864f907}{Global\_Physical\_Variables::ReSt}/
                          \hyperlink{namespaceGlobal__Physical__Variables_ab814e627d2eb5bc50318879d19ab16b9}{Global\_Physical\_Variables::Re} << std::endl;
 Trace\_file << \textcolor{stringliteral}{"# dt "} << time\_stepper\_pt()->time\_pt()->dt() << std::endl;
 Trace\_file << \textcolor{stringliteral}{"# initial # elements "} << mesh\_pt()->nelement() << std::endl;
 Trace\_file << \textcolor{stringliteral}{"# min\_refinement\_level "} 
            << fluid\_mesh\_pt()->min\_refinement\_level() << std::endl;
 Trace\_file << \textcolor{stringliteral}{"# max\_refinement\_level "} 
            << fluid\_mesh\_pt()->max\_refinement\_level() << std::endl;



 Trace\_file << \textcolor{stringliteral}{"VARIABLES=\(\backslash\)"time\(\backslash\)",\(\backslash\)"V\_c\_t\_r\_l\(\backslash\)",\(\backslash\)"e\_k\_i\_n\(\backslash\)""};
 Trace\_file << \textcolor{stringliteral}{",\(\backslash\)"e\_k\_i\_n\_(\_a\_s\_y\_m\_p\_t\_)\(\backslash\)",\(\backslash\)"R\_0\(\backslash\)",\(\backslash\)"Area\(\backslash\)""} ;
 Trace\_file << \textcolor{stringliteral}{",\(\backslash\)"Average pressure\(\backslash\)",\(\backslash\)"Total dissipation (quarter domain)\(\backslash\)""};
 Trace\_file << \textcolor{stringliteral}{",\(\backslash\)"Asymptotic dissipation (quarter domain)\(\backslash\)""};
 Trace\_file << \textcolor{stringliteral}{",\(\backslash\)"x<sub>1</sub><sup>(track)</sup>\(\backslash\)""};
 Trace\_file << \textcolor{stringliteral}{",\(\backslash\)"x<sub>2</sub><sup>(track)</sup>\(\backslash\)""};
 Trace\_file << \textcolor{stringliteral}{",\(\backslash\)"u<sub>1</sub><sup>(track)</sup>\(\backslash\)""};
 Trace\_file << \textcolor{stringliteral}{",\(\backslash\)"u<sub>2</sub><sup>(track)</sup>\(\backslash\)""};
 Trace\_file << \textcolor{stringliteral}{",\(\backslash\)"N<sub>element</sub>\(\backslash\)""};
 Trace\_file << \textcolor{stringliteral}{",\(\backslash\)"N<sub>dof</sub>\(\backslash\)""};
 Trace\_file << \textcolor{stringliteral}{",\(\backslash\)"max. refinement level\(\backslash\)""};
 Trace\_file << \textcolor{stringliteral}{",\(\backslash\)"min. refinement level\(\backslash\)""};
 Trace\_file << \textcolor{stringliteral}{",\(\backslash\)"# of elements whose refinement was over-ruled\(\backslash\)""};
 Trace\_file << \textcolor{stringliteral}{",\(\backslash\)"max. error\(\backslash\)""};
 Trace\_file << \textcolor{stringliteral}{",\(\backslash\)"min. error\(\backslash\)""};
 Trace\_file << \textcolor{stringliteral}{",\(\backslash\)"max. permitted error\(\backslash\)""};
 Trace\_file << \textcolor{stringliteral}{",\(\backslash\)"min. permitted error\(\backslash\)""};
 Trace\_file << \textcolor{stringliteral}{",\(\backslash\)"max. permitted # of unrefined elements\(\backslash\)""};
 Trace\_file << \textcolor{stringliteral}{",\(\backslash\)"doc number\(\backslash\)""};
 Trace\_file << \textcolor{stringliteral}{",\(\backslash\)"x<sub>1</sub><sup>(track2 FE)</sup>\(\backslash\)""};
 Trace\_file << \textcolor{stringliteral}{",\(\backslash\)"x<sub>2</sub><sup>(track2 FE)</sup>\(\backslash\)""};
 Trace\_file << \textcolor{stringliteral}{",\(\backslash\)"u<sub>1</sub><sup>(track2 FE)</sup>\(\backslash\)""};
 Trace\_file << \textcolor{stringliteral}{",\(\backslash\)"u<sub>2</sub><sup>(track2 FE)</sup>\(\backslash\)""};
 Trace\_file << \textcolor{stringliteral}{",\(\backslash\)"x<sub>1</sub><sup>(track2 Sarah)</sup>\(\backslash\)""};
 Trace\_file << \textcolor{stringliteral}{",\(\backslash\)"x<sub>2</sub><sup>(track2 Sarah)</sup>\(\backslash\)""};
 Trace\_file << \textcolor{stringliteral}{",\(\backslash\)"u<sub>1</sub><sup>(track2 Sarah)</sup>\(\backslash\)""};
 Trace\_file << \textcolor{stringliteral}{",\(\backslash\)"u<sub>2</sub><sup>(track2 Sarah)</sup>\(\backslash\)""};
 Trace\_file << \textcolor{stringliteral}{",\(\backslash\)"R<sub>0</sub>-1\(\backslash\)""};
 Trace\_file << std::endl;

\}



\textcolor{comment}{}
\textcolor{comment}{////////////////////////////////////////////////////////////////////////}
\textcolor{comment}{////////////////////////////////////////////////////////////////////////}
\textcolor{comment}{////////////////////////////////////////////////////////////////////////}
\textcolor{comment}{}






\textcolor{comment}{//========================================================================}\textcolor{comment}{}
\textcolor{comment}{/// Demonstrate how to solve OscRingNSt problem in deformable domain}
\textcolor{comment}{/// with mesh adaptation}
\textcolor{comment}{}\textcolor{comment}{//========================================================================}
\textcolor{keywordtype}{int} \hyperlink{fsi__osc__ring_8cc_a0ddf1224851353fc92bfbff6f499fa97}{main}(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char}* argv[])
\{
 \textcolor{comment}{// Store command line arguments}
 CommandLineArgs::setup(argc,argv);

 \textcolor{comment}{//Do a certain number of timesteps per period}
 \textcolor{keywordtype}{unsigned} nstep\_per\_period=40; \textcolor{comment}{// 80;  // ADJUST\_PRIORITY}
 \textcolor{keywordtype}{unsigned} nperiod=3;

 \textcolor{comment}{// Work out total number of steps and timestep}
 \textcolor{keywordtype}{unsigned} nstep=nstep\_per\_period*nperiod;  
 \textcolor{keywordtype}{double} dt=1.0/double(nstep\_per\_period);

 \textcolor{comment}{// Set up the problem: Pass timestep and Sarah's asymptotic solution for}
 \textcolor{comment}{// generation of initial condition}
 
      \hyperlink{classOscRingNStProblem}{OscRingNStProblem<MacroElementNodeUpdateElement<RefineableQCrouzeixRaviartElement<2>}
       > >
  problem(dt,&\hyperlink{namespaceoomph_1_1SarahBL_a80c7c03073f6436ace00d2b2c5bfa501}{SarahBL::full\_exact\_soln});


 \textcolor{comment}{// Restart?}
 \textcolor{comment}{//---------}
 \textcolor{keywordtype}{bool} restarted=\textcolor{keyword}{false};

 \textcolor{comment}{// Pointer to restart file}
 ifstream* restart\_file\_pt=0;

 \textcolor{comment}{// No restart}
 \textcolor{comment}{//-----------}
 \textcolor{keywordflow}{if} (CommandLineArgs::Argc!=2)
  \{
   cout << \textcolor{stringliteral}{"No restart"} << std::endl;
   restarted=\textcolor{keyword}{false};

   \textcolor{comment}{// Refine uniformly}
   problem.refine\_uniformly();
   problem.refine\_uniformly();

   \textcolor{comment}{// Set initial condition on uniformly refined domain (if this isn't done}
   \textcolor{comment}{// then the mesh contains the interpolation of the initial guess}
   \textcolor{comment}{// on the original coarse mesh -- if the nodal values were zero in}
   \textcolor{comment}{// the interior and nonzero on the boundary, then the the waviness of}
   \textcolor{comment}{// of the interpolated i.g. between the nodes on the coarse mesh}
   \textcolor{comment}{// gets transferred onto the fine mesh where we can do better}
   problem.set\_initial\_condition();

  \}
 
 \textcolor{comment}{// Restart}
 \textcolor{comment}{//--------}
 \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (CommandLineArgs::Argc==2)
  \{
   restarted=\textcolor{keyword}{true};

   \textcolor{comment}{// Open restart file}
   restart\_file\_pt=\textcolor{keyword}{new} ifstream(CommandLineArgs::Argv[1],ios\_base::in);
   \textcolor{keywordflow}{if} (restart\_file\_pt!=0)
    \{
     cout << \textcolor{stringliteral}{"Have opened "} << CommandLineArgs::Argv[1] << 
      \textcolor{stringliteral}{" for restart. "} << std::endl;
    \}
   \textcolor{keywordflow}{else}
    \{
     std::ostringstream error\_stream;
     error\_stream << \textcolor{stringliteral}{"ERROR while trying to open "} 
                  << CommandLineArgs::Argv[2] 
                  << \textcolor{stringliteral}{" for restart."} << std::endl;

     \textcolor{keywordflow}{throw} OomphLibError(error\_stream.str(),
                         OOMPH\_CURRENT\_FUNCTION,
                         OOMPH\_EXCEPTION\_LOCATION);
    \}
   \textcolor{comment}{// Do the actual restart}
   problem.restart(*restart\_file\_pt);
  \}


 \textcolor{comment}{// Two command line arguments: do validation run}
 \textcolor{keywordflow}{if} (CommandLineArgs::Argc==3)
  \{
    nstep=3;
    cout << \textcolor{stringliteral}{"Only doing nstep steps for validation: "} << nstep << std::endl;
  \}




 \textcolor{comment}{// Setup labels for output}
 DocInfo doc\_info;
 
 \textcolor{comment}{// Output directory}
 doc\_info.set\_directory(\textcolor{stringliteral}{"RESLT"}); 


 \textcolor{comment}{// Do unsteady run of the problem for nstep steps}
 \textcolor{comment}{//-----------------------------------------------}
 problem.unsteady\_run(nstep,restarted,doc\_info);


 \textcolor{comment}{// Validate the restart procedure}
 \textcolor{comment}{//-------------------------------}
 \textcolor{keywordflow}{if} (CommandLineArgs::Argc==3)
  \{
   
   \textcolor{comment}{// Build problem and restart}
   
   \textcolor{comment}{// Set up the problem: Pass timestep and Sarah's asymptotic solution for}
   \textcolor{comment}{// generation of initial condition}
   \hyperlink{classOscRingNStProblem}{OscRingNStProblem}<MacroElementNodeUpdateElement<
    RefineableQCrouzeixRaviartElement<2> > >
    restarted\_problem(dt,&\hyperlink{namespaceoomph_1_1SarahBL_a80c7c03073f6436ace00d2b2c5bfa501}{SarahBL::full\_exact\_soln});
   
   \textcolor{comment}{// Setup labels for output}
   DocInfo restarted\_doc\_info;
   
   \textcolor{comment}{// Output directory}
   restarted\_doc\_info.set\_directory(\textcolor{stringliteral}{"RESLT\_restarted"}); 
   
   \textcolor{comment}{// Step number}
   restarted\_doc\_info.number()=0;
   
   \textcolor{comment}{// Copy by performing a restart from old problem}
   restart\_file\_pt=\textcolor{keyword}{new} ifstream(\textcolor{stringliteral}{"RESLT/restart2.dat"});
   
   \textcolor{comment}{// Do the actual restart}
   restarted\_problem.restart(*restart\_file\_pt);
   
   \textcolor{comment}{// Do unsteady run of the problem for one step}
   \textcolor{keywordtype}{unsigned} nstep=2;
   \textcolor{keywordtype}{bool} restarted=\textcolor{keyword}{true};
   restarted\_problem.unsteady\_run(nstep,restarted,restarted\_doc\_info);

  \}

\}










\end{DoxyCodeInclude}




 

 \hypertarget{index_pdf}{}\section{P\+D\+F file}\label{index_pdf}
A \href{../latex/refman.pdf}{\tt pdf version} of this document is available. \end{document}
