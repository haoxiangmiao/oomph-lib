In this example we shall consider our first (toy!) interaction problem. The problem combines two single-\/physics problems, studied in earlier examples, and combines them into a coupled free-\/boundary problem.


\begin{DoxyItemize}
\item In \href{../../../poisson/fish_poisson/html/index.html}{\tt one of our first examples} we demonstrated the solution of Poisson\textquotesingle{}s equation in a fish-\/shaped domain, $ D_{fish} $, in which the curvilinear upper and lower boundaries of the fish\textquotesingle{}s body were given by circular arcs which we represented by {\ttfamily Geom\+Objects}. Given the position of the two circular arcs, whose centres are located at $ (X_c, \pm Y_c) $, the single-\/physics Poisson code computes the solution of Poisson\textquotesingle{}s equation in the corresponding domain. \href{../../../poisson/fish_poisson2/html/index.html#com}{\tt We have already demonstrated} how {\ttfamily oomph-\/lib\textquotesingle{}s} {\ttfamily Macro\+Element} / {\ttfamily Domain} representation of $ D_{fish} $ allows an update of the nodal positions in response to changes in the domain boundary by a simple call to {\ttfamily Mesh\+::node\+\_\+update()}. The example code therefore allowed us to compute the solution at a control node, $ u_{ctrl}$, as a function of the \char`\"{}height\char`\"{} of the domain, characterised by $ Y_c $. ~\newline
~\newline

\item In \href{../../../interaction/circle_as_element/html/index.html}{\tt another example}, we demonstrated how to solve a (trivial) solid mechanics problem\+: The vertical displacement of a circular ring (represented by a {\ttfamily Geom\+Object}) that is mounted on an elastic foundation of spring stiffness $ k $. The example code allowed us to compute the displacement of the ring, characterised by $ Y_c $, as a function of the load $ f $ acting on it.
\end{DoxyItemize}We will now consider the coupled problem obtained by using the solution of Poisson\textquotesingle{}s equation at the control node, $ u_{ctrl} $, as the \char`\"{}load\char`\"{}, $ f $, that acts on the two circular arcs that define the curvilinear boundaries of $ D_{fish} $. The resulting coupled problem is sketched in the figure below. While this problem is obviously somewhat artificial, it has many of the key features that arise in genuine fluid-\/structure interaction problems. In particular, the displacement of the domain boundary is driven by the solution of the \char`\"{}bulk\char`\"{} (Poisson) equations, just as the deformation of an elastic structure in an F\+SI problem is driven by the fluid pressure and shear stresses, i.\+e. quantities that are derived from the solution of the Navier-\/\+Stokes equations in the \char`\"{}bulk\char`\"{} domain.

 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{fish_fsi_sketch}
\doxyfigcaption{Sketch of the two individual single-\/physics problems (top) and the coupled problem (bottom). }
\end{DoxyImage}


The two single-\/physics problems involve two uncoupled sets of equations and unknowns\+:
\begin{DoxyItemize}
\item The residual vector of the Poisson elements in the single-\/physics Poisson problem depends on the nodal values in the \char`\"{}bulk\char`\"{} mesh. These nodal values are the only unknowns in the problem since the position of the domain boundary, and hence the position of the nodes are fixed. An update of the nodal positions in response to any changes in the domain boundary is a mere pre-\/processing step, to be performed just once, before computing the solution.
\item The residual vector of the {\ttfamily Elastically\+Supported\+Ring\+Element} depends on the position of ring\textquotesingle{}s centre, $ Y_c $, which is the only unknown in the problem as the load on the ring is fixed.
\end{DoxyItemize}The coupling between the two single-\/physics problem introduces additional dependencies\+:
\begin{DoxyItemize}
\item The residuals of the Poisson elements also depend on the nodal positions which in turn depend (via the {\ttfamily Macro\+Element/\+Domain} -\/ based node-\/update function) on the the position of the domain boundary. The boundary position is controlled by the {\ttfamily Elastically\+Supported\+Ring\+Element\textquotesingle{}s} geometric {\ttfamily Data}, which stores the value of $ Y_c $.
\item The residual vector of the {\ttfamily Elastically\+Supported\+Ring\+Element} also depends on the load, which is now given by the unknown nodal value at a control node in the \char`\"{}bulk\char`\"{} mesh.
\end{DoxyItemize}We note that most of the methodology required to solve this coupled problem is already available\+:
\begin{DoxyItemize}
\item The {\ttfamily Macro\+Element/\+Domain} representation of the Mesh makes it possible to update the nodal positions in the bulk mesh in response to changes in the shape/position of the curvilinear domain boundary.
\item Multiple inheritance allows the {\ttfamily Elastically\+Supported\+Ring\+Element} to act as a {\ttfamily Geom\+Object} (a role in which it can be used to parametrise the unknown curvilinear domain boundary) and as a {\ttfamily Generalised\+Element} (a role in which its unknown geometric {\ttfamily Data} value, $ Y_c $, can be determined as part of the overall solution).
\item The load $ f $ on the {\ttfamily Elastically\+Supported\+Ring\+Element} is stored in the element\textquotesingle{}s external {\ttfamily Data}, and derivatives of the element\textquotesingle{}s residual vector with respect to $ f $ are automatically taken into account when the element\textquotesingle{}s Jacobian matrix is computed.
\end{DoxyItemize}The only interaction that still has to be incorporated into the problem formulation is the dependence of the Poisson element\textquotesingle{}s residual vectors on the geometric {\ttfamily Data} in the {\ttfamily Elastically\+Supported\+Ring\+Element}. This interaction arises through the {\ttfamily Macro\+Element/\+Domain} -\/ based node-\/update function which translates changes in the {\ttfamily Geom\+Object\textquotesingle{}s} geometric {\ttfamily Data} into changes in the nodal positions. Such dependencies may be added to {\itshape any} existing element by \char`\"{}wrapping\char`\"{} the element into the templated wrapper class {\ttfamily Macro\+Element\+Node\+Update\+Element} which has the following inheritance structure\+:


\begin{DoxyCode}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT>
\textcolor{keyword}{class }MacroElementNodeUpdateElement : \textcolor{keyword}{public} \textcolor{keyword}{virtual} ELEMENT, 
                                      \textcolor{keyword}{public} \textcolor{keyword}{virtual} MacroElementNodeUpdateElementBase
\end{DoxyCode}


An element of type {\ttfamily Macro\+Element\+Node\+Update\+Element$<$\+E\+L\+E\+M\+E\+N\+T$>$} is an element of type {\ttfamily E\+L\+E\+M\+E\+NT}, and inherits the additional functionality provided by the {\ttfamily Macro\+Element\+Node\+Update\+Element\+Base} base class. The most important additional functionality provided by this class is the ability to add the values stored in the geometric {\ttfamily Data} of associated {\ttfamily Geom\+Objects} to the element\textquotesingle{}s list of unknowns. Once added, the derivatives of the element\textquotesingle{}s residual vector with respect to these additional unknowns are automatically included into the element\textquotesingle{}s Jacobian matrix. This is achieved by overloading the {\ttfamily E\+L\+E\+M\+E\+N\+T\+::get\+\_\+jacobian}(...) function and evaluating the additional derivatives by finite differencing. See \hyperlink{index_comments}{Comments} for details on the implementation.

The solution of the coupled problem therefore only requires a few trivial changes to the single-\/physics (Poisson) code\+:
\begin{DoxyEnumerate}
\item The element type used for the solution of the \char`\"{}bulk\char`\"{} equations must be changed to its \char`\"{}wrapped\char`\"{} counterpart, as discussed above. For instance, if the single-\/physics code used a nine-\/node refineable Poisson element of type {\ttfamily Refineable\+Q\+Poisson\+Element$<$2,3$>$}, the coupled problem must be discretised by elements of type {\ttfamily Macro\+Element\+Node\+Update\+Element$<$Refineable\+Q\+Poisson\+Element$<$2,3$>$} $>$ (Yes, it\textquotesingle{}s a bit of a mouthful...).
\item The \char`\"{}bulk\char`\"{} mesh must be \char`\"{}upgraded\char`\"{} (again via multiple inheritance) to a Mesh that is derived from the {\ttfamily Macro\+Element\+Node\+Update\+Mesh} base class.
\item A vector of pointers to those {\ttfamily Geom\+Objects} that are involved in an element\textquotesingle{}s {\ttfamily Macro\+Element/\+Domain} -\/ based node update operation must be passed to the elements. (This is done most easily in the constructor of the \char`\"{}upgraded\char`\"{} mesh.) The geometric {\ttfamily Data} contained in these {\ttfamily Geom\+Objects} is then automatically included in the elements\textquotesingle{} list of unknowns.
\item The Mesh\textquotesingle{}s {\ttfamily node\+\_\+update()} function must be executed whenever the Newton method has changed the values of the unknowns\+: This is because changing a value that is stored in a {\ttfamily Geom\+Object\textquotesingle{}s} geometric {\ttfamily Data} does not automatically update the positions of any dependent nodes. This is done most easily be including the {\ttfamily node\+\_\+update()} function into the {\ttfamily Problem\+::actions\+\_\+before\+\_\+newton\+\_\+convergence\+\_\+check()} function; we refer to \href{../../../order_of_action_functions/html/index.html}{\tt another document} for a more detailed discussion of the order in which the various \char`\"{}action\char`\"{} functions are called by {\ttfamily oomph-\/lib\textquotesingle{}s} Newton solver.
\end{DoxyEnumerate}

 

\hypertarget{index_results}{}\section{Results}\label{index_results}
The animation below shows the results of a spatially-\/adaptive solution of Poisson\textquotesingle{}s equations in the fish-\/shaped domain, for a variety of domain \char`\"{}heights\char`\"{}. This animation was produced with the \href{../../../poisson/fish_poisson/html/index.html}{\tt single-\/physics Poisson solver discussed in an earlier example}.

 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{elastic_fish}
\doxyfigcaption{Spatially adaptive solution of Poisson\textquotesingle{}s equation in a fish-\/shaped domain for various `widths\textquotesingle{} of the domain. }
\end{DoxyImage}


An increase in the height of the domain increases the amplitude of the solution. This is reflected by the red line in the figure below which shows a plot of $ u_{ctrl} $ as a function of $ Y_c $. The green marker shows the solution of the coupled problem for a spring stiffness of $ k=1 $. For this value of the spring stiffness, the solution of the coupled problem should be (and indeed is) located at the intersection of the curve $ u_{ctrl}(Y_c) $ with the diagonal, $ u_{ctrl} = Y_c $, shown by the dashed blue line.

 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{trace}
\doxyfigcaption{Solution of Poisson\textquotesingle{}s equation at a control node as a function of the `height\textquotesingle{} of the domain. }
\end{DoxyImage}




 

\hypertarget{index_impl}{}\section{Implementation in oomph-\/lib}\label{index_impl}
The sections below provide the usual annotated listing of the driver code. We stress that only a few trivial changes are required to incorporate the presence of the free boundary into the existing single-\/physics code\+:
\begin{DoxyItemize}
\item \hyperlink{index_mesh}{The Mesh} \+: Upgrading the {\ttfamily Refineable\+Fish\+Mesh} via multiple inheritance.
\item \hyperlink{index_main}{The driver code} \+: Changing the element type for the solution of the Poisson equation.
\item \hyperlink{index_constructor}{The Problem constructor} \+: Storing the element that represents the free boundary in a (sub-\/)mesh.
\item \hyperlink{index_problem}{The problem class} \+: Implementing the function {\ttfamily Problem\+::actions\+\_\+before\+\_\+newton\+\_\+convergence\+\_\+check()} to update the nodal positions after each Newton step.
\end{DoxyItemize}

 

\hypertarget{index_global}{}\section{Global parameters and functions}\label{index_global}
The namespace {\ttfamily \hyperlink{namespaceConstSourceForPoisson}{Const\+Source\+For\+Poisson}} defines the constant source function, exactly as in the \href{../../../poisson/fish_poisson/html/index.html#global}{\tt corresponding single-\/physics code.}

 
\begin{DoxyCodeInclude}
\textcolor{comment}{//=============start\_of\_namespace=====================================}
\textcolor{comment}{/// Namespace for const source term in Poisson equation}
\textcolor{comment}{}\textcolor{comment}{//====================================================================}
\textcolor{keyword}{namespace }\hyperlink{namespaceConstSourceForPoisson}{ConstSourceForPoisson}
\{
\textcolor{comment}{}
\textcolor{comment}{/// Const source function}
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{namespaceConstSourceForPoisson_a40ef79083874b58ed42b4df2ca0f4c10}{get\_source}(\textcolor{keyword}{const} Vector<double>& x, \textcolor{keywordtype}{double}& source)
 \{
  source = -1.0;
 \}
 
\} \textcolor{comment}{// end of namespace}

\end{DoxyCodeInclude}




 

\hypertarget{index_mesh}{}\section{The Mesh}\label{index_mesh}
Meshes that are to be used with {\ttfamily Macro\+Element\+Node\+Update\+Elements} should be derived (typically by multiple inheritance) from the {\ttfamily Macro\+Element\+Node\+Update\+Mesh} class. This class overloads the generic {\ttfamily Mesh\+::node\+\_\+update()} function and ensures that the node update is performed by calling the {\ttfamily node\+\_\+update()} function of the {\ttfamily Mesh\textquotesingle{}s} constituent nodes, rather than simply updating their positions, using the {\ttfamily Finite\+Element\+::get\+\_\+x}(...) function. The overloaded version is not only more efficient but also ensures that any auxiliary node update functions (e.\+g. functions that update the no-\/slip condition on a moving fluid node on a solid boundary) are performed too.

In our driver code we add the additional functionality provided by the {\ttfamily Macro\+Element\+Node\+Update\+Mesh} class to the {\ttfamily Refineable\+Fish\+Mesh} class used in the \href{../../../poisson/fish_poisson/html/index.html}{\tt single-\/physics Poisson problem considered earlier}.


\begin{DoxyCodeInclude}
\textcolor{comment}{//==========start\_of\_mesh=================================================}
\textcolor{comment}{/// Refineable, fish-shaped mesh with MacroElement-based node update.}
\textcolor{comment}{}\textcolor{comment}{//========================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT>
\textcolor{keyword}{class }\hyperlink{classMyMacroElementNodeUpdateRefineableFishMesh}{MyMacroElementNodeUpdateRefineableFishMesh} : 
 \textcolor{keyword}{public} \textcolor{keyword}{virtual} RefineableFishMesh<ELEMENT>,
 \textcolor{keyword}{public} \textcolor{keyword}{virtual} MacroElementNodeUpdateMesh
\{

\end{DoxyCodeInclude}


The constructor calls the constructors of the underlying {\ttfamily Refineable\+Fish\+Mesh}. \mbox{[}Note the explicit call to the {\ttfamily Fish\+Mesh} constructor prior to calling the constructor of the {\ttfamily Refineable\+Fish\+Mesh}. Without this call, only the default (argument-\/free) constructor of the {\ttfamily Fish\+Mesh} would be called! Consult your favourite C++ book to check on constructors for derived classes if you don\textquotesingle{}t understand this. We recommend \href{http://www.math.wayne.edu/~yang/}{\tt Daoqi Yang\textquotesingle{}s} brilliant book \href{http://www.springeronline.com/sgw/cda/frontpage/0,11855,4-40007-22-2105335-0,00.html?changeHeader=true}{\tt C++ and Object-\/\+Oriented Numeric Computing for Scientists and Engineers.})


\begin{DoxyCodeInclude}

\textcolor{keyword}{public}: 
\textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Constructor: Pass pointer to GeomObject that defines}
\textcolor{comment}{ /// the fish's back and pointer to timestepper}
\textcolor{comment}{ /// (defaults to (Steady) default timestepper defined in the Mesh}
\textcolor{comment}{ /// base class).}
\textcolor{comment}{} \hyperlink{classMyMacroElementNodeUpdateRefineableFishMesh}{MyMacroElementNodeUpdateRefineableFishMesh}(GeomObject* back\_pt, 
                   TimeStepper* time\_stepper\_pt=&Mesh::Default\_TimeStepper) :  
  FishMesh<ELEMENT>(back\_pt,time\_stepper\_pt),
  RefineableFishMesh<ELEMENT>(time\_stepper\_pt)
  \{

\end{DoxyCodeInclude}


To activate the {\ttfamily Macro\+Element\+Node\+Update\+Element\textquotesingle{}s} ability to automatically compute the derivatives of the residual vectors with respect to the geometric {\ttfamily Data} that determines its nodal positions, we must pass the pointers to the {\ttfamily Geom\+Objects} that are involved in the element\textquotesingle{}s {\ttfamily Macro\+Element} -\/ based node-\/update to the elements. In general, an element\textquotesingle{}s node-\/update will be affected by multiple {\ttfamily Geom\+Objects} therefore the {\ttfamily set\+\_\+node\+\_\+update\+\_\+info}(...) function expects a vector of pointers to {\ttfamily Geom\+Objects}. In the present example, only a single {\ttfamily Geom\+Object} (the {\ttfamily Geom\+Object} that represents the fish\textquotesingle{}s curved \char`\"{}back\char`\"{}) determines the nodal position of all elements\+:


\begin{DoxyCodeInclude}
   \textcolor{comment}{// Set up all the information that's required for MacroElement-based}
   \textcolor{comment}{// node update: Tell the elements that their geometry depends on the}
   \textcolor{comment}{// fishback geometric object. }
   \textcolor{keywordtype}{unsigned} n\_element = this->nelement();
   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} i=0;i<n\_element;i++)
    \{
     \textcolor{comment}{// Upcast from FiniteElement to the present element}
     ELEMENT *el\_pt = \textcolor{keyword}{dynamic\_cast<}ELEMENT*\textcolor{keyword}{>}(this->element\_pt(i));

     \textcolor{comment}{// There's just one GeomObject}
     Vector<GeomObject*> geom\_object\_pt(1);
     geom\_object\_pt[0] = back\_pt;
     
     \textcolor{comment}{// Tell the element which geom objects its macro-element-based}
     \textcolor{comment}{// node update depends on     }
     el\_pt->set\_node\_update\_info(geom\_object\_pt);
    \}

  \} \textcolor{comment}{//end of constructor}

\end{DoxyCodeInclude}


The destructor can remain empty but we provide a final overload for the {\ttfamily Mesh\textquotesingle{}s} {\ttfamily node\+\_\+update()} function to avoid any ambiguities as to which one is to be used. 
\begin{DoxyCodeInclude}
\textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Destructor: empty}
\textcolor{comment}{} \textcolor{keyword}{virtual} ~\hyperlink{classMyMacroElementNodeUpdateRefineableFishMesh}{MyMacroElementNodeUpdateRefineableFishMesh}()\{\}
\textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Resolve mesh update: Node update current nodal}
\textcolor{comment}{ /// positions via sparse MacroElement-based update.}
\textcolor{comment}{} \textcolor{comment}{//void node\_update()}
 \textcolor{comment}{// \{}
 \textcolor{comment}{//  MacroElementNodeUpdateMesh::node\_update();}
 \textcolor{comment}{// \}}

\}; \textcolor{comment}{// end of mesh class}

\end{DoxyCodeInclude}




 

\hypertarget{index_main}{}\section{The driver code}\label{index_main}
The driver code is very simple\+: We build the problem with the \char`\"{}wrapped\char`\"{} version of the refineable quadrilateral nine-\/node Poisson element. Since the initial mesh is very coarse we perform two uniform mesh refinements before solving the problem with automatic spatial adaptivity, allowing for up to two further mesh adaptations.

 
\begin{DoxyCodeInclude}
\textcolor{comment}{//==================start\_of\_main=========================================}
\textcolor{comment}{/// Driver for "free-boundary" fish poisson solver with adaptation.}
\textcolor{comment}{}\textcolor{comment}{//========================================================================}
\textcolor{keywordtype}{int} \hyperlink{algebraic__free__boundary__poisson_8cc_a0ddf1224851353fc92bfbff6f499fa97}{main}()
\{

 \textcolor{comment}{// Shorthand for element type}
 \textcolor{keyword}{typedef} MacroElementNodeUpdateElement<RefineableQPoissonElement<2,3> > 
  ELEMENT;

 \textcolor{comment}{// Build problem}
 \hyperlink{classFreeBoundaryPoissonProblem}{FreeBoundaryPoissonProblem<ELEMENT>} problem;

 \textcolor{comment}{// Do some uniform mesh refinement first}
 problem.refine\_uniformly();
 problem.refine\_uniformly();
 
 \textcolor{comment}{// Solve/doc fully coupled problem, allowing for up to two spatial}
 \textcolor{comment}{// adaptations. }
 \textcolor{keywordtype}{unsigned} max\_solve=2; 
 problem.newton\_solve(max\_solve);
 problem.\hyperlink{classFreeBoundaryPoissonProblem_a2282d8ac1d5753771a9a3cfc0417f6b6}{doc\_solution}();

\} \textcolor{comment}{// end of main}

\end{DoxyCodeInclude}




 

\hypertarget{index_problem}{}\section{The problem class}\label{index_problem}
Apart from a few trivial additions, the problem class is virtually identical to that used in the \href{../../../poisson/fish_poisson/html/index.html}{\tt single-\/physics Poisson problem}. The most important addition to the single-\/physics problem class is the function {\ttfamily Problem\+::actions\+\_\+before\+\_\+newton\+\_\+convergence\+\_\+check()} which updates the nodal positions in the \char`\"{}bulk\char`\"{} Poisson mesh following an update of the geometric {\ttfamily Data} that controls the position of the curvilinear domain boundary; we refer to \href{../../../order_of_action_functions/html/index.html}{\tt another document} for a more detailed discussion of the order in which the various \char`\"{}action\char`\"{} functions are called by {\ttfamily oomph-\/lib\textquotesingle{}s} Newton solver.

 
\begin{DoxyCodeInclude}
\textcolor{comment}{//==========start\_of\_problem\_class====================================}
\textcolor{comment}{/// Refineable "free-boundary" Poisson problem in deformable }
\textcolor{comment}{}\textcolor{comment}{/// fish-shaped domain. Template parameter identifies the element.}
\textcolor{comment}{}\textcolor{comment}{//====================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT>
\textcolor{keyword}{class }\hyperlink{classFreeBoundaryPoissonProblem}{FreeBoundaryPoissonProblem} : \textcolor{keyword}{public} Problem
\{

\textcolor{keyword}{public}:
\textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short  Constructor}
\textcolor{comment}{} \hyperlink{classFreeBoundaryPoissonProblem_a0efe7c342eea790fc0240830bc3c4ebc}{FreeBoundaryPoissonProblem}();
\textcolor{comment}{}
\textcolor{comment}{ /// Destructor (empty)}
\textcolor{comment}{} \textcolor{keyword}{virtual} \hyperlink{classFreeBoundaryPoissonProblem_a5b75b8553f3dfed4e9a8996c1b13edf3}{~FreeBoundaryPoissonProblem}()\{\};
\textcolor{comment}{}
\textcolor{comment}{ /// Update the problem specs before solve (empty)}
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{classFreeBoundaryPoissonProblem_aeef57bd5dc79b6aba9eeadcd0c01a2e0}{actions\_before\_newton\_solve}() \{\}
\textcolor{comment}{}
\textcolor{comment}{ /// Update the problem specs after solve (empty)}
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{classFreeBoundaryPoissonProblem_aa18df6c9a9287f67ae1bff0f67aaa625}{actions\_after\_newton\_solve}()\{\}
  \textcolor{comment}{}
\textcolor{comment}{ /// Access function for the fish mesh}
\textcolor{comment}{} \hyperlink{classMyMacroElementNodeUpdateRefineableFishMesh}{MyMacroElementNodeUpdateRefineableFishMesh<ELEMENT>}* 
      \hyperlink{classFreeBoundaryPoissonProblem_adccab51afed9228783120934b6be37c9}{fish\_mesh\_pt}() 
  \{
   \textcolor{keywordflow}{return} \hyperlink{classFreeBoundaryPoissonProblem_ae81a7e22c2c61854696b80a94053a663}{Fish\_mesh\_pt};
  \}
\textcolor{comment}{}
\textcolor{comment}{ /// Doc the solution}
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{classFreeBoundaryPoissonProblem_a2282d8ac1d5753771a9a3cfc0417f6b6}{doc\_solution}();
\textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Before checking the new residuals in Newton's method}
\textcolor{comment}{ /// we have to update nodal positions in response to possible }
\textcolor{comment}{ /// changes in the position of the domain boundary}
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{classFreeBoundaryPoissonProblem_a885a6e3a4efd1f02314806dced566569}{actions\_before\_newton\_convergence\_check}()
  \{
   \hyperlink{classFreeBoundaryPoissonProblem_adccab51afed9228783120934b6be37c9}{fish\_mesh\_pt}()->node\_update();
  \}

\textcolor{keyword}{private}:
\textcolor{comment}{}
\textcolor{comment}{ /// Pointer to fish mesh}
\textcolor{comment}{} \hyperlink{classMyMacroElementNodeUpdateRefineableFishMesh}{MyMacroElementNodeUpdateRefineableFishMesh<ELEMENT>}* 
      \hyperlink{classFreeBoundaryPoissonProblem_ae81a7e22c2c61854696b80a94053a663}{Fish\_mesh\_pt};
\textcolor{comment}{}
\textcolor{comment}{ /// Pointer to single-element mesh that stores the GeneralisedElement}
\textcolor{comment}{ /// that represents the fish's back}
\textcolor{comment}{} Mesh* \hyperlink{classFreeBoundaryPoissonProblem_aaa45902e79f963060b4b6820c5383cfc}{Fish\_back\_mesh\_pt};

\}; \textcolor{comment}{// end of problem class}

\end{DoxyCodeInclude}




 

\hypertarget{index_constructor}{}\section{The Problem constructor}\label{index_constructor}
We start by creating the {\ttfamily Geom\+Object/\+Generalised\+Element} that will represent the unknown curvilinear domain boundary and pass it (in its role as a {\ttfamily Geom\+Object}) to the constructor of the bulk mesh. We then add the pointer to the bulk mesh to the {\ttfamily Problem\textquotesingle{}s} collection of submeshes and create an error estimator for the adaptive solution of the Poisson equation.


\begin{DoxyCodeInclude}
\textcolor{comment}{//=========start\_of\_constructor===========================================}
\textcolor{comment}{/// Constructor for adaptive free-boundary Poisson problem in }
\textcolor{comment}{}\textcolor{comment}{/// deformable fish-shaped domain. }
\textcolor{comment}{}\textcolor{comment}{//========================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT>
\hyperlink{classFreeBoundaryPoissonProblem_a0efe7c342eea790fc0240830bc3c4ebc}{FreeBoundaryPoissonProblem<ELEMENT>::FreeBoundaryPoissonProblem}
      ()
\{ 

 \textcolor{comment}{// Set coordinates and radius for the circle that will become the fish back}
 \textcolor{keywordtype}{double} x\_c=0.5;
 \textcolor{keywordtype}{double} y\_c=0.0;
 \textcolor{keywordtype}{double} r\_back=1.0;

 \textcolor{comment}{// Build geometric object that will become the fish back}
 ElasticallySupportedRingElement* fish\_back\_pt=
  \textcolor{keyword}{new} ElasticallySupportedRingElement(x\_c,y\_c,r\_back);

 \textcolor{comment}{// Build fish mesh with geometric object that specifies the fish back }
 Fish\_mesh\_pt=\textcolor{keyword}{new} 
  \hyperlink{classMyMacroElementNodeUpdateRefineableFishMesh}{MyMacroElementNodeUpdateRefineableFishMesh<ELEMENT>}(
      fish\_back\_pt);

 \textcolor{comment}{// Add the fish mesh to the problem's collection of submeshes:}
 add\_sub\_mesh(Fish\_mesh\_pt);

 \textcolor{comment}{// Create/set error estimator for the fish mesh}
 fish\_mesh\_pt()->spatial\_error\_estimator\_pt()=\textcolor{keyword}{new} Z2ErrorEstimator;

\end{DoxyCodeInclude}


Next we store the pointer to the {\ttfamily Elastically\+Supported\+Ring\+Element} in its own Mesh and add it to the {\ttfamily Problem\textquotesingle{}s} collection of submeshes before building the {\ttfamily Problem\textquotesingle{}s} global {\ttfamily Mesh} from its two submeshes\+:


\begin{DoxyCodeInclude}
 \textcolor{comment}{// Build mesh that will store only the geometric wall element}
 Fish\_back\_mesh\_pt=\textcolor{keyword}{new} Mesh;

 \textcolor{comment}{// So far, the mesh is completely empty. Let's add the }
 \textcolor{comment}{// GeneralisedElement that represents the shape}
 \textcolor{comment}{// of the fish's back to it:}
 Fish\_back\_mesh\_pt->add\_element\_pt(fish\_back\_pt);

 \textcolor{comment}{// Add the fish back mesh to the problem's collection of submeshes:}
 add\_sub\_mesh(Fish\_back\_mesh\_pt);

 \textcolor{comment}{// Now build global mesh from the submeshes}
 build\_global\_mesh();

\end{DoxyCodeInclude}


We choose the central node in the Poisson mesh as the control node and use it (in its role as {\ttfamily Data}) as the \char`\"{}load\char`\"{} for the {\ttfamily Elastically\+Supported\+Ring\+Element}.


\begin{DoxyCodeInclude}
 \textcolor{comment}{// Choose a control node: We'll use the}
 \textcolor{comment}{// central node that is shared by all four elements in}
 \textcolor{comment}{// the base mesh because it exists at all refinement levels.}
 
 \textcolor{comment}{// How many nodes does element 0 have?}
 \textcolor{keywordtype}{unsigned} nnod=fish\_mesh\_pt()->finite\_element\_pt(0)->nnode();

 \textcolor{comment}{// The central node is the last node in element 0:}
 Node* control\_node\_pt=fish\_mesh\_pt()->finite\_element\_pt(0)->node\_pt(nnod-1);
 
 \textcolor{comment}{// Use the solution (value 0) at the control node as the load}
 \textcolor{comment}{// that acts on the ring. [Note: Node == Data by inheritance]}
 \textcolor{keyword}{dynamic\_cast<}ElasticallySupportedRingElement*\textcolor{keyword}{>}(Fish\_mesh\_pt->fish\_back\_pt())->
  set\_load\_pt(control\_node\_pt);

\end{DoxyCodeInclude}


Finally, we pin the nodal values on all boundaries, apply the homogeneous Dirichlet boundary conditions, pass the pointer to the source function to the elements, and set up the equation numbering scheme.


\begin{DoxyCodeInclude}
 \textcolor{comment}{// Set the boundary conditions for this problem: All nodes are}
 \textcolor{comment}{// free by default -- just pin the ones that have Dirichlet conditions}
 \textcolor{comment}{// here.  Set homogeneous boundary conditions everywhere}
 \textcolor{keywordtype}{unsigned} num\_bound = fish\_mesh\_pt()->nboundary();
 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} ibound=0;ibound<num\_bound;ibound++)
  \{
   \textcolor{keywordtype}{unsigned} num\_nod= fish\_mesh\_pt()->nboundary\_node(ibound);
   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} inod=0;inod<num\_nod;inod++)
    \{
     fish\_mesh\_pt()->boundary\_node\_pt(ibound,inod)->pin(0); 
     fish\_mesh\_pt()->boundary\_node\_pt(ibound,inod)->set\_value(0,0.0);

    \}
  \}
 \textcolor{comment}{}
\textcolor{comment}{ /// Loop over elements and set pointers to source function}
\textcolor{comment}{} \textcolor{keywordtype}{unsigned} n\_element = fish\_mesh\_pt()->nelement();
 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} i=0;i<n\_element;i++)
  \{
   \textcolor{comment}{// Upcast from FiniteElement to the present element}
   ELEMENT *el\_pt = \textcolor{keyword}{dynamic\_cast<}ELEMENT*\textcolor{keyword}{>}(fish\_mesh\_pt()->element\_pt(i));
   
   \textcolor{comment}{//Set the source function pointer}
   el\_pt->source\_fct\_pt() = &\hyperlink{namespaceConstSourceForPoisson_a40ef79083874b58ed42b4df2ca0f4c10}{ConstSourceForPoisson::get\_source};
  \}

 \textcolor{comment}{// Do equation numbering}
 cout << \textcolor{stringliteral}{"Number of equations: "} << assign\_eqn\_numbers() << std::endl; 

\} \textcolor{comment}{// end of constructor}

\end{DoxyCodeInclude}




 

\hypertarget{index_doc}{}\section{Post-\/processing}\label{index_doc}
The post-\/processing routine writes the computed result to an output file.


\begin{DoxyCodeInclude}
\textcolor{comment}{//============start\_of\_doc================================================}
\textcolor{comment}{/// Doc the solution in tecplot format.}
\textcolor{comment}{}\textcolor{comment}{//========================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT>
\textcolor{keywordtype}{void} \hyperlink{classFreeBoundaryPoissonProblem_a2282d8ac1d5753771a9a3cfc0417f6b6}{FreeBoundaryPoissonProblem<ELEMENT>::doc\_solution}()
\{ 

 \textcolor{comment}{// Number of plot points in each coordinate direction.}
 \textcolor{keywordtype}{unsigned} npts=5;

 \textcolor{comment}{// Output solution }
 ofstream some\_file(\textcolor{stringliteral}{"RESLT/soln0.dat"});
 fish\_mesh\_pt()->output(some\_file,npts);
 some\_file.close();

\} \textcolor{comment}{// end of doc}

\end{DoxyCodeInclude}




 

\hypertarget{index_comments}{}\section{Comments}\label{index_comments}
A more detailed description of the theory and the implementation can be found in the paper
\begin{DoxyItemize}
\item Heil, M. \& Hazel, A. L. "{\ttfamily oomph-\/lib} -- An {\itshape O}bject-\/{\itshape O}riented {\itshape M}ulti-\/{\itshape Ph}ysics Finite-\/\+Element {\itshape Lib}rary". In\+: {\itshape Fluid-\/\+Structure Interaction}, Editors\+: M. Schafer and H.-\/J. Bungartz. Springer (Lecture Notes on Computational Science and Engineering 53, 2006), (32 pages) \href{http://www.maths.man.ac.uk/~mheil/MATTHIAS/ABSTRACTS/HeilHazelOomph2006.html}{\tt (abstract)} \href{http://www.maths.man.ac.uk/~mheil/MATTHIAS/PDF/oomph_for_www.pdf}{\tt (pdf preprint)}.
\end{DoxyItemize}and in this talk\+:
\begin{DoxyItemize}
\item Heil, M. \& Hazel, A. L. "An object-\/oriented approach to the evaluation of the `shape derivatives\textquotesingle{} in monolithic fluid-\/structure interaction solvers". 7th World Congress on Computational Mechanics, LA, July 2006. \href{http://www.maths.man.ac.uk/~mheil/oomph_lib_additional_material/LA_talk_2006/LA_talk.pdf}{\tt (pdf)}.
\end{DoxyItemize}The following subsections provide a brief description of the main features.



\hypertarget{index_sparse_node_updates}{}\subsection{Sparse node updates}\label{index_sparse_node_updates}
The key feature of our implementation which allows the efficient computation of the \char`\"{}shape derivatives\char`\"{} is the ability of {\ttfamily Macro\+Element\+Node\+Update\+Nodes} (discussed in more detail below) to \char`\"{}update their own position\char`\"{} in response to changes in shape/position of the domain boundary. This capability is demonstrated in the following simple example code.

We start by building the Mesh as before

 
\begin{DoxyCodeInclude}
\textcolor{comment}{//==================start\_of\_main=========================================}
\textcolor{comment}{/// Driver to document sparse MacroElement-based node update.}
\textcolor{comment}{}\textcolor{comment}{//========================================================================}
\textcolor{keywordtype}{int} \hyperlink{algebraic__free__boundary__poisson_8cc_a0ddf1224851353fc92bfbff6f499fa97}{main}()
\{

 \textcolor{comment}{// Shorthand for element type}
 \textcolor{keyword}{typedef} MacroElementNodeUpdateElement<RefineableQPoissonElement<2,3> > 
  ELEMENT;

 \textcolor{comment}{// Set coordinates and radius for the circle that will become the fish back}
 \textcolor{keywordtype}{double} x\_c=0.5;
 \textcolor{keywordtype}{double} y\_c=-0.2;
 \textcolor{keywordtype}{double} r\_back=1.0;

 \textcolor{comment}{// Build geometric object that will become the fish back}
  ElasticallySupportedRingElement* Fish\_back\_pt=
   \textcolor{keyword}{new} ElasticallySupportedRingElement(x\_c,y\_c,r\_back);

 \textcolor{comment}{// Build fish mesh with geometric object that specifies the fish back }
 MacroElementNodeUpdateRefineableFishMesh<ELEMENT>* Fish\_mesh\_pt=\textcolor{keyword}{new} 
  MacroElementNodeUpdateRefineableFishMesh<ELEMENT>(Fish\_back\_pt);

\end{DoxyCodeInclude}


and document the mesh (i.\+e. the shape of its constituent finite elements and the nodal positions)\+:


\begin{DoxyCodeInclude}
 \textcolor{comment}{// Number of plot points in each coordinate direction.}
 \textcolor{keywordtype}{unsigned} npts=11; 

 ofstream some\_file;
 \textcolor{keywordtype}{char} filename[100];

 \textcolor{comment}{// Output initial mesh}
 \textcolor{keywordtype}{unsigned} count=0;
 sprintf(filename,\textcolor{stringliteral}{"RESLT/soln%i.dat"},count);
 some\_file.open(filename);
 Fish\_mesh\_pt->output(some\_file,npts);
 some\_file.close();
 count++; 

\end{DoxyCodeInclude}


Next, we \char`\"{}manually\char`\"{} increment $ Y_c $, i.\+e. the y-\/coordinate of the centre of the circular arc that defines the upper curvilinear boundary of the fish mesh.


\begin{DoxyCodeInclude}
 \textcolor{comment}{// Increment y\_c}
 Fish\_back\_pt->y\_c()+=0.2;

\end{DoxyCodeInclude}


This step mimics the incrementation of one of the {\ttfamily Problems\textquotesingle{}s} unknowns (recall that in the free-\/boundary problem considered above, $ Y_c $ has to be determined as part of the solution!) during the finite-\/difference based computation of the shape derivatives.

For meshes that are not derived from the {\ttfamily Macro\+Element\+Node\+Update\+Mesh\+Base} class, the only way to update the nodal positions in response to a change in the boundary position, is to call the {\ttfamily Mesh\+::node\+\_\+update()} function. This updates the position of {\itshape all} nodes in the mesh -- a very costly operation.

Meshes that are derived from the {\ttfamily Macro\+Element\+Node\+Update\+Mesh\+Base} class contain {\ttfamily Macro\+Element\+Node\+Update\+Nodes} which can update their own position, as shown here\+:


\begin{DoxyCodeInclude}



 \textcolor{comment}{// Adjust each node in turn and doc}
 \textcolor{keywordtype}{unsigned} nnod=Fish\_mesh\_pt->nnode();
 \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} i=0;i<nnod;i++)
  \{
   \textcolor{comment}{// Update individual nodal position}
   Fish\_mesh\_pt->node\_pt(i)->node\_update();

   \textcolor{comment}{// Doc mesh}
   sprintf(filename,\textcolor{stringliteral}{"RESLT/soln%i.dat"},count);
   some\_file.open(filename);
   Fish\_mesh\_pt->output(some\_file,npts);
   some\_file.close();
   count++; 
  \}

\} \textcolor{comment}{// end of main}

\end{DoxyCodeInclude}


We note that the {\ttfamily Node\+::node\+\_\+update()} function is defined as an empty virtual function in the {\ttfamily Node} base class, indicating that \char`\"{}normal\char`\"{} {\ttfamily Nodes} cannot \char`\"{}update their own position\char`\"{}. The function is overloaded in the {\ttfamily Macro\+Element\+Node\+Update\+Node} class, details of which are given below. Overloaded versions of this function also exist in various other derived {\ttfamily Node} classes (such as as the {\ttfamily Algebraic\+Nodes} and the {\ttfamily Spine\+Nodes}) for which algebraic node update operations are defined.

Here is an animation that illustrates how the successive update of the individual nodal positions in response to the change in the boundary position gradually updates the entire mesh.

 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{sparse_node_update}
\doxyfigcaption{Illustration of the sparse node-\/update procedure. }
\end{DoxyImage}




\hypertarget{index_how_it_works}{}\subsection{How it works}\label{index_how_it_works}
The implementation employs three key components\+:
\begin{DoxyItemize}
\item {\bfseries {\ttfamily Macro\+Element\+Node\+Update\+Nodes}} are derived from the {\ttfamily Node} base class. Their main purpose is to provide the {\ttfamily Macro\+Element\+Node\+Update\+Nodes\+::node\+\_\+update()} function which updates the nodal position in response to changes in the domain boundary. This capability was demonstrated above and is achieved by allowing the {\ttfamily Macro\+Element\+Node\+Update\+Nodes} to store a pointer to the {\ttfamily Macro\+Element\+Node\+Update\+Element} that determines its position (using its own {\ttfamily Macro\+Element} -\/ based representation) and its local coordinates in that element. ~\newline
~\newline
 {\ttfamily Macro\+Element\+Node\+Update\+Nodes} also store a function pointer to an auxiliary node update function that allows additional tasks to be performed whenever a node update is performed. This is useful, e.\+g. in unsteady fluid-\/structure interaction problems in which a change in the position of nodes that are located on a no-\/slip boundary also requires an update of the fluid velocities at that node. By default, the function pointer is initialised to N\+U\+LL, indicating that no auxiliary node update functions have to be executed. ~\newline
~\newline
 Finally, the {\ttfamily Macro\+Element\+Node\+Update\+Nodes} store pointers to the {\ttfamily Geom\+Objects} that affect their node update. While this information is not required by the node update function itself, it must be available to correctly set up the equation numbering scheme in the presence of hanging nodes. (Details are too messy to explain here but it\textquotesingle{}s true!). ~\newline
~\newline

\item The {\bfseries {\ttfamily Macro\+Element\+Node\+Update\+Element$<$\+E\+L\+E\+M\+E\+N\+T$>$}} class was already discussed in the main part of this document. These elements \char`\"{}wrap around\char`\"{} the element specified by the template argument, {\ttfamily E\+L\+E\+M\+E\+NT}, overload some of its member functions and add some new ones. ~\newline
 ~\newline
 Overloaded functions include\+: ~\newline
~\newline

\begin{DoxyItemize}
\item The {\ttfamily Finite\+Element\+::construct\+\_\+node}(...) functions create an element\textquotesingle{}s local {\ttfamily Nodes}. This is overloaded by a version that creates {\ttfamily Macro\+Element\+Node\+Update\+Nodes} instead. ~\newline
~\newline

\item The functions {\ttfamily Generalised\+Element\+::get\+\_\+jacobian}(...) and {\ttfamily Generalised\+Element\+::fill\+\_\+in\+\_\+contribution\+\_\+to\+\_\+jacobian}(...) are overloaded by versions that add the shape derivatives to the Jacobian matrices computed by the underlying E\+L\+E\+M\+E\+NT. ~\newline
~\newline

\item Similarly, the function {\ttfamily Finite\+Element\+::assign\+\_\+all\+\_\+generic\+\_\+local\+\_\+eqn\+\_\+numbers()} is overloaded to add the unknowns associated with the node update functions into the element\textquotesingle{}s equation numbering scheme. ~\newline
~\newline

\end{DoxyItemize}Additional member functions are provided to specify (and access) the {\ttfamily Geom\+Objects} that affect an element\textquotesingle{}s {\ttfamily Macro\+Element} -\/ based node update. Full details may be found in the \href{../../../the_data_structure/html/index.html}{\tt \char`\"{}bottom
  up\char`\"{}} discussion of {\ttfamily oomph-\/lib\textquotesingle{}s} data structure. ~\newline
~\newline

\item Finally, the {\bfseries {\ttfamily Macro\+Element\+Node\+Update\+Mesh\+Base}} class overloads the {\ttfamily Mesh\+::node\+\_\+update()} function to ensure that node updates are performed node-\/by-\/node, using the {\ttfamily Macro\+Element\+Node\+Update\+Node\+::node\+\_\+update()} function. This ensures that the node update not only updates the nodal positions but also executes any auxiliary update functions.
\end{DoxyItemize}

\hypertarget{index_fsi}{}\subsection{The method also works for non-\/\char`\"{}toy\char`\"{} problems!}\label{index_fsi}
The above example demonstrated how easy it is to \char`\"{}upgrade\char`\"{} a driver code for the solution of a single-\/physics problem to a fluid-\/structure-\/interaction-\/like free-\/boundary problem. It is important to stress that the methodology employed in our \char`\"{}toy\char`\"{} free-\/boundary problem can also be used for genuine fluid-\/structure interaction problems. For instance, the driver code for the simulation of \href{../../../navier_stokes/collapsible_channel/html/index.html}{\tt 2D unsteady finite-\/\+Reynolds number flow in a channel with an oscillating wall whose motion is prescribed} can easily be extended to a driver code for the corresponding \href{../../../interaction/fsi_collapsible_channel/html/index.html}{\tt fluid-\/structure interaction problem in which the wall is replaced by a flexible membrane that is loaded by the fluid traction.}



 

\hypertarget{index_sources}{}\section{Source files for this tutorial}\label{index_sources}

\begin{DoxyItemize}
\item The source files for this tutorial are located in the directory\+:~\newline
~\newline
\begin{center} \href{../../../../demo_drivers/interaction/free_boundary_poisson/}{\tt demo\+\_\+drivers/interaction/free\+\_\+boundary\+\_\+poisson/ } \end{center} ~\newline

\item The driver code is\+: ~\newline
~\newline
\begin{center} \href{../../../../demo_drivers/interaction/free_boundary_poisson/macro_element_free_boundary_poisson.cc}{\tt demo\+\_\+drivers/interaction/free\+\_\+boundary\+\_\+poisson/macro\+\_\+element\+\_\+free\+\_\+boundary\+\_\+poisson.\+cc } \end{center} 
\end{DoxyItemize}

 

 \hypertarget{index_pdf}{}\section{P\+D\+F file}\label{index_pdf}
A \href{../latex/refman.pdf}{\tt pdf version} of this document is available. \end{document}
