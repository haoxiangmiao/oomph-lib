This tutorial demonstrates the use of unstructured meshes in 2D fluid-\/structure interaction problems. We combine two single-\/physics problems, namely
\begin{DoxyItemize}
\item \href{../../../solid/unstructured_solid/html/index.html}{\tt Large deformations of an elastic 2D solid, loaded by surface tractions and a gravitational body force} ~\newline
~\newline

\item \href{../../../navier_stokes/unstructured_fluid/html/index.html}{\tt Flow through a 2D channel that is partly obstructed by a rigid 2D solid body}
\end{DoxyItemize}for which we have already created unstructured 2D meshes, using the combination of \href{http://en.wikipedia.org/wiki/Xfig}{\tt xfig}, {\ttfamily oomph-\/lib\textquotesingle{}s} conversion code \href{../../../meshes/mesh_from_xfig/html/index.html}{\tt {\ttfamily fig2poly},} and the unstructured mesh generator \href{http://www.cs.cmu.edu/~quake/triangle.html}{\tt {\ttfamily Triangle}. }



 

\hypertarget{index_the_problem}{}\section{The problem}\label{index_the_problem}
The figure below shows a sketch of the problem. A 2D channel is partly obstructed by an odd-\/shaped elastic obstacle that deforms in response to gravity and to the traction that the fluid exerts onto it. The coupled problem is a straightforward combination of the two single-\/physics problems shown at the top of the sketch\+: The flow through a channel with a rigid obstacle (shown on the top left), and the deformation of the elastic obstacle in response to a prescribed surface traction (shown on the top right). When the two constituent single-\/physics problems interact, the fluid provides the traction onto the solid while the change in the solid\textquotesingle{}s shape affects the fluid domain.

 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{fsi_sketch}
\doxyfigcaption{Sketch of the problem and its two single-\/physics constituents. }
\end{DoxyImage}


As usual, we solve the problem in non-\/dimensional form. For this purpose we non-\/dimensionalise all lengths on some reference length $ {\cal L} $ and use the average inflow velocity, $ {\cal U}$, to non-\/dimensionalise the velocities in the Navier-\/\+Stokes equations. As discussed in the \href{../../../navier_stokes/unstructured_fluid/html/index.html#reynolds}{\tt single-\/physics fluids tutorial,} the Reynolds number of the flow is then given by \[ Re = \frac{\rho {\cal U} {\cal L}}{\mu} \ , \] where $ \rho $ and $ \mu $ are the fluid density and viscosity, respectively. {\ttfamily oomph-\/lib\textquotesingle{}s} Navier Stokes elements non-\/dimensionalise the fluid stresses, and in particular the pressure, on the viscous scale, $ \mu {\cal U}/{\cal L} $.

We assume that the solid\textquotesingle{}s constitutive equation is given by {\ttfamily oomph-\/lib\textquotesingle{}s} generalised Hookean constitutive law and non-\/dimensionalise the solid-\/mechanics stresses and tractions with Young\textquotesingle{}s modulus $ E $.

The F\+SI interaction parameter $ Q $ which represents the ratio of the (viscous) fluid stress scale to the reference stress used to non-\/dimensionalise the solid stresses is therefore given by \[ Q = \frac{\mu {\cal U}}{{\cal L} E} \ . \]



 

\hypertarget{index_results}{}\section{Results}\label{index_results}
The animation below shows a number of steady flow fields (streamlines and pressure contours) and deformations, obtained in a parameter study in which we first compute the solution of the coupled problem at zero Reynolds number and for a vanishing F\+SI interaction parameter, $ Q=0 $. For these parameter values, the structure is loaded only by gravity and does not feel the presence of the fluid, whereas the fluid flow is affected by the changes to the fluid domain when the obstacle deforms (first frame). Next, we increase the Reynolds number to $ Re=10$ and re-\/compute the solution (second frame), before increasing $ Q $ in small increments (subsequent frames). The increase in $ Q $ may be interpreted as a reduction in the obstacle\textquotesingle{}s stiffness and the animation shows clearly how this increases its flow-\/induced deformation.

 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{flow}
\doxyfigcaption{Animation of the flow field (streamlines and pressure contours) and the deformation of the elastic obstacle. }
\end{DoxyImage}




 

\hypertarget{index_overview_implementation}{}\section{Overview of the implementation}\label{index_overview_implementation}
The use of unstructured meshes means that the design of an algebraic node update strategy for the deforming fluid mesh, as described for \href{../../fsi_collapsible_channel_algebraic/html/index.html}{\tt fluid-\/structure interaction with structured meshes, } is (almost) impossible and would, in any case, defeat the point of using automatic mesh generation tools. A slightly less efficient, but easily and generally applicable strategy is to update the nodal positions within the fluid mesh by treating the fluid domain as a pseudo-\/elastic solid. Apart from this change in the node-\/update strategy, the majority of the steps described below are the same as for fluid-\/structure-\/interaction problems on structured meshes.

One important prerequisite for the use of the F\+SI helper functions in {\ttfamily oomph-\/lib\textquotesingle{}s} {\ttfamily F\+S\+I\+\_\+functions} namespace is that each boundary at the F\+SI interface between the fluid and solid meshes must be parametrised by boundary coordinates. Moreover, the boundary-\/coordinate representations in the fluid and solid meshes {\bfseries  must } be consistent. Once the appropriate boundaries have been identified, {\ttfamily oomph-\/lib\textquotesingle{}s} unstructured meshes allow the automatic (and consistent) generation of these boundary coordinates; see \hyperlink{index_boundary_coord}{How the boundary coordinates are generated}. Unfortunately, different third-\/party mesh generators use different strategies to label mesh boundaries and a certain amount of \char`\"{}manual labour\char`\"{} tends be required to identify boundaries after the mesh has been imported into {\ttfamily oomph-\/lib}.

Since the driver code, discussed in detail below, is somewhat lengthy (partly because of the large number of self-\/tests and diagnostics included), we provide a brief overview of the main steps required to solve this problem\+: ~\newline
~\newline

\begin{DoxyEnumerate}
\item Use the combination of \href{http://en.wikipedia.org/wiki/Xfig}{\tt xfig}, {\ttfamily oomph-\/lib\textquotesingle{}s} conversion code \href{../../../meshes/mesh_from_xfig/html/index.html}{\tt {\ttfamily fig2poly},} and the unstructured mesh generator \href{http://www.cs.cmu.edu/~quake/triangle.html}{\tt {\ttfamily Triangle} } to generate the solid mesh, as already discussed in \href{../../../solid/unstructured_solid/html/index.html#mesh}{\tt another tutorial.} ~\newline
~\newline

\item Use the same procedure to generate the fluid mesh, as discussed in \href{../../../navier_stokes/unstructured_fluid/html/index.html#mesh}{\tt the single-\/physics fluids tutorial.} Make sure that the fluid mesh is derived from the {\ttfamily Solid\+Mesh} base class to allow the use of pseudo-\/elasticity to update the nodal positions in response to the deformation of the domain boundary. ~\newline
~\newline

\item Ensure that boundary coordinates are set up (consistently) on the F\+SI interface between the two meshes. For meshes derived from {\ttfamily oomph-\/lib\textquotesingle{}s} {\ttfamily Triangle\+Mesh} class, this may be done by calling the function {\ttfamily Triangle\+Mesh\+::setup\+\_\+boundary\+\_\+coordinates()}. ~\newline
~\newline

\item Attach {\ttfamily F\+S\+I\+Solid\+Traction\+Elements} to the faces of the \char`\"{}bulk\char`\"{} solid elements that are exposed to the fluid flow. These elements will apply the fluid traction to the solid. ~\newline
~\newline

\item Combine the {\ttfamily F\+S\+I\+Solid\+Traction\+Elements} into a compound {\ttfamily Geom\+Object} that provides a continuous representation of the solid\textquotesingle{}s F\+SI boundary, required by the {\ttfamily Impose\+Displacement\+By\+Lagrange\+Multiplier\+Elements} described below. ~\newline
~\newline

\item Attach {\ttfamily Impose\+Displacement\+By\+Lagrange\+Multiplier\+Elements} to the faces of the \char`\"{}bulk\char`\"{} fluid elements that are adjacent to the solid. These elements will employ Lagrange multipliers to deform the pseudo-\/solid fluid mesh so that its shape remains consistent with the solid\textquotesingle{}s F\+SI boundary (as described by the compound {\ttfamily Geom\+Object} created in the previous step). ~\newline
~\newline

\item Determine the \char`\"{}bulk\char`\"{} fluid elements that are adjacent to the integration points of the {\ttfamily F\+S\+I\+Solid\+Traction\+Elements}, using the function {\ttfamily F\+S\+I\+\_\+functions\+::setup\+\_\+fluid\+\_\+load\+\_\+info\+\_\+for\+\_\+solid\+\_\+elements}(...). ~\newline
~\newline

\end{DoxyEnumerate}In our experience, the most error-\/prone part of this procedure is the identification of the mesh boundaries in the \href{http://en.wikipedia.org/wiki/Xfig}{\tt xfig}-\/based, unstructured meshes. It is very easy to exclude a node at the end of the F\+SI boundary in the fluid mesh, say, while \char`\"{}remembering\char`\"{} it in the solid mesh. If this happens, the automatic matching of the unstructured fluid and solid meshes will not work (see \hyperlink{index_boundary_coord}{How the boundary coordinates are generated} for details). For this reason, the driver code presented below generates a lot of output that can be used to identify and fix such problems. See also the section \hyperlink{index_go_wrong}{What can go wrong?} at the end of this tutorial.



 

\hypertarget{index_namespace}{}\section{Problem Parameters}\label{index_namespace}
As usual we define the various problem parameters in a global namespace. We define the Reynolds number, $ Re $, and the F\+SI interaction parameter $ Q $.

 
\begin{DoxyCodeInclude}
\textcolor{comment}{//==start\_of\_namespace==============================}
\textcolor{comment}{/// Namespace for physical parameters}
\textcolor{comment}{}\textcolor{comment}{//==================================================}
\textcolor{keyword}{namespace }\hyperlink{namespaceGlobal__Parameters}{Global\_Parameters}
\{\textcolor{comment}{}
\textcolor{comment}{ /// Reynolds number}
\textcolor{comment}{} \textcolor{keywordtype}{double} Re=0.0; 
\textcolor{comment}{}
\textcolor{comment}{ /// FSI parameter}
\textcolor{comment}{} \textcolor{keywordtype}{double} Q=0.0;

\end{DoxyCodeInclude}


We define the gravitational body force that acts (only!) on the solid (see \hyperlink{index_b_f}{Gravity only affects the solid -\/-\/ really?} to find out why this is odd...)


\begin{DoxyCodeInclude}
\textcolor{comment}{}
\textcolor{comment}{ /// Non-dim gravity}
\textcolor{comment}{} \textcolor{keywordtype}{double} Gravity=0.0;
\textcolor{comment}{}
\textcolor{comment}{ /// Non-dimensional gravity as body force}
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{namespaceGlobal__Parameters_a200109847bf4cc26da4d00e8d68d569e}{gravity}(\textcolor{keyword}{const} \textcolor{keywordtype}{double}& time, 
              \textcolor{keyword}{const} Vector<double> &xi, 
              Vector<double> &b)
 \{
  b[0]=0.0;
  b[1]=-\hyperlink{namespaceGlobal__Parameters_a335000b5db4206486a116ae0468d2d0c}{Gravity};
 \}

\end{DoxyCodeInclude}


and provide a pointer to the constitutive equation for the solid. For simplicity, this constitutive equation will also be used for the (pseudo-\/)solid elements that determine the deformation of the fluid mesh. In general, the constitutive law used to control the deformation of the fluid mesh need not have any physical basis, it is more important that the elements do not become too deformed during the mesh motion.


\begin{DoxyCodeInclude}
\textcolor{comment}{}
\textcolor{comment}{ /// Pseudo-solid Poisson ratio}
\textcolor{comment}{} \textcolor{keywordtype}{double} Nu=0.3;
\textcolor{comment}{}
\textcolor{comment}{ /// Constitutive law for the solid (and pseudo-solid) mechanics}
\textcolor{comment}{} ConstitutiveLaw *Constitutive\_law\_pt=0;

\end{DoxyCodeInclude}


Finally, we provide a helper function that will be used to establish whether a node is located on the F\+SI boundary when the mesh is in its undeformed configuration. This function uses a simple \char`\"{}brute force\char`\"{} approach. It is required because currently our \href{http://en.wikipedia.org/wiki/Xfig}{\tt xfig}-\/based mesh generation procedures do not allow us to associate fractional parts of a polygonal domain boundary as belonging to different mesh boundaries. Hence, such boundaries have to be identified a posteriori in the driver code. Although similar in form, equivalent helper functions must be (re-\/)written for different domain geometries.


\begin{DoxyCodeInclude}
\textcolor{comment}{}
\textcolor{comment}{ /// Boolean to identify if node is on fsi boundary}
\textcolor{comment}{} \textcolor{keywordtype}{bool} \hyperlink{namespaceGlobal__Parameters_a655abf819eb3045dac883f2b7073ba22}{is\_on\_fsi\_boundary}(Node* nod\_pt)
 \{
  \textcolor{keywordflow}{if} (
   (
    \textcolor{comment}{// Is it a boundary node?}
    dynamic\_cast<BoundaryNodeBase*>(nod\_pt)!=0)&&
   (
    \textcolor{comment}{// Horizontal extent of main immersed obstacle}
    (  (nod\_pt->x(0)>1.6)&&(nod\_pt->x(0)<4.75)&&
       \textcolor{comment}{// Vertical extent of main immersed obstacle}
       (nod\_pt->x(1)>0.1125)&&(nod\_pt->x(1)<2.8) ) ||
    \textcolor{comment}{// Two nodes on the bottom wall are below y=0.3}
    (  (nod\_pt->x(1)<0.3)&&
       \textcolor{comment}{// ...and bracketed in these two x-ranges}
       (  ( (nod\_pt->x(0)>3.0)&&(nod\_pt->x(0)<3.1) ) ||
          ( (nod\_pt->x(0)<4.6)&&(nod\_pt->x(0)>4.5) )   ) 
     )
    )
   )
   \{
    \textcolor{keywordflow}{return} \textcolor{keyword}{true};
   \}
  \textcolor{keywordflow}{else}
   \{
    \textcolor{keywordflow}{return} \textcolor{keyword}{false};
   \}
 \}


\} \textcolor{comment}{// end\_of\_namespace}

\end{DoxyCodeInclude}




 

\hypertarget{index_mesh_code}{}\section{Creating the meshes}\label{index_mesh_code}
\hypertarget{index_solid_mesh}{}\subsection{The solid mesh}\label{index_solid_mesh}
Following the procedure discussed in the corresponding \href{../../../solid/unstructured_solid/html/index.html}{\tt single-\/physics solid mechanics problem} we create the mesh for the elastic obstacle using multiple inheritance from {\ttfamily oomph-\/lib\textquotesingle{}s} {\ttfamily Triangle\+Mesh} and the {\ttfamily Solid\+Mesh} base class.


\begin{DoxyCodeInclude}
\textcolor{comment}{//========start\_solid\_mesh=================================================}
\textcolor{comment}{/// Triangle-based mesh upgraded to become a solid mesh}
\textcolor{comment}{}\textcolor{comment}{//=========================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT>
\textcolor{keyword}{class }\hyperlink{classMySolidTriangleMesh}{MySolidTriangleMesh} : \textcolor{keyword}{public} \textcolor{keyword}{virtual} TriangleMesh<ELEMENT>, 
                          \textcolor{keyword}{public} \textcolor{keyword}{virtual} SolidMesh 
\{

\end{DoxyCodeInclude}


As before, we set the Lagrangian coordinates to the current nodal positions to make the initial configuration stress-\/free. Initially all boundary nodes are located on the same boundary, corresponding to the single xfig polyline that defines the surface of the elastic obstacle. In the current problem we have to identify two additional boundaries\+: The \char`\"{}bottom boundary\char`\"{} (boundary 1) where the positions of the solid nodes will be pinned; and the nodes that are located on the F\+SI boundary (boundary 2).


\begin{DoxyCodeInclude}
 
\textcolor{keyword}{public}:
 \textcolor{comment}{}
\textcolor{comment}{ /// Constructor: }
\textcolor{comment}{} \hyperlink{classMySolidTriangleMesh}{MySolidTriangleMesh}(\textcolor{keyword}{const} std::string& node\_file\_name,
                     \textcolor{keyword}{const} std::string& element\_file\_name,
                     \textcolor{keyword}{const} std::string& poly\_file\_name,
                     TimeStepper* time\_stepper\_pt=
                     &Mesh::Default\_TimeStepper) :
  TriangleMesh<ELEMENT>(node\_file\_name,element\_file\_name,
                        poly\_file\_name, time\_stepper\_pt)
  \{
   \textcolor{comment}{//Assign the Lagrangian coordinates}
   set\_lagrangian\_nodal\_coordinates();

   \textcolor{comment}{// Identify special boundaries}
   set\_nboundary(3);

   \textcolor{keywordtype}{unsigned} n\_node=this->nnode();
   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} j=0;j<n\_node;j++)
    \{
     Node* nod\_pt=this->node\_pt(j);

     \textcolor{comment}{// Boundary 1 is lower boundary}
     \textcolor{keywordflow}{if} (nod\_pt->x(1)<0.15)
      \{
       this->remove\_boundary\_node(0,nod\_pt);
       this->add\_boundary\_node(1,nod\_pt);
      \}

     \textcolor{comment}{// Boundary 2 is FSI interface}
     \textcolor{keywordflow}{if} (\hyperlink{namespaceGlobal__Parameters_a655abf819eb3045dac883f2b7073ba22}{Global\_Parameters::is\_on\_fsi\_boundary}(nod\_pt))
      \{
       this->remove\_boundary\_node(0,nod\_pt);
       this->add\_boundary\_node(2,nod\_pt);
      \}
    \}\textcolor{comment}{// done boundary assignment}

\end{DoxyCodeInclude}


Finally, we identify the elements that are located next to the newly created domain boundaries and create boundary coordinates along boundaries 1 and 2.


\begin{DoxyCodeInclude}

   \textcolor{comment}{// Identify the elements next to the newly created boundaries}
   TriangleMesh<ELEMENT>::setup\_boundary\_element\_info();
   
   \textcolor{comment}{// Setup boundary coordinates for boundaries 1 and 2}
   this->\textcolor{keyword}{template} setup\_boundary\_coordinates<ELEMENT>(1);
   this->\textcolor{keyword}{template} setup\_boundary\_coordinates<ELEMENT>(2);
  \}
 \textcolor{comment}{}
\textcolor{comment}{ /// Empty Destructor}
\textcolor{comment}{} \textcolor{keyword}{virtual} ~\hyperlink{classMySolidTriangleMesh}{MySolidTriangleMesh}() \{ \}

\};

\end{DoxyCodeInclude}




\hypertarget{index_fluid_mesh}{}\subsection{The fluid mesh}\label{index_fluid_mesh}
The creation of the fluid mesh follows the same process but uses the mesh created for the \href{../../../navier_stokes/unstructured_fluid/html/index.html}{\tt single-\/physics fluids problem.} The use of multiple inheritance from the {\ttfamily Triangle\+Mesh} and {\ttfamily Solid\+Mesh} base classes will allow us to employ pseudo-\/solid node-\/update techniques to update the position of the fluid nodes in response to changes in the domain boundary.


\begin{DoxyCodeInclude}
\textcolor{comment}{//======================start\_fluid\_mesh===================================}
\textcolor{comment}{/// Triangle-based mesh upgraded to become a pseudo-solid mesh}
\textcolor{comment}{}\textcolor{comment}{//=========================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT>
\textcolor{keyword}{class }\hyperlink{classFluidTriangleMesh}{FluidTriangleMesh} : \textcolor{keyword}{public} \textcolor{keyword}{virtual} TriangleMesh<ELEMENT>,
                          \textcolor{keyword}{public} \textcolor{keyword}{virtual} SolidMesh 
\{
 
\textcolor{keyword}{public}:
 \textcolor{comment}{}
\textcolor{comment}{ /// Constructor}
\textcolor{comment}{} \hyperlink{classFluidTriangleMesh_ab86c8fd8ee699923f5a4b199981d8c76}{FluidTriangleMesh}(\textcolor{keyword}{const} std::string& node\_file\_name,
                   \textcolor{keyword}{const} std::string& element\_file\_name,
                   \textcolor{keyword}{const} std::string& poly\_file\_name,
                   TimeStepper* time\_stepper\_pt=
                   &Mesh::Default\_TimeStepper) :
  TriangleMesh<ELEMENT>(node\_file\_name,element\_file\_name,
                        poly\_file\_name, time\_stepper\_pt)
  \{
   \textcolor{comment}{//Assign the Lagrangian coordinates}
   set\_lagrangian\_nodal\_coordinates();

\end{DoxyCodeInclude}


The fluid problem requires the identification of three additional boundaries\+: The inflow boundary (boundary 1), the outflow boundary (boundary 2) and the F\+SI boundary (boundary 3).


\begin{DoxyCodeInclude}

   \textcolor{comment}{// Identify special boundaries}
   this->set\_nboundary(4);

   \textcolor{keywordtype}{unsigned} n\_node=this->nnode();
   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} j=0;j<n\_node;j++)
    \{
     Node* nod\_pt=this->node\_pt(j);

     \textcolor{comment}{// Boundary 1 is left (inflow) boundary}
     \textcolor{keywordflow}{if} (nod\_pt->x(0)<0.226)
      \{
       this->remove\_boundary\_node(0,nod\_pt);
       this->add\_boundary\_node(1,nod\_pt);

       \textcolor{comment}{// Add overlapping nodes back to boundary 0}
       \textcolor{keywordflow}{if} (nod\_pt->x(1)<0.2) this->add\_boundary\_node(0,nod\_pt);
       \textcolor{keywordflow}{if} (nod\_pt->x(1)>4.06) this->add\_boundary\_node(0,nod\_pt);
      \}

     \textcolor{comment}{// Boundary 2 is right (outflow) boundary}
     \textcolor{keywordflow}{if} (nod\_pt->x(0)>8.28)
      \{
       this->remove\_boundary\_node(0,nod\_pt);
       this->add\_boundary\_node(2,nod\_pt);

       \textcolor{comment}{// Add overlapping nodes back to boundary 0}
       \textcolor{keywordflow}{if} (nod\_pt->x(1)<0.2) this->add\_boundary\_node(0,nod\_pt);
       \textcolor{keywordflow}{if} (nod\_pt->x(1)>4.06) this->add\_boundary\_node(0,nod\_pt);

      \}

     \textcolor{comment}{// Boundary 3 is FSI boundary}
     \textcolor{keywordflow}{if} (\hyperlink{namespaceGlobal__Parameters_a655abf819eb3045dac883f2b7073ba22}{Global\_Parameters::is\_on\_fsi\_boundary}(nod\_pt))
      \{
       this->remove\_boundary\_node(0,nod\_pt);
       this->add\_boundary\_node(3,nod\_pt);
       
       \textcolor{comment}{//If it's below y=0.2 it's also on boundary 0 so stick it back on}
       \textcolor{keywordflow}{if} (nod\_pt->x(1)<0.2) this->add\_boundary\_node(0,nod\_pt);
      \}
    \}
   TriangleMesh<ELEMENT>::setup\_boundary\_element\_info();

\end{DoxyCodeInclude}


We create boundary coordinates along the three newly-\/created mesh boundaries and document the process for the F\+SI boundary (boundary 3). See \hyperlink{index_go_wrong}{What can go wrong?} for a more detailed discussion of the output created here.


\begin{DoxyCodeInclude}
   
   \textcolor{comment}{// Open a file to doc the FaceElements that are used to}
   \textcolor{comment}{// create the boundary coordinates. The elements must}
   \textcolor{comment}{// form a simply-connected line. This may not work}
   \textcolor{comment}{// if the mesh is too coarse so that, e.g. an element}
   \textcolor{comment}{// that goes through the interior has endpoints that are}
   \textcolor{comment}{// both located on the same boundary. Outputting the}
   \textcolor{comment}{// FaceElements can help identify such cases.}
   ofstream some\_file(\textcolor{stringliteral}{"RESLT/boundary\_generation\_test.dat"});
   
   \textcolor{comment}{// Setup boundary coordinates for boundaries 1, 2 and 3}
   this->\textcolor{keyword}{template} setup\_boundary\_coordinates<ELEMENT>(1);
   this->\textcolor{keyword}{template} setup\_boundary\_coordinates<ELEMENT>(2);
   this->\textcolor{keyword}{template} setup\_boundary\_coordinates<ELEMENT>(3,some\_file);

   \textcolor{comment}{// Close it again}
   some\_file.close();
  \}
 \textcolor{comment}{}
\textcolor{comment}{ /// Empty Destructor}
\textcolor{comment}{} \textcolor{keyword}{virtual} ~\hyperlink{classFluidTriangleMesh}{FluidTriangleMesh}() \{ \}

\};

\end{DoxyCodeInclude}




 

\hypertarget{index_main}{}\section{The driver code}\label{index_main}
We specify an output directory and instantiate the constitutive equation for the solid mechanics computations, specifying the Poisson ratio. (\href{../../../solid/solid_theory/html/index.html#non-dim_solid}{\tt Recall} that the omission of Young\textquotesingle{}s modulus $ E $ in the constructor of the constitutive equation implies that all stresses and tractions are non-\/dimensionalised on $ E $.)

 
\begin{DoxyCodeInclude}
\textcolor{comment}{//==start\_of\_main======================================================}
\textcolor{comment}{/// Driver for unstructured fsi problem}
\textcolor{comment}{}\textcolor{comment}{//=====================================================================}
\textcolor{keywordtype}{int} \hyperlink{unstructured__two__d__fsi_8cc_ae66f6b31b5ad750f1fe042a706a4e3d4}{main}()
\{
 \textcolor{comment}{// Label for output}
 DocInfo doc\_info;
 
 \textcolor{comment}{// Set output directory}
 doc\_info.set\_directory(\textcolor{stringliteral}{"RESLT"});
 
 \textcolor{comment}{//Create the constitutive law}
 \hyperlink{namespaceGlobal__Parameters_adbd1f040f375c96fe56b3f475f7dbec2}{Global\_Parameters::Constitutive\_law\_pt} = \textcolor{keyword}{new} GeneralisedHookean(
  &\hyperlink{namespaceGlobal__Parameters_a20fccdcfa2c15ad8b951b9ada3bb1661}{Global\_Parameters::Nu});

\end{DoxyCodeInclude}


We create the {\ttfamily Problem} object and output the domain boundaries and the initial guess for the solution.


\begin{DoxyCodeInclude}
 
 \textcolor{comment}{// Build the problem with triangular Taylor Hood for fluid and solid}
 \hyperlink{classUnstructuredFSIProblem}{UnstructuredFSIProblem}<
 PseudoSolidNodeUpdateElement<TTaylorHoodElement<2>, TPVDElement<2,3> >, 
  TPVDElement<2,3> > problem;

 \textcolor{comment}{// Output boundaries }
 problem.\hyperlink{classUnstructuredFSIProblem_afe86a739cadf57036a0bf351ed9bc1a9}{fluid\_mesh\_pt}()->output\_boundaries(\textcolor{stringliteral}{"RESLT/fluid\_boundaries.dat"});
 problem.solid\_mesh\_pt()->output\_boundaries(\textcolor{stringliteral}{"RESLT/solid\_boundaries.dat"});
 
 \textcolor{comment}{// Output the initial guess for the solution}
 problem.doc\_solution(doc\_info);
 doc\_info.number()++;

\end{DoxyCodeInclude}


Finally, we perform a two-\/stage parameter study. We start by solving the problem at zero Reynolds number with the F\+SI parameter $ Q $ set to zero.


\begin{DoxyCodeInclude}
 
 \textcolor{comment}{// Parameter study}
 \hyperlink{namespaceGlobal__Parameters_a335000b5db4206486a116ae0468d2d0c}{Global\_Parameters::Gravity}=2.0e-4;
 \textcolor{keywordtype}{double} q\_increment=1.0e-6;

 \textcolor{comment}{// Solve the problem at zero Re and Q}
 problem.newton\_solve();
 
 \textcolor{comment}{// Output the solution}
 problem.doc\_solution(doc\_info);
 doc\_info.number()++;

\end{DoxyCodeInclude}


Next we re-\/solve the problem at finite Reynolds number, before slowly increasing the strength of the fluid-\/structure interaction.


\begin{DoxyCodeInclude}
 
 \textcolor{comment}{// Bump up Re}
 \hyperlink{namespaceGlobal__Parameters_a9d72e94a9305c6a310940a6a427ebe06}{Global\_Parameters::Re}=10.0;

 \textcolor{comment}{// Now do proper parameter study with increase in Q}
 \textcolor{keywordtype}{unsigned} nstep=2; \textcolor{comment}{// 10;}
 \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} i=0;i<nstep;i++)
  \{
   \textcolor{comment}{// Solve the problem}
   problem.newton\_solve();
   
   \textcolor{comment}{// Output the solution}
   problem.doc\_solution(doc\_info);
   doc\_info.number()++;

   \textcolor{comment}{// Bump up Q}
   \hyperlink{namespaceGlobal__Parameters_a7814fddf663e56168174a42d2cd6b4c1}{Global\_Parameters::Q}+=q\_increment;
  \}
 

\} \textcolor{comment}{// end\_of\_main}

\end{DoxyCodeInclude}




 

\hypertarget{index_class}{}\section{The Problem class}\label{index_class}
The {\ttfamily Problem} class has the usual members, with access functions to the fluid and solid meshes, and a post-\/processing routine.

 
\begin{DoxyCodeInclude}
\textcolor{comment}{//==start\_of\_problem\_class============================================}
\textcolor{comment}{/// Unstructured FSI Problem}
\textcolor{comment}{}\textcolor{comment}{//====================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} FLUID\_ELEMENT, \textcolor{keyword}{class} SOLID\_ELEMENT>
\textcolor{keyword}{class }\hyperlink{classUnstructuredFSIProblem}{UnstructuredFSIProblem} : \textcolor{keyword}{public} Problem
\{

\textcolor{keyword}{public}:
\textcolor{comment}{}
\textcolor{comment}{ /// Constructor}
\textcolor{comment}{} \hyperlink{classUnstructuredFSIProblem_a6a31fd839e0215ef1312942cf7284bd2}{UnstructuredFSIProblem}();
\textcolor{comment}{}
\textcolor{comment}{ /// Destructor (empty)}
\textcolor{comment}{} \hyperlink{classUnstructuredFSIProblem_a976a81e0dee902f6713bd8ca4d79d000}{~UnstructuredFSIProblem}()\{\}
\textcolor{comment}{}
\textcolor{comment}{ /// Access function for the fluid mesh}
\textcolor{comment}{} \hyperlink{classFluidTriangleMesh}{FluidTriangleMesh<FLUID\_ELEMENT>}*& 
      \hyperlink{classUnstructuredFSIProblem_afe86a739cadf57036a0bf351ed9bc1a9}{fluid\_mesh\_pt}() 
  \{
   \textcolor{keywordflow}{return} \hyperlink{classUnstructuredFSIProblem_a33c3b4cd9923f8b25368ff20e4810b2c}{Fluid\_mesh\_pt};
  \}
\textcolor{comment}{}
\textcolor{comment}{ /// Access function for the solid mesh}
\textcolor{comment}{} \hyperlink{classMySolidTriangleMesh}{MySolidTriangleMesh<SOLID\_ELEMENT>}*& 
      \hyperlink{classUnstructuredFSIProblem_ad1430c627842b8ea0a373adcf571647f}{solid\_mesh\_pt}() 
  \{
   \textcolor{keywordflow}{return} \hyperlink{classUnstructuredFSIProblem_aeb164665366e237ca311e448466d7c9d}{Solid\_mesh\_pt};
  \}
\textcolor{comment}{}
\textcolor{comment}{ /// Doc the solution}
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{classUnstructuredFSIProblem_a15f581318b505de07f50bd570da8c8d0}{doc\_solution}(DocInfo& doc\_info);

\end{DoxyCodeInclude}


The class provides two private helper functions\+: one to create the {\ttfamily Face\+Elements} that apply the fluid traction to the solid and one to create the {\ttfamily Face\+Elements} that use Lagrange multipliers to deform the fluid mesh according to the motion of the solid boundary.


\begin{DoxyCodeInclude}

\textcolor{keyword}{private}:
\textcolor{comment}{}
\textcolor{comment}{ /// Create FSI traction elements}
\textcolor{comment}{} \textcolor{keywordtype}{void} create\_fsi\_traction\_elements();
\textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Create elements that enforce prescribed boundary motion}
\textcolor{comment}{ /// for the pseudo-solid fluid mesh by Lagrange multipliers}
\textcolor{comment}{} \textcolor{keywordtype}{void} create\_lagrange\_multiplier\_elements();

\end{DoxyCodeInclude}


Another private helper function is provided to document the boundary parametrisation of the solid\textquotesingle{}s F\+SI interface\+:


\begin{DoxyCodeInclude}
\textcolor{comment}{}
\textcolor{comment}{ /// Sanity check: Doc boundary coordinates from solid side}
\textcolor{comment}{} \textcolor{keywordtype}{void} doc\_solid\_boundary\_coordinates();

\end{DoxyCodeInclude}


The private member data includes pointers to the various meshes and a {\ttfamily Geom\+Object} representation of the F\+SI boundary.


\begin{DoxyCodeInclude}
 \textcolor{comment}{}
\textcolor{comment}{ /// Fluid mesh}
\textcolor{comment}{} \hyperlink{classFluidTriangleMesh}{FluidTriangleMesh<FLUID\_ELEMENT>}* Fluid\_mesh\_pt;
\textcolor{comment}{}
\textcolor{comment}{ /// Solid mesh}
\textcolor{comment}{} \hyperlink{classMySolidTriangleMesh}{MySolidTriangleMesh<SOLID\_ELEMENT>}* Solid\_mesh\_pt;
\textcolor{comment}{}
\textcolor{comment}{ /// Pointers to mesh of Lagrange multiplier elements}
\textcolor{comment}{} SolidMesh* Lagrange\_multiplier\_mesh\_pt;
\textcolor{comment}{}
\textcolor{comment}{ /// Vector of pointers to mesh of FSI traction elements}
\textcolor{comment}{} SolidMesh* Traction\_mesh\_pt;
\textcolor{comment}{}
\textcolor{comment}{ /// GeomObject incarnation of fsi boundary in solid mesh}
\textcolor{comment}{} MeshAsGeomObject* 
 Solid\_fsi\_boundary\_pt;

\}; 

\end{DoxyCodeInclude}




 

\hypertarget{index_constructor}{}\section{The Problem constructor}\label{index_constructor}
We start by building the fluid mesh, using the files created by \href{http://www.cs.cmu.edu/~quake/triangle.html}{\tt {\ttfamily Triangle} }; see the discussion in the corresponding \href{../../../navier_stokes/unstructured_fluid/html/index.html#mesh}{\tt single-\/physics fluids problem.}


\begin{DoxyCodeInclude}
\textcolor{comment}{//==start\_of\_constructor==================================================}
\textcolor{comment}{/// Constructor for unstructured FSI problem.}
\textcolor{comment}{}\textcolor{comment}{//========================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} FLUID\_ELEMENT, \textcolor{keyword}{class} SOLID\_ELEMENT>
\hyperlink{classUnstructuredFSIProblem_a6a31fd839e0215ef1312942cf7284bd2}{UnstructuredFSIProblem<FLUID\_ELEMENT,SOLID\_ELEMENT>::UnstructuredFSIProblem}
      ()
\{ 

 \textcolor{comment}{// Fluid mesh}
 \textcolor{comment}{//-----------}

 \textcolor{comment}{//Create fluid mesh}
 \textcolor{keywordtype}{string} fluid\_node\_file\_name=\textcolor{stringliteral}{"fluid.fig.1.node"};
 \textcolor{keywordtype}{string} fluid\_element\_file\_name=\textcolor{stringliteral}{"fluid.fig.1.ele"};
 \textcolor{keywordtype}{string} fluid\_poly\_file\_name=\textcolor{stringliteral}{"fluid.fig.1.poly"}; 
 Fluid\_mesh\_pt = \textcolor{keyword}{new} \hyperlink{classFluidTriangleMesh}{FluidTriangleMesh<FLUID\_ELEMENT>}(fluid\_node\_file\_name,
                                                      fluid\_element\_file\_name,
                                                      fluid\_poly\_file\_name);

\end{DoxyCodeInclude}


Next, we apply the boundary conditions for the fluid and the pseudo-\/solid equations. We pin the pseudo-\/solid nodes along all domain boundaries, apart from the F\+SI boundary (boundary 3), apply a no-\/slip condition for the fluid velocity along the solid channel walls (boundary 0) and the F\+SI boundary (boundary 3); pin the velocity at the inflow (boundary 1, where we will impose a Poiseuille flow profile); and impose parallel outflow at the downstream end (boundary 2). As mentioned before, the manual identification of mesh boundaries in unstructured meshes that are generated by third-\/party mesh generators is a relatively error-\/prone process. Therefore we document the boundary conditions for the pseudo-\/solid to allow an external sanity check.


\begin{DoxyCodeInclude}
 
 \textcolor{comment}{// Doc pinned solid nodes}
 std::ofstream pseudo\_solid\_bc\_file(\textcolor{stringliteral}{"pinned\_pseudo\_solid\_nodes.dat"});

 \textcolor{comment}{// Set the boundary conditions for fluid problem: All nodes are}
 \textcolor{comment}{// free by default -- just pin the ones that have Dirichlet conditions}
 \textcolor{comment}{// here. }
 \textcolor{keywordtype}{unsigned} nbound=Fluid\_mesh\_pt->nboundary();
 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} ibound=0;ibound<nbound;ibound++)
  \{
   \textcolor{keywordtype}{unsigned} num\_nod=Fluid\_mesh\_pt->nboundary\_node(ibound);
   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} inod=0;inod<num\_nod;inod++)
    \{
     \textcolor{comment}{// Pin velocity everywhere apart from outlet where we}
     \textcolor{comment}{// have parallel outflow}
     \textcolor{keywordflow}{if} (ibound!=2)
      \{
       Fluid\_mesh\_pt->boundary\_node\_pt(ibound,inod)->pin(0); 
      \}
     Fluid\_mesh\_pt->boundary\_node\_pt(ibound,inod)->pin(1); 

     \textcolor{comment}{// Pin pseudo-solid positions everywhere apart from boundary 3, }
     \textcolor{comment}{// the fsi boundary }
     \textcolor{keywordflow}{if} ((ibound==0)||(ibound==1)||(ibound==2))
      \{
       \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} i=0;i<2;i++)
        \{
         \textcolor{comment}{// Pin the node}
         SolidNode* nod\_pt=Fluid\_mesh\_pt->boundary\_node\_pt(ibound,inod);
         nod\_pt->pin\_position(i);

         \textcolor{comment}{// Doc it as pinned}
         pseudo\_solid\_bc\_file << nod\_pt->x(i) << \textcolor{stringliteral}{" "};
        \}
       pseudo\_solid\_bc\_file << std::endl;
      \}
    \}
  \} \textcolor{comment}{// end loop over boundaries}

 \textcolor{comment}{// Close}
 pseudo\_solid\_bc\_file.close();

\end{DoxyCodeInclude}


We complete the build of the elements by specifying the Reynolds number and the constitutive equation used in the pseudo-\/solid mesh deformation.


\begin{DoxyCodeInclude}

 
 \textcolor{comment}{// Complete the build of the fluid elements so they are fully functional}
 \textcolor{keywordtype}{unsigned} n\_element = Fluid\_mesh\_pt->nelement();
 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} e=0;e<n\_element;e++)
  \{
   \textcolor{comment}{// Upcast from GeneralisedElement to the present element}
   FLUID\_ELEMENT* el\_pt = 
    \textcolor{keyword}{dynamic\_cast<}FLUID\_ELEMENT*\textcolor{keyword}{>}(Fluid\_mesh\_pt->element\_pt(e));
   
   \textcolor{comment}{//Set the Reynolds number}
   el\_pt->re\_pt() = &\hyperlink{namespaceGlobal__Parameters_a9d72e94a9305c6a310940a6a427ebe06}{Global\_Parameters::Re};
   
   \textcolor{comment}{// Set the constitutive law for pseudo-elastic mesh deformation}
   el\_pt->constitutive\_law\_pt() =
    \hyperlink{namespaceGlobal__Parameters_adbd1f040f375c96fe56b3f475f7dbec2}{Global\_Parameters::Constitutive\_law\_pt};
   
  \} \textcolor{comment}{// end loop over elements}

\end{DoxyCodeInclude}


Finally, we impose a Poiseuille profile at the inflow boundary (boundary 1) and assign the equation numbers.


\begin{DoxyCodeInclude}


 \textcolor{comment}{// Apply fluid boundary conditions: Poiseuille at inflow}

 \textcolor{comment}{// Find max. and min y-coordinate at inflow}
 \textcolor{keywordtype}{unsigned} ibound=1;
 \textcolor{comment}{//Initialise both to the y-coordinate of the first boundary node}
 \textcolor{keywordtype}{double} y\_min=fluid\_mesh\_pt()->boundary\_node\_pt(ibound,0)->x(1);;
 \textcolor{keywordtype}{double} y\_max=y\_min;

 \textcolor{comment}{//Loop over the rest of the boundary nodes}
 \textcolor{keywordtype}{unsigned} num\_nod= fluid\_mesh\_pt()->nboundary\_node(ibound);
 \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} inod=1;inod<num\_nod;inod++)
  \{
   \textcolor{keywordtype}{double} y=fluid\_mesh\_pt()->boundary\_node\_pt(ibound,inod)->x(1);
   \textcolor{keywordflow}{if} (y>y\_max)
    \{
     y\_max=y;
    \}
   \textcolor{keywordflow}{if} (y<y\_min)
    \{
     y\_min=y;
    \}
  \}
 \textcolor{keywordtype}{double} y\_mid=0.5*(y\_min+y\_max);
 
 \textcolor{comment}{// Loop over all boundaries}
 \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} n\_boundary = fluid\_mesh\_pt()->nboundary();
 \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} ibound=0;ibound<n\_boundary;ibound++)
  \{
   \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} num\_nod= fluid\_mesh\_pt()->nboundary\_node(ibound);
   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} inod=0;inod<num\_nod;inod++)
    \{
     \textcolor{comment}{// Parabolic inflow at the left boundary (boundary 1)}
     \textcolor{keywordflow}{if} (ibound==1)
      \{
       \textcolor{keywordtype}{double} y=fluid\_mesh\_pt()->boundary\_node\_pt(ibound,inod)->x(1);
       \textcolor{keywordtype}{double} veloc=1.5/(y\_max-y\_min)*
        (y-y\_min)*(y\_max-y)/((y\_mid-y\_min)*(y\_max-y\_mid));
       fluid\_mesh\_pt()->boundary\_node\_pt(ibound,inod)->set\_value(0,veloc);
       fluid\_mesh\_pt()->boundary\_node\_pt(ibound,inod)->set\_value(1,0.0);
      \}
     \textcolor{comment}{// Zero flow elsewhere }
     \textcolor{keywordflow}{else}
      \{
       fluid\_mesh\_pt()->boundary\_node\_pt(ibound,inod)->set\_value(0,0.0);
       fluid\_mesh\_pt()->boundary\_node\_pt(ibound,inod)->set\_value(1,0.0);
      \}
    \}
  \} \textcolor{comment}{// end Poiseuille}

\end{DoxyCodeInclude}


Next, we create the solid mesh, using the files created by \href{http://www.cs.cmu.edu/~quake/triangle.html}{\tt {\ttfamily Triangle} }; see the discussion in the corresponding \href{../../../solid/unstructured_solid/html/index.html#mesh}{\tt single-\/physics solids problem.}


\begin{DoxyCodeInclude}
 
 
 \textcolor{comment}{// Solid mesh}
 \textcolor{comment}{//-----------}
 
 \textcolor{comment}{//Create solid mesh}
 \textcolor{keywordtype}{string} solid\_node\_file\_name=\textcolor{stringliteral}{"solid.fig.1.node"};
 \textcolor{keywordtype}{string} solid\_element\_file\_name=\textcolor{stringliteral}{"solid.fig.1.ele"};
 \textcolor{keywordtype}{string} solid\_poly\_file\_name=\textcolor{stringliteral}{"solid.fig.1.poly"}; 
 Solid\_mesh\_pt = \textcolor{keyword}{new} \hyperlink{classMySolidTriangleMesh}{MySolidTriangleMesh<SOLID\_ELEMENT>}(
      solid\_node\_file\_name,
                                                     solid\_element\_file\_name,
                                                     solid\_poly\_file\_name);

\end{DoxyCodeInclude}


We complete the build of the solid elements by passing the pointer to the constitutive equation and the function pointer to the gravitational body force.


\begin{DoxyCodeInclude}

 
 \textcolor{comment}{// Complete the build of all solid elements so they are fully functional}
 n\_element = Solid\_mesh\_pt->nelement();
 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} i=0;i<n\_element;i++)
  \{
   \textcolor{comment}{//Cast to a solid element}
   SOLID\_ELEMENT *el\_pt = 
    \textcolor{keyword}{dynamic\_cast<}SOLID\_ELEMENT*\textcolor{keyword}{>}(Solid\_mesh\_pt->element\_pt(i));

   \textcolor{comment}{// Set the constitutive law}
   el\_pt->constitutive\_law\_pt() =
    \hyperlink{namespaceGlobal__Parameters_adbd1f040f375c96fe56b3f475f7dbec2}{Global\_Parameters::Constitutive\_law\_pt};
   
   \textcolor{comment}{//Set the body force}
   el\_pt->body\_force\_fct\_pt() = \hyperlink{namespaceGlobal__Parameters_a200109847bf4cc26da4d00e8d68d569e}{Global\_Parameters::gravity};
  \}

\end{DoxyCodeInclude}


We suppress the displacements of the nodes on boundary 1.


\begin{DoxyCodeInclude}
 
 \textcolor{comment}{// Pin both positions at lower boundary of solid mesh (boundary 1)}
 ibound=1;
 num\_nod=Solid\_mesh\_pt->nboundary\_node(ibound);
 \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} inod=0;inod<num\_nod;inod++)
  \{    
   Solid\_mesh\_pt->boundary\_node\_pt(ibound,inod)->pin\_position(0);
   Solid\_mesh\_pt->boundary\_node\_pt(ibound,inod)->pin\_position(1);
  \}

\end{DoxyCodeInclude}


Next, we create the {\ttfamily Face\+Elements} that apply the fluid traction to the solid


\begin{DoxyCodeInclude}


 \textcolor{comment}{// Create FSI Traction elements}
 \textcolor{comment}{//-----------------------------}

 \textcolor{comment}{// Now construct the (empty) traction element mesh}
 Traction\_mesh\_pt=\textcolor{keyword}{new} SolidMesh;

  \textcolor{comment}{// Build the FSI traction elements and add them to the traction mesh}
 create\_fsi\_traction\_elements();

\end{DoxyCodeInclude}


and the {\ttfamily Face\+Elements} that use Lagrange multipliers to deform the fluid mesh to keep it aligned with the F\+SI boundary.


\begin{DoxyCodeInclude}

 \textcolor{comment}{// Create Lagrange multiplier mesh for boundary motion}
 \textcolor{comment}{//----------------------------------------------------}
 
 \textcolor{comment}{// Construct the mesh of elements that enforce prescribed boundary motion}
 \textcolor{comment}{// of pseudo-solid fluid mesh by Lagrange multipliers}
 Lagrange\_multiplier\_mesh\_pt=\textcolor{keyword}{new} SolidMesh;
 create\_lagrange\_multiplier\_elements();

\end{DoxyCodeInclude}


We combine the various sub-\/meshes into a global mesh.


\begin{DoxyCodeInclude}


 \textcolor{comment}{// Combine meshes}
 \textcolor{comment}{//---------------}

 \textcolor{comment}{// Add sub meshes}
 add\_sub\_mesh(Fluid\_mesh\_pt);
 add\_sub\_mesh(Solid\_mesh\_pt);
 add\_sub\_mesh(Traction\_mesh\_pt);
 add\_sub\_mesh(Lagrange\_multiplier\_mesh\_pt);
 
 \textcolor{comment}{// Build global mesh}
 build\_global\_mesh();

\end{DoxyCodeInclude}


Finally, we set up the fluid-\/structure interaction by determining which \char`\"{}bulk\char`\"{} fluid elements are located next to the F\+SI traction elements that apply the fluid load to the solid. We document the boundary coordinate along the F\+SI interface by opening the {\ttfamily Multi\+\_\+domain\+\_\+functions\+::\+Doc\+\_\+boundary\+\_\+coordinate\+\_\+file} stream before calling {\ttfamily F\+S\+I\+\_\+functions\+::setup\+\_\+fluid\+\_\+load\+\_\+info\+\_\+for\+\_\+solid\+\_\+elements}(...) If this stream is open, the setup routine writes the Eulerian coordinates of the points on the F\+SI interface and their intrinsic surface coordinate $ [ x, y, \zeta ] $ to the specified file.


\begin{DoxyCodeInclude}


 \textcolor{comment}{// Setup FSI}
 \textcolor{comment}{//----------}

 \textcolor{comment}{// Document the boundary coordinate  along the FSI interface }
 \textcolor{comment}{// of the fluid mesh during call to}
 \textcolor{comment}{// setup\_fluid\_load\_info\_for\_solid\_elements()}
 Multi\_domain\_functions::Doc\_boundary\_coordinate\_file.open(
  \textcolor{stringliteral}{"fluid\_boundary\_test.dat"});

 \textcolor{comment}{// Work out which fluid dofs affect the residuals of the wall elements:}
 \textcolor{comment}{// We pass the boundary between the fluid and solid meshes and }
 \textcolor{comment}{// pointers to the meshes. The interaction boundary is boundary 3}
 \textcolor{comment}{// of the 2D fluid mesh.}
 FSI\_functions::setup\_fluid\_load\_info\_for\_solid\_elements<FLUID\_ELEMENT,2>
  (\textcolor{keyword}{this},3,Fluid\_mesh\_pt,Traction\_mesh\_pt);
 
 \textcolor{comment}{// Close the doc file}
 Multi\_domain\_functions::Doc\_boundary\_coordinate\_file.close();

\end{DoxyCodeInclude}


We use the private helper function {\ttfamily doc\+\_\+solid\+\_\+boundary\+\_\+coordinates()} to create the same output from the \char`\"{}solid side\char`\"{} of the F\+SI interface. This is useful for debugging purposes because it allows us to check whether the fluid and solid meshes employ a matching parametrisation of the F\+SI interface; see \hyperlink{index_go_wrong}{What can go wrong?} for more details.


\begin{DoxyCodeInclude}

 \textcolor{comment}{// Sanity check: Doc boundary coordinates from solid side}
 doc\_solid\_boundary\_coordinates();

\end{DoxyCodeInclude}


All that\textquotesingle{}s left to do is to set up the equation numbering scheme and the problem is ready to be solved.


\begin{DoxyCodeInclude}

 \textcolor{comment}{// Setup equation numbering scheme}
 cout <<\textcolor{stringliteral}{"Number of equations: "} << assign\_eqn\_numbers() << std::endl; 

\} \textcolor{comment}{// end\_of\_constructor}

\end{DoxyCodeInclude}




 

\hypertarget{index_fsi_traction}{}\section{Creating the F\+S\+I traction elements}\label{index_fsi_traction}
The creation of the F\+SI traction elements adjacent to the solid boundary 2 follows the usual procedure. We loop over the relevant 2D \char`\"{}bulk\char`\"{} solid elements and attach the {\ttfamily F\+S\+I\+Solid\+Traction\+Elements} to the appropriate faces.


\begin{DoxyCodeInclude}
\textcolor{comment}{//============start\_of\_create\_traction\_elements==========================}
\textcolor{comment}{/// Create FSI traction elements }
\textcolor{comment}{}\textcolor{comment}{//=======================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} FLUID\_ELEMENT,\textcolor{keyword}{class} SOLID\_ELEMENT>
\textcolor{keywordtype}{void} \hyperlink{classUnstructuredFSIProblem_a934a587c99668fca969a72814b3142a7}{UnstructuredFSIProblem<FLUID\_ELEMENT,SOLID\_ELEMENT>::}
\hyperlink{classUnstructuredFSIProblem_a934a587c99668fca969a72814b3142a7}{create\_fsi\_traction\_elements}()
\{
 \textcolor{comment}{// Traction elements are located on boundary 2 of solid bulk mesh}
 \textcolor{keywordtype}{unsigned} b=2;
 
 \textcolor{comment}{// How many bulk elements are adjacent to boundary b?}
 \textcolor{keywordtype}{unsigned} n\_element = solid\_mesh\_pt()->nboundary\_element(b);
 
 \textcolor{comment}{// Loop over the bulk elements adjacent to boundary b}
 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} e=0;e<n\_element;e++)
  \{
   \textcolor{comment}{// Get pointer to the bulk element that is adjacent to boundary b}
   SOLID\_ELEMENT* bulk\_elem\_pt = \textcolor{keyword}{dynamic\_cast<}SOLID\_ELEMENT*\textcolor{keyword}{>}(
    solid\_mesh\_pt()->boundary\_element\_pt(b,e));
   
   \textcolor{comment}{//What is the index of the face of the element e along boundary b}
   \textcolor{keywordtype}{int} face\_index = solid\_mesh\_pt()->face\_index\_at\_boundary(b,e);
  
   \textcolor{comment}{// Create new element }
   FSISolidTractionElement<SOLID\_ELEMENT,2>* el\_pt=
    \textcolor{keyword}{new} FSISolidTractionElement<SOLID\_ELEMENT,2>(bulk\_elem\_pt,face\_index);

\end{DoxyCodeInclude}


Next we add the newly-\/created {\ttfamily Face\+Element} to the mesh of traction elements, specify which boundary of the bulk mesh it is attached to, and pass the F\+SI interaction parameter $ Q $ to the element.


\begin{DoxyCodeInclude}
   
   \textcolor{comment}{// Add it to the mesh}
   Traction\_mesh\_pt->add\_element\_pt(el\_pt);
   
   \textcolor{comment}{// Specify boundary number}
   el\_pt->set\_boundary\_number\_in\_bulk\_mesh(b);
   
   \textcolor{comment}{// Function that specifies the load ratios}
   el\_pt->q\_pt() = &\hyperlink{namespaceGlobal__Parameters_a7814fddf663e56168174a42d2cd6b4c1}{Global\_Parameters::Q}; 
  \} 

 \} \textcolor{comment}{// end of create\_traction\_elements}

\end{DoxyCodeInclude}




 

\hypertarget{index_create_lagr}{}\section{Creating the Lagrange multiplier elements}\label{index_create_lagr}
The creation of the {\ttfamily Face\+Elements} that use Lagrange multipliers to impose the boundary displacement of the pseudo-\/solid fluid mesh is again fairly straightforward (the use of Lagrange multipliers for the imposition of boundary displacements is explained in \href{../../../solid/prescribed_displ_lagr_mult/html/index.html}{\tt another tutorial}). We start by combining the {\ttfamily F\+S\+I\+Solid\+Traction\+Elements} attached to the solid\textquotesingle{}s F\+SI boundary to form a compound {\ttfamily Geom\+Object}. This {\ttfamily Geom\+Object} provides a continuous representation of the F\+SI boundary (as determined by the deformation of the solid) and is parametrised by the boundary coordinate assigned earlier. This continuous representation will define the desired position of the boundary as enforced by the Lagrange multiplier elements.


\begin{DoxyCodeInclude}



\textcolor{comment}{//============start\_of\_create\_lagrange\_multiplier\_elements===============}\textcolor{comment}{}
\textcolor{comment}{/// Create elements that impose the prescribed boundary displacement}
\textcolor{comment}{/// for the pseudo-solid fluid mesh}
\textcolor{comment}{}\textcolor{comment}{//=======================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} FLUID\_ELEMENT, \textcolor{keyword}{class} SOLID\_ELEMENT>
\textcolor{keywordtype}{void} \hyperlink{classUnstructuredFSIProblem_a6f810c300f373cfc79e23d58f95944e3}{UnstructuredFSIProblem<FLUID\_ELEMENT,SOLID\_ELEMENT>::}
\hyperlink{classUnstructuredFSIProblem_a6f810c300f373cfc79e23d58f95944e3}{create\_lagrange\_multiplier\_elements}()
\{

 \textcolor{comment}{// Create  GeomObject incarnation of fsi boundary in solid mesh}
 Solid\_fsi\_boundary\_pt=
  \textcolor{keyword}{new} MeshAsGeomObject
  (Traction\_mesh\_pt);

\end{DoxyCodeInclude}


Now we attach {\ttfamily Impose\+Displacement\+By\+Lagrange\+Multiplier\+Elements} to the appropriate faces of the \char`\"{}bulk\char`\"{} fluid elements that are adjacent to the F\+SI interface (boundary 3 in the fluid mesh).


\begin{DoxyCodeInclude}
 
 \textcolor{comment}{// Lagrange multiplier elements are located on boundary 3 of the fluid mesh}
 \textcolor{keywordtype}{unsigned} b=3;

 \textcolor{comment}{// How many bulk fluid elements are adjacent to boundary b?}
 \textcolor{keywordtype}{unsigned} n\_element = Fluid\_mesh\_pt->nboundary\_element(b);
 
 \textcolor{comment}{// Loop over the bulk fluid elements adjacent to boundary b?}
 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} e=0;e<n\_element;e++)
  \{
   \textcolor{comment}{// Get pointer to the bulk fluid element that is adjacent to boundary b}
   FLUID\_ELEMENT* bulk\_elem\_pt = \textcolor{keyword}{dynamic\_cast<}FLUID\_ELEMENT*\textcolor{keyword}{>}(
    Fluid\_mesh\_pt->boundary\_element\_pt(b,e));
   
   \textcolor{comment}{//Find the index of the face of element e along boundary b}
   \textcolor{keywordtype}{int} face\_index = Fluid\_mesh\_pt->face\_index\_at\_boundary(b,e);
      
   \textcolor{comment}{// Create new element}
   ImposeDisplacementByLagrangeMultiplierElement<FLUID\_ELEMENT>* el\_pt =
    \textcolor{keyword}{new} ImposeDisplacementByLagrangeMultiplierElement<FLUID\_ELEMENT>(
     bulk\_elem\_pt,face\_index);   
   
   \textcolor{comment}{// Add it to the mesh}
   Lagrange\_multiplier\_mesh\_pt->add\_element\_pt(el\_pt);

\end{DoxyCodeInclude}


Next we pass a pointer to the compound {\ttfamily Geom\+Object} that defines the desired shape of the F\+SI interface and specify which boundary in the \char`\"{}bulk\char`\"{} fluid mesh the element is attached to.


\begin{DoxyCodeInclude}

   \textcolor{comment}{// Set the GeomObject that defines the boundary shape and set}
   \textcolor{comment}{// which bulk boundary we are attached to (needed to extract}
   \textcolor{comment}{// the boundary coordinate from the bulk nodes)}
   el\_pt->set\_boundary\_shape\_geom\_object\_pt(Solid\_fsi\_boundary\_pt,b);

\end{DoxyCodeInclude}


Finally, we apply boundary conditions for the Lagrange multipliers\+: we pin the Lagrange multipliers for nodes that are located on boundary 0 where the nodal displacements are pinned. (\href{../../../solid/prescribed_displ_lagr_mult/html/index.html}{\tt Recall} that the Lagrange multipliers are additional degrees of freedom added to the \char`\"{}bulk\char`\"{} degrees of freedom originally created by the \char`\"{}bulk\char`\"{} element.)


\begin{DoxyCodeInclude}
   
   \textcolor{comment}{// Loop over the nodes to apply boundary conditions}
   \textcolor{keywordtype}{unsigned} nnod=el\_pt->nnode();
   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} j=0;j<nnod;j++)
    \{
     Node* nod\_pt = el\_pt->node\_pt(j);
     
     \textcolor{comment}{// Is the node also on boundary 0? }
     \textcolor{keywordflow}{if} (nod\_pt->is\_on\_boundary(0))
      \{
       \textcolor{comment}{// How many nodal values were used by the "bulk" element}
       \textcolor{comment}{// that originally created this node?}
       \textcolor{keywordtype}{unsigned} n\_bulk\_value=el\_pt->nbulk\_value(j);
       
        \textcolor{comment}{// The remaining ones are Lagrange multipliers and we pin them.}
       \textcolor{keywordtype}{unsigned} nval=nod\_pt->nvalue();
       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} j=n\_bulk\_value;j<nval;j++)
        \{
         nod\_pt->pin(j);
        \}
      \}
    \}
  \}
 
\} \textcolor{comment}{// end of create\_lagrange\_multiplier\_elements}

\end{DoxyCodeInclude}




 

\hypertarget{index_doc_solution}{}\section{Post-\/processing}\label{index_doc_solution}
The post-\/processing routine simply executes the output functions for the fluid and solid meshes and writes the results into separate files.


\begin{DoxyCodeInclude}
\textcolor{comment}{//==start\_of\_doc\_solution=================================================}
\textcolor{comment}{/// Doc the solution}
\textcolor{comment}{}\textcolor{comment}{//========================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} FLUID\_ELEMENT, \textcolor{keyword}{class} SOLID\_ELEMENT>
\textcolor{keywordtype}{void} \hyperlink{classUnstructuredFSIProblem_a15f581318b505de07f50bd570da8c8d0}{UnstructuredFSIProblem<FLUID\_ELEMENT,SOLID\_ELEMENT>::}
\hyperlink{classUnstructuredFSIProblem_a15f581318b505de07f50bd570da8c8d0}{doc\_solution}(DocInfo& doc\_info)
\{ 
 ofstream some\_file;
 \textcolor{keywordtype}{char} filename[100];

 \textcolor{comment}{// Number of plot points}
 \textcolor{keywordtype}{unsigned} npts;
 npts=5; 

 \textcolor{comment}{// Output fluid solution }
 sprintf(filename,\textcolor{stringliteral}{"%s/fluid\_soln%i.dat"},doc\_info.directory().c\_str(),
         doc\_info.number());
 some\_file.open(filename);
 Fluid\_mesh\_pt->output(some\_file,npts);
 some\_file.close();


 \textcolor{comment}{// Output solid solution }
 sprintf(filename,\textcolor{stringliteral}{"%s/solid\_soln%i.dat"},doc\_info.directory().c\_str(),
         doc\_info.number());
 some\_file.open(filename);
 Solid\_mesh\_pt->output(some\_file,npts);
 some\_file.close();


\} \textcolor{comment}{// end\_of\_doc\_solution}

\end{DoxyCodeInclude}




 

\hypertarget{index_doc_solid_zeta}{}\section{Sanity check\+: Documenting the solid boundary coordinates}\label{index_doc_solid_zeta}
The function {\ttfamily doc\+\_\+solid\+\_\+boundary\+\_\+conditions()} documents the parametrisation of the solid\textquotesingle{}s F\+SI boundary in the file {\ttfamily solid\+\_\+boundary\+\_\+test.\+dat}. The file contains the solid\textquotesingle{}s counterpart of the $ [ x, y, \zeta ] $ data that we created for the fluid side of the F\+SI interface when setting up the fluid-\/structure interaction with {\ttfamily F\+S\+I\+\_\+functions\+::setup\+\_\+fluid\+\_\+load\+\_\+info\+\_\+for\+\_\+solid\+\_\+elements}(...). The two parametrisations should be consistent; see \hyperlink{index_go_wrong}{What can go wrong?} for more details.

The function also writes the file {\ttfamily fsi\+\_\+geom\+\_\+object.\+dat}, which may be used to check the integrity of the compound {\ttfamily Geom\+Object} that represents the F\+SI interface of the solid\+: As $ \zeta $ sweeps along the range used to parametrise the boundary, the position vector $ {\bf R}(\zeta) $, returned by {\ttfamily Geom\+Object\+::position}(...) should follow the F\+SI interface.

The implementation of the function is reasonably straightforward so we omit its listing here, see the \href{../../../../demo_drivers/interaction/unstructured_fsi/unstructured_two_d_fsi.cc}{\tt source code} for details.



 

\hypertarget{index_comm_ex}{}\section{Comments and Exercises}\label{index_comm_ex}
\hypertarget{index_boundary_coord}{}\subsection{How the boundary coordinates are generated}\label{index_boundary_coord}
The use of pseudo-\/elasticity for the node update in the fluid mesh makes the solution of F\+SI problems extremely straightforward. They key ingredient that allows the \char`\"{}automatic\char`\"{} coupling between the unstructured fluid and solid meshes is the (consistent!) generation of the boundary coordinate $ \zeta $ along the F\+SI interface. The function {\ttfamily Triangle\+Mesh\+::setup\+\_\+boundary\+\_\+coordinates}(...) achieves this automatically and exploits the facts that
\begin{DoxyEnumerate}
\item Meshes generated by \href{http://www.cs.cmu.edu/~quake/triangle.html}{\tt {\ttfamily Triangle} } are bounded by polygonal line segments.
\item Vertices in the polygonal domain boundary coincide with vertex nodes of the triangular finite elements.
\end{DoxyEnumerate}The assignment of the boundary coordinate along mesh boundary {\ttfamily b} is performed as follows\+:
\begin{DoxyEnumerate}
\item Attach {\ttfamily Face\+Elements} to the relevant faces of the \char`\"{}bulk\char`\"{} elements that are adjacent to mesh boundary {\ttfamily b}.
\item Establish the connectivity of the {\ttfamily Face\+Elements} using the fact that they share common {\ttfamily Nodes} and sort the elements into \char`\"{}connectivity\char`\"{} order around the boundary.
\item Locate the \char`\"{}lowest left\char`\"{} boundary node on the boundary and set its boundary coordinate to zero.
\item Step through the {\ttfamily Face\+Elements} (and their nodes) in order (taking into account that some {\ttfamily Face\+Elements} may be reversed relative to each other) and use the distance between adjacent nodes as the increment in the boundary coordinate.
\item Delete the {\ttfamily Face\+Elements}.
\end{DoxyEnumerate}This procedure generates a consistent boundary parametrisation, irrespective of how many fluid and solid elements meet at the shared F\+SI boundary. This is because the nodes along all {\ttfamily Face\+Elements} are located along the same straight line segments. The method would not work if the boundary was curvilinear!

The method also fails, if the \char`\"{}lower left\char`\"{} boundary nodes identified in the two meshes are not located at the same position. This tends to happen if boundary nodes are assigned inconsistently, e.\+g. because the final node on the F\+SI interface was identified as being located on the appropriate mesh boundary in the fluid mesh but not in the solid mesh. In that case the boundary coordinates of the two meshes are offset relatively to each other by an amount equal to the distance between the respective \char`\"{}lower left\char`\"{} nodes.

Here is a plot of the boundary coordinate $ \zeta $ generated from the fluid (blue) and solid (red) sides, with $ \zeta $ being plotted \char`\"{}on top\char`\"{} of the unstructured solid mesh.

 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{boundary_coordinate_check}
\doxyfigcaption{Plot of the boundary coordinates generated from the fluid and solid sides of the F\+SI interface. }
\end{DoxyImage}




\hypertarget{index_non_matching}{}\subsection{Fluid and solid meshes do not have to be matching}\label{index_non_matching}
To demonstrate that the fluid and solid meshes to not have to be matching across the F\+SI interface, here are the results of another computation in which a much finer fluid mesh was used.

This computation was performed by re-\/generating the mesh, running triangle with a smaller maximum element size\+:


\begin{DoxyCode}
triangle -q -a0.01 fluid.fig.poly
\end{DoxyCode}


The driver code remained completely unchanged.

 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{flow_fine}
\doxyfigcaption{Animation of the flow field (streamlines and pressure contours) and the deformation, computed on a refined fluid mesh. }
\end{DoxyImage}




\hypertarget{index_b_f}{}\subsection{Gravity only affects the solid -\/-\/ really?}\label{index_b_f}
The computations presented above suffer from a rather embarrassing modelling error. We have implicitly assumed that the solid is deformed significantly by gravity whereas no body force acts in the fluid. This is extremely unlikely to be right but makes for a useful exercise.
\begin{DoxyEnumerate}
\item Formulate the problem properly, starting from the dimensional form of the governing equations, to determine the correct non-\/dimensional body forces for the fluid and the solid. ~\newline
~\newline

\item Use your analysis to explain under what circumstances our \char`\"{}error\char`\"{} could actually be a justifiable approximation to the real system.
\end{DoxyEnumerate}



\hypertarget{index_go_wrong}{}\subsection{What can go wrong?}\label{index_go_wrong}
As indicated above, the methodology employed in this tutorial makes the formulation of 2D F\+SI problems extremely straightforward. The most difficult part of the entire procedure is identifying the appropriate boundaries in the mesh generated by third-\/party software. Here are a few things that can (and often do) go wrong, which result in the code being unable to set up consistent boundary coordinates.
\begin{DoxyItemize}
\item {\bfseries  Boundaries don\textquotesingle{}t match in xfig\+:} ~\newline
~\newline
 When drawing the boundaries of the fluid and solid domains in \href{http://en.wikipedia.org/wiki/Xfig}{\tt xfig}, it is important to ensure that the F\+SI boundary is the same. A simple way to achieve this is to draw the fluid domain first and then make a copy of the resulting $\ast$.fig file. Once the file has been renamed it can be loaded into \href{http://en.wikipedia.org/wiki/Xfig}{\tt xfig} and the polygonal vertices that are not part of the F\+SI interface can be deleted, while new vertices that are only part of the solid boundary can then be added. Just make sure that you don\textquotesingle{}t move any of the vertices that define the F\+SI interface! ~\newline
~\newline

\item {\bfseries  The mesh is too coarse for the automatic generation of boundary-\/lookup schemes\+:} ~\newline
~\newline
 \begin{center} \tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*{1}{|X[-1]}|}
\hline
{\bfseries Note\+:} We believe that the problem described here has now been fixed. However, it is possible/likely that there are particularly pathological meshes in which the scheme fails. If you encounter any such problems, please \href{../../../contact/html/index.html}{\tt let us know. }   \\\cline{1-1}
\end{longtabu}
\end{center}  ~\newline
~\newline
 Another problem arises if the mesh generated by \href{http://www.cs.cmu.edu/~quake/triangle.html}{\tt {\ttfamily Triangle} } is too coarse for the automatic identification of mesh boundaries by {\ttfamily Triangle\+Mesh\+Base\+::setup\+\_\+boundary\+\_\+element\+\_\+info()}. This function gets (justifiably) confused when the mesh is so coarse that both vertex nodes on an element edge that crosses the interior of the domain are located on the same mesh boundary. We do not intend to fix this problem -- if your mesh is that coarse, you should refine it! Anyway, if it happens, the problem may be diagnosed by plotting the output written to {\ttfamily Multi\+\_\+domain\+\_\+functions\+::\+Doc\+\_\+boundary\+\_\+coordinate\+\_\+file} if this stream is open when {\ttfamily F\+S\+I\+\_\+functions\+::setup\+\_\+fluid\+\_\+load\+\_\+info\+\_\+for\+\_\+solid\+\_\+elements}(...) is called. The file ({\ttfamily fluid\+\_\+boundary\+\_\+test.\+dat} in our driver code) contains the {\ttfamily Face\+Elements} that are attached to the (perceived) F\+SI boundary in the fluid mesh. (The file {\ttfamily solid\+\_\+boundary\+\_\+test.\+dat}, generated manually in our driver code, contains the same information for the solid mesh.) ~\newline
~\newline
 Here is what the plot should look like if the fluid mesh is sufficiently fine (the {\ttfamily Face\+Elements} are shown as thick red lines on top of the \char`\"{}bulk\char`\"{} fluid mesh)\+: ~\newline
~\newline
 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{boundary_generation_test}
\doxyfigcaption{Correct F\+SI boundary. }
\end{DoxyImage}
 ~\newline
 In the next figure, the fluid mesh is too coarse and the boundary detection has failed spectacularly\+: ~\newline
~\newline
 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{boundary_generation_test_too_coarse}
\doxyfigcaption{Wrongly identified F\+SI boundary on a (too) coarse fluid mesh. }
\end{DoxyImage}
 ~\newline
~\newline

\item {\bfseries  The boundary coordinates on the fluid and solid side of the F\+SI interface don\textquotesingle{}t match\+:} ~\newline
~\newline
 We have already alluded to this problem when discussing \hyperlink{index_boundary_coord}{How the boundary coordinates are generated}. The problem arises mainly (only?) when nodes at the \char`\"{}end\char`\"{} of the F\+SI interface are only added to the F\+SI boundary in one of the meshes but not the other. For this reason, we strongly recommend printing out the mesh boundaries and checking them carefully before proceeding. Here is a plot of the mesh boundaries for the current problem\+: ~\newline
~\newline
 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{boundaries}
\doxyfigcaption{Boundary nodes in the fluid (triangle) and solid (square) meshes. }
\end{DoxyImage}
 ~\newline

\end{DoxyItemize}



 

\hypertarget{index_sources}{}\section{Source files for this tutorial}\label{index_sources}

\begin{DoxyItemize}
\item The source files for this tutorial are located in the directory\+:~\newline
~\newline
\begin{center} \href{../../../../demo_drivers/interaction/unstructured_fsi}{\tt demo\+\_\+drivers/interaction/unstructured\+\_\+fsi } \end{center} ~\newline

\item The driver code is\+: ~\newline
~\newline
\begin{center} \href{../../../../demo_drivers/interaction/unstructured_fsi/unstructured_two_d_fsi.cc}{\tt demo\+\_\+drivers/interaction/unstructured\+\_\+fsi/unstructured\+\_\+two\+\_\+d\+\_\+fsi.\+cc } \end{center} 
\end{DoxyItemize}



 

 \hypertarget{index_pdf}{}\section{P\+D\+F file}\label{index_pdf}
A \href{../latex/refman.pdf}{\tt pdf version} of this document is available. \end{document}
