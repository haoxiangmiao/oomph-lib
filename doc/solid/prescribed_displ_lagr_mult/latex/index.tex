The purpose of this tutorial is to demonstrate how to impose the deformation of domain boundaries using Lagrange multipliers. This functionality is required, e.\+g. when using (pseudo-\/)solid mechanics to update the shape of the fluid mesh in fluid-\/structure interaction problems, say. (See \hyperlink{index_comm_and_ex}{Comments and Exercises} for a discussion of an alternative, somewhat easier method for imposing boundary displacements in single-\/physics solid mechanics problems).



 

\hypertarget{index_model}{}\section{The model problem}\label{index_model}
Here is a sketch of the model problem. A unit square is parametrised by two Lagrangian coordinates $ (\xi^1,\xi^2) $. Three of the four boundaries are held in a fixed position while the square\textquotesingle{}s upper boundary $ \partial D_{prescr}$ (which is parametrised by the boundary coordinate $ \zeta$) is displaced to a new position given by $ {\bf R}_{prescr}(\zeta) $\+:

 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{sketch}
\doxyfigcaption{Sketch of the problem. }
\end{DoxyImage}




 

\hypertarget{index_theory}{}\section{Theory and implementation}\label{index_theory}
We identify the upper boundary by writing the Lagrangian coordinates of points on $ \partial D_{prescr} $ as \[ \left. \big( \xi^1, \xi^2\big)\right|_{\partial D_{prescr}} = \big( \xi^1_{\partial D_{prescr}}(\zeta), \xi^2_{\partial D_{prescr}}(\zeta) \big) \] which allows us to write the displacement constraint as \[ {\bf R}(\xi^1_{\partial D_{prescr}}(\zeta),\xi^2_{\partial D_{prescr}}(\zeta)) = {\bf R}_{prescr}(\zeta). \] We enforce this constraint by augmenting the principle of virtual displacements, discussed in \href{../../solid_theory/html/index.html#equilibrium}{\tt the solid mechanics theory tutorial}, by a Lagrange multiplier term so that it becomes \[ \int \left\{ \sigma^{ij} \ \delta \gamma_{ij} - \left( {\bf f} - \Lambda^2 \frac{\partial^2 {\bf R}}{\partial t^2} \right) \cdot \delta {\bf R} \right\} \ dv - \oint_{A_{tract}} {\bf T} \cdot \delta {\bf R} \ dA \ + \ \delta \Pi_{constraint} = 0 \ \ \ \ \ \ \ \ (1) \] where \[ \Pi_{constraint} = \int_{\partial D} \bigg( {\bf R}(\xi^1(\zeta),\xi^2(\zeta)) - {\bf R}_{prescr}(\zeta) \bigg) \cdot {\bf \Lambda} \ dS. \] Here \[ dS = \left| \frac{d {\bf R}(\xi^1(\zeta),\xi^2(\zeta))}{d \zeta} \right| d\zeta \] is the differential of the arclength along the domain boundary and the vector $ {\bf \Lambda} $ (not to be confused with the scalar $ \Lambda^2 $ which represents the non-\/dimensional density in (1)!) is the Lagrange multiplier -- the surface traction to be applied to $ \partial D_{prescr} $ to deform the boundary into the required shape.

We discretise this constraint by attaching {\ttfamily Face\+Elements} to the boundaries of the \char`\"{}bulk\char`\"{} solid elements that are adjacent to $ \partial D_{prescr} $. We denote the number of nodes in these {\ttfamily Face\+Elements} by $ N $ and write the $ i $-\/th component of the discrete Lagrange multiplier stored at node $ j $ as $ L_{ij} $. Thus the $ i $ -\/th component of the Lagrange multiplier at local coordinate $ s $ in the element is given by \[ \Lambda_i = \sum_{j=1}^{N} L_{ij} \psi_j(s) \] where $ \psi_j(s) $ is the shape function associated with node $ j $.

Upon taking the variations of the discretised constraint with respect to the unknown nodal positions and the discrete Lagrange multipliers we obtain {\bfseries (i)} additional contributions to the residuals of the \char`\"{}bulk\char`\"{} solid mechanics equations (these may be interpreted as the virtual work done by the boundary tractions required to impose the prescribed boundary displacement) and {\bfseries (ii)} the equations that impose the displacement constraints in weak form.

The actual implementation of this approach in {\ttfamily oomph-\/lib} is best thought of as a generalisation of the {\ttfamily Solid\+Traction\+Elements} that are used to impose a prescribed traction to the boundary of a solid domain. The main difference is that in the {\ttfamily Impose\+Displacement\+By\+Lagrange\+Multiplier\+Element}, the imposed traction is one of the unknowns in the problem and must be determined via the displacement constraint, using the approach described above. The element introduces additional unknowns (the nodal values of the Lagrange multiplier) into the problem, therefore the {\ttfamily Impose\+Displacement\+By\+Lagrange\+Multiplier\+Element} resizes (increases) the number of values stored at the node from the value that was originally assigned by the \char`\"{}bulk\char`\"{} solid element it is attached to. (If the elements are used in a single-\/physics solid mechanics problem the discrete Lagrange multipliers are the only nodal values in the problem since the unknown nodal positions are stored in a separate {\ttfamily Data} item; cf. \href{../../solid_theory/html/index.html#solid_node}{\tt \char`\"{}\+Solid mechanics\+: Theory and implementation\char`\"{}} for more details). The prescribed boundary shape $ {\bf R}_{prescr}(\zeta) $ is provided by a {\ttfamily Geom\+Object}.



 

\hypertarget{index_results}{}\section{Results}\label{index_results}
The animation below shows the domain deformation in response to a prescribed boundary displacement given by

\[ {\bf R}_{prescr}(\zeta)= \left( \begin{array}{c} \zeta \\ 1 \end{array} \right) + A \left( \begin{array}{c} 5 \zeta\ (\zeta-1) \ (\zeta-0.7) \\ \frac{1}{2}\left(1-\cos\left(2\pi\zeta\right)\right) \end{array} \right) \]

With this choice the upper boundary remains flat (i.\+e. at $ x_2=1 $) when $ A=0 $. As $ A $ increases, the boundary is pulled upwards into a sinusoidal shape while simultaneously being pushed to the right. The vectors in the animation represent the Lagrange multipliers (i.\+e. the physical surface tractions) required to deform the domain into the required shape. Note how the automatic mesh adaptation refines the mesh in regions where the solid is strongly deformed.

 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{lagr_distort}
\doxyfigcaption{Domain deformation in response to the prescribed boundary displacement. }
\end{DoxyImage}




 

\hypertarget{index_prescribed_boundary}{}\section{Describing the prescribed boundary motion with a Geom\+Object}\label{index_prescribed_boundary}
Here is the implementation of the prescribed boundary shape as the {\ttfamily \hyperlink{classWarpedLine}{Warped\+Line}}, a two-\/dimensional {\ttfamily Geom\+Object} whose shape is parametrised by a single intrinsic coordinate.

 
\begin{DoxyCodeInclude}
\textcolor{comment}{//======Start\_of\_warped\_line===============================================}
\textcolor{comment}{/// Warped line in 2D space}
\textcolor{comment}{}\textcolor{comment}{//=========================================================================}
\textcolor{keyword}{class }\hyperlink{classWarpedLine}{WarpedLine} : \textcolor{keyword}{public} GeomObject
\{

\textcolor{keyword}{public}:
\textcolor{comment}{}
\textcolor{comment}{ /// Constructor: Specify amplitude of deflection from straight horizontal line}
\textcolor{comment}{} \hyperlink{classWarpedLine_a9d80dca2c907b426f7130579c94f3310}{WarpedLine}(\textcolor{keyword}{const} \textcolor{keywordtype}{double}& \hyperlink{classWarpedLine_ae43c2f997b9c0de62783375341ac5794}{ampl}) : GeomObject(1,2)
  \{
   \hyperlink{classWarpedLine_ac44286e84ff213e67e0f247d00ad50af}{Ampl}=\hyperlink{classWarpedLine_ae43c2f997b9c0de62783375341ac5794}{ampl};
  \}
\textcolor{comment}{}
\textcolor{comment}{ /// Broken copy constructor}
\textcolor{comment}{} \hyperlink{classWarpedLine_a9d80dca2c907b426f7130579c94f3310}{WarpedLine}(\textcolor{keyword}{const} \hyperlink{classWarpedLine}{WarpedLine}& dummy) 
  \{ 
   BrokenCopy::broken\_copy(\textcolor{stringliteral}{"WarpedLine"});
  \} 
 \textcolor{comment}{}
\textcolor{comment}{ /// Broken assignment operator}
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{classWarpedLine_ae2ee796906c0caa7e94f277f6fc499e1}{operator=}(\textcolor{keyword}{const} \hyperlink{classWarpedLine}{WarpedLine}&) 
  \{
   BrokenCopy::broken\_assign(\textcolor{stringliteral}{"WarpedLine"});
  \}

\textcolor{comment}{}
\textcolor{comment}{ /// Empty Destructor}
\textcolor{comment}{} \hyperlink{classWarpedLine_a4cb07fb7f06d42e2008afe65d8750cad}{~WarpedLine}()\{\}
\textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Position vector at Lagrangian coordinate zeta }
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{classWarpedLine_aaeef89818148ee3a305c561e91c8851d}{position}(\textcolor{keyword}{const} Vector<double>& zeta, Vector<double>& r)\textcolor{keyword}{ const}
\textcolor{keyword}{  }\{
   \textcolor{comment}{// Position vector}
   r[0] = zeta[0]+5.0*\hyperlink{classWarpedLine_ac44286e84ff213e67e0f247d00ad50af}{Ampl}*zeta[0]*(zeta[0]-1.0)*(zeta[0]-0.7);
   r[1] = 1.0+\hyperlink{classWarpedLine_ac44286e84ff213e67e0f247d00ad50af}{Ampl}*0.5*(1.0-cos(2.0*MathematicalConstants::Pi*zeta[0]));
  \}
 \textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Parametrised position on object: r(zeta). Evaluated at}
\textcolor{comment}{ /// previous timestep. t=0: current time; t>0: previous}
\textcolor{comment}{ /// timestep. Forward to steady version}
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{classWarpedLine_aaeef89818148ee3a305c561e91c8851d}{position}(\textcolor{keyword}{const} \textcolor{keywordtype}{unsigned}& t, \textcolor{keyword}{const} Vector<double>& zeta,
                       Vector<double>& r)\textcolor{keyword}{ const}
\textcolor{keyword}{  }\{
   \hyperlink{classWarpedLine_aaeef89818148ee3a305c561e91c8851d}{position}(zeta,r);
  \}
\textcolor{comment}{}
\textcolor{comment}{ /// Access to amplitude}
\textcolor{comment}{} \textcolor{keywordtype}{double}& \hyperlink{classWarpedLine_ae43c2f997b9c0de62783375341ac5794}{ampl}() \{\textcolor{keywordflow}{return} \hyperlink{classWarpedLine_ac44286e84ff213e67e0f247d00ad50af}{Ampl};\}
\textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short How many items of Data does the shape of the object depend on?}
\textcolor{comment}{ /// None.}
\textcolor{comment}{} \textcolor{keywordtype}{unsigned} \hyperlink{classWarpedLine_aa4157cd4ff2e80f33b106b7ed4e4d804}{ngeom\_data}()\textcolor{keyword}{ const}
\textcolor{keyword}{  }\{
   \textcolor{keywordflow}{return} 0;
  \}
 
\textcolor{keyword}{private}:
\textcolor{comment}{}
\textcolor{comment}{ /// Amplitude of perturbation}
\textcolor{comment}{} \textcolor{keywordtype}{double} \hyperlink{classWarpedLine_ac44286e84ff213e67e0f247d00ad50af}{Ampl};

\};

\end{DoxyCodeInclude}




 

\hypertarget{index_namespace}{}\section{Global parameters}\label{index_namespace}
As usual we define the problem parameters in a global namespace. We provide an instantiation of the {\ttfamily Geom\+Object} that defines the deformed boundary shape (setting its initial displacement amplitude to zero), and create an instance of {\ttfamily oomph-\/lib\textquotesingle{}s} generalised Hookean constitutive equation with a Poisson ratio of 0.\+3 (recall that the use of the single-\/argument constructor for this constitutive equation implies that all stresses are non-\/dimensionalised on Young\textquotesingle{}s modulus $ E $; see \href{../../solid_theory/html/index.html#non-dim_solid}{\tt the solid mechanics theory tutorial} for details).

 
\begin{DoxyCodeInclude}
\textcolor{comment}{//=======start\_namespace==========================================}
\textcolor{comment}{/// Global parameters}
\textcolor{comment}{}\textcolor{comment}{//================================================================}
\textcolor{keyword}{namespace }\hyperlink{namespaceGlobal__Physical__Variables}{Global\_Physical\_Variables}
\{
\textcolor{comment}{}
\textcolor{comment}{ /// GeomObject specifying the shape of the boundary: Initially it's flat.}
\textcolor{comment}{} \hyperlink{classWarpedLine}{WarpedLine} \hyperlink{namespaceGlobal__Physical__Variables_ab0a184463cbaaa353f2235411adef3c4}{Boundary\_geom\_object}(0.0);
\textcolor{comment}{}
\textcolor{comment}{ /// Poisson's ratio}
\textcolor{comment}{} \textcolor{keywordtype}{double} \hyperlink{namespaceGlobal__Physical__Variables_a9e06f4ada334a9a911aa8cdcfb3ff30b}{Nu}=0.3;

 \textcolor{comment}{// Generalised Hookean constitutive equations}
 GeneralisedHookean Constitutive\_law(&\hyperlink{namespaceGlobal__Physical__Variables_a9e06f4ada334a9a911aa8cdcfb3ff30b}{Global\_Physical\_Variables::Nu});
 
\} \textcolor{comment}{//end namespace}

\end{DoxyCodeInclude}




 

\hypertarget{index_driver}{}\section{The driver code}\label{index_driver}
We build an instantiation of the {\ttfamily Problem} class (described below), using nine-\/noded, two-\/dimensional {\ttfamily Refineable\+Q\+P\+V\+D\+Elements} to discretise the domain, and document the initial domain shape.

 
\begin{DoxyCodeInclude}
\textcolor{comment}{//=======start\_of\_main==================================================}
\textcolor{comment}{/// Driver code}
\textcolor{comment}{}\textcolor{comment}{//======================================================================}
\textcolor{keywordtype}{int} \hyperlink{prescribed__displ__lagr__mult_8cc_ae66f6b31b5ad750f1fe042a706a4e3d4}{main}()
\{
 
 \textcolor{comment}{//Set up the problem}
 \hyperlink{classPrescribedBoundaryDisplacementProblem}{PrescribedBoundaryDisplacementProblem<RefineableQPVDElement<2,3>}
       > problem;
 
 \textcolor{comment}{// Doc initial domain shape}
 problem.\hyperlink{classPrescribedBoundaryDisplacementProblem_abc58821d6b49cd9773dcd90b240aab6e}{doc\_solution}();

\end{DoxyCodeInclude}


We perform a parameter study, increasing the amplitude of the prescribed boundary deflection in small increments, while allowing one mesh adaptation per solution.


\begin{DoxyCodeInclude}

 \textcolor{comment}{// Max. number of adaptations per solve}
 \textcolor{keywordtype}{unsigned} max\_adapt=1;

 \textcolor{comment}{//Parameter incrementation}
 \textcolor{keywordtype}{unsigned} nstep=2; 
 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} i=0;i<nstep;i++)
  \{
   \textcolor{comment}{// Increment imposed boundary displacement}
   \hyperlink{namespaceGlobal__Physical__Variables_ab0a184463cbaaa353f2235411adef3c4}{Global\_Physical\_Variables::Boundary\_geom\_object}.
      \hyperlink{classWarpedLine_ae43c2f997b9c0de62783375341ac5794}{ampl}()+=0.1;

   \textcolor{comment}{// Solve the problem with Newton's method, allowing}
   \textcolor{comment}{// up to max\_adapt mesh adaptations after every solve.}
   problem.newton\_solve(max\_adapt);
   
   \textcolor{comment}{// Doc solution}
   problem.\hyperlink{classPrescribedBoundaryDisplacementProblem_abc58821d6b49cd9773dcd90b240aab6e}{doc\_solution}();

\end{DoxyCodeInclude}


Since the main use of the methodology demonstrated here is in free-\/boundary problems where the solution of the solid problem merely serves to update the nodal positions in response to the prescribed boundary motion, we re-\/set the nodes\textquotesingle{} Lagrangian coordinates to their Eulerian positions after every solve. This makes the deformed configuration stress-\/free and tends to stabilise the computation, allowing larger domain deformations to be computed. We stress, however, that this renders the computed solutions physically meaningless in the sense that the domain shapes no longer represent the solution of the original elasticity problem for which the stress-\/free, undeformed configuration remains unchanged throughout the body\textquotesingle{}s deformation.


\begin{DoxyCodeInclude}

   \textcolor{comment}{// For maximum stability: Reset the current nodal positions to be}
   \textcolor{comment}{// the "stress-free" ones -- this assignment means that the}
   \textcolor{comment}{// parameter study no longer corresponds to a physical experiment}
   \textcolor{comment}{// but is what we'd do if we wanted to use the solid solve}
   \textcolor{comment}{// to update a fluid mesh in an FSI problem, say.}
   problem.\hyperlink{classPrescribedBoundaryDisplacementProblem_ac0fc3028f61cec5ac4b01670d7728934}{solid\_mesh\_pt}()->set\_lagrangian\_nodal\_coordinates();
   
  \}
 
\} \textcolor{comment}{//end of main}

\end{DoxyCodeInclude}




 

\hypertarget{index_problem}{}\section{The Problem class}\label{index_problem}
The definition of the {\ttfamily Problem} class follows the usual pattern. We provide an access functions to the bulk mesh, as well as a few private helper functions that attach and detach the {\ttfamily Impose\+Displacement\+By\+Lagrange\+Multiplier\+Elements} from the bulk mesh before and after the mesh adaptation.

 
\begin{DoxyCodeInclude}
\textcolor{comment}{//=============begin\_problem============================================ }
\textcolor{comment}{/// Problem class for deformation of elastic block by prescribed}
\textcolor{comment}{}\textcolor{comment}{/// boundary motion.}
\textcolor{comment}{}\textcolor{comment}{//====================================================================== }
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT>
\textcolor{keyword}{class }\hyperlink{classPrescribedBoundaryDisplacementProblem}{PrescribedBoundaryDisplacementProblem} : \textcolor{keyword}{public} Problem
\{

\textcolor{keyword}{public}:
\textcolor{comment}{}
\textcolor{comment}{ /// Constructor:}
\textcolor{comment}{} \hyperlink{classPrescribedBoundaryDisplacementProblem_ac0c8b47eeb75ba2c618757e6b56e62dc}{PrescribedBoundaryDisplacementProblem}();
 \textcolor{comment}{}
\textcolor{comment}{ /// Update function (empty)}
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{classPrescribedBoundaryDisplacementProblem_a53e7d18d9d748388160d6c4106f1d493}{actions\_after\_newton\_solve}() \{\}
\textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Update function (empty)}
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{classPrescribedBoundaryDisplacementProblem_ad2184bb8d7391da21bec62d4aacf5c20}{actions\_before\_newton\_solve}() \{\}
\textcolor{comment}{}
\textcolor{comment}{ /// Access function for the solid mesh}
\textcolor{comment}{} ElasticRefineableRectangularQuadMesh<ELEMENT>*& \hyperlink{classPrescribedBoundaryDisplacementProblem_ac0fc3028f61cec5ac4b01670d7728934}{solid\_mesh\_pt}() 
  \{\textcolor{keywordflow}{return} \hyperlink{classPrescribedBoundaryDisplacementProblem_a6d2cdbd9ae1077c80831d938bdb72a61}{Solid\_mesh\_pt};\} 
\textcolor{comment}{}
\textcolor{comment}{ /// Actions before adapt: Wipe the mesh of Lagrange multiplier elements}
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{classPrescribedBoundaryDisplacementProblem_a2e9f335e8680b0f2338b579e37e9d38a}{actions\_before\_adapt}();
\textcolor{comment}{}
\textcolor{comment}{ /// Actions after adapt: Rebuild the mesh of Lagrange multiplier elements}
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{classPrescribedBoundaryDisplacementProblem_aae7225db18ad5c8429c0eb96fa37b585}{actions\_after\_adapt}();
\textcolor{comment}{}
\textcolor{comment}{ /// Doc the solution}
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{classPrescribedBoundaryDisplacementProblem_abc58821d6b49cd9773dcd90b240aab6e}{doc\_solution}();

\textcolor{keyword}{private}:
\textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Create elements that enforce prescribed boundary motion}
\textcolor{comment}{ /// by Lagrange multiplilers}
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{classPrescribedBoundaryDisplacementProblem_adf4798f13809f5b2f2be6e3d63421edc}{create\_lagrange\_multiplier\_elements}();
\textcolor{comment}{}
\textcolor{comment}{ /// Delete elements that enforce prescribed boundary motion}
\textcolor{comment}{ /// by Lagrange multiplilers}
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{classPrescribedBoundaryDisplacementProblem_a0204ae947ffd18ed3d7690395901a1e8}{delete\_lagrange\_multiplier\_elements}();
\textcolor{comment}{}
\textcolor{comment}{ /// Pointer to solid mesh}
\textcolor{comment}{} ElasticRefineableRectangularQuadMesh<ELEMENT>* \hyperlink{classPrescribedBoundaryDisplacementProblem_a6d2cdbd9ae1077c80831d938bdb72a61}{Solid\_mesh\_pt};
\textcolor{comment}{}
\textcolor{comment}{ /// Pointers to meshes of Lagrange multiplier elements}
\textcolor{comment}{} SolidMesh* \hyperlink{classPrescribedBoundaryDisplacementProblem_abb87cb0933297f449af7ceac7fe2bd77}{Lagrange\_multiplier\_mesh\_pt};
\textcolor{comment}{}
\textcolor{comment}{ /// DocInfo object for output}
\textcolor{comment}{} DocInfo \hyperlink{classPrescribedBoundaryDisplacementProblem_aef72ea29567df89d82fe93235f1907f8}{Doc\_info};
 
\};

\end{DoxyCodeInclude}




 

\hypertarget{index_constructor}{}\section{The Problem constructor}\label{index_constructor}
We start by creating the \char`\"{}bulk\char`\"{} mesh, discretising the domain with 5x5 elements of the type specified by the class\textquotesingle{}s template argument.

 
\begin{DoxyCodeInclude}
\textcolor{comment}{//===========start\_of\_constructor======================================= }
\textcolor{comment}{/// Constructor: }
\textcolor{comment}{}\textcolor{comment}{//====================================================================== }
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT>

      \hyperlink{classPrescribedBoundaryDisplacementProblem_ac0c8b47eeb75ba2c618757e6b56e62dc}{PrescribedBoundaryDisplacementProblem<ELEMENT>::PrescribedBoundaryDisplacementProblem}
      () 
\{

 \textcolor{comment}{// Create the mesh}

 \textcolor{comment}{// # of elements in x-direction}
 \textcolor{keywordtype}{unsigned} n\_x=5;

 \textcolor{comment}{// # of elements in y-direction}
 \textcolor{keywordtype}{unsigned} n\_y=5;

 \textcolor{comment}{// Domain length in x-direction}
 \textcolor{keywordtype}{double} l\_x=1.0;

 \textcolor{comment}{// Domain length in y-direction}
 \textcolor{keywordtype}{double} l\_y=1.0;

 \textcolor{comment}{//Now create the mesh }
 solid\_mesh\_pt() = \textcolor{keyword}{new} ElasticRefineableRectangularQuadMesh<ELEMENT>(
  n\_x,n\_y,l\_x,l\_y);

\end{DoxyCodeInclude}


Next we specify the error estimator, pass the pointer to the constitutive equation to the elements and perform one uniform mesh refinement\+:


\begin{DoxyCodeInclude}

 \textcolor{comment}{// Set error estimator}
 solid\_mesh\_pt()->spatial\_error\_estimator\_pt()=\textcolor{keyword}{new} Z2ErrorEstimator;

 \textcolor{comment}{//Assign the physical properties to the elements before any refinement}
 \textcolor{comment}{//Loop over the elements in the main mesh}
 \textcolor{keywordtype}{unsigned} n\_element =solid\_mesh\_pt()->nelement();
 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} i=0;i<n\_element;i++)
  \{
   \textcolor{comment}{//Cast to a solid element}
   ELEMENT *el\_pt = \textcolor{keyword}{dynamic\_cast<}ELEMENT*\textcolor{keyword}{>}(solid\_mesh\_pt()->element\_pt(i));
   
   \textcolor{comment}{// Set the constitutive law}
   el\_pt->constitutive\_law\_pt()=&Global\_Physical\_Variables::Constitutive\_law;
  \}

 \textcolor{comment}{// Refine the mesh uniformly}
 solid\_mesh\_pt()->refine\_uniformly();

\end{DoxyCodeInclude}


We now create a new {\ttfamily Solid\+Mesh} in which we store the elements that apply the displacement constraint. These elements are built (and added to the newly created {\ttfamily Solid\+Mesh}) in the helper function {\ttfamily create\+\_\+lagrange\+\_\+multiplier\+\_\+elements()}. Both meshes are then combined to the {\ttfamily Problem\textquotesingle{}s} global mesh.


\begin{DoxyCodeInclude}

 \textcolor{comment}{// Construct the mesh of elements that enforce prescribed boundary motion}
 \textcolor{comment}{// by Lagrange multipliers}
 Lagrange\_multiplier\_mesh\_pt=\textcolor{keyword}{new} SolidMesh;
 create\_lagrange\_multiplier\_elements();
 
 \textcolor{comment}{// Solid mesh is first sub-mesh}
 add\_sub\_mesh(solid\_mesh\_pt());

 \textcolor{comment}{// Add Lagrange multiplier sub-mesh}
 add\_sub\_mesh(Lagrange\_multiplier\_mesh\_pt);

 \textcolor{comment}{// Build combined "global" mesh}
 build\_global\_mesh();

\end{DoxyCodeInclude}


We pin the position of the nodes on all domain boundaries apart from the top boundary (boundary 2) and pin any redundant pressure degrees of freedom. (This is not strictly necessary in the present driver code since the displacement-\/based {\ttfamily Refineable\+Q\+P\+V\+D\+Elements} do not have any pressure degrees of freedom. However, it is good practice to do this anyway to guard against unpleasant surprises when the element type is changed at some point).


\begin{DoxyCodeInclude}
 
 \textcolor{comment}{// Pin nodal positions on all boundaries apart from the top one (2) }
 \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} b=0;b<4;b++)
  \{
   \textcolor{keywordflow}{if} (b!=2)
    \{
     \textcolor{keywordtype}{unsigned} n\_side = solid\_mesh\_pt()->nboundary\_node(b);
     
     \textcolor{comment}{//Loop over the nodes}
     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} i=0;i<n\_side;i++)
      \{
       solid\_mesh\_pt()->boundary\_node\_pt(b,i)->pin\_position(0);
       solid\_mesh\_pt()->boundary\_node\_pt(b,i)->pin\_position(1);
      \}
    \}
  \}

 \textcolor{comment}{// Pin the redundant solid pressures (if any)}
 PVDEquationsBase<2>::pin\_redundant\_nodal\_solid\_pressures(
  solid\_mesh\_pt()->element\_pt());

\end{DoxyCodeInclude}


Finally, we assign the equation numbers and specify the output directory.


\begin{DoxyCodeInclude}

 \textcolor{comment}{// Setup equation numbering scheme}
 cout << \textcolor{stringliteral}{"Number of dofs: "} << assign\_eqn\_numbers() << std::endl; 

 \textcolor{comment}{// Set output directory}
 Doc\_info.set\_directory(\textcolor{stringliteral}{"RESLT"});

\} \textcolor{comment}{//end of constructor}

\end{DoxyCodeInclude}




 

\hypertarget{index_actions_before_adapt}{}\section{Actions before mesh adaptation}\label{index_actions_before_adapt}
As usual, we remove the {\ttfamily Face\+Elements} that apply the displacement constraints before the bulk mesh is adapted.

 
\begin{DoxyCodeInclude}
\textcolor{comment}{//=====================start\_of\_actions\_before\_adapt======================}
\textcolor{comment}{/// Actions before adapt: Wipe the mesh of elements that impose}
\textcolor{comment}{}\textcolor{comment}{/// the prescribed boundary displacements}
\textcolor{comment}{}\textcolor{comment}{//========================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT>
\textcolor{keywordtype}{void} \hyperlink{classPrescribedBoundaryDisplacementProblem_a2e9f335e8680b0f2338b579e37e9d38a}{PrescribedBoundaryDisplacementProblem<ELEMENT>::actions\_before\_adapt}
      ()
\{
 \textcolor{comment}{// Kill the  elements and wipe surface mesh}
 delete\_lagrange\_multiplier\_elements();
 
 \textcolor{comment}{// Rebuild the Problem's global mesh from its various sub-meshes}
 rebuild\_global\_mesh();

\}\textcolor{comment}{// end of actions\_before\_adapt}

\end{DoxyCodeInclude}




 

\hypertarget{index_actions_after_adapt}{}\section{Actions after mesh adaptation}\label{index_actions_after_adapt}
We re-\/attach the {\ttfamily Face\+Elements} that apply the displacement constraints once the bulk mesh has been adapted. Since the hanging status of nodes in the bulk mesh can change during the mesh adaptation it is again good practice to pin any nodal solid pressure values that may have become redundant.

 
\begin{DoxyCodeInclude}
\textcolor{comment}{//=====================start\_of\_actions\_after\_adapt=======================}
\textcolor{comment}{///  Actions after adapt: Rebuild the mesh of elements that impose}
\textcolor{comment}{}\textcolor{comment}{/// the prescribed boundary displacements}
\textcolor{comment}{}\textcolor{comment}{//========================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT>
\textcolor{keywordtype}{void} \hyperlink{classPrescribedBoundaryDisplacementProblem_aae7225db18ad5c8429c0eb96fa37b585}{PrescribedBoundaryDisplacementProblem<ELEMENT>::actions\_after\_adapt}
      ()
\{
 \textcolor{comment}{// Create the elements that impose the displacement constraint }
 \textcolor{comment}{// and attach them to the bulk elements that are}
 \textcolor{comment}{// adjacent to boundary 2 }
 create\_lagrange\_multiplier\_elements();
 
 \textcolor{comment}{// Rebuild the Problem's global mesh from its various sub-meshes}
 rebuild\_global\_mesh();
 
 \textcolor{comment}{// Pin the redundant solid pressures (if any)}
 PVDEquationsBase<2>::pin\_redundant\_nodal\_solid\_pressures(
  solid\_mesh\_pt()->element\_pt());
 
\}\textcolor{comment}{// end of actions\_after\_adapt}

\end{DoxyCodeInclude}




 

\hypertarget{index_lagr_elements}{}\section{Creating the Lagrange multiplier elements that impose the displacement constraint}\label{index_lagr_elements}
The creation of the Lagrange multiplier elements that impose the displacement constraint follows the usual pattern. We loop over the \char`\"{}bulk\char`\"{} solid elements that are adjacent to mesh boundary 2 and attach {\ttfamily Impose\+Displacement\+By\+Lagrange\+Multiplier\+Elements} to the appropriate faces.

 
\begin{DoxyCodeInclude}
\textcolor{comment}{//============start\_of\_create\_lagrange\_multiplier\_elements===============}
\textcolor{comment}{/// Create elements that impose the prescribed boundary displacement}
\textcolor{comment}{}\textcolor{comment}{//=======================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT>
\textcolor{keywordtype}{void} \hyperlink{classPrescribedBoundaryDisplacementProblem_adf4798f13809f5b2f2be6e3d63421edc}{PrescribedBoundaryDisplacementProblem<ELEMENT>::}
\hyperlink{classPrescribedBoundaryDisplacementProblem_adf4798f13809f5b2f2be6e3d63421edc}{create\_lagrange\_multiplier\_elements}()
\{
 \textcolor{comment}{// Lagrange multiplier elements are located on boundary 2:}
 \textcolor{keywordtype}{unsigned} b=2;

 \textcolor{comment}{// How many bulk elements are adjacent to boundary b?}
 \textcolor{keywordtype}{unsigned} n\_element = solid\_mesh\_pt()->nboundary\_element(b);
 
 \textcolor{comment}{// Loop over the bulk elements adjacent to boundary b?}
 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} e=0;e<n\_element;e++)
  \{
   \textcolor{comment}{// Get pointer to the bulk element that is adjacent to boundary b}
   ELEMENT* bulk\_elem\_pt = \textcolor{keyword}{dynamic\_cast<}ELEMENT*\textcolor{keyword}{>}(
    solid\_mesh\_pt()->boundary\_element\_pt(b,e));
   
   \textcolor{comment}{//Find the index of the face of element e along boundary b}
   \textcolor{keywordtype}{int} face\_index = solid\_mesh\_pt()->face\_index\_at\_boundary(b,e);
      
   \textcolor{comment}{// Create new element and add to mesh}
   Lagrange\_multiplier\_mesh\_pt->add\_element\_pt(
    \textcolor{keyword}{new} ImposeDisplacementByLagrangeMultiplierElement<ELEMENT>(
     bulk\_elem\_pt,face\_index));   
  \}  

\end{DoxyCodeInclude}


Next we loop over the newly-\/created {\ttfamily Impose\+Displacement\+By\+Lagrange\+Multiplier\+Elements} and specify the {\ttfamily Geom\+Object} that defines the imposed boundary displacements. We also specify which boundary of the bulk mesh the {\ttfamily Impose\+Displacement\+By\+Lagrange\+Multiplier\+Elements} are located on. This is required to enable the {\ttfamily Impose\+Displacement\+By\+Lagrange\+Multiplier\+Elements} to extract the appropriate boundary coordinate from its constituent nodes. (We discussed \href{../../../poisson/fish_poisson2/html/index.html#boundary_coords}{\tt elsewhere} that boundary coordinates are usually defined (and passed to the nodes) when the nodes are first created, typically during the construction of the bulk mesh. Since nodes can be located on multiple domain boundaries, each boundary coordinate is associated with a particular boundary number. Passing this number to the {\ttfamily Impose\+Displacement\+By\+Lagrange\+Multiplier\+Elements} allows them to obtain the correct boundary coordinate from the node.)


\begin{DoxyCodeInclude}

 
 \textcolor{comment}{// Loop over the elements in the Lagrange multiplier element mesh}
 \textcolor{comment}{// for elements on the top boundary (boundary 2)}
 n\_element=Lagrange\_multiplier\_mesh\_pt->nelement();
 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} i=0;i<n\_element;i++)
  \{
   \textcolor{comment}{//Cast to a Lagrange multiplier element}
   ImposeDisplacementByLagrangeMultiplierElement<ELEMENT> *el\_pt = 
    \textcolor{keyword}{dynamic\_cast<}ImposeDisplacementByLagrangeMultiplierElement<ELEMENT>*\textcolor{keyword}{>}
    (Lagrange\_multiplier\_mesh\_pt->element\_pt(i));

   \textcolor{comment}{// Set the GeomObject that defines the boundary shape and}
   \textcolor{comment}{// specify which bulk boundary we are attached to (needed to extract}
   \textcolor{comment}{// the boundary coordinate from the bulk nodes)}
   el\_pt->set\_boundary\_shape\_geom\_object\_pt( 
    &\hyperlink{namespaceGlobal__Physical__Variables_ab0a184463cbaaa353f2235411adef3c4}{Global\_Physical\_Variables::Boundary\_geom\_object},b);

\end{DoxyCodeInclude}


Finally, we impose boundary conditions for the Lagrange multipliers. Their values must be pinned (and set to zero) at the left and right ends of the upper mesh boundary (boundary 2), since the displacement of the nodes at these points is already enforced by the boundary conditions imposed at the left and right vertical boundaries (boundaries 1 and 3).

\label{_bcs_for_lagrange_multipliers}%
 We discussed above that the discrete Lagrange multipliers are added to any already existing nodal degrees of freedom when the {\ttfamily Impose\+Displacement\+By\+Lagrange\+Multiplier\+Elements} are attached to the faces of the \char`\"{}bulk\char`\"{} solid elements. The number of nodal values that were stored at an element\textquotesingle{}s {\ttfamily j} -\/th node before the additional nodal values were added, can be obtained from the function {\ttfamily nbulk\+\_\+value(j)}, defined in the {\ttfamily Face\+Element} base class. We pin the Lagrange multipliers at the \char`\"{}corner nodes\char`\"{} by looping over all nodes in the {\ttfamily Impose\+Displacement\+By\+Lagrange\+Multiplier\+Elements} and pinning the additional nodal values of any nodes that are located on mesh boundaries 1 or 3.


\begin{DoxyCodeInclude}
   
   \textcolor{comment}{// Loop over the nodes }
   \textcolor{keywordtype}{unsigned} nnod=el\_pt->nnode();
   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} j=0;j<nnod;j++)
    \{
     Node* nod\_pt = el\_pt->node\_pt(j);
     
     \textcolor{comment}{// Is the node also on boundary 1 or 3?}
     \textcolor{keywordflow}{if} ((nod\_pt->is\_on\_boundary(1))||(nod\_pt->is\_on\_boundary(3)))
      \{
       \textcolor{comment}{// How many nodal values were used by the "bulk" element}
       \textcolor{comment}{// that originally created this node?}
       \textcolor{keywordtype}{unsigned} n\_bulk\_value=el\_pt->nbulk\_value(j);
       
       \textcolor{comment}{// The remaining ones are Lagrange multipliers and we pin them.}
       \textcolor{keywordtype}{unsigned} nval=nod\_pt->nvalue();
       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} j=n\_bulk\_value;j<nval;j++)
        \{
         nod\_pt->pin(j);
        \}
      \}
    \}
  \}
  
\} \textcolor{comment}{// end of create\_lagrange\_multiplier\_elements}

\end{DoxyCodeInclude}




 

\hypertarget{index_kill_lagr_elements}{}\section{Deleting the Lagrange multiplier elements that impose the displacement constraint}\label{index_kill_lagr_elements}
The function {\ttfamily delete\+\_\+lagrange\+\_\+multiplier\+\_\+elements()} deletes the Lagrange multiplier elements that impose the displacement constraint and flushes the associated mesh.

 
\begin{DoxyCodeInclude}
\textcolor{comment}{//====start\_of\_delete\_lagrange\_multiplier\_elements=======================}
\textcolor{comment}{/// Delete elements that impose the prescribed boundary displacement}
\textcolor{comment}{}\textcolor{comment}{/// and wipe the associated mesh}
\textcolor{comment}{}\textcolor{comment}{//=======================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT>
\textcolor{keywordtype}{void} 
      \hyperlink{classPrescribedBoundaryDisplacementProblem_a0204ae947ffd18ed3d7690395901a1e8}{PrescribedBoundaryDisplacementProblem<ELEMENT>::delete\_lagrange\_multiplier\_elements}
      ()
\{
 \textcolor{comment}{// How many surface elements are in the surface mesh}
 \textcolor{keywordtype}{unsigned} n\_element = Lagrange\_multiplier\_mesh\_pt->nelement();
 
 \textcolor{comment}{// Loop over the surface elements}
 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} e=0;e<n\_element;e++)
  \{
   \textcolor{comment}{// Kill surface element}
   \textcolor{keyword}{delete} Lagrange\_multiplier\_mesh\_pt->element\_pt(e);
  \}
 
 \textcolor{comment}{// Wipe the mesh}
 Lagrange\_multiplier\_mesh\_pt->flush\_element\_and\_node\_storage();

\} \textcolor{comment}{// end of delete\_lagrange\_multiplier\_elements}

\end{DoxyCodeInclude}




 

\hypertarget{index_doc}{}\section{Post-\/processing}\label{index_doc}
The function {\ttfamily doc\+\_\+solution()} outputs the shape of the deformed body and the Lagrange multiplier along the upper boundary.

 
\begin{DoxyCodeInclude}
\textcolor{comment}{//==============start\_doc===========================================}
\textcolor{comment}{/// Doc the solution}
\textcolor{comment}{}\textcolor{comment}{//==================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT>
\textcolor{keywordtype}{void} \hyperlink{classPrescribedBoundaryDisplacementProblem_abc58821d6b49cd9773dcd90b240aab6e}{PrescribedBoundaryDisplacementProblem<ELEMENT>::doc\_solution}
      ()
\{

 ofstream some\_file;
 \textcolor{keywordtype}{char} filename[100];

 \textcolor{comment}{// Number of plot points}
 \textcolor{keywordtype}{unsigned} n\_plot = 5; 


 \textcolor{comment}{// Output shape of deformed body}
 \textcolor{comment}{//------------------------------}
 sprintf(filename,\textcolor{stringliteral}{"%s/soln%i.dat"},Doc\_info.directory().c\_str(),
         Doc\_info.number());
 some\_file.open(filename);
 solid\_mesh\_pt()->output(some\_file,n\_plot);
 some\_file.close();

 \textcolor{comment}{// Output Lagrange multipliers}
 \textcolor{comment}{//----------------------------}
 sprintf(filename,\textcolor{stringliteral}{"%s/lagr%i.dat"},Doc\_info.directory().c\_str(),
         Doc\_info.number());
 some\_file.open(filename);

 \textcolor{comment}{// This makes sure the elements are ordered in same way every time}
 \textcolor{comment}{// the code is run -- necessary for validation tests.}
 std::vector<FiniteElement*> el\_pt;
 \textcolor{keywordtype}{unsigned} nelem=Lagrange\_multiplier\_mesh\_pt->nelement();
 \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} e=0;e<nelem;e++)
  \{
   el\_pt.push\_back(Lagrange\_multiplier\_mesh\_pt->finite\_element\_pt(e));
  \}
 std::sort(el\_pt.begin(),el\_pt.end(),\hyperlink{classFiniteElementComp}{FiniteElementComp}());
 \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} e=0;e<nelem;e++)
  \{
   el\_pt[e]->output(some\_file);
  \}
 some\_file.close();

 \textcolor{comment}{// Increment label for output files}
 Doc\_info.number()++;

\} \textcolor{comment}{//end doc}

\end{DoxyCodeInclude}




 

\hypertarget{index_comm_and_ex}{}\section{Comments and Exercises}\label{index_comm_and_ex}
\hypertarget{index_comm}{}\subsection{Comments}\label{index_comm}
As mentioned in the introduction, there is an alternative, much simpler way of imposing prescribed boundary motions which does not require Lagrange multipliers\+: Pin the nodal positions of all nodes on $ \partial D_{prescr} $ and update their positions manually before calling the Newton solver, e.\+g. by changing the {\ttfamily actions\+\_\+before\+\_\+newton\+\_\+solve()} function to

 
\begin{DoxyCodeInclude}
 \textcolor{comment}{/// Update boundary position directly}
 \textcolor{keywordtype}{void} actions\_before\_newton\_solve()
  \{

   \textcolor{comment}{// Loop over all nodes on top boundary (boundary 2)}
   \textcolor{keywordtype}{unsigned} b=2;
   \textcolor{keywordtype}{unsigned} n\_nod = solid\_mesh\_pt()->nboundary\_node(b);
   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} i=0;i<n\_nod;i++)
    \{
     Node* nod\_pt= solid\_mesh\_pt()->boundary\_node\_pt(b,i);

     \textcolor{comment}{// Get boundary coordinate associated with boundary 2}
     Vector<double> zeta(1);
     nod\_pt->get\_coordinates\_on\_boundary(b,zeta);

     \textcolor{comment}{// Get prescribed position from GeomObject}
     Vector<double> r(2);
     \hyperlink{namespaceGlobal__Physical__Variables_ab0a184463cbaaa353f2235411adef3c4}{Global\_Physical\_Variables::Boundary\_geom\_object}.
      \hyperlink{classWarpedLine_aaeef89818148ee3a305c561e91c8851d}{position}(zeta,r);

     \textcolor{comment}{// Update position}
     nod\_pt->x(0)=r[0];
     nod\_pt->x(1)=r[1];
    \}

  \} \textcolor{comment}{// end actions\_before\_newton\_solve}

\end{DoxyCodeInclude}


This approach is implemented in the alternative driver code \href{../../../../demo_drivers/solid/prescribed_displ_lagr_mult/prescribed_displ_lagr_mult2.cc}{\tt prescribed\+\_\+displ\+\_\+lagr\+\_\+mult2.\+cc}.\hypertarget{index_ex}{}\subsection{Exercises}\label{index_ex}

\begin{DoxyEnumerate}
\item In order to familiarise yourself with the details of how {\ttfamily Face\+Elements} add additional nodal values to the nodes they are attached to, output the values of {\ttfamily n\+\_\+bulk\+\_\+value} and {\ttfamily nval} in the loop that pins the Lagrange multipliers in {\ttfamily create\+\_\+lagrange\+\_\+multiplier\+\_\+elements()}. Explain why, for the {\ttfamily Refineable\+Q\+P\+V\+D\+Element$<$2,3$>$} used here, we have {\ttfamily n\+\_\+bulk\+\_\+value} = 0. What happens if you use elements of type {\ttfamily Refineable\+Q\+P\+V\+D\+Element\+With\+Continous\+Pressure$<$2$>$} instead? ~\newline
~\newline

\item Comment out the call to {\ttfamily set\+\_\+lagrangian\+\_\+nodal\+\_\+coordinates()} after the solve and compare the robustness of the computation and the resulting domain shapes. \mbox{[}Hint\+: You will have to reduce the increment for the amplitude of the prescribed boundary deflection to 0.\+025 or less, otherwise the Newton iteration will diverge very rapidly.\mbox{]} ~\newline
~\newline

\item Explore the performance of the alternative driver code (without the use of Lagrange multipliers) \href{../../../../demo_drivers/solid/prescribed_displ_lagr_mult/prescribed_displ_lagr_mult2.cc}{\tt prescribed\+\_\+displ\+\_\+lagr\+\_\+mult2.\+cc} and explain why it is less robust than the version with Lagrange multipliers (in the sense that the increment in the amplitude of the prescribed boundary displacement has to be reduced significantly to keep the Newton method from diverging). Hint\+: Compare the domain shapes before the call to the Newton solver. ~\newline
~\newline

\item Omit the specification of the boundary number in the bulk mesh by commenting out the call to {\ttfamily set\+\_\+boundary\+\_\+number\+\_\+in\+\_\+bulk\+\_\+mesh}(...) in the function {\ttfamily create\+\_\+lagrange\+\_\+multiplier\+\_\+elements()}. Check what happens when the code is compiled with and without the {\ttfamily P\+A\+R\+A\+N\+O\+ID} flag.
\end{DoxyEnumerate}

 

 \hypertarget{index_pdf}{}\section{P\+D\+F file}\label{index_pdf}
A \href{../latex/refman.pdf}{\tt pdf version} of this document is available. \end{document}
