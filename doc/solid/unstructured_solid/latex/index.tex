The purpose of this tutorial is to demonstrate the solution of solid mechanics problems using unstructured meshes. We focus primarily on two-\/dimensional meshes, generated using \href{http://www.cs.berkeley.edu/~jrs/}{\tt Jonathan Shewchuk\textquotesingle{}s} open-\/source mesh generator \href{http://www.cs.cmu.edu/~quake/triangle.html}{\tt {\ttfamily Triangle},} based on the output from the open-\/source drawing program \href{http://en.wikipedia.org/wiki/Xfig}{\tt xfig.} An example three-\/dimensional problem is described \href{../../unstructured_three_d_solid/html/index.html}{\tt here; } see also \hyperlink{index_three_d}{3D Problems} later in this document.

The solid mechanics problem studied here also serves as a \char`\"{}warm-\/up problem\char`\"{} for the \href{../../../interaction/unstructured_fsi/html/index.html}{\tt corresponding fluid-\/structure interaction problem } in which the solid object is immersed in (and loaded by) a viscous fluid.



 

\hypertarget{index_problem}{}\section{The problem}\label{index_problem}
Here is a sketch of the problem\+: A slightly strange-\/looking elastic solid is loaded by gravity and by a pressure load, acting on its upper face.

 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{solid_sketch}
\doxyfigcaption{Sketch of the problem. }
\end{DoxyImage}




 

\hypertarget{index_mesh}{}\section{Mesh generation}\label{index_mesh}
We employ the combination of \href{http://en.wikipedia.org/wiki/Xfig}{\tt xfig}, {\ttfamily oomph-\/lib\textquotesingle{}s} conversion code \href{../../../meshes/mesh_from_xfig/html/index.html}{\tt {\ttfamily fig2poly} }, and the unstructured mesh generator \href{http://www.cs.cmu.edu/~quake/triangle.html}{\tt {\ttfamily Triangle} } to generate the mesh, using the procedure discussed in \href{../../../meshes/mesh_from_xfig/html/index.html}{\tt another tutorial.}

We start by drawing the outline of the solid as a polyline in \href{http://en.wikipedia.org/wiki/Xfig}{\tt xfig}\+:

 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{xfig_screenshot}
\doxyfigcaption{xfig drawing of the solid body. }
\end{DoxyImage}


(Note that we draw the solid upside-\/down because of the way \href{http://en.wikipedia.org/wiki/Xfig}{\tt xfig} orients its coordinate axes.)

We save the figure as a $\ast$.fig file and convert it to a $\ast$.poly file using {\ttfamily oomph-\/lib\textquotesingle{}s} conversion code \href{../../../meshes/mesh_from_xfig/html/index.html}{\tt {\ttfamily fig2poly} } (a copy of which is located in {\ttfamily oomph-\/lib\textquotesingle{}s} {\ttfamily bin} directory)\+:


\begin{DoxyCode}
fig3poly solid.fig 
\end{DoxyCode}


This creates a file called {\ttfamily solid.\+fig.\+poly} that can be processed using Triangle. For instance, to create a quality mesh with a maximum element size of 0.\+025 we use 
\begin{DoxyCode}
triangle -q -a0.025 solid.fig.poly
\end{DoxyCode}


Here is a plot of the mesh, generated by {\ttfamily showme} distributed with \href{http://www.cs.cmu.edu/~quake/triangle.html}{\tt {\ttfamily Triangle} }\+:

 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{showme_screenshot}
\doxyfigcaption{Visualisation of the mesh with showme. }
\end{DoxyImage}


The {\ttfamily  $\ast$.poly, $\ast$.ele } and {\ttfamily  $\ast$.node } files generated by \href{http://www.cs.cmu.edu/~quake/triangle.html}{\tt {\ttfamily Triangle} } can now be used as input to {\ttfamily oomph-\/lib\textquotesingle{}s} {\ttfamily Triangle\+Mesh} class.



 

\hypertarget{index_results}{}\section{Results}\label{index_results}
The animation shown below illustrates the solid\textquotesingle{}s deformation. The first frame shows the undeformed, stress-\/free reference configuration; the second frame shows the deformation induced by gravity. Subsequent frames illustrate the deformation in response to the (additional) increasing \char`\"{}suction\char`\"{} applied at the upper face.

 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{two_d}
\doxyfigcaption{Plot of the deformation. }
\end{DoxyImage}


The blue markers show the position of pinned nodes.



 

\hypertarget{index_mesh_code}{}\section{Creating the mesh}\label{index_mesh_code}
We create the mesh by multiple inheritance from {\ttfamily oomph-\/lib\textquotesingle{}s} {\ttfamily Triangle\+Mesh} and the {\ttfamily Solid\+Mesh} base class\+:

 
\begin{DoxyCodeInclude}
\textcolor{comment}{//================start\_mesh===============================================}
\textcolor{comment}{/// Triangle-based mesh upgraded to become a solid mesh}
\textcolor{comment}{}\textcolor{comment}{//=========================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT>
\textcolor{keyword}{class }\hyperlink{classElasticTriangleMesh}{ElasticTriangleMesh} : \textcolor{keyword}{public} \textcolor{keyword}{virtual} TriangleMesh<ELEMENT>, 
                            \textcolor{keyword}{public} \textcolor{keyword}{virtual} SolidMesh 
\{

\end{DoxyCodeInclude}


The constructor calls the constructor of the underlying {\ttfamily Triangle\+Mesh}, and, as usual, sets the Lagrangian coordinates to the current nodal positions, making the current configuration stress-\/free.


\begin{DoxyCodeInclude}
 
\textcolor{keyword}{public}:
 \textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Constructor: }
\textcolor{comment}{} \hyperlink{classElasticTriangleMesh}{ElasticTriangleMesh}(\textcolor{keyword}{const} std::string& node\_file\_name,
                     \textcolor{keyword}{const} std::string& element\_file\_name,
                     \textcolor{keyword}{const} std::string& poly\_file\_name,
                     TimeStepper* time\_stepper\_pt=
                     &Mesh::Default\_TimeStepper) : 
 TriangleMesh<ELEMENT>(node\_file\_name,element\_file\_name,
                       poly\_file\_name, time\_stepper\_pt)
  \{
   \textcolor{comment}{//Assign the Lagrangian coordinates}
   set\_lagrangian\_nodal\_coordinates();

\end{DoxyCodeInclude}


The {\ttfamily Triangle\+Mesh} constructor associates each polyline in the {\ttfamily xfig} drawing with a distinct {\ttfamily oomph-\/lib} mesh boundary. Hence the boundary nodes are initially located on the same, single boundary. To facilitate the application of boundary conditions, we divide the single boundary into three\+:


\begin{DoxyCodeInclude}

   \textcolor{comment}{// Identify special boundaries}
   set\_nboundary(3);

\end{DoxyCodeInclude}


We loop over all nodes in the mesh and identify nodes on the lower (pinned) boundary by their y-\/coordinate. We remove the node from the boundary 0 and re-\/allocate it to the new boundary 1\+:


\begin{DoxyCodeInclude}

   \textcolor{keywordtype}{unsigned} n\_node=this->nnode();
   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} j=0;j<n\_node;j++)
    \{
     Node* nod\_pt=this->node\_pt(j);

     \textcolor{comment}{// Boundary 1 is lower boundary}
     \textcolor{keywordflow}{if} (nod\_pt->x(1)<0.15)
      \{
       this->remove\_boundary\_node(0,nod\_pt);
       this->add\_boundary\_node(1,nod\_pt);
      \}

\end{DoxyCodeInclude}


Similarly, we identify all nodes on the upper boundary and re-\/assign them to boundary 2, before re-\/generating the various boundary lookup schemes that identify which elements are located next to the various mesh boundaries\+:


\begin{DoxyCodeInclude}

     \textcolor{comment}{// Boundary 2 is upper boundary}
     \textcolor{keywordflow}{if} (nod\_pt->x(1)>2.69)
      \{
       this->remove\_boundary\_node(0,nod\_pt);
       this->add\_boundary\_node(2,nod\_pt);
      \}
    \}

   std::cout << \textcolor{stringliteral}{"About to setup the boundary elements"} << std::endl;
   \textcolor{comment}{// Re-setup boundary info, i.e. elements next to boundaries}
   TriangleMesh<ELEMENT>::setup\_boundary\_element\_info();
   \textcolor{comment}{//This is the bit that has gone wrong}
  \}
\textcolor{comment}{}
\textcolor{comment}{ /// Empty Destructor}
\textcolor{comment}{} \textcolor{keyword}{virtual} ~\hyperlink{classElasticTriangleMesh}{ElasticTriangleMesh}() \{ \}

\};

\end{DoxyCodeInclude}




 

\hypertarget{index_namespace}{}\section{Problem Parameters}\label{index_namespace}
As usual we define the various problem parameters in a global namespace. We define Poisson\textquotesingle{}s ratio and prepare a pointer to a constitutive equation.


\begin{DoxyCodeInclude}
\textcolor{comment}{//=======start\_namespace==========================================}
\textcolor{comment}{/// Global variables}
\textcolor{comment}{}\textcolor{comment}{//================================================================}
\textcolor{keyword}{namespace }\hyperlink{namespaceGlobal__Physical__Variables}{Global\_Physical\_Variables}
\{\textcolor{comment}{}
\textcolor{comment}{ /// Poisson's ratio}
\textcolor{comment}{} \textcolor{keywordtype}{double} Nu=0.3;
\textcolor{comment}{}
\textcolor{comment}{ /// Pointer to constitutive law}
\textcolor{comment}{} ConstitutiveLaw* Constitutive\_law\_pt=0;

\end{DoxyCodeInclude}


Next we define the gravitational body force


\begin{DoxyCodeInclude}
\textcolor{comment}{}
\textcolor{comment}{ /// Non-dim gravity}
\textcolor{comment}{} \textcolor{keywordtype}{double} Gravity=0.0;
\textcolor{comment}{}
\textcolor{comment}{ /// Non-dimensional gravity as body force}
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{namespaceGlobal__Physical__Variables_a0777aef63372db7f91ad894c38159681}{gravity}(\textcolor{keyword}{const} \textcolor{keywordtype}{double}& time, 
              \textcolor{keyword}{const} Vector<double> &xi, 
              Vector<double> &b)
 \{
  b[0]=0.0;
  b[1]=-\hyperlink{namespaceGlobal__Physical__Variables_a8b80d3e8d63b8d0a0ed435a2dd7fe2ad}{Gravity};
 \}

\end{DoxyCodeInclude}


and the pressure load to be applied at the upper boundary


\begin{DoxyCodeInclude}
 \textcolor{comment}{}
\textcolor{comment}{ /// Uniform pressure}
\textcolor{comment}{} \textcolor{keywordtype}{double} P = 0.0;
\textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Constant pressure load. The arguments to this function are imposed}
\textcolor{comment}{ /// on us by the SolidTractionElements which allow the traction to }
\textcolor{comment}{ /// depend on the Lagrangian and Eulerian coordinates x and xi, and on the }
\textcolor{comment}{ /// outer unit normal to the surface. Here we only need the outer unit}
\textcolor{comment}{ /// normal.}
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{namespaceGlobal__Physical__Variables_a19f4e20a92e7d216b4d2b00308f96917}{constant\_pressure}(\textcolor{keyword}{const} Vector<double> &xi, \textcolor{keyword}{const} Vector<double> &x,
                        \textcolor{keyword}{const} Vector<double> &n, Vector<double> &traction)
 \{
  \textcolor{keywordtype}{unsigned} dim = traction.size();
  \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} i=0;i<dim;i++)
   \{
    traction[i] = -P*n[i];
   \}
 \} 

\} \textcolor{comment}{//end namespace}

\end{DoxyCodeInclude}




 

\hypertarget{index_main}{}\section{The driver code}\label{index_main}
The driver code is straightforward. We specify an output directory and instantiate a constitutive equation. (Recall that the single-\/argument constructor to the {\ttfamily Generalised\+Hookean} constitutive law implies that all stresses are non-\/dimensionalised on Young\textquotesingle{}s modulus $ E $).

 
\begin{DoxyCodeInclude}
\textcolor{comment}{//===========start\_main===================================================}
\textcolor{comment}{/// Demonstrate how to solve an unstructured solid problem}
\textcolor{comment}{}\textcolor{comment}{//========================================================================}
\textcolor{keywordtype}{int} \hyperlink{unstructured__three__d__solid_8cc_ae66f6b31b5ad750f1fe042a706a4e3d4}{main}()
\{
 \textcolor{comment}{// Label for output}
 DocInfo doc\_info;
 
 \textcolor{comment}{// Output directory}
 doc\_info.set\_directory(\textcolor{stringliteral}{"RESLT"});
 
 \textcolor{comment}{// Create generalised Hookean constitutive equations}
 \hyperlink{namespaceGlobal__Physical__Variables_a5d5f19442938130d36ee7476ae25049c}{Global\_Physical\_Variables::Constitutive\_law\_pt} = 
  \textcolor{keyword}{new} GeneralisedHookean(&\hyperlink{namespaceGlobal__Physical__Variables_a3962c36313826b19f216f6bbbdd6a477}{Global\_Physical\_Variables::Nu});

\end{DoxyCodeInclude}


We create the {\ttfamily Problem} object using a displacement formulation of the equations and output the initial configuration


\begin{DoxyCodeInclude}
 
 \{
  std::cout << \textcolor{stringliteral}{"Running with pure displacement formulation\(\backslash\)n"};

  \textcolor{comment}{//Set up the problem}
  \hyperlink{classUnstructuredSolidProblem}{UnstructuredSolidProblem<TPVDElement<2,3>} > problem;
  
  \textcolor{comment}{//Output initial configuration}
  problem.\hyperlink{classUnstructuredSolidProblem_ab3d66fd61b69d12b4f159d763fc44f15}{doc\_solution}(doc\_info);
  doc\_info.number()++;

\end{DoxyCodeInclude}


Finally, we perform a straightforward parameter study, applying a constant gravitational load and slowly increasing the suction (negative pressure) on the upper boundary.


\begin{DoxyCodeInclude}
  
  \textcolor{comment}{// Parameter study}
  \hyperlink{namespaceGlobal__Physical__Variables_a8b80d3e8d63b8d0a0ed435a2dd7fe2ad}{Global\_Physical\_Variables::Gravity}=2.0e-4;
  \hyperlink{namespaceGlobal__Physical__Variables_a23c2ade6398f54040b869f7f3a2bcc4b}{Global\_Physical\_Variables::P}=0.0;
  \textcolor{keywordtype}{double} pressure\_increment=-1.0e-4;
  
  \textcolor{keywordtype}{unsigned} nstep=2; \textcolor{comment}{// 10;}
  \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} istep=0;istep<nstep;istep++)
   \{
    \textcolor{comment}{// Solve the problem}
    problem.newton\_solve();
    
    \textcolor{comment}{//Output solution}
    problem.\hyperlink{classUnstructuredSolidProblem_ab3d66fd61b69d12b4f159d763fc44f15}{doc\_solution}(doc\_info);
    doc\_info.number()++;
    
    \textcolor{comment}{// Bump up suction}
    \hyperlink{namespaceGlobal__Physical__Variables_a23c2ade6398f54040b869f7f3a2bcc4b}{Global\_Physical\_Variables::P}+=pressure\_increment;
   \}
 \} \textcolor{comment}{//end\_displacement\_formulation}

\end{DoxyCodeInclude}


The parameter study is then repeated for a pressure-\/displacement formulation with and without an incompressibility constraint, see the \href{../../../../demo_drivers/solid/unstructured_solid/unstructured_two_d_solid.cc}{\tt source code } for details.



 

\hypertarget{index_class}{}\section{The Problem class}\label{index_class}
The {\ttfamily Problem} class has the usual member functions and provides storage for the two sub-\/meshes\+: the bulk mesh of 2D solid elements and the mesh of 1D traction elements that will be attached to the upper boundary.

 
\begin{DoxyCodeInclude}
\textcolor{comment}{//==============start\_problem=========================================}
\textcolor{comment}{/// Unstructured solid problem}
\textcolor{comment}{}\textcolor{comment}{//====================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT> 
\textcolor{keyword}{class }\hyperlink{classUnstructuredSolidProblem}{UnstructuredSolidProblem} : \textcolor{keyword}{public} Problem
\{

\textcolor{keyword}{public}:
\textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Constructor: }
\textcolor{comment}{} \hyperlink{classUnstructuredSolidProblem_a18ce02b6e4bbc86403c9e1b32c095772}{UnstructuredSolidProblem}();
\textcolor{comment}{}
\textcolor{comment}{ /// Destructor (empty)}
\textcolor{comment}{} \hyperlink{classUnstructuredSolidProblem_a25fe105d949498bf8f7c15aff96a7d00}{~UnstructuredSolidProblem}()\{\}
 \textcolor{comment}{}
\textcolor{comment}{ /// Doc the solution}
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{classUnstructuredSolidProblem_ab3d66fd61b69d12b4f159d763fc44f15}{doc\_solution}(DocInfo& doc\_info);
 
\textcolor{keyword}{private}:
 \textcolor{comment}{}
\textcolor{comment}{ /// Bulk mesh}
\textcolor{comment}{} \hyperlink{classElasticTriangleMesh}{ElasticTriangleMesh<ELEMENT>}* \hyperlink{classUnstructuredSolidProblem_a09c0a07feb1586f2cca3766b4ac92099}{Solid\_mesh\_pt};
 \textcolor{comment}{}
\textcolor{comment}{ /// Pointer to mesh of traction elements}
\textcolor{comment}{} SolidMesh* \hyperlink{classUnstructuredSolidProblem_ade114e509464031ba8657600584b9743}{Traction\_mesh\_pt};

\};

\end{DoxyCodeInclude}




 

\hypertarget{index_constructor}{}\section{The Problem constructor}\label{index_constructor}
We start by building the bulk mesh, using the files created by \href{http://www.cs.cmu.edu/~quake/triangle.html}{\tt {\ttfamily Triangle} }.


\begin{DoxyCodeInclude}
\textcolor{comment}{//===============start\_constructor========================================}
\textcolor{comment}{/// Constructor for unstructured solid problem}
\textcolor{comment}{}\textcolor{comment}{//========================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT>
\hyperlink{classUnstructuredSolidProblem_a18ce02b6e4bbc86403c9e1b32c095772}{UnstructuredSolidProblem<ELEMENT>::UnstructuredSolidProblem}
      ()
\{  

 \textcolor{comment}{//Create solid mesh}
 \textcolor{keywordtype}{string} node\_file\_name=\textcolor{stringliteral}{"solid.fig.1.node"};
 \textcolor{keywordtype}{string} element\_file\_name=\textcolor{stringliteral}{"solid.fig.1.ele"};
 \textcolor{keywordtype}{string} poly\_file\_name=\textcolor{stringliteral}{"solid.fig.1.poly"}; 
 Solid\_mesh\_pt = \textcolor{keyword}{new} \hyperlink{classElasticTriangleMesh}{ElasticTriangleMesh<ELEMENT>}(node\_file\_name,
                                                  element\_file\_name,
                                                  poly\_file\_name);

\end{DoxyCodeInclude}


Next we create traction elements, attaching them to the \char`\"{}bulk\char`\"{} solid elements that are adjacent to boundary 2. We also specify the load function.


\begin{DoxyCodeInclude}
 
 \textcolor{comment}{// Traction elements are located on boundary 2:}
 \textcolor{keywordtype}{unsigned} b=2;

 \textcolor{comment}{// Make traction mesh}
 Traction\_mesh\_pt=\textcolor{keyword}{new} SolidMesh;
 
 \textcolor{comment}{// How many bulk elements are adjacent to boundary b?}
 \textcolor{keywordtype}{unsigned} n\_element = Solid\_mesh\_pt->nboundary\_element(b);
 
 \textcolor{comment}{// Loop over the bulk elements adjacent to boundary b}
 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} e=0;e<n\_element;e++)
  \{
   \textcolor{comment}{// Get pointer to the bulk element that is adjacent to boundary b}
   ELEMENT* bulk\_elem\_pt = \textcolor{keyword}{dynamic\_cast<}ELEMENT*\textcolor{keyword}{>}(
    Solid\_mesh\_pt->boundary\_element\_pt(b,e));
   
   \textcolor{comment}{//Find the index of the face of element e along boundary b}
   \textcolor{keywordtype}{int} face\_index = Solid\_mesh\_pt->face\_index\_at\_boundary(b,e);
   
   \textcolor{comment}{//Create solid traction element}
   SolidTractionElement<ELEMENT> *el\_pt = 
    \textcolor{keyword}{new} SolidTractionElement<ELEMENT>(bulk\_elem\_pt,face\_index);   
   
   \textcolor{comment}{// Add to mesh}
   Traction\_mesh\_pt->add\_element\_pt(el\_pt);
 
   \textcolor{comment}{//Set the traction function}
   el\_pt->traction\_fct\_pt() = \hyperlink{namespaceGlobal__Physical__Variables_a19f4e20a92e7d216b4d2b00308f96917}{Global\_Physical\_Variables::constant\_pressure}
      ;
  \}  

\end{DoxyCodeInclude}


We add both meshes as sub-\/meshes to the {\ttfamily Problem} and build the global mesh


\begin{DoxyCodeInclude}
 
 \textcolor{comment}{// Add sub meshes}
 add\_sub\_mesh(Solid\_mesh\_pt);
 add\_sub\_mesh(Traction\_mesh\_pt);
 
 \textcolor{comment}{// Build global mesh}
 build\_global\_mesh();

\end{DoxyCodeInclude}


Next we apply the boundary conditions at the lower boundary where we suppress the displacements in both directions. We document the position of the pinned nodes to allow us to check that the boundary I\+Ds were identified correctly -- see \hyperlink{index_comm_ex}{Comments and Exercises} for a further discussion of this issue.


\begin{DoxyCodeInclude}
 
 \textcolor{comment}{// Doc pinned solid nodes}
 std::ofstream bc\_file(\textcolor{stringliteral}{"pinned\_nodes.dat"});

 \textcolor{comment}{// Pin both positions at lower boundary (boundary 1)}
 \textcolor{keywordtype}{unsigned} ibound=1;
 \textcolor{keywordtype}{unsigned} num\_nod= mesh\_pt()->nboundary\_node(ibound);
 \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} inod=0;inod<num\_nod;inod++)
  \{  

   \textcolor{comment}{// Get node}
   SolidNode* nod\_pt=Solid\_mesh\_pt->boundary\_node\_pt(ibound,inod);
   
   \textcolor{comment}{// Pin both directions}
   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} i=0;i<2;i++)
    \{
     nod\_pt->pin\_position(i);
     
     \textcolor{comment}{// ...and doc it as pinned}
     bc\_file << nod\_pt->x(i) << \textcolor{stringliteral}{" "};
    \}

   bc\_file << std::endl;
  \}
 bc\_file.close();

\end{DoxyCodeInclude}


Finally, we complete the build of the solid elements by specifying their constitutive equation and the body force before assigning the equation numbers.


\begin{DoxyCodeInclude}


 \textcolor{comment}{// Complete the build of all elements so they are fully functional}
 n\_element = Solid\_mesh\_pt->nelement();
 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} i=0;i<n\_element;i++)
  \{
   \textcolor{comment}{//Cast to a solid element}
   ELEMENT *el\_pt = \textcolor{keyword}{dynamic\_cast<}ELEMENT*\textcolor{keyword}{>}(Solid\_mesh\_pt->element\_pt(i));
   
   \textcolor{comment}{// Set the constitutive law}
   el\_pt->constitutive\_law\_pt() =
    \hyperlink{namespaceGlobal__Physical__Variables_a5d5f19442938130d36ee7476ae25049c}{Global\_Physical\_Variables::Constitutive\_law\_pt};
   
   \textcolor{comment}{//Set the body force}
   el\_pt->body\_force\_fct\_pt() = \hyperlink{namespaceGlobal__Physical__Variables_a0777aef63372db7f91ad894c38159681}{Global\_Physical\_Variables::gravity};
  \}
   
 \textcolor{comment}{// Setup equation numbering scheme}
 cout <<\textcolor{stringliteral}{"Number of equations: "} << assign\_eqn\_numbers() << std::endl; 
 
\} \textcolor{comment}{//end constructor}

\end{DoxyCodeInclude}




 

\hypertarget{index_doc}{}\section{Post-\/processing}\label{index_doc}
The post-\/processing routine outputs the deformed domain shape and the applied traction. In the spirit of continuing paranoia we also document the domain boundaries; see \hyperlink{index_comm_ex}{Comments and Exercises}.


\begin{DoxyCodeInclude}


\textcolor{comment}{//========================================================================}\textcolor{comment}{}
\textcolor{comment}{/// Doc the solution}
\textcolor{comment}{}\textcolor{comment}{//========================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT>
\textcolor{keywordtype}{void} \hyperlink{classUnstructuredSolidProblem_ab3d66fd61b69d12b4f159d763fc44f15}{UnstructuredSolidProblem<ELEMENT>::doc\_solution}(DocInfo
      & doc\_info)
\{ 

 ofstream some\_file;
 \textcolor{keywordtype}{char} filename[100];

 \textcolor{comment}{// Number of plot points}
 \textcolor{keywordtype}{unsigned} npts;
 npts=5;

 \textcolor{comment}{// Output solution}
 \textcolor{comment}{//----------------}
 sprintf(filename,\textcolor{stringliteral}{"%s/soln%i.dat"},doc\_info.directory().c\_str(),
         doc\_info.number());
 some\_file.open(filename);
 Solid\_mesh\_pt->output(some\_file,npts);
 some\_file.close();

 \textcolor{comment}{// Output traction}
 \textcolor{comment}{//----------------}
 sprintf(filename,\textcolor{stringliteral}{"%s/traction%i.dat"},doc\_info.directory().c\_str(),
         doc\_info.number());
 some\_file.open(filename);
 Traction\_mesh\_pt->output(some\_file,npts);
 some\_file.close();

 \textcolor{comment}{// Output boundaries}
 \textcolor{comment}{//------------------}
 sprintf(filename,\textcolor{stringliteral}{"%s/boundaries.dat"},doc\_info.directory().c\_str());
 some\_file.open(filename);
 Solid\_mesh\_pt->output\_boundaries(some\_file);
 some\_file.close();

\}

\end{DoxyCodeInclude}




 

\hypertarget{index_comm_ex}{}\section{Comments and Exercises}\label{index_comm_ex}
\hypertarget{index_bound}{}\subsection{Identification/assignment of mesh boundaries}\label{index_bound}
This tutorial demonstrates that the use of unstructured meshes for solid mechanics problems is extremely straightforward. The only aspect that requires some care (and not just for solid mechanics applications) is the correct identification/assignment of domain boundaries when the mesh is generated with \href{http://en.wikipedia.org/wiki/Xfig}{\tt xfig.} The fact that we documented the mesh boundaries and the positions of the pinned nodes in the driver code suggests (correctly!) that we managed to get both assignments (slightly) wrong when we first wrote the driver code. The manual identification of nodes on domain boundaries is tedious and therefore error prone and, as usual, it pays to {\bfseries be as a paranoid as possible}! Ignore this advice at your own risk...

We also welcome any improvements to our conversion code \href{../../../../demo_drivers/meshing/mesh_from_xfig_triangle/fig2poly.cc}{\tt fig2poly.\+cc } that would allow the specification of domain boundaries from within \href{http://en.wikipedia.org/wiki/Xfig}{\tt xfig.} It\textquotesingle{}s probably not possible but if you have any ideas how to go about this (either by hijacking information that can be generated by \href{http://en.wikipedia.org/wiki/Xfig}{\tt xfig} or via some other G\+UI interface), \href{../../../contact/html/index.html}{\tt let us know.}



\hypertarget{index_three_d}{}\subsection{3\+D Problems}\label{index_three_d}
Unstructured meshes may also be used for the 3D solid mechanics problems. The overall procedure is very similar to that documented above, we will not provide a detailed discussion of the corresponding 3D driver code

\begin{center} \href{../../../../demo_drivers/solid/unstructured_solid/unstructured_three_d_solid.cc}{\tt demo\+\_\+drivers/solid/unstructured\+\_\+solid/unstructured\+\_\+three\+\_\+d\+\_\+solid.\+cc } \end{center} 

which computes the deformation of the hollow cube used in the \href{../../../meshes/mesh_from_tetgen/html/index.html}{\tt Mesh Generation with Tetgen Tutorial}.

Here is an animation of the cube\textquotesingle{}s deformation when it is subjected to gravity, acting in the negative $ z $-\/direction, and a \char`\"{}suction\char`\"{} force applied on the upper face, while its right face is held in a fixed position.

 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{three_d}
\doxyfigcaption{Plot of the deformation of a hollow 3D cube. }
\end{DoxyImage}


An alternative three-\/dimensional problem\+: the deformation of a bifurcating tube is described \href{../../unstructured_three_d_solid/html/index.html}{\tt here. }



 

\hypertarget{index_sources}{}\section{Source files for this tutorial}\label{index_sources}

\begin{DoxyItemize}
\item The source files for this tutorial are located in the directory\+:~\newline
~\newline
\begin{center} \href{../../../../demo_drivers/solid/unstructured_solid/}{\tt demo\+\_\+drivers/solid/unstructured\+\_\+solid/ } \end{center} ~\newline

\item The driver codes are\+: ~\newline
~\newline
\begin{center} \href{../../../../demo_drivers/solid/unstructured_solid/unstructured_two_d_solid.cc}{\tt demo\+\_\+drivers/solid/unstructured\+\_\+solid/unstructured\+\_\+two\+\_\+d\+\_\+solid.\+cc } \end{center}  and \begin{center} \href{../../../../demo_drivers/solid/unstructured_solid/unstructured_three_d_solid.cc}{\tt demo\+\_\+drivers/solid/unstructured\+\_\+solid/unstructured\+\_\+three\+\_\+d\+\_\+solid.\+cc } \end{center} 
\end{DoxyItemize}



 

 \hypertarget{index_pdf}{}\section{P\+D\+F file}\label{index_pdf}
A \href{../latex/refman.pdf}{\tt pdf version} of this document is available. \end{document}
