In this example we study the compression of a 2D circular disk, loaded by an external pressure. We also demonstrate\+:
\begin{DoxyItemize}
\item how to \char`\"{}upgrade\char`\"{} a {\ttfamily Mesh} to a {\ttfamily Solid\+Mesh} 
\item why it is necessary to use \char`\"{}undeformed Macro\+Elements\char`\"{} to ensure that the numerical results converge to the correct solution under mesh refinement if the domain has curvilinear boundaries.
\item how to switch between different constitutive equations
\item how to incorporate isotropic growth into the model
\end{DoxyItemize}We validate the numerical results by comparing them against the analytical solution of the equations of linear elasticity which are valid for small deflections.



 

\hypertarget{index_problem}{}\section{The problem}\label{index_problem}
The figure below shows a sketch of the basic problem\+: A 2D circular disk of radius $ a $ is loaded by a uniform pressure $ p_0^*$. We wish to compute the disk\textquotesingle{}s deformation for a variety of constitutive equations.

 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{disk_compression}
\doxyfigcaption{Sketch of the problem. }
\end{DoxyImage}


The next sketch shows a variant of the problem\+: We assume that the material undergoes isotropic growth (e.\+g. via a biological growth process or thermal expansion, say) with a constant growth factor $ \Gamma $. We refer to the the document \href{../../solid_theory/html/index.html#isotropic_growth}{\tt \char`\"{}\+Solid mechanics\+: Theory and implementation\char`\"{}} for a detailed discussion of the theory of isotropic growth. Briefly, the growth factor defines the relative increase in the volume of an infinitesimal material element, relative to its volume in the stress-\/free reference configuration. If the growth factor is spatially uniform, isotropic growth leads to a uniform expansion of the material. For a circular disk, uniform growth increases the disk\textquotesingle{}s radius from $ a_0 $ to $ a = a_0 \sqrt{\Gamma} $ without inducing any internal stresses. This uniformly expanded disk may then be regarded as the stress-\/free reference configuration upon which the external pressure acts.

 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{disk_compression_with_growth}
\doxyfigcaption{Sketch of the problem. }
\end{DoxyImage}




 

\hypertarget{index_results}{}\section{Results}\label{index_results}
The animation shows the disk\textquotesingle{}s deformation when subjected to uniform growth of $ \Gamma = 1.1 $ and loaded by a pressure that ranges from negative to positive values. All lengths were scaled on the disks initial radius (i.\+e. its radius in the absence of growth and without any external load).

 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{disk_compression_anim}
\doxyfigcaption{Deformation of the uniformly grown disk when subjected to an external pressure. }
\end{DoxyImage}


The figure below illustrates the disk\textquotesingle{}s load-\/displacement characteristics by plotting the disk\textquotesingle{}s non-\/dimensional radius as function of the non-\/dimensional pressure, $ p_0 = p_0^*/{\cal S} $ , where $ {\cal S} $ is the characteristic stiffness of the material, for a variety of constitutive equations.

 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{trace}
\doxyfigcaption{Load displacement characteristics for various constitutive equations. }
\end{DoxyImage}
\hypertarget{index_hooke}{}\subsection{Generalised Hooke\textquotesingle{}s law}\label{index_hooke}
The blue, dash-\/dotted line corresponds to {\ttfamily oomph-\/lib\textquotesingle{}s} generalisation of Hooke\textquotesingle{}s law (with Young\textquotesingle{}s modulus $ E $ and Poisson ratio $ \nu $ ) in which the dimensionless second Piola Kirchhoff stress tensor (non-\/dimensionalised with the material\textquotesingle{}s Young\textquotesingle{}s modulus $ E $, so that $ {\cal S} = E $ ) is given by \[ \sigma^{ij} = \frac{1}{2(1+\nu)} \left( G^{ik} G^{jl} + G^{il} G^{jk} + \frac{2\nu}{1-2\nu} G^{ij} G^{kl} \right) \gamma_{kl}. \] Here $ \gamma_{ij}= 1/2 (G_{ij}-g_{ij})$ is Green\textquotesingle{}s strain tensor, formed from the difference between the deformed and undeformed metric tensors, $ G_{ij} $ and $ g_{ij} $, respectively. The three different markers identify the results obtained with the two forms of the principle of virtual displacement, employing the displacement formulation (squares), and a pressure/displacement formulation with a continuous (delta) and a discontinuous (nabla) pressure interpolation.

For zero pressure the disk\textquotesingle{}s non-\/dimensional radius is equal to the uniformly grown radius $ \sqrt{\Gamma} = 1.0488. $ For small pressures the load-\/displacement curve follows the linear approximation \[ r = \sqrt{\Gamma} \big( 1-p_0 (1+\nu)(1-2\nu) \big). \] We note that the generalised Hooke\textquotesingle{}s law leads to strain softening behaviour under compression (the pressure required to reduce the disk\textquotesingle{}s radius to a given value increases more rapidly than predicted by the linear approximation) whereas under expansion (for negative external pressures) the behaviour is strain softening.\hypertarget{index_mr}{}\subsection{Generalised Mooney-\/\+Rivlin law}\label{index_mr}
The red, dashed line illustrates the behaviour when Fung \& Tong\textquotesingle{}s generalisation of the Mooney-\/\+Rivlin law (with Young\textquotesingle{}s modulus, $ E $, Poisson ratio $ \nu $ and Mooney-\/\+Rivlin parameter $ C_1$) is used as the constitutive equation. For this constitutive law, the non-\/dimensional strain energy function $ W = W^*/{\cal S}$, where the characteristic stress is given by Young\textquotesingle{}s modulus, i.\+e. $ {\cal S} =E $, is given by \[ W = \frac{1}{2} (I_1-3) + (G-C_1)(I_2-3) + (C_1-2G)(I_3-1) + (I_3-1)^2 \ \frac{G(1-\nu)}{2(1-2\nu)} \ , \] where \[ G = \frac{E}{2(1+\nu)} \] is the shear modulus, and $ I_1, I_2 $ and $ I_3 $ are the three invariants of Green\textquotesingle{}s strain tensor. See \href{../../solid_theory/html/index.html#strain-energy}{\tt \char`\"{}\+Solid mechanics\+: Theory and implementation\char`\"{}} for a detailed discussion of strain energy functions. The figure shows that for small deflections, the disk\textquotesingle{}s behaviour is again well approximated by linear elasticity. However, in the large-\/displacement regime the Mooney-\/\+Rivlin is strain hardening under extension and softening under compression when compared to the linear elastic behaviour.



 

\hypertarget{index_namespace}{}\section{Global parameters and functions}\label{index_namespace}
As usual we define the global problem parameters in a namespace. We provide pointers to the constitutive equations and strain energy functions to be explored, and define the associated constitutive parameters.

 
\begin{DoxyCodeInclude}
\textcolor{comment}{//============namespace\_for\_problem\_parameters=====================}
\textcolor{comment}{/// Global variables}
\textcolor{comment}{}\textcolor{comment}{//=================================================================}
\textcolor{keyword}{namespace }\hyperlink{namespaceGlobal__Physical__Variables}{Global\_Physical\_Variables}
\{\textcolor{comment}{}
\textcolor{comment}{ /// Pointer to strain energy function}
\textcolor{comment}{} StrainEnergyFunction* \hyperlink{namespaceGlobal__Physical__Variables_a73135f793690b4386bf83bbefc7bf310}{Strain\_energy\_function\_pt};
\textcolor{comment}{}
\textcolor{comment}{ /// Pointer to constitutive law}
\textcolor{comment}{} ConstitutiveLaw* \hyperlink{namespaceGlobal__Physical__Variables_a2a37fb040c832ee7a086bb13bb02a100}{Constitutive\_law\_pt};
\textcolor{comment}{}
\textcolor{comment}{ /// Elastic modulus}
\textcolor{comment}{} \textcolor{keywordtype}{double} E=1.0; 
\textcolor{comment}{}
\textcolor{comment}{ /// Poisson's ratio}
\textcolor{comment}{} \textcolor{keywordtype}{double} Nu=0.3;
\textcolor{comment}{}
\textcolor{comment}{ /// "Mooney Rivlin" coefficient for generalised Mooney Rivlin law}
\textcolor{comment}{} \textcolor{keywordtype}{double} C1=1.3;

\end{DoxyCodeInclude}


Next we define the pressure load, using the general interface defined in the {\ttfamily Solid\+Traction\+Element} class. The arguments of the function reflect that the load on a solid may be a function of the Lagrangian and Eulerian coordinates, and the external unit normal on the solid. Here we apply a spatially constant external pressure of magnitude {\ttfamily P} which acts in the direction of the negative outer unit normal on the solid.


\begin{DoxyCodeInclude}
\textcolor{comment}{}
\textcolor{comment}{ /// Uniform pressure}
\textcolor{comment}{} \textcolor{keywordtype}{double} P = 0.0;
\textcolor{comment}{}
\textcolor{comment}{ /// Constant pressure load}
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{namespaceGlobal__Physical__Variables_a19f4e20a92e7d216b4d2b00308f96917}{constant\_pressure}(\textcolor{keyword}{const} Vector<double> &xi,\textcolor{keyword}{const} Vector<double> &x,
                        \textcolor{keyword}{const} Vector<double> &n, Vector<double> &traction)
 \{
  \textcolor{keywordtype}{unsigned} dim = traction.size();
  \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} i=0;i<dim;i++)
   \{
    traction[i] = -P*n[i];
   \}
 \} \textcolor{comment}{// end of pressure load}

\end{DoxyCodeInclude}


Finally, we define the growth function and impose a spatially uniform expansion that (in the absence of any external load) would increase the disk\textquotesingle{}s volume by 10\%.


\begin{DoxyCodeInclude}

\textcolor{comment}{}
\textcolor{comment}{ /// Uniform volumetric expansion}
\textcolor{comment}{} \textcolor{keywordtype}{double} \hyperlink{namespaceGlobal__Physical__Variables_ae02b5f5b098b05fba75f3b61f381c5f7}{Uniform\_gamma}=1.1;
\textcolor{comment}{}
\textcolor{comment}{ /// Growth function}
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{namespaceGlobal__Physical__Variables_a6be3760e5494b1772e4bfe5d5f3c5d53}{growth\_function}(\textcolor{keyword}{const} Vector<double>& xi, \textcolor{keywordtype}{double}& gamma)
 \{
  gamma = \hyperlink{namespaceGlobal__Physical__Variables_ae02b5f5b098b05fba75f3b61f381c5f7}{Uniform\_gamma};
 \}
 
\} \textcolor{comment}{// end namespace}

\end{DoxyCodeInclude}




 

\hypertarget{index_main}{}\section{The driver code}\label{index_main}
The driver code is very short\+: We store the command line arguments (as usual, we use a non-\/zero number of command line arguments as an indication that the code is run in self-\/test mode and reduce the number of steps performed in the parameter study) and create a strain-\/energy-\/based constitutive equation\+: Fung \& Tong\textquotesingle{}s generalisation of the Mooney-\/\+Rivlin law.


\begin{DoxyCodeInclude}
\textcolor{comment}{//=====start\_of\_main====================================================}
\textcolor{comment}{/// Driver code for disk-compression}
\textcolor{comment}{}\textcolor{comment}{//======================================================================}
\textcolor{keywordtype}{int} \hyperlink{disk__compression_8cc_a0ddf1224851353fc92bfbff6f499fa97}{main}(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char}* argv[])
\{

 \textcolor{comment}{// Store command line arguments}
 CommandLineArgs::setup(argc,argv);
  
 \textcolor{comment}{// Define a strain energy function: Generalised Mooney Rivlin}
 \hyperlink{namespaceGlobal__Physical__Variables_a73135f793690b4386bf83bbefc7bf310}{Global\_Physical\_Variables::Strain\_energy\_function\_pt} =
       
  \textcolor{keyword}{new} GeneralisedMooneyRivlin(&\hyperlink{namespaceGlobal__Physical__Variables_a3962c36313826b19f216f6bbbdd6a477}{Global\_Physical\_Variables::Nu},
                              &\hyperlink{namespaceGlobal__Physical__Variables_a849754fa7155c1a31481674ce4845658}{Global\_Physical\_Variables::C1},
                              &\hyperlink{namespaceGlobal__Physical__Variables_a09a019474b7405b35da2437f7779bc7e}{Global\_Physical\_Variables::E});
 
 \textcolor{comment}{// Define a constitutive law (based on strain energy function)}
 \hyperlink{namespaceGlobal__Physical__Variables_a2a37fb040c832ee7a086bb13bb02a100}{Global\_Physical\_Variables::Constitutive\_law\_pt} = 
  \textcolor{keyword}{new} IsotropicStrainEnergyFunctionConstitutiveLaw(
   \hyperlink{namespaceGlobal__Physical__Variables_a73135f793690b4386bf83bbefc7bf310}{Global\_Physical\_Variables::Strain\_energy\_function\_pt}
      );

\end{DoxyCodeInclude}


We build a problem object, using the displacement-\/based {\ttfamily Refineable\+Q\+P\+V\+D\+Elements} to discretise the domain, and perform a parameter study, exploring the disk\textquotesingle{}s deformation for a range of external pressures.


\begin{DoxyCodeInclude}
 
 \textcolor{comment}{// Case 0: No pressure, generalised Mooney Rivlin}
 \textcolor{comment}{//-----------------------------------------------}
 \{
    \textcolor{comment}{//Set up the problem}
  \hyperlink{classStaticDiskCompressionProblem}{StaticDiskCompressionProblem<RefineableQPVDElement<2,3>}
       > problem;
  
  cout << \textcolor{stringliteral}{"gen. M.R.: RefineableQPVDElement<2,3>"} << std::endl;
  
  \textcolor{comment}{//Run the simulation}
  problem.\hyperlink{classStaticDiskCompressionProblem_ac64db4786efde78e70b1110422331b02}{parameter\_study}(0);
  
 \} \textcolor{comment}{// done case 0}

\end{DoxyCodeInclude}


We repeat the exercise with elements from the {\ttfamily Refineable\+Q\+P\+V\+D\+Element\+With\+Continuous\+Pressure} family which discretise the principle of virtual displacements (P\+VD) in the pressure/displacement formulation, using continuous pressures (Q2\+Q1; Taylor Hood).


\begin{DoxyCodeInclude}
 
 
 \textcolor{comment}{// Case 1: Continuous pressure formulation with generalised Mooney Rivlin}
 \textcolor{comment}{//------------------------------------------------------------------------}
 \{
  \textcolor{comment}{//Set up the problem}
  \hyperlink{classStaticDiskCompressionProblem}{StaticDiskCompressionProblem}<
   RefineableQPVDElementWithContinuousPressure<2> > problem;
  
  cout << \textcolor{stringliteral}{"gen. M.R.: RefineableQPVDElementWithContinuousPressure<2> "} 
       << std::endl;
  
  \textcolor{comment}{//Run the simulation}
  problem.\hyperlink{classStaticDiskCompressionProblem_ac64db4786efde78e70b1110422331b02}{parameter\_study}(1);

 \}  \textcolor{comment}{// done case 1}

\end{DoxyCodeInclude}


The next computation employs {\ttfamily Refineable\+Q\+P\+V\+D\+Element\+With\+Pressure} elements in which the pressure is interpolated by piecewise linear but globally discontinuous basis functions (Q2\+Q-\/1; Crouzeiux-\/\+Raviart).


\begin{DoxyCodeInclude}
 
 
 
 \textcolor{comment}{// Case 2: Discontinuous pressure formulation with generalised Mooney Rivlin}
 \textcolor{comment}{//--------------------------------------------------------------------------}
 \{
  \textcolor{comment}{//Set up the problem}
  \hyperlink{classStaticDiskCompressionProblem}{StaticDiskCompressionProblem<RefineableQPVDElementWithPressure<2>}
       > 
   problem;
  
  cout << \textcolor{stringliteral}{"gen. M.R.: RefineableQPVDElementWithPressure<2>"} << std::endl;
  
  \textcolor{comment}{//Run the simulation}
  problem.\hyperlink{classStaticDiskCompressionProblem_ac64db4786efde78e70b1110422331b02}{parameter\_study}(2);
  
 \}  \textcolor{comment}{// done case 2}

\end{DoxyCodeInclude}


Next, we change the constitutive equation to {\ttfamily oomph-\/lib\textquotesingle{}s} generalised Hooke\textquotesingle{}s law,


\begin{DoxyCodeInclude}
 
 
 \textcolor{comment}{// Change the consitutive law: Delete the old one}
 \textcolor{keyword}{delete} \hyperlink{namespaceGlobal__Physical__Variables_a2a37fb040c832ee7a086bb13bb02a100}{Global\_Physical\_Variables::Constitutive\_law\_pt};
 
 \textcolor{comment}{// Create oomph-lib's generalised Hooke's law constitutive equation}
 \hyperlink{namespaceGlobal__Physical__Variables_a2a37fb040c832ee7a086bb13bb02a100}{Global\_Physical\_Variables::Constitutive\_law\_pt} = 
  \textcolor{keyword}{new} GeneralisedHookean(&\hyperlink{namespaceGlobal__Physical__Variables_a3962c36313826b19f216f6bbbdd6a477}{Global\_Physical\_Variables::Nu},
                         &\hyperlink{namespaceGlobal__Physical__Variables_a09a019474b7405b35da2437f7779bc7e}{Global\_Physical\_Variables::E});

\end{DoxyCodeInclude}


before repeating the parameter studies with the same three element types\+:


\begin{DoxyCodeInclude}
 
 \textcolor{comment}{// Case 3: No pressure, generalised Hooke's law}
 \textcolor{comment}{//----------------------------------------------}
 \{
  \textcolor{comment}{//Set up the problem}
  \hyperlink{classStaticDiskCompressionProblem}{StaticDiskCompressionProblem<RefineableQPVDElement<2,3>}
       > problem;
  
  cout << \textcolor{stringliteral}{"gen. Hooke: RefineableQPVDElement<2,3> "} << std::endl;
  
  \textcolor{comment}{//Run the simulation}
  problem.\hyperlink{classStaticDiskCompressionProblem_ac64db4786efde78e70b1110422331b02}{parameter\_study}(3);  

 \}  \textcolor{comment}{// done case 3}
 
 \textcolor{comment}{// Case 4: Continuous pressure formulation with generalised Hooke's law}
 \textcolor{comment}{//---------------------------------------------------------------------}
 \{
  
  \textcolor{comment}{//Set up the problem}
  \hyperlink{classStaticDiskCompressionProblem}{StaticDiskCompressionProblem}<
   RefineableQPVDElementWithContinuousPressure<2> > problem;
  
  cout << \textcolor{stringliteral}{"gen. Hooke: RefineableQPVDElementWithContinuousPressure<2> "} 
       << std::endl;
  
  \textcolor{comment}{//Run the simulation}
  problem.\hyperlink{classStaticDiskCompressionProblem_ac64db4786efde78e70b1110422331b02}{parameter\_study}(4);
  
 \}  \textcolor{comment}{// done case 4}
 
 
 \textcolor{comment}{// Case 5:  Discontinous pressure formulation with generalised Hooke's law}
 \textcolor{comment}{//------------------------------------------------------------------------}
 \{
  
  \textcolor{comment}{//Set up the problem}
  \hyperlink{classStaticDiskCompressionProblem}{StaticDiskCompressionProblem<RefineableQPVDElementWithPressure<2>}
       > problem;
  
  cout << \textcolor{stringliteral}{"gen. Hooke: RefineableQPVDElementWithPressure<2> "} << std::endl;
  
  \textcolor{comment}{//Run the simulation}
  problem.\hyperlink{classStaticDiskCompressionProblem_ac64db4786efde78e70b1110422331b02}{parameter\_study}(5);
    
 \}  \textcolor{comment}{// done case 5}
 
 \textcolor{comment}{// Clean up }
 \textcolor{keyword}{delete} \hyperlink{namespaceGlobal__Physical__Variables_a2a37fb040c832ee7a086bb13bb02a100}{Global\_Physical\_Variables::Constitutive\_law\_pt};
 \hyperlink{namespaceGlobal__Physical__Variables_a2a37fb040c832ee7a086bb13bb02a100}{Global\_Physical\_Variables::Constitutive\_law\_pt}=0;
 
\} \textcolor{comment}{// end of main}

\end{DoxyCodeInclude}




 

\hypertarget{index_mesh}{}\section{The mesh}\label{index_mesh}
We formulate the problem in cartesian coordinates (ignoring the problem\textquotesingle{}s axisymmetry) but discretise only one quarter of the domain, applying appropriate symmetry conditions along the x and y axes. The computational domain may be discretised with the {\ttfamily Refineable\+Quarter\+Circle\+Sector\+Mesh} that we already used in many previous examples. To use the mesh in this solid mechanics problem we must first \char`\"{}upgrade\char`\"{} it to a {\ttfamily Solid\+Mesh}. This is easily done by multiple inheritance\+:

 
\begin{DoxyCodeInclude}
\textcolor{comment}{//==========start\_mesh=================================================}
\textcolor{comment}{/// Elastic quarter circle sector mesh with functionality to}
\textcolor{comment}{}\textcolor{comment}{/// attach traction elements to the curved surface. We "upgrade"}
\textcolor{comment}{}\textcolor{comment}{/// the RefineableQuarterCircleSectorMesh to become an}
\textcolor{comment}{}\textcolor{comment}{/// SolidMesh and equate the Eulerian and Lagrangian coordinates,}
\textcolor{comment}{}\textcolor{comment}{/// thus making the domain represented by the mesh the stress-free }
\textcolor{comment}{}\textcolor{comment}{/// configuration. }
\textcolor{comment}{}\textcolor{comment}{/// \(\backslash\)n\(\backslash\)n}
\textcolor{comment}{}\textcolor{comment}{/// The member function \(\backslash\)c make\_traction\_element\_mesh() creates}
\textcolor{comment}{}\textcolor{comment}{/// a separate mesh of SolidTractionElements that are attached to the}
\textcolor{comment}{}\textcolor{comment}{/// mesh's curved boundary (boundary 1). }
\textcolor{comment}{}\textcolor{comment}{//=====================================================================}
\textcolor{keyword}{template} <\textcolor{keyword}{class} ELEMENT>
\textcolor{keyword}{class }\hyperlink{classElasticRefineableQuarterCircleSectorMesh}{ElasticRefineableQuarterCircleSectorMesh} :
 \textcolor{keyword}{public} \textcolor{keyword}{virtual} RefineableQuarterCircleSectorMesh<ELEMENT>,
 \textcolor{keyword}{public} \textcolor{keyword}{virtual} SolidMesh
\{

\end{DoxyCodeInclude}


The constructor calls the constructor of the underlying {\ttfamily Refineable\+Quarter\+Circle\+Sector\+Mesh} and sets the Lagrangian coordinates of the nodes to their current Eulerian positions, making the initial configuration stress-\/free.


\begin{DoxyCodeInclude}


\textcolor{keyword}{public}:
\textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Constructor: Build mesh and copy Eulerian coords to Lagrangian}
\textcolor{comment}{ /// ones so that the initial configuration is the stress-free one.}
\textcolor{comment}{} \hyperlink{classElasticRefineableQuarterCircleSectorMesh}{ElasticRefineableQuarterCircleSectorMesh<ELEMENT>}(
      GeomObject* wall\_pt,
                                         \textcolor{keyword}{const} \textcolor{keywordtype}{double}& xi\_lo,
                                         \textcolor{keyword}{const} \textcolor{keywordtype}{double}& fract\_mid,
                                         \textcolor{keyword}{const} \textcolor{keywordtype}{double}& xi\_hi,
                                         TimeStepper* time\_stepper\_pt=
                                         &Mesh::Default\_TimeStepper) :
  RefineableQuarterCircleSectorMesh<ELEMENT>(wall\_pt,xi\_lo,fract\_mid,xi\_hi,
                                             time\_stepper\_pt)
  \{\textcolor{comment}{}
\textcolor{comment}{   /// Make the current configuration the undeformed one by}
\textcolor{comment}{   /// setting the nodal Lagrangian coordinates to their current}
\textcolor{comment}{   /// Eulerian ones}
\textcolor{comment}{}   set\_lagrangian\_nodal\_coordinates();
  \}

\end{DoxyCodeInclude}


We also provide a helper function that creates a mesh of {\ttfamily Solid\+Traction\+Elements} which are attached to the curved domain boundary (boundary 1). These elements will be used to apply the external pressure load.


\begin{DoxyCodeInclude}

\textcolor{comment}{}
\textcolor{comment}{ /// Function to create mesh made of traction elements}
\textcolor{comment}{} \textcolor{keywordtype}{void} make\_traction\_element\_mesh(SolidMesh*& traction\_mesh\_pt)
  \{

   \textcolor{comment}{// Make new mesh}
   traction\_mesh\_pt = \textcolor{keyword}{new} SolidMesh;

   \textcolor{comment}{// Loop over all elements on boundary 1:}
   \textcolor{keywordtype}{unsigned} b=1;
   \textcolor{keywordtype}{unsigned} n\_element = this->nboundary\_element(b);
   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} e=0;e<n\_element;e++)
    \{
     \textcolor{comment}{// The element itself:}
     FiniteElement* fe\_pt = this->boundary\_element\_pt(b,e);
     
     \textcolor{comment}{// Find the index of the face of element e along boundary b}
     \textcolor{keywordtype}{int} face\_index = this->face\_index\_at\_boundary(b,e);
     
     \textcolor{comment}{// Create new element}
     traction\_mesh\_pt->add\_element\_pt(\textcolor{keyword}{new} SolidTractionElement<ELEMENT>
                                      (fe\_pt,face\_index));
    \}
  \}

\};

\end{DoxyCodeInclude}




 

\hypertarget{index_problem_class}{}\section{The Problem class}\label{index_problem_class}
The definition of the Problem class is very straightforward. In addition to the constructor and the (empty) {\ttfamily actions\+\_\+before\+\_\+newton\+\_\+solve()} and {\ttfamily actions\+\_\+after\+\_\+newton\+\_\+solve()} functions, we provide the function {\ttfamily parameter\+\_\+study}(...) which performs a parameter study, computing the disk\textquotesingle{}s deformation for a range of external pressures. The member data includes pointers to the mesh of \char`\"{}bulk\char`\"{} solid elements, and the mesh of {\ttfamily Solid\+Traction\+Elements} that apply the pressure load. The trace file is used to document the disk\textquotesingle{}s load-\/displacement characteristics by plotting the radial displacement of the nodes on the curvilinear boundary, pointers to which are stored in the vector {\ttfamily Trace\+\_\+node\+\_\+pt}.


\begin{DoxyCodeInclude}


\textcolor{comment}{//====================================================================== }\textcolor{comment}{}
\textcolor{comment}{/// Uniform compression of a circular disk in a state of plane strain,}
\textcolor{comment}{/// subject to uniform growth. }
\textcolor{comment}{}\textcolor{comment}{//====================================================================== }
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT>
\textcolor{keyword}{class }\hyperlink{classStaticDiskCompressionProblem}{StaticDiskCompressionProblem} : \textcolor{keyword}{public} Problem
\{

\textcolor{keyword}{public}:
\textcolor{comment}{}
\textcolor{comment}{ /// Constructor:}
\textcolor{comment}{} \hyperlink{classStaticDiskCompressionProblem_a462e81aec225a5d6204b579719b3db87}{StaticDiskCompressionProblem}();
\textcolor{comment}{}
\textcolor{comment}{ /// Run simulation: Pass case number to label output files}
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{classStaticDiskCompressionProblem_ac64db4786efde78e70b1110422331b02}{parameter\_study}(\textcolor{keyword}{const} \textcolor{keywordtype}{unsigned}& case\_number);
 \textcolor{comment}{}
\textcolor{comment}{ /// Doc the solution}
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{classStaticDiskCompressionProblem_a9154152d022e86461966b5562f5acba4}{doc\_solution}(DocInfo& doc\_info);
\textcolor{comment}{}
\textcolor{comment}{ /// Update function (empty)}
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{classStaticDiskCompressionProblem_a484b47d6a10a91cbd30cb807a49b1f58}{actions\_after\_newton\_solve}() \{\}
\textcolor{comment}{}
\textcolor{comment}{ /// Update function (empty)}
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{classStaticDiskCompressionProblem_a2b00608d2992b40217248e01b2294153}{actions\_before\_newton\_solve}() \{\}

\textcolor{keyword}{private}:
\textcolor{comment}{}
\textcolor{comment}{ /// Trace file}
\textcolor{comment}{} ofstream \hyperlink{classStaticDiskCompressionProblem_a7affbfca1efcaadb4770386dc7d23e4c}{Trace\_file};
 \textcolor{comment}{}
\textcolor{comment}{ /// Vector of pointers to nodes whose position we're tracing}
\textcolor{comment}{} Vector<Node*> \hyperlink{classStaticDiskCompressionProblem_a8e98a225a1bb49cb6943b59d9f3145dc}{Trace\_node\_pt};
\textcolor{comment}{}
\textcolor{comment}{ /// Pointer to solid mesh}
\textcolor{comment}{} \hyperlink{classElasticRefineableQuarterCircleSectorMesh}{ElasticRefineableQuarterCircleSectorMesh<ELEMENT>}* 
      \hyperlink{classStaticDiskCompressionProblem_a6ad5b428d535a90f71e2e9325e9a5b15}{Solid\_mesh\_pt};
\textcolor{comment}{}
\textcolor{comment}{ /// Pointer to mesh of traction elements}
\textcolor{comment}{} SolidMesh* \hyperlink{classStaticDiskCompressionProblem_a66623722b4cb3bdc94d46a56c18d2908}{Traction\_mesh\_pt};

\};

\end{DoxyCodeInclude}




 

\hypertarget{index_constructor}{}\section{The Constructor}\label{index_constructor}
We start by constructing the mesh of \char`\"{}bulk\char`\"{} {\ttfamily Solid\+Elements}, using the {\ttfamily Ellipse} object to specify the shape of the curvilinear domain boundary.


\begin{DoxyCodeInclude}

\textcolor{comment}{//====================================================================== }\textcolor{comment}{}
\textcolor{comment}{/// Constructor: }
\textcolor{comment}{}\textcolor{comment}{//====================================================================== }
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT>
\hyperlink{classStaticDiskCompressionProblem_a462e81aec225a5d6204b579719b3db87}{StaticDiskCompressionProblem<ELEMENT>::StaticDiskCompressionProblem}
      () 
\{
 \textcolor{comment}{// Build the geometric object that describes the curvilinear}
 \textcolor{comment}{// boundary of the quarter circle domain}
 Ellipse* curved\_boundary\_pt = \textcolor{keyword}{new} Ellipse(1.0,1.0);

 \textcolor{comment}{// The curved boundary of the mesh is defined by the geometric object}
 \textcolor{comment}{// What follows are the start and end coordinates on the geometric object:}
 \textcolor{keywordtype}{double} xi\_lo=0.0;
 \textcolor{keywordtype}{double} xi\_hi=2.0*atan(1.0);

 \textcolor{comment}{// Fraction along geometric object at which the radial dividing line}
 \textcolor{comment}{// is placed}
 \textcolor{keywordtype}{double} fract\_mid=0.5;

 \textcolor{comment}{//Now create the mesh using the geometric object}
 Solid\_mesh\_pt = \textcolor{keyword}{new} \hyperlink{classElasticRefineableQuarterCircleSectorMesh}{ElasticRefineableQuarterCircleSectorMesh<ELEMENT>}
      (
  curved\_boundary\_pt,xi\_lo,fract\_mid,xi\_hi);

\end{DoxyCodeInclude}


Next we choose the nodes on the curvilinear domain boundary (boundary 1) as the nodes whose displacement we document in the trace file.


\begin{DoxyCodeInclude}

 \textcolor{comment}{// Setup trace nodes as the nodes on boundary  1 (=curved boundary) }
 \textcolor{comment}{// in the original mesh.}
 \textcolor{keywordtype}{unsigned} n\_boundary\_node = Solid\_mesh\_pt->nboundary\_node(1);
 Trace\_node\_pt.resize(n\_boundary\_node);
 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} j=0;j<n\_boundary\_node;j++)
  \{Trace\_node\_pt[j]=Solid\_mesh\_pt->boundary\_node\_pt(1,j);\}

\end{DoxyCodeInclude}


The {\ttfamily Quarter\+Circle\+Sector\+Mesh} that forms the basis of the \char`\"{}bulk\char`\"{} mesh contains only three elements -- not enough to expect the solution to be accurate. Therefore we apply one round of uniform mesh refinement before attaching the {\ttfamily Solid\+Traction\+Elements} to the mesh boundary 1, using the function {\ttfamily make\+\_\+traction\+\_\+element\+\_\+mesh()} in the {\ttfamily \hyperlink{classElasticRefineableQuarterCircleSectorMesh}{Elastic\+Refineable\+Quarter\+Circle\+Sector\+Mesh}}.


\begin{DoxyCodeInclude}

 \textcolor{comment}{// Refine the mesh uniformly}
 Solid\_mesh\_pt->refine\_uniformly();

 \textcolor{comment}{// Now construct the traction element mesh}
 Solid\_mesh\_pt->make\_traction\_element\_mesh(Traction\_mesh\_pt);

\end{DoxyCodeInclude}


We add both meshes to the {\ttfamily Problem} and build a combined global mesh\+:


\begin{DoxyCodeInclude}
 
 \textcolor{comment}{// Solid mesh is first sub-mesh}
 add\_sub\_mesh(Solid\_mesh\_pt);

 \textcolor{comment}{// Traction mesh is second sub-mesh}
 add\_sub\_mesh(Traction\_mesh\_pt);

 \textcolor{comment}{// Build combined "global" mesh}
 build\_global\_mesh();

\end{DoxyCodeInclude}


Symmetry boundary conditions along the horizontal and vertical symmetry lines require that the nodes\textquotesingle{} vertical position is pinned along boundary 0, while their horizontal position is pinned along boundary 2.


\begin{DoxyCodeInclude}


 \textcolor{comment}{// Pin the left edge in the horizontal direction}
 \textcolor{keywordtype}{unsigned} n\_side = mesh\_pt()->nboundary\_node(2);
 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} i=0;i<n\_side;i++)
  \{Solid\_mesh\_pt->boundary\_node\_pt(2,i)->pin\_position(0);\}

 \textcolor{comment}{// Pin the bottom in the vertical direction}
 \textcolor{keywordtype}{unsigned} n\_bottom = mesh\_pt()->nboundary\_node(0);
 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} i=0;i<n\_bottom;i++)
  \{Solid\_mesh\_pt->boundary\_node\_pt(0,i)->pin\_position(1);\}

\end{DoxyCodeInclude}


Since we are using refineable solid elements, we pin any \char`\"{}redundant\char`\"{} pressure degrees of freedom in the \char`\"{}bulk\char`\"{} solid mesh (see \href{../../airy_cantilever/html/index.html#ex}{\tt the exercises in another tutorial} for a more detailed discussion of this issue).


\begin{DoxyCodeInclude}

 \textcolor{comment}{// Pin the redundant solid pressures (if any)}
 PVDEquationsBase<2>::pin\_redundant\_nodal\_solid\_pressures(
  Solid\_mesh\_pt->element\_pt());

\end{DoxyCodeInclude}


Next, we complete the build of the elements in the \char`\"{}bulk\char`\"{} solid mesh by passing the pointer to the constitutive equation and the pointer to the isotropic-\/growth function to the elements\+:


\begin{DoxyCodeInclude}

 \textcolor{comment}{//Complete the build process for elements in "bulk" solid mesh}
 \textcolor{keywordtype}{unsigned} n\_element =Solid\_mesh\_pt->nelement();
 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} i=0;i<n\_element;i++)
  \{
   \textcolor{comment}{//Cast to a solid element}
   ELEMENT *el\_pt = \textcolor{keyword}{dynamic\_cast<}ELEMENT*\textcolor{keyword}{>}(Solid\_mesh\_pt->element\_pt(i));
   
   \textcolor{comment}{// Set the constitutive law}
   el\_pt->constitutive\_law\_pt() =
    \hyperlink{namespaceGlobal__Physical__Variables_a2a37fb040c832ee7a086bb13bb02a100}{Global\_Physical\_Variables::Constitutive\_law\_pt};
   
   \textcolor{comment}{// Set the isotropic growth function pointer}
   el\_pt->isotropic\_growth\_fct\_pt()=\hyperlink{namespaceGlobal__Physical__Variables_a6be3760e5494b1772e4bfe5d5f3c5d53}{Global\_Physical\_Variables::growth\_function}
      ;
  \}

\end{DoxyCodeInclude}


We repeat this exercise for the {\ttfamily Solid\+Traction\+Elements} which must be given a pointer to the function that applies the pressure load


\begin{DoxyCodeInclude}

 \textcolor{comment}{// Complete build process for SolidTractionElements}
 n\_element=Traction\_mesh\_pt->nelement();
 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} i=0;i<n\_element;i++)
  \{
   \textcolor{comment}{//Cast to a solid traction element}
   SolidTractionElement<ELEMENT> *el\_pt = 
    \textcolor{keyword}{dynamic\_cast<}SolidTractionElement<ELEMENT>*\textcolor{keyword}{>}
    (Traction\_mesh\_pt->element\_pt(i));

   \textcolor{comment}{//Set the traction function}
   el\_pt->traction\_fct\_pt() = \hyperlink{namespaceGlobal__Physical__Variables_a19f4e20a92e7d216b4d2b00308f96917}{Global\_Physical\_Variables::constant\_pressure}
      ;
  \}

\end{DoxyCodeInclude}


Finally, we set up the equation numbering scheme and report the number of unknowns.


\begin{DoxyCodeInclude}

 \textcolor{comment}{//Set up equation numbering scheme}
 cout << \textcolor{stringliteral}{"Number of equations: "} <<  assign\_eqn\_numbers() << std::endl; 
\}

\end{DoxyCodeInclude}




 

\hypertarget{index_doc_solution}{}\section{Post-\/processing}\label{index_doc_solution}
The post-\/processing function outputs the shape of the deformed disk. We use the trace file to record how the disk\textquotesingle{}s volume (area) and the radii of the control nodes on the curvilinear domain boundary vary with the applied pressure. To facilitate the validation of the results against the analytical solution, we also add the radius predicted by the linear theory to the trace file.


\begin{DoxyCodeInclude}


\textcolor{comment}{//==================================================================}\textcolor{comment}{}
\textcolor{comment}{/// Doc the solution}
\textcolor{comment}{}\textcolor{comment}{//==================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT>
\textcolor{keywordtype}{void} \hyperlink{classStaticDiskCompressionProblem_a9154152d022e86461966b5562f5acba4}{StaticDiskCompressionProblem<ELEMENT>::doc\_solution}
      (DocInfo& doc\_info)
\{

 ofstream some\_file;
 \textcolor{keywordtype}{char} filename[100];

 \textcolor{comment}{// Number of plot points}
 \textcolor{keywordtype}{unsigned} npts = 5; 

 \textcolor{comment}{// Output shape of deformed body}
 sprintf(filename,\textcolor{stringliteral}{"%s/soln%i.dat"},doc\_info.directory().c\_str(),
         doc\_info.number());
 some\_file.open(filename);
 Solid\_mesh\_pt->output(some\_file,npts);
 some\_file.close();

 \textcolor{comment}{//Find number of solid elements}
 \textcolor{keywordtype}{unsigned} nelement = Solid\_mesh\_pt->nelement();

 \textcolor{comment}{// Work out volume}
 \textcolor{keywordtype}{double} volume = 0.0;
 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} e=0;e<nelement;e++) 
  \{volume+= Solid\_mesh\_pt->finite\_element\_pt(e)->size();\}
 
 \textcolor{comment}{// Exact outer radius for linear elasticity}
 \textcolor{keywordtype}{double} nu=\hyperlink{namespaceGlobal__Physical__Variables_a3962c36313826b19f216f6bbbdd6a477}{Global\_Physical\_Variables::Nu};
 \textcolor{keywordtype}{double} exact\_r=sqrt(\hyperlink{namespaceGlobal__Physical__Variables_ae02b5f5b098b05fba75f3b61f381c5f7}{Global\_Physical\_Variables::Uniform\_gamma})*
  (1.0-\hyperlink{namespaceGlobal__Physical__Variables_a23c2ade6398f54040b869f7f3a2bcc4b}{Global\_Physical\_Variables::P}/
      \hyperlink{namespaceGlobal__Physical__Variables_a09a019474b7405b35da2437f7779bc7e}{Global\_Physical\_Variables::E}
   *((1.0+nu)*(1.0-2.0*nu)));


 \textcolor{comment}{// Write trace file: Problem parameters}
 Trace\_file << \hyperlink{namespaceGlobal__Physical__Variables_a23c2ade6398f54040b869f7f3a2bcc4b}{Global\_Physical\_Variables::P}  << \textcolor{stringliteral}{" "} 
            << \hyperlink{namespaceGlobal__Physical__Variables_ae02b5f5b098b05fba75f3b61f381c5f7}{Global\_Physical\_Variables::Uniform\_gamma} << \textcolor{stringliteral}{" "} 
            << volume << \textcolor{stringliteral}{" "} 
            << exact\_r << \textcolor{stringliteral}{" "};
   
 \textcolor{comment}{// Write radii of trace nodes}
 \textcolor{keywordtype}{unsigned} ntrace\_node=Trace\_node\_pt.size();
 \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} j=0;j<ntrace\_node;j++)
  \{
   Trace\_file << sqrt(pow(Trace\_node\_pt[j]->x(0),2)+
                      pow(Trace\_node\_pt[j]->x(1),2)) << \textcolor{stringliteral}{" "};
  \}
 Trace\_file << std::endl;

\} \textcolor{comment}{// end of doc\_solution}

\end{DoxyCodeInclude}




 

\hypertarget{index_run_it}{}\section{Performing the parameter study}\label{index_run_it}
The function {\ttfamily parameter\+\_\+study}(...) computes the disk\textquotesingle{}s deformation for a range of external pressures and outputs the results. The output directory is labelled by the {\ttfamily unsigned} function argument. This ensures that parameter studies performed with different constitutive equations are written into different directories.


\begin{DoxyCodeInclude}


\textcolor{comment}{//==================================================================}\textcolor{comment}{}
\textcolor{comment}{/// Run the paramter study}
\textcolor{comment}{}\textcolor{comment}{//==================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT>
\textcolor{keywordtype}{void} \hyperlink{classStaticDiskCompressionProblem_ac64db4786efde78e70b1110422331b02}{StaticDiskCompressionProblem<ELEMENT>::parameter\_study}
      (
 \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned}& case\_number)
\{
 \textcolor{comment}{// Output}
 DocInfo doc\_info;

 \textcolor{keywordtype}{char} dirname[100];
 sprintf(dirname,\textcolor{stringliteral}{"RESLT%i"},case\_number);

 \textcolor{comment}{// Set output directory}
 doc\_info.set\_directory(dirname);

 \textcolor{comment}{// Step number}
 doc\_info.number()=0;

 \textcolor{comment}{// Open trace file}
 \textcolor{keywordtype}{char} filename[100];   
 sprintf(filename,\textcolor{stringliteral}{"%s/trace.dat"},doc\_info.directory().c\_str());
 Trace\_file.open(filename);
 
 \textcolor{comment}{//Parameter incrementation}
 \textcolor{keywordtype}{double} delta\_p=0.0125;
 \textcolor{keywordtype}{unsigned} nstep=21; 

 \textcolor{comment}{// Perform fewer steps if run as self-test (indicated by nonzero number}
 \textcolor{comment}{// of command line arguments)}
 \textcolor{keywordflow}{if} (CommandLineArgs::Argc!=1)
  \{
   nstep=3;
  \}

 \textcolor{comment}{// Offset external pressure so that the computation sweeps }
 \textcolor{comment}{// over a range of positive and negative pressures}
 \hyperlink{namespaceGlobal__Physical__Variables_a23c2ade6398f54040b869f7f3a2bcc4b}{Global\_Physical\_Variables::P} =-delta\_p*double(nstep-1)*0.5; 

 \textcolor{comment}{// Do the parameter study}
 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} i=0;i<nstep;i++)
  \{
   \textcolor{comment}{//Solve the problem for current load}
   newton\_solve();

   \textcolor{comment}{// Doc solution}
   doc\_solution(doc\_info);
   doc\_info.number()++;

   \textcolor{comment}{// Increment pressure load}
   \hyperlink{namespaceGlobal__Physical__Variables_a23c2ade6398f54040b869f7f3a2bcc4b}{Global\_Physical\_Variables::P} += delta\_p;   
  \}

\} \textcolor{comment}{// end of parameter study}

\end{DoxyCodeInclude}




 

\hypertarget{index_comm_and_ex}{}\section{Comments and Exercises}\label{index_comm_and_ex}
\hypertarget{index_macro}{}\subsection{The use of Macro\+Elements in solid mechanics problems}\label{index_macro}
\href{../../../poisson/fish_poisson2/html/index.html}{\tt Recall} how {\ttfamily oomph-\/lib} employs {\ttfamily Macro\+Elements} to represent the exact domain shapes in adaptive computations involving problems with curvilinear boundaries. When an element is refined, the (Eulerian) position of any newly-\/created nodes is based on the element\textquotesingle{}s {\ttfamily Macro\+Element} counterpart, rather than being determined by finite-\/element interpolation from the \char`\"{}father element\char`\"{}. This ensures that {\bfseries (i)} newly-\/created nodes on curvilinear domain boundaries are placed exactly onto those boundaries and {\bfseries (ii)} that newly-\/created nodes in the interior are placed at positions that match smoothly onto the boundary.

This strategy is adapted slightly for solid mechanics problems\+:
\begin{DoxyEnumerate}
\item The Eulerian position of newly-\/created {\ttfamily Solid\+Nodes} is determined by finite element interpolation from the \char`\"{}father element\char`\"{}, {\bfseries unless} the newly-\/created {\ttfamily Solid\+Node} is located on a domain boundary and its position is pinned by displacement boundary conditions. ~\newline
~\newline

\item The same procedure is employed to determine the Lagrangian coordinates of newly-\/created {\ttfamily Solid\+Nodes}.
\end{DoxyEnumerate}These modifications ensure that, as before, newly-\/created nodes on curvilinear domain boundaries are placed exactly onto those boundaries if their positions are pinned by displacement boundary conditions. (If the nodal positions are not pinned, the node\textquotesingle{}s Eulerian position will be determined as part of the solution.) The use of finite-\/element interpolation from the \char`\"{}father element\char`\"{} in the interior of the domain for both Lagrangian and Eulerian coordinates ensures that the creation of new nodes does not induce any stresses into a previously computed solution.\hypertarget{index_ex}{}\subsection{Exercises}\label{index_ex}

\begin{DoxyEnumerate}
\item Our discretisation of the problem in cartesian coordinates did not exploit the problem\textquotesingle{}s axisymmetry. Examine the trace file to assess to which extent the computation retained the axisymmetry. ~\newline
~\newline

\end{DoxyEnumerate}



 

 \hypertarget{index_pdf}{}\section{P\+D\+F file}\label{index_pdf}
A \href{../latex/refman.pdf}{\tt pdf version} of this document is available. \end{document}
