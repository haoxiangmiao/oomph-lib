The purpose of this tutorial is to show how to specify different linear solvers for {\ttfamily oomph-\/lib\textquotesingle{}s} Newton solver.


\begin{DoxyItemize}
\item \hyperlink{index_overview}{Overview}
\item \hyperlink{index_available_solvers}{List of available linear solvers}
\item \hyperlink{index_how_to_change_linear_solver}{How to change the Linear\+Solver}
\begin{DoxyItemize}
\item \hyperlink{index_direct}{Direct solvers}
\item \hyperlink{index_iterative_linear_solvers}{Iterative linear solvers and preconditioners}
\item \hyperlink{index_third_party_iterative_linear_solvers}{Third-\/party iterative linear solvers and preconditioners}
\end{DoxyItemize}
\item \hyperlink{index_specific_precond}{Problem-\/specific preconditioners}
\end{DoxyItemize}

 

\hypertarget{index_overview}{}\section{Overview}\label{index_overview}
As discussed in the \href{../../the_data_structure/html/index.html}{\tt bottom-\/up discussion of {\ttfamily oomph-\/lib\textquotesingle{}s} data structure}, by default {\ttfamily oomph-\/lib\textquotesingle{}s} Newton solver, {\ttfamily Problem\+::newton\+\_\+solve}(...) solves the linear systems arising during the Newton iteration with its default linear solver, \href{../../the_data_structure/html/classoomph_1_1SuperLUSolver.html}{\tt {\ttfamily  Super\+L\+U\+Solver}}, a wrapper to Demmel, Eistenstat, Gilbert, Li \& Liu\textquotesingle{}s sparse direct solver \href{http://crd.lbl.gov/~xiaoye/SuperLU}{\tt Super\+LU.}

{\ttfamily oomph-\/lib} provides a large number of alternative linear solvers that may be used instead. All linear solvers within the library are derived from the base class \href{../../the_data_structure/html/classoomph_1_1LinearSolver.html}{\tt {\ttfamily  Linear\+Solver}} which contains a single pure virtual function

 
\begin{DoxyCodeInclude}
 \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} solve(Problem* \textcolor{keyword}{const} &problem\_pt, DoubleVector &result)=0;

\end{DoxyCodeInclude}


whose task it is to compute the solution $ \delta {\bf x} $ (returned in the vector {\ttfamily result}) of the linear system \[ {\cal J} \delta {\bf x} = -{\bf r} \] where $ {\bf r} $ and $ {\cal J} $ are the global Jacobian and the residual vector, computed by the {\ttfamily Problem} pointed to by {\ttfamily problem\+\_\+pt}. The \href{../../the_data_structure/html/classoomph_1_1LinearSolver.html}{\tt {\ttfamily  Linear\+Solver}} class also defines linear-\/algebra-\/type interfaces that allow the solution of linear systems with matrices other than the {\ttfamily Problem\textquotesingle{}s} Jacobian matrix. However, these methods may not be implemented for all linear solvers.



 

\hypertarget{index_available_solvers}{}\section{List of available linear solvers}\label{index_available_solvers}
{\ttfamily oomph-\/lib\textquotesingle{}s} linear solvers can be sub-\/divided into serial and parallel, and direct and iterative linear solvers. Here is a quick overview of the available linear solvers. If you are viewing this document online, the links take you directly to the solvers\textquotesingle{} class references which explain any solver-\/specific member functions.


\begin{DoxyItemize}
\item {\bfseries Serial solvers\+: } ~\newline
~\newline

\begin{DoxyItemize}
\item {\bfseries Direct solvers\+:} ~\newline
~\newline

\begin{DoxyItemize}
\item \href{../../the_data_structure/html/classoomph_1_1SuperLUSolver.html}{\tt {\ttfamily Super\+L\+U\+Solver}}\+: {\ttfamily oomph-\/lib\textquotesingle{}s} default linear solver, a wrapper to Demmel, Eistenstat, Gilbert, Li \& Liu\textquotesingle{}s sparse direct solver \href{http://crd.lbl.gov/~xiaoye/SuperLU}{\tt Super\+LU.} ~\newline
~\newline

\item \href{../../the_data_structure/html/classoomph_1_1HSL__MA42.html}{\tt {\ttfamily H\+S\+L\+\_\+\+M\+A42}}\+: A wrapper to the frontal solver M\+A42 from the \href{http://www.hsl.rl.ac.uk/}{\tt H\+SL library.} This solver is available free-\/of-\/charge for UK academics. The source code can be dropped into the {\ttfamily oomph-\/lib} distribution; see the instructions in the dummy code~\newline
~\newline
 \begin{center} \href{../../../external_src/oomph_hsl/dummy_frontal.f}{\tt external\+\_\+src/oomph\+\_\+hsl/dummy\+\_\+frontal.\+f}~\newline
~\newline
 \end{center} 
\item \href{../../the_data_structure/html/classoomph_1_1DenseLU.html}{\tt {\ttfamily Dense\+LU}}\+: A direct solver, based on the LU decomposition of the Jacobian matrix which is stored as a dense matrix. Given that the Jacobian matrices arising from most problems are sparse, this is likely to be a very inefficient solver. It is mainly used by the derived (and even more inefficient!) solver \href{../../the_data_structure/html/classoomph_1_1FD__LU.html}{\tt {\ttfamily F\+D\+\_\+\+LU}}.~\newline
~\newline

\item \href{../../the_data_structure/html/classoomph_1_1FD__LU.html}{\tt {\ttfamily F\+D\+\_\+\+LU}}\+: Almost certainly the world\textquotesingle{}s most inefficient solver. It computes the Jacobian matrix by finite differencing the global residual vector, without taking any sparsity into account. Mainly used by developers as a last-\/resort sanity check. ~\newline
~\newline

\end{DoxyItemize}
\item {\bfseries Iterative solvers\+:} ~\newline
~\newline

\begin{DoxyItemize}
\item {\ttfamily oomph-\/lib} provides its own implementations of various standard iterative linear solvers. They are derived from the base class \href{../../the_data_structure/html/classoomph_1_1IterativeLinearSolver.html}{\tt {\ttfamily Iterative\+Linear\+Solver}} and are typically templated by the matrix type used store the Jacobian matrix. In most cases you will want to set the template argument {\ttfamily M\+A\+T\+R\+IX} to {\ttfamily C\+R\+Double\+Matrix\+:} ~\newline
~\newline

\begin{DoxyItemize}
\item \href{../../the_data_structure/html/classoomph_1_1GMRES.html}{\tt {\ttfamily G\+M\+R\+ES}}\+: A Krylov subspace solver for symmetric and non-\/symmetric linear systems. The memory usage increases with each iteration but the iteration can be restarted. ~\newline
~\newline

\item \href{../../the_data_structure/html/classoomph_1_1BiCGStab.html}{\tt {\ttfamily Bi\+C\+G\+Stab}}\+: A Krylov subspace method for symmetric and non-\/symmetric linear systems. The memory requirement remains constant throughout the iteration.~\newline
~\newline

\item \href{../../the_data_structure/html/classoomph_1_1CG.html}{\tt {\ttfamily CG}}\+: The classical conjugate gradient method for symmetric positive definite matrices. The memory requirement remains constant throughout the iteration. ~\newline

\item \href{../../the_data_structure/html/classoomph_1_1GS.html}{\tt {\ttfamily GS}}\+: Gauss-\/\+Seidel -- a stationary iterative solver. ~\newline
~\newline

\end{DoxyItemize}
\item {\ttfamily oomph-\/lib} also provides wrappers to third-\/party iterative linear solvers. These tend to provide their own implementations of {\ttfamily G\+M\+R\+ES}, {\ttfamily Bi\+C\+G\+Stab}, {\ttfamily CG}, etc. but are not necessarily derived from {\ttfamily oomph-\/lib\textquotesingle{}s} own \href{../../the_data_structure/html/classoomph_1_1IterativeLinearSolver.html}{\tt {\ttfamily Iterative\+Linear\+Solver}} base class. ~\newline
~\newline

\begin{DoxyItemize}
\item \href{../../the_data_structure/html/classoomph_1_1HypreSolver.html}{\tt {\ttfamily Hypre\+Solver}}\+: A wrapper to the high-\/performance linear solvers/preconditioners from the \href{https://computation.llnl.gov/casc/linear_solvers/sls_hypre.html}{\tt Scalable Linear Solvers Project.} ~\newline
~\newline

\item \href{../../the_data_structure/html/classoomph_1_1TrilinosAztecOOSolver.html}{\tt {\ttfamily Trilinos\+Aztec\+O\+O\+Solver}}\+: A wrapper to the linear solvers from the \href{http://trilinos.sandia.gov/}{\tt Trilinos Project.}~\newline
~\newline

\end{DoxyItemize}
\end{DoxyItemize}
\end{DoxyItemize}
\item {\bfseries Parallel solvers\+:} ~\newline
~\newline

\begin{DoxyItemize}
\item {\bfseries Direct solvers\+:} ~\newline
~\newline

\begin{DoxyItemize}
\item When {\ttfamily oomph-\/lib} is compiled with M\+PI support, its default linear solver \href{../../the_data_structure/html/classoomph_1_1SuperLUSolver.html}{\tt {\ttfamily Super\+L\+U\+Solver}} becomes a wrapper to Demmel, Eistenstat, Gilbert, Li \& Liu\textquotesingle{}s parallel sparse direct solver \href{http://crd.lbl.gov/~xiaoye/SuperLU#superlu_dist}{\tt Super\+L\+U\+\_\+\+D\+I\+ST.} This behaviour can be over-\/ruled with the member function 
\begin{DoxyCode}
SuperLUSolver::set\_solver\_type(...)
\end{DoxyCode}
 whose argument must specify one of the three options listed in the enumeration {\ttfamily Super\+L\+U\+Solver\+::\+Type}. This allows the serial solver \href{http://crd.lbl.gov/~xiaoye/SuperLU}{\tt Super\+LU} to be used even if {\ttfamily oomph-\/lib} is compiled with M\+PI support. ~\newline
~\newline

\item \href{../../the_data_structure/html/classoomph_1_1MumpsSolver.html}{\tt {\ttfamily  Mumps\+Solver }}\+: is a wrapper to the \href{http://graal.ens-lyon.fr/MUMPS/}{\tt M\+U\+M\+PS } multifrontal solver that is available when {\ttfamily oomph-\/lib} is compiled with M\+PI support and support for M\+U\+M\+PS.
\end{DoxyItemize}
\item {\bfseries Iterative solvers\+:} ~\newline
~\newline

\begin{DoxyItemize}
\item \href{../../the_data_structure/html/classoomph_1_1HypreSolver.html}{\tt {\ttfamily Hypre\+Solver}}\+: A wrapper to the high-\/performance linear solvers/preconditioners from the \href{https://computation.llnl.gov/casc/linear_solvers/sls_hypre.html}{\tt Scalable Linear Solvers Project.} ~\newline
~\newline

\item \href{../../the_data_structure/html/classoomph_1_1TrilinosAztecOOSolver.html}{\tt {\ttfamily Trilinos\+Aztec\+O\+O\+Solver}}\+: A wrapper to the linear solvers from the \href{http://trilinos.sandia.gov/}{\tt Trilinos Project.}~\newline
~\newline

\end{DoxyItemize}
\end{DoxyItemize}
\end{DoxyItemize}



 

\hypertarget{index_how_to_change_linear_solver}{}\section{How to change the Linear\+Solver}\label{index_how_to_change_linear_solver}
\hypertarget{index_direct}{}\subsection{Direct solvers}\label{index_direct}
Changing {\ttfamily oomph-\/lib\textquotesingle{}s} linear solver is straightforward. For instance, to change the linear solver to {\ttfamily oomph-\/lib\textquotesingle{}s} {\ttfamily Dense\+LU} solver, simply create an instance of this solver and pass a pointer to it to the {\ttfamily Problem}. This most easily done in the {\ttfamily Problem} constructor\+:

 
\begin{DoxyCodeInclude}
 \textcolor{comment}{// Change solver to DenseLU}
 linear\_solver\_pt()=\textcolor{keyword}{new} DenseLU;

\end{DoxyCodeInclude}


In any subsequent calls to {\ttfamily oomph-\/lib\textquotesingle{}s} Newton solver, {\ttfamily Dense\+LU} will now be used to solve the linear systems arising during the Newton iteration.



 

\hypertarget{index_iterative_linear_solvers}{}\subsection{Iterative linear solvers and preconditioners}\label{index_iterative_linear_solvers}
The specification of an iterative linear solver is just as easy\+: For instance, to specify {\ttfamily oomph-\/lib\textquotesingle{}s} conjugate gradient solver {\ttfamily CG} (storing the Jacobian matrix in compressed row format) as the linear solver, add

 
\begin{DoxyCodeInclude}
 \textcolor{comment}{// Change solver to CG}
 IterativeLinearSolver* solver\_pt=\textcolor{keyword}{new} CG<CRDoubleMatrix>;
 linear\_solver\_pt()=solver\_pt;

\end{DoxyCodeInclude}


to the problem constructor. We note that, by default, {\ttfamily oomph-\/lib\textquotesingle{}s} {\ttfamily Iterative\+Linear\+Solvers} perform the preconditioning using the trivial \char`\"{}identity preconditioner\char`\"{}. Most Krylov subspace solvers perform very poorly without some sort of preconditioning.

Specific preconditioners may be implemented by deriving from the {\ttfamily Preconditioner} base class, by implementing its two pure virtual functions

 
\begin{DoxyCodeInclude}
  \textcolor{comment}{/// \(\backslash\)short Apply the preconditioner. Pure virtual generic interface}
\textcolor{comment}{  /// function. This method should apply the preconditioner operator to the}
\textcolor{comment}{}\textcolor{comment}{  /// vector r and return the vector z.}
\textcolor{comment}{}  \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} preconditioner\_solve(\textcolor{keyword}{const} DoubleVector &r, DoubleVector &z)
  = 0;

\end{DoxyCodeInclude}


and

 
\begin{DoxyCodeInclude}
  \textcolor{comment}{/// \(\backslash\)short Setup the preconditioner. Pure virtual generic interface}
\textcolor{comment}{  /// function.}
\textcolor{comment}{}  \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} setup() = 0;

\end{DoxyCodeInclude}


Note that, by default, {\ttfamily oomph-\/lib\textquotesingle{}s} {\ttfamily Iterative\+Linear\+Solvers} employ left preconditioning.

{\ttfamily oomph-\/lib} provides fully-\/functional implementations of several general-\/purpose preconditioners. For instance, the zero-\/fill-\/in incomplete LU factorisation preconditioner I\+L\+U(0) may be employed by adding the lines

 
\begin{DoxyCodeInclude}
 \textcolor{comment}{// Specify preconditioner}
 solver\_pt->preconditioner\_pt()=\textcolor{keyword}{new} ILUZeroPreconditioner<CRDoubleMatrix>; 

\end{DoxyCodeInclude}


to the {\ttfamily Problem} constructor.

Of particular interest is the availability of an \char`\"{}exact preconditioner\char`\"{} \href{../../the_data_structure/html/classoomph_1_1SuperLUPreconditioner.html}{\tt {\ttfamily Super\+L\+U\+Preconditioner}} whose use guarantees the convergence of any iterative solver within a single iteration -- useful for code development.



 

\hypertarget{index_third_party_iterative_linear_solvers}{}\subsection{Third-\/party iterative linear solvers and preconditioners}\label{index_third_party_iterative_linear_solvers}
{\ttfamily oomph-\/lib} provides wrappers to various third-\/party iterative linear solvers and preconditioners. We stress that these solvers are not necessarily implemented as {\ttfamily oomph-\/lib} {\ttfamily Iterative\+Linear\+Solvers} since their interfaces for the specification of preconditioners, etc may differ from those employed by {\ttfamily oomph-\/lib}. Furthermore, unlike {\ttfamily Super\+L\+U\+Solver} these solvers are not distributed as part of {\ttfamily oomph-\/lib} so you have to build/install them separately before installing {\ttfamily oomph-\/lib} ({\ttfamily oomph-\/lib\textquotesingle{}s} build machinery can do this for you if you wish; see \href{../../the_distribution/html/index.html#external_dist}{\tt installation instructions} for details). Once this is done, they may be used like any other linear solver.



\hypertarget{index_trilinos}{}\subsubsection{Trilinos}\label{index_trilinos}
{\ttfamily oomph-\/lib} provides wrappers to the iterative linear solvers/preconditioners from the \href{http://trilinos.sandia.gov/}{\tt Trilinos Project.} The demo code \href{../../../demo_drivers/linear_solvers/TrilinosSolver_test.cc}{\tt Trilinos\+Solver\+\_\+test.\+cc} demonstrates how use various combinations of solvers/preconditioners. Here is a brief overview\+:

{\bfseries Trilinos solvers}

The wrappers to Trilinos\textquotesingle{} Krylov subspace solvers are implemented as {\ttfamily oomph-\/lib} {\ttfamily Iterative\+Linear\+Solvers}, allowing them to be used via the standard interfaces described above. For instance, to use {\ttfamily oomph-\/lib\textquotesingle{}s} wrapper to {\ttfamily Trilinos\textquotesingle{}} Aztec solver, using {\ttfamily Trilinos\textquotesingle{}} {\ttfamily ML} multilevel preconditioner, set the solvers and preconditioners as usual\+:

 
\begin{DoxyCodeInclude}
  \textcolor{comment}{// Create a Trilinos Solver }
  TrilinosAztecOOSolver* linear\_solver\_pt = \textcolor{keyword}{new} TrilinosAztecOOSolver;
  
  \textcolor{comment}{// Create the Trilinos ML preconditioner}
  TrilinosMLPreconditioner* preconditioner\_pt = \textcolor{keyword}{new} TrilinosMLPreconditioner;

  \textcolor{comment}{// Set the preconditioner pointer}
  linear\_solver\_pt->preconditioner\_pt() = preconditioner\_pt;

  \textcolor{comment}{// Set linear solver}
  problem.linear\_solver\_pt() = linear\_solver\_pt;

\end{DoxyCodeInclude}


The actual Krylov subspace solver used by the {\ttfamily Trilinos} solver is specified by passing an enumerated flag (defined as static member data in the {\ttfamily Trilinos\+Aztec\+O\+O\+Solver} class) to the solver. For instance, {\ttfamily Trilinos\textquotesingle{}} CG, G\+M\+R\+ES and Bi\+C\+G\+Stab solvers are selected with

 
\begin{DoxyCodeInclude}
      linear\_solver\_pt->solver\_type() = TrilinosAztecOOSolver::CG;

\end{DoxyCodeInclude}


or


\begin{DoxyCodeInclude}
      linear\_solver\_pt->solver\_type() = TrilinosAztecOOSolver::GMRES;

\end{DoxyCodeInclude}


or


\begin{DoxyCodeInclude}
      linear\_solver\_pt->solver\_type() = TrilinosAztecOOSolver::BiCGStab;

\end{DoxyCodeInclude}


respectively.

{\bfseries Trilinos preconditioners}

{\ttfamily oomph-\/lib} provides wrappers to {\ttfamily Trilinos\textquotesingle{}} ML and I\+F\+P\+A\+CK preconditioners that allows them to be used as {\ttfamily oomph-\/lib} {\ttfamily Preconditioners} that may be used with {\ttfamily oomph-\/lib\textquotesingle{}s} own {\ttfamily Iterative\+Linear\+Solvers}. Here is an example that shows how to build an instance of {\ttfamily oomph-\/lib\textquotesingle{}s} {\ttfamily G\+M\+R\+ES}, preconditioned with its wrapper to {\ttfamily Trilinos\textquotesingle{}} {\ttfamily I\+F\+P\+A\+CK} preconditioner\+:

 
\begin{DoxyCodeInclude}
   \textcolor{comment}{// Create oomph-lib linear solver}
   IterativeLinearSolver* linear\_solver\_pt=\textcolor{keyword}{new} GMRES<CRDoubleMatrix>;

   \textcolor{comment}{// Create Trilinos IFPACK preconditioner as oomph-lib Preconditioner}
   Preconditioner* preconditioner\_pt=\textcolor{keyword}{new} TrilinosIFPACKPreconditioner;

   \textcolor{comment}{// Pass pointer to preconditioner to oomph-lib IterativeLinearSolver}
   linear\_solver\_pt->preconditioner\_pt()=preconditioner\_pt;

\end{DoxyCodeInclude}




 

\hypertarget{index_hypre}{}\subsubsection{Hypre}\label{index_hypre}
{\ttfamily oomph-\/lib} provides wrappers to the high-\/performance linear solvers/preconditioners from the \href{https://computation.llnl.gov/casc/linear_solvers/sls_hypre.html}{\tt Scalable Linear Solvers Project.} The demo code \href{../../../demo_drivers/linear_solvers/HypreSolver_test.cc}{\tt Hypre\+Solver\+\_\+test.\+cc} demonstrates how use various combinations of solvers/preconditioners. Here is a brief overview\+:

{\bfseries Hypre solvers}

The wrappers to Hypre\textquotesingle{}s Krylov subspace and A\+MG solvers are implemented as {\ttfamily oomph-\/lib} {\ttfamily Linear\+Solvers} (not {\ttfamily Iterative\+Linear\+Solvers!}) so the interfaces for the specification of preconditioners etc. differ from those for {\ttfamily oomph-\/lib\textquotesingle{}s} own {\ttfamily Iterative\+Linear\+Solvers}.

The {\ttfamily Hypre\+Solver} is set like any other {\ttfamily Linear\+Solver\+:} 

 
\begin{DoxyCodeInclude}
 \textcolor{comment}{// Create a new Hypre linear solver}
 HypreSolver* hypre\_linear\_solver\_pt = \textcolor{keyword}{new} HypreSolver;

 \textcolor{comment}{// Set the linear solver for problem}
 problem.linear\_solver\_pt() = hypre\_linear\_solver\_pt;

\end{DoxyCodeInclude}


The actual solver used by the {\ttfamily Hypre\+Solver} is specified by passing an enumerated flag (defined as static member data in the {\ttfamily Hypre\+Solver} class) to the solver. For instance, {\ttfamily Hypre\textquotesingle{}s} A\+MG, CG, G\+M\+R\+ES and Bi\+C\+G\+Stab solvers are selected with

 
\begin{DoxyCodeInclude}
     hypre\_linear\_solver\_pt->hypre\_method() = HypreSolver::BoomerAMG;

\end{DoxyCodeInclude}


or


\begin{DoxyCodeInclude}
     hypre\_linear\_solver\_pt->hypre\_method() = HypreSolver::CG;

\end{DoxyCodeInclude}


or


\begin{DoxyCodeInclude}
     hypre\_linear\_solver\_pt->hypre\_method() = HypreSolver::GMRES;

\end{DoxyCodeInclude}


or


\begin{DoxyCodeInclude}
     hypre\_linear\_solver\_pt->hypre\_method() = HypreSolver::BiCGStab;

\end{DoxyCodeInclude}


respectively.

These Krylov subspace methods may then be preconditioned by {\ttfamily Hypre\textquotesingle{}s} own (internal) preconditioners, again by specifying the method via an enumerated flag. So, to use no preconditioning, or to precondition with {\ttfamily Boomer\+A\+MG} (and A\+M\+G-\/based preconditioner), {\ttfamily Euclid} (an I\+LU preconditioner) or {\ttfamily Para\+Sails} (a sparse approximate inverse preconditioner), set\+:


\begin{DoxyCodeInclude}
       hypre\_linear\_solver\_pt->internal\_preconditioner()=HypreSolver::None;

\end{DoxyCodeInclude}


or


\begin{DoxyCodeInclude}
       hypre\_linear\_solver\_pt->internal\_preconditioner()=HypreSolver::BoomerAMG;

\end{DoxyCodeInclude}


or


\begin{DoxyCodeInclude}
       hypre\_linear\_solver\_pt->internal\_preconditioner()=HypreSolver::Euclid;

\end{DoxyCodeInclude}
 or


\begin{DoxyCodeInclude}
       hypre\_linear\_solver\_pt->internal\_preconditioner()=HypreSolver::ParaSails;

\end{DoxyCodeInclude}


respectively.

{\bfseries Hypre preconditioners}

{\ttfamily oomph-\/lib} provides wrappers to {\ttfamily Hypre\textquotesingle{}s} preconditioners that allows them to be used as {\ttfamily oomph-\/lib} {\ttfamily Preconditioners} that may be used with {\ttfamily oomph-\/lib\textquotesingle{}s} own {\ttfamily Iterative\+Linear\+Solvers}. Here is an example that shows how to build an instance of {\ttfamily oomph-\/lib\textquotesingle{}s} {\ttfamily Bi\+C\+G\+Stab} and to use the {\ttfamily Hypre\+Preconditioner} as the preconditioner\+:

 
\begin{DoxyCodeInclude}
 \textcolor{comment}{// Build and instance of BiCGStab and pass it to the problem}
 oomph\_linear\_solver\_pt = \textcolor{keyword}{new} BiCGStab<CRDoubleMatrix>;

 problem.linear\_solver\_pt() = oomph\_linear\_solver\_pt;

\end{DoxyCodeInclude}


Now we build an instance of a {\ttfamily Hypre\+Preconditioner} 

 
\begin{DoxyCodeInclude}
 \textcolor{comment}{// Create a new Hypre preconditioner}
 HyprePreconditioner* hypre\_preconditioner\_pt = \textcolor{keyword}{new} HyprePreconditioner;

\end{DoxyCodeInclude}


and set it as the {\ttfamily Preconditioner} for {\ttfamily oomph-\/lib\textquotesingle{}s} {\ttfamily Bi\+C\+G\+Stab} solver\+:


\begin{DoxyCodeInclude}
   oomph\_linear\_solver\_pt->preconditioner\_pt()=hypre\_preconditioner\_pt;

\end{DoxyCodeInclude}


The actual preconditioning methodology to be used by the {\ttfamily Hypre\+Preconditioner} is again selected via enumerated flags, i.\+e.


\begin{DoxyCodeInclude}
     hypre\_preconditioner\_pt->hypre\_method() = HyprePreconditioner::BoomerAMG;

\end{DoxyCodeInclude}


or


\begin{DoxyCodeInclude}
     hypre\_preconditioner\_pt->hypre\_method() = HyprePreconditioner::Euclid;

\end{DoxyCodeInclude}


or


\begin{DoxyCodeInclude}
     hypre\_preconditioner\_pt->hypre\_method() = HyprePreconditioner::ParaSails;

\end{DoxyCodeInclude}




 

\hypertarget{index_specific_precond}{}\section{Problem-\/specific preconditioners}\label{index_specific_precond}
In addition to \char`\"{}general-\/purpose\char`\"{} preconditioners like I\+LU, {\ttfamily oomph-\/lib} provides a number of problem-\/specific preconditioners which are typically based on the library\textquotesingle{}s block preconditioning framework. Separate documentation is available for these\+:


\begin{DoxyItemize}
\item We provide a (very!) detailed discussion of {\ttfamily oomph-\/lib\textquotesingle{}s} \href{../../mpi/block_preconditioners/html/index.html}{\tt block preconditioning framework.} ~\newline
~\newline

\item Another tutorial discusses {\ttfamily oomph-\/lib\textquotesingle{}s} \href{../../mpi/distributed_general_purpose_block_preconditioners/html/index.html}{\tt \char`\"{}general purpose\char`\"{} block preconditioners.} ~\newline
~\newline

\item The Navier\+Stokes\+Schur\+Complement\+Preconditioner for Navier-\/\+Stokes problems is described in its \href{../../preconditioners/lsc_navier_stokes/html/index.html}{\tt own tutorial. } ~\newline
~\newline

\item The F\+S\+I\+Preconditioner for monolithically-\/discretised fluid-\/structure interaction problems is described in its \href{../../preconditioners/fsi/html/index.html}{\tt own tutorial} ~\newline
~\newline

\item We provide a \href{../../preconditioners/prescribed_displ_lagr_mult/html/index.html}{\tt preconditioner for large-\/displacement solid mechanics problems in which boundary displacements are prescribed.}~\newline
~\newline

\item The previous preconditioner is mainly used as a subsidiary block preconditioner for the \href{../../preconditioners/pseudo_solid_fsi/html/index.html}{\tt solution of fluid-\/structure interaction problems with (pseudo-\/)solid fluid mesh updates.} ~\newline
~\newline

\end{DoxyItemize}

 

 \hypertarget{index_pdf}{}\section{P\+D\+F file}\label{index_pdf}
A \href{../latex/refman.pdf}{\tt pdf version} of this document is available. \end{document}
