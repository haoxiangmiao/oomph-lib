In this example we consider the solution of the unsteady heat equation in a domain with moving boundaries. We demonstrate that the presence of moving boundaries only requires trivial changes to driver codes for corresponding fixed-\/mesh computations.

\begin{center} \tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*{1}{|X[-1]}|}
\hline
\begin{center} {\bfseries The two-\/dimensional unsteady heat equation with flux boundary conditions in a moving domain.} \end{center}  Solve \[ \sum_{i=1}^2\frac{\partial^2 u}{\partial x_i^2} = \frac{\partial u}{\partial t} + f\left(x_1,x_2,t\right), \ \ \ \ \ \ \ \ \ \ (1) \] in the domain $ D $ , bounded by the coordinate axes and the time-\/dependent ellipse \[ \mathbf{r}_{ellipse}(\xi,t) = \left( \begin{array}{c} \big( a+\hat{a}\sin(2\pi t/\hat{T}) \big) \cos(\xi) \\ \big( b+\hat{b}\sin(2\pi t/\hat{T}) \big) \sin(\xi) \end{array} \right), \ \ \ \ \ \ \ \ \ \ (2) \] subject to Neumann boundary conditions, \[ \left. \frac{\partial u}{\partial n}\right|_{\partial D_{Neumann}}= - \left. \frac{\partial u}{\partial x_2}\right|_{\partial D_{Neumann}}= g_0, \ \ \ \ \ \ \ \ \ \ (3) \] along the horizontal domain boundary $ \partial D_{Neumann} = \{ (x_1,x_2) | x_1 \in [0,1], x_2=0 \} $ , and to Dirichlet boundary conditions, \[ \left. u\right|_{\partial D_{Dirichlet}}=h_0, \ \ \ \ \ \ \ \ \ \ (4) \] elsewhere.  
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{domain}
\doxyfigcaption{Sketch of the time-\/dependent domain and the boundary conditions. }
\end{DoxyImage}
 The initial conditions are given by \[ u(x_1,x_2,t=0)=k_0(x_1,x_2), \ \ \ \ \ \ \ \ \ \ (5) \] where the functions $ f, g_0, \ h_0 $ and $ k_0 $ are given.   \\\cline{1-1}
\end{longtabu}
\end{center} 

We choose the functions $ f, g_0, \ h_0 $ and $ k_0 $ so that \[ u_0(x_1,x_2,t) = \tanh\bigg[ 1-\alpha\bigg( \tan\Phi \big(x_1-\beta\tanh[ \gamma\cos\left(2\pi t\right)]\big)- x_2\bigg)\bigg] \ \ \ \ \ \ \ \ \ \ (6) \] is the exact solution.

The solution represents the \char`\"{}usual\char`\"{} tanh profile, whose steepness is controlled by the parameter $ \alpha $ so that for $ \alpha \gg 1 $ the solution approaches a step. The step is oriented at an angle $ \Phi $ against the $ x_1- $ axis and its position varies periodically. The parameter $ \beta $ controls the amplitude of the step\textquotesingle{}s lateral displacement, while $ \gamma $ determines the rate at which its position changes. For $ \gamma \gg 1 $ , the step remains stationary for most of the period and then translates rapidly parallel to the $ x_1- $ axis, making this a very challenging problem.

The figure below shows a snapshot of the \href{../figures/step_soln.avi}{\tt animated solution}, obtained from the spatially adaptive simulation discussed below, for the parameter values $ \alpha=10, \ \Phi=45^o, \ \beta=-0.3, \ \gamma=5. $

 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{step_soln}
\doxyfigcaption{Snapshot of the solution. }
\end{DoxyImage}


The mesh adaptation in response to the translation of the step can be seen more clearly in this contour plot, taken from \href{../figures/unsteady_heat_contour.avi}{\tt another animation of the solution}.

 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{unsteady_heat_contour}
\doxyfigcaption{Contour plot of the solution. }
\end{DoxyImage}




 

\hypertarget{index_ale}{}\section{Background\+: A\+L\+E methods and the evaluation of time-\/derivatives in moving domains}\label{index_ale}
{\ttfamily oomph-\/lib\textquotesingle{}s} {\ttfamily Unsteady\+Heat\+Equations}, the equation class that forms the basis for the isoparametric {\ttfamily Q\+Unsteady\+Heat\+Elements}, is based on the Arbitrary Lagrangian Eulerian (A\+LE) formulation of the weak form of the governing P\+DE, (1). Within each element, the solution is represented by interpolation between the element\textquotesingle{}s $ N_{node}^{(E)} $ nodal values $ U_j^{(E)}(t) \ (i=1,..., N_{node}^{(E)})$ , i.\+e. \[ u = \sum_{j=1}^{N_{node}^{(E)}} U_j^{(E)}(t) \ \psi_{j}(s_1,s_2), \ \ \ \ \ \ \ \ \ \ (7) \] where $ s_1 $ and $ s_2 $ are the element\textquotesingle{}s two local coordinates. The mapping between the local and global (Eulerian) coordinates is based on the interpolation between the nodal coordinates, \[ x_i(s_1,s_2) = \sum_{j=1}^{N_{node}^{(E)}} X_{ij}^{(E)}(t) \ \psi_{j}(s_1,s_2), \ \ \ \ (i=1,2) \ \ \ \ \ \ (8) \] where $ X_{ij}^{(E)}(t) $ is the i-\/th global (Eulerian) coordinate of node j in the element. In moving-\/domain problems, where the nodal positions vary as function of time, the time-\/derivative of the nodal value, $ dU_j(t)/dt $ , represents the rate-\/of-\/change of $ u $ at the moving node, rather than the time-\/derivative of $ u $ at a fixed Eulerian position, $ \partial u/\partial t, $ the quantity required in the P\+DE, (1).

The rate of change of $ u $ at a moving node, $ dU_j(t)/dt $ , may also be expressed by the material derivative, \[ \left. \frac{D u}{Dt}\right|_{\mbox{\small node} \ j} = \frac{\partial u}{\partial t} + \sum_{i=1}^2 v_{ij} \ \frac{\partial u}{\partial x_i} \] where \[ v_{ij} = \frac{dX_{ij}^{(E)}}{dt} \] is the i-\/th velocity component of node j, often referred to as the \char`\"{}mesh velocity\char`\"{}. The rate of change of $ u $ , experienced at the (fixed) spatial position that coincides with the current position of node j is therefore given by \[ \frac{\partial u}{\partial t} = \frac{d U_j^{(E)}}{dt} - \sum_{i=1}^2 \left( \frac{dX_{ij}^{(E)}}{dt} \ \sum_{k=1}^{N_{node}^{(E)}} U_k^{(E)} \ \frac{\partial \psi_{k}}{\partial x_i} \right) . \] This is the form in which the time-\/derivative in (1) is implemented in {\ttfamily oomph-\/lib\textquotesingle{}s} unsteady heat elements. The mesh velocity is determined automatically, using the {\ttfamily Node\textquotesingle{}s} positional {\ttfamily Time\+Stepper} and the history values of the nodal positions. \mbox{[}By default, the positional {\ttfamily Time\+Stepper} is the same as the {\ttfamily Time\+Stepper} used for the evaluation of the time-\/derivatives of the nodal values; a different one may be assigned with the access function {\ttfamily Node\+::position\+\_\+time\+\_\+stepper\+\_\+pt()}.\mbox{]} This is why it is important to initialise the \char`\"{}previous nodal positions\char`\"{} in computations on fixed meshes, as demonstrated in the \href{../../two_d_unsteady_heat/html/index.html}{\tt exercise in our earlier example\+:} The previous nodal positions are initialised to zero when a {\ttfamily Node} is first created. Therefore, if the previous positions are not overwritten with the actual nodal positions, the positional {\ttfamily Time\+Stepper} would compute non-\/zero mesh velocities, even though the {\ttfamily Nodes} are stationary.

{\ttfamily oomph-\/lib\textquotesingle{}s} unsteady Newton solvers automatically advance the time-\/history of the nodal positions when computing a new timestep. Performing computations on moving meshes is therefore extremely straightforward\+: The only task to be performed by the \char`\"{}user\char`\"{} is to update the nodal positions before a new timestep is taken. This is best done in the function {\ttfamily Problem\+::actions\+\_\+before\+\_\+implicit\+\_\+timestep()}.

The update of the nodal positions may be performed \char`\"{}manually\char`\"{}, by assigning new nodal positions directly, using the function {\ttfamily Node\+::x}(...). However, in most cases, the deformation of the domain will be driven by the motion of its boundaries. We discussed in an \href{../../../poisson/fish_poisson2/html/index.html}{\tt earlier example,} that in {\ttfamily oomph-\/lib} curvilinear, moving boundaries are typically represented by (time-\/dependent) {\ttfamily Geom\+Objects} which define the {\ttfamily Macro\+Element} boundaries of the {\ttfamily Domain} object associated with the {\ttfamily Mesh}. In this case, the update of the nodal positions may be performed by updating the parameters that control the shape of the {\ttfamily Geom\+Object} and calling the {\ttfamily Mesh\textquotesingle{}s} node-\/update function {\ttfamily Mesh\+::node\+\_\+update()}, as illustrated in the \href{../../../poisson/fish_poisson2/html/index.html}{\tt earlier example.}

It is also possible (and, in fact, much easier) to include the time-\/dependence of the domain boundaries into the definition of the {\ttfamily Geom\+Object}, by making its shape, described by {\ttfamily Geom\+Object\+::position}(...), a function of time. In that case, the update of the nodal positions in response to the boundary motion merely requires a call to {\ttfamily Mesh\+::node\+\_\+update()} in {\ttfamily Problem\+::actions\+\_\+before\+\_\+implicit\+\_\+timestep()}. This is the approach we take in the present problem.



 

\hypertarget{index_namespace}{}\section{Global parameters and functions}\label{index_namespace}
As usual, we store the problem parameters in a namespace, {\ttfamily \hyperlink{namespaceTanhSolnForUnsteadyHeat}{Tanh\+Soln\+For\+Unsteady\+Heat}}, in which we also specify the source function, the prescribed flux along the Neumann boundary and the exact solution. The namespace is identical to that used in \href{../../two_d_unsteady_heat/html/index.html}{\tt the fixed domain example.}



 

\hypertarget{index_ellipse}{}\section{Representing the moving curvilinear domain boundary by a time-\/dependent Geom\+Object}\label{index_ellipse}
As discussed above, we will incorporate the time-\/dependence of the moving curvilinear boundary into the specification of the {\ttfamily Geom\+Object} that defines that boundary. For this purpose we represent the elliptical boundary by the {\ttfamily Geom\+Object} {\ttfamily \hyperlink{classMyEllipse}{My\+Ellipse}}. Its constructor stores the geometric parameters (the mean values of the ellipse\textquotesingle{}s half axes, $ a $ and $ b $ , the amplitude of their temporal variations $ \hat{a} $ and $ \hat{b} $ , and the period of the oscillation, $ \hat{T} $ , in its private member data. We also store a pointer to a {\ttfamily Time} object to give the {\ttfamily Geom\+Object} access to the \char`\"{}current\char`\"{} and \char`\"{}previous\char`\"{} values of the \char`\"{}continuous time\char`\"{}. The destructor can remain empty.

 
\begin{DoxyCodeInclude}
\textcolor{comment}{//============start\_of\_MyEllipse===========================================}
\textcolor{comment}{/// \(\backslash\)short Oscillating ellipse}
\textcolor{comment}{}\textcolor{comment}{/// \(\backslash\)f[ x = (a + \(\backslash\)widehat\{a\} \(\backslash\)sin(2\(\backslash\)Pi t/T)) \(\backslash\)cos(\(\backslash\)xi)  \(\backslash\)f]}
\textcolor{comment}{}\textcolor{comment}{/// \(\backslash\)f[ y = (b + \(\backslash\)widehat\{b\} \(\backslash\)sin(2\(\backslash\)Pi t/T)) \(\backslash\)sin(\(\backslash\)xi)  \(\backslash\)f]}
\textcolor{comment}{}\textcolor{comment}{//=========================================================================}
\textcolor{keyword}{class }\hyperlink{classMyEllipse}{MyEllipse} : \textcolor{keyword}{public} GeomObject
\{

\textcolor{keyword}{public}:
\textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Constructor:  Pass half axes, amplitudes of their variation, period}
\textcolor{comment}{ /// of oscillation and pointer to time object.}
\textcolor{comment}{} \hyperlink{classMyEllipse_aaa00984813af171e611e420eb3433653}{MyEllipse}(\textcolor{keyword}{const} \textcolor{keywordtype}{double}& a, \textcolor{keyword}{const} \textcolor{keywordtype}{double}& b, 
           \textcolor{keyword}{const} \textcolor{keywordtype}{double}& a\_hat, \textcolor{keyword}{const} \textcolor{keywordtype}{double}& b\_hat, 
           \textcolor{keyword}{const} \textcolor{keywordtype}{double}& period, Time* time\_pt) : 
  GeomObject(1,2), \hyperlink{classMyEllipse_aa2a0efd0a39f9d4fc307a6ff011682ed}{A}(a), \hyperlink{classMyEllipse_a8f991996b9040fe94b942eab7e51f0af}{B}(b), \hyperlink{classMyEllipse_a653e71cf296cdc86cc595d16f18004dd}{A\_hat}(a\_hat), \hyperlink{classMyEllipse_a39d06488447d80f16b80ed8915edf3e3}{B\_hat}(b\_hat), 
  \hyperlink{classMyEllipse_ab098069ab23bbbd8f30b0da3523dc87f}{T}(period), \hyperlink{classMyEllipse_abc1c4c863a599ce87bdff1abb9971953}{Time\_pt}(time\_pt) \{\}
\textcolor{comment}{}
\textcolor{comment}{ /// Destructor: Empty}
\textcolor{comment}{} \textcolor{keyword}{virtual} \hyperlink{classMyEllipse_ac2f2d3fb269c57fb26b4db6d9a0c7c05}{~MyEllipse}() \{\}

\end{DoxyCodeInclude}


The \char`\"{}steady\char`\"{} version of the {\ttfamily position}(...) function must return the position vector to the point on the {\ttfamily Geom\+Object}, identified by its intrinsic coordinate {\ttfamily xi}, and evaluated at the current value of the continuous time, which we extract from {\ttfamily Time\+::time()}\+: 
\begin{DoxyCodeInclude}
 \textcolor{comment}{/// \(\backslash\)short Current position vector to material point at }
\textcolor{comment}{ /// Lagrangian coordinate xi }
\textcolor{comment}{} \textcolor{keywordtype}{void} position(\textcolor{keyword}{const} Vector<double>& xi, Vector<double>& r)\textcolor{keyword}{ const}
\textcolor{keyword}{  }\{
   \textcolor{comment}{// Get current time:}
   \textcolor{keywordtype}{double} time=Time\_pt->time();

   \textcolor{comment}{// Position vector}
   r[0] = (A+A\_hat*sin(2.0*MathematicalConstants::Pi*time/T))*cos(xi[0]);
   r[1] = (B+B\_hat*sin(2.0*MathematicalConstants::Pi*time/T))*sin(xi[0]);

  \} \textcolor{comment}{// end of position(...)}

\end{DoxyCodeInclude}


The \char`\"{}time-\/dependent\char`\"{} version of the {\ttfamily position}(...) function must return the position vector to the {\ttfamily Geom\+Object}, evaluated at the {\ttfamily t} -\/ th previous timestep. The value of the continuous time at that timestep is available from from {\ttfamily Time\+::time(t)}\+: 
\begin{DoxyCodeInclude}
 \textcolor{comment}{/// \(\backslash\)short Parametrised position on object: r(xi). Evaluated at}
\textcolor{comment}{ /// previous time level. t=0: current time; t>0: previous}
\textcolor{comment}{}\textcolor{comment}{ /// time level.}
\textcolor{comment}{} \textcolor{keywordtype}{void} position(\textcolor{keyword}{const} \textcolor{keywordtype}{unsigned}& t, \textcolor{keyword}{const} Vector<double>& xi,
               Vector<double>& r)\textcolor{keyword}{ const}
\textcolor{keyword}{  }\{
   \textcolor{comment}{// Get current time:}
   \textcolor{keywordtype}{double} time=Time\_pt->time(t);
   
   \textcolor{comment}{// Position vector}
   r[0] = (A+A\_hat*sin(2.0*MathematicalConstants::Pi*time/T))*cos(xi[0]);
   r[1] = (B+B\_hat*sin(2.0*MathematicalConstants::Pi*time/T))*sin(xi[0]);

  \} \textcolor{comment}{// end of position(...)}

\end{DoxyCodeInclude}


We omit the code that defines the private member data.



 

\hypertarget{index_main}{}\section{The main function}\label{index_main}
Since the deformation of the domain and the update of the nodal positions will be handled automatically by adding a call to {\ttfamily Mesh\+::node\+\_\+update()} to {\ttfamily Problem\+::actions\+\_\+before\+\_\+implicit\+\_\+timestep()}, the driver code for this problem is exactly the same as that in the \href{../../two_d_unsteady_heat_adapt/html/index.html}{\tt previous example in a fixed domain. }



 

\hypertarget{index_problem_class}{}\section{The Problem class}\label{index_problem_class}
The {\ttfamily Problem} class and most of its member functions are exactly the same as in the \href{../../two_d_unsteady_heat/html/index.html}{\tt previous example.}



 

\hypertarget{index_constructor}{}\section{The Problem constructor}\label{index_constructor}
The {\ttfamily Problem} constructor is identical to the fixed-\/mesh version in the \href{../../two_d_unsteady_heat/html/index.html}{\tt previous example,} apart from the fact that we use the {\ttfamily \hyperlink{classMyEllipse}{My\+Ellipse}} {\ttfamily Geom\+Object} to define the curvilinear {\ttfamily Mesh} boundary. Here is the relevant code fragment\+:

 
\begin{DoxyCodeInclude}
 \textcolor{comment}{// Setup mesh}
 \textcolor{comment}{//-----------}

 \textcolor{comment}{// Build geometric object that forms the curvilinear domain boundary:}
 \textcolor{comment}{// an oscillating ellipse}

 \textcolor{comment}{// Half axes}
 \textcolor{keywordtype}{double} a=1.0;
 \textcolor{keywordtype}{double} b=1.0;

 \textcolor{comment}{// Variations of half axes}
 \textcolor{keywordtype}{double} a\_hat= 0.1;
 \textcolor{keywordtype}{double} b\_hat=-0.1;

 \textcolor{comment}{// Period of the oscillation}
 \textcolor{keywordtype}{double} period=1.0;

 \textcolor{comment}{// Create GeomObject}
 Boundary\_pt=\textcolor{keyword}{new} \hyperlink{classMyEllipse}{MyEllipse}(a,b,a\_hat,b\_hat,period,Problem::time\_pt()); 

 \textcolor{comment}{// Start and end coordinates of curvilinear domain boundary on ellipse}
 \textcolor{keywordtype}{double} xi\_lo=0.0;
 \textcolor{keywordtype}{double} xi\_hi=MathematicalConstants::Pi/2.0;

 \textcolor{comment}{// Now create the bulk mesh. Separating line between the two }
 \textcolor{comment}{// elements next to the curvilinear boundary is located half-way}
 \textcolor{comment}{// along the boundary.}
 \textcolor{keywordtype}{double} fract\_mid=0.5;
 Bulk\_mesh\_pt = \textcolor{keyword}{new} RefineableQuarterCircleSectorMesh<ELEMENT>(
  Boundary\_pt,xi\_lo,fract\_mid,xi\_hi,time\_stepper\_pt());

\end{DoxyCodeInclude}




 

\hypertarget{index_actions_before_implicit_timestep}{}\section{Actions before timestep}\label{index_actions_before_implicit_timestep}
As discussed above, the addition of a single line to {\ttfamily Problem\+::actions\+\_\+before\+\_\+implicit\+\_\+timestep()} suffices to update the nodal positions in response to the changes in the domain boundary.

 
\begin{DoxyCodeInclude}
\textcolor{comment}{//=========start of actions\_before\_implicit\_timestep===============================}
\textcolor{comment}{/// \(\backslash\)short Actions before timestep: Update the domain shape, then set the }
\textcolor{comment}{}\textcolor{comment}{/// boundary conditions for the current time.}
\textcolor{comment}{}\textcolor{comment}{//========================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT>
\textcolor{keywordtype}{void} \hyperlink{classRefineableUnsteadyHeatProblem_ac754f1313cd6d684c149443beb5bcf9e}{RefineableUnsteadyHeatProblem<ELEMENT>::actions\_before\_implicit\_timestep}
      ()
\{
 \textcolor{comment}{// Update the domain shape}
 Bulk\_mesh\_pt->node\_update();

\end{DoxyCodeInclude}


The rest of this function is identical to the that in the \href{../../two_d_unsteady_heat/html/index.html}{\tt fixed-\/domain version} and updates the nodal values on the Dirichlet boundaries according to the values given by the exact solution.



 

\hypertarget{index_set_init}{}\section{Setting the initial condition}\label{index_set_init}
The only other change to the code occurs in the assignment of the initial conditions. The {\ttfamily Nodes\textquotesingle{}} positional history values are given by the positions at which the {\ttfamily Nodes} would have been at previous timesteps. Similarly, the history values themselves must be computed by evaluating the exact solution at the position at which the {\ttfamily Nodes} would have been at those timesteps.

This is achieved with a few minor changes to the previous version of this function. We loop over the previous timesteps, reconstruct the value of the continuous time at that timestep, and temporarily over-\/write the value of the continuous time stored in {\ttfamily Time\+::time()}. This ensures that the call to {\ttfamily \hyperlink{classMyEllipse_a7b139a2f4564005773c83325f2414e3e}{My\+Ellipse\+::position}}(...) during the node update operation returns the position vector to the domain boundary at that timestep. Following the update of the nodal positions (which moves them into the position they would have occupied at the previous timestep) we copy their positions and the value of the exact solution into the appropriate history values. Here is the relevant code fragment from the {\ttfamily set\+\_\+initial\+\_\+condition()} function\+:


\begin{DoxyCodeInclude}
   \textcolor{comment}{// Loop over current & previous timesteps (in outer loop because}
   \textcolor{comment}{// the mesh also moves!)}
   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} itime=nprev\_steps;itime>=0;itime--)
    \{
     \textcolor{keywordtype}{double} time=prev\_time[itime];
     
     \textcolor{comment}{// Set global time (because this is how the geometric object refers }
     \textcolor{comment}{// to continous time }
     time\_pt()->time()=time;
     
     cout << \textcolor{stringliteral}{"setting IC at time ="} << time << std::endl;
     
     \textcolor{comment}{// Update the mesh for this value of the continuous time}
     \textcolor{comment}{// (The wall object reads the continous time from the same}
     \textcolor{comment}{// global time object)}
     Bulk\_mesh\_pt->node\_update(); 
     
     \textcolor{comment}{// Loop over the nodes to set initial guess everywhere}
     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} jnod=0;jnod<num\_nod;jnod++)
      \{
       \textcolor{comment}{// Get nodal coordinates}
       x[0]=Bulk\_mesh\_pt->node\_pt(jnod)->x(0);
       x[1]=Bulk\_mesh\_pt->node\_pt(jnod)->x(1);
       
       \textcolor{comment}{// Get intial solution}
       \hyperlink{namespaceTanhSolnForUnsteadyHeat_a36857bbdec45f44018772de70558db7d}{TanhSolnForUnsteadyHeat::get\_exact\_u}(time,x,soln);
       
       \textcolor{comment}{// Assign solution}
       Bulk\_mesh\_pt->node\_pt(jnod)->set\_value(itime,0,soln[0]);
       
       \textcolor{comment}{// Loop over coordinate directions}
       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} i=0;i<2;i++)
        \{
         Bulk\_mesh\_pt->node\_pt(jnod)->x(itime,i)=x[i];
        \}
      \} 
    \} \textcolor{comment}{// end of loop over previous timesteps}

\end{DoxyCodeInclude}




 

\hypertarget{index_comm}{}\section{Comments and Exercises}\label{index_comm}
While the spatial adaptivity resolves the rapid spatial variations in the solution, the time-\/integration with a fixed timestep introduces errors during the phases when the solution undergoes rapid temporal variations. The \href{../figures/step_soln.avi}{\tt animations} of the exact and computed solutions show clearly that the computed solution lags behind the exact one during these phases. In the \href{../../two_d_unsteady_heat_2adapt/html/index.html}{\tt next example} we will therefore demonstrate how to combine temporal and spatial adaptivity.



 

\hypertarget{index_sources}{}\section{Source files for this tutorial}\label{index_sources}

\begin{DoxyItemize}
\item The source files for this tutorial are located in the directory\+: \begin{center} \href{../../../../demo_drivers/unsteady_heat/two_d_unsteady_heat_ALE/}{\tt demo\+\_\+drivers/unsteady\+\_\+heat/two\+\_\+d\+\_\+unsteady\+\_\+heat\+\_\+\+A\+L\+E/ } \end{center} 
\item The driver code is\+: \begin{center} \href{../../../../demo_drivers/unsteady_heat/two_d_unsteady_heat_ALE/two_d_unsteady_heat_ALE.cc}{\tt demo\+\_\+drivers/unsteady\+\_\+heat/two\+\_\+d\+\_\+unsteady\+\_\+heat\+\_\+\+A\+L\+E/two\+\_\+d\+\_\+unsteady\+\_\+heat\+\_\+\+A\+L\+E.\+cc } \end{center} 
\end{DoxyItemize}



 

 \hypertarget{index_pdf}{}\section{P\+D\+F file}\label{index_pdf}
A \href{../latex/refman.pdf}{\tt pdf version} of this document is available. \end{document}
