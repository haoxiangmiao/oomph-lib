This example illustrates {\ttfamily oomph-\/lib\textquotesingle{}s} adaptive timestepping capabilities. We consider, yet again, the 2D unsteady heat equation \begin{center} \tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*{1}{|X[-1]}|}
\hline
\begin{center} {\bfseries The two-\/dimensional unsteady heat equation in a square domain.} \end{center}  Solve \[ \sum_{i=1}^2\frac{\partial^2 u}{\partial x_i^2} = \frac{\partial u}{\partial t} + f\left(x_1,x_2,t\right), \ \ \ \ \ \ \ \ \ \ (1) \] in the square domain $ D = \{x_i \in [0,1]; i=1,2 \} $, subject to the Dirichlet boundary conditions \[ \left. u\right|_{\partial D}=g_0 \ \ \ \ \ \ \ \ \ \ (2) \] and initial conditions \[ u(x_1,x_2,t=0)=h_0(x_1,x_2), \ \ \ \ \ \ \ \ \ \ (3) \] where the functions $ g_0$ and $ h_0$ are given.   \\\cline{1-1}
\end{longtabu}
\end{center} 

Here we choose the forcing function and the boundary and initial conditions so that \[ u_0(x_1,x_2,t) = \frac{1}{2} \bigg( 1 + \tanh\big(\gamma \cos(2\pi t)\big)\bigg) \sin\left(K \left( x_1 \cos \Phi + x_2 \sin \Phi\right)\right), \ \ \ \ \ \ \ \ \ \ (4) \] is the exact solution. The solution represents a 1D sin profile with wavenumber $ K $, rotated against the $x_1$-\/axis by an angle $ \Phi $, and modulated by a time-\/periodically varying amplitude. The parameter $ \gamma $ controls the rate at which the amplitude changes. For large values of $ \gamma $, the amplitude remains constant for most of the period but changes rapidly at $ t = \left( 1/4 + i/2 \right), i=0,1,2,... $. To resolve these rapid changes accurately, very small timesteps are required. Conversely, relatively large timesteps could be employed during the phases when the solution remains approximately constant. The problem therefore presents an ideal test case for an adaptive timestepping scheme.

The figure below shows a snapshot from the \href{../figures/unsteady_heat_soln.avi}{\tt animation of the exact and computed solutions,} obtained from a simulation with {\ttfamily oomph-\/lib\textquotesingle{}s} adaptive {\ttfamily B\+D\+F$<$2$>$} timestepper. Since the time interval between subsequent frames in this animation varies, each frame shows a blue line (in the top left corner) whose length is proportional to the elapsed time. The different rate at which the length of the line increases reflects the fact that smaller timesteps are taken when the solution varies rapidly.

 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{unsteady_heat_soln}
\doxyfigcaption{Snapshot from the animation of the exact and computed solutions. }
\end{DoxyImage}


The figure below shows the time trace of the solution and documents the timesteps chosen by the adaptive timestepping scheme. Note how smaller timesteps are chosen when the solution undergoes rapid changes.

 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{trace}
\doxyfigcaption{Upper plot\+: Time evolution of the computed and exact solutions at a control node. Lower plot\+: The timestep dt and the norm of the error. }
\end{DoxyImage}


Most of the driver code for this example is identical to that discussed in the \href{../../two_d_unsteady_heat/html/index.html}{\tt previous example,} therefore we only discuss the modifications required to enable temporal adaptivity\+:
\begin{DoxyItemize}
\item We pass a boolean flag to the constructor of the {\ttfamily B\+D\+F$<$2$>$} timestepper.
\item We define a global error norm for the adaptive timestepper by overloading the (empty) virtual function {\ttfamily Problem\+::global\+\_\+temporal\+\_\+error\+\_\+norm()}.
\item We replace the call to {\ttfamily Problem\+::unsteady\+\_\+newton\+\_\+solve}(...) by a call to {\ttfamily Problem\+::adaptive\+\_\+unsteady\+\_\+newton\+\_\+solve}(...) and specify a target for the temporal error norm.
\end{DoxyItemize}

 

\hypertarget{index_namespace}{}\section{Global parameters and functions}\label{index_namespace}
We store the problem parameters and define the source function and the exact solution in the usual namespace.

 
\begin{DoxyCodeInclude}
\textcolor{comment}{//======start\_of\_ExactSolnForUnsteadyHeat=====================}
\textcolor{comment}{/// Namespace for forced exact solution for UnsteadyHeat equation }
\textcolor{comment}{}\textcolor{comment}{//====================================================================}
\textcolor{keyword}{namespace }\hyperlink{namespaceExactSolnForUnsteadyHeat}{ExactSolnForUnsteadyHeat}
\{
\textcolor{comment}{}
\textcolor{comment}{ /// Factor controlling the rate of change}
\textcolor{comment}{} \textcolor{keywordtype}{double} Gamma=10.0;
\textcolor{comment}{}
\textcolor{comment}{ /// Wavenumber}
\textcolor{comment}{} \textcolor{keywordtype}{double} K=3.0;
\textcolor{comment}{}
\textcolor{comment}{ /// Angle of bump}
\textcolor{comment}{} \textcolor{keywordtype}{double} Phi=1.0; 
 \textcolor{comment}{}
\textcolor{comment}{ /// Exact solution as a Vector}
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{namespaceExactSolnForUnsteadyHeat_a1d5b22857bd2a7825397daf1cf9c89eb}{get\_exact\_u}(\textcolor{keyword}{const} \textcolor{keywordtype}{double}& time, \textcolor{keyword}{const} Vector<double>& x, 
                  Vector<double>& u)
 \{
  \textcolor{keywordtype}{double} zeta=cos(Phi)*x[0]+sin(Phi)*x[1];
  u[0]=sin(K*zeta)*
       0.5*(1.0+tanh(Gamma*cos(2.0*MathematicalConstants::Pi*time)));
 \}
 \textcolor{comment}{}
\textcolor{comment}{ /// Exact solution as a scalar}
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{namespaceExactSolnForUnsteadyHeat_a1d5b22857bd2a7825397daf1cf9c89eb}{get\_exact\_u}(\textcolor{keyword}{const} \textcolor{keywordtype}{double}& time, \textcolor{keyword}{const} Vector<double>& x, \textcolor{keywordtype}{double}& u)
 \{
  \textcolor{keywordtype}{double} zeta=cos(Phi)*x[0]+sin(Phi)*x[1];
  u=sin(K*zeta)*
       0.5*(1.0+tanh(Gamma*cos(2.0*MathematicalConstants::Pi*time)));
 \}
 \textcolor{comment}{}
\textcolor{comment}{ /// Source function to make it an exact solution }
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{namespaceExactSolnForUnsteadyHeat_ab4e853d6368b1fcdbd6205079687455a}{get\_source}(\textcolor{keyword}{const} \textcolor{keywordtype}{double}& time, \textcolor{keyword}{const} Vector<double>& x, \textcolor{keywordtype}{double}& source)
 \{
  source=
   -0.5*sin(K*(cos(Phi)*x[0]+sin(Phi)*x[1]))*K*K*pow(cos(Phi),2.0)*(
    0.1E1+tanh(Gamma*cos(0.2E1*0.3141592653589793E1*time)))-
   0.5*sin(K*(cos(Phi)*x[0]+sin(Phi)*x[1]))*K*K*pow(sin(Phi),2.0)*
   (0.1E1+tanh(Gamma*cos(0.2E1*0.3141592653589793E1*time)))+
   0.1E1*sin(K*(cos(Phi)*x[0]+sin(Phi)*x[1]))*
   (1.0-pow(tanh(Gamma*cos(0.2E1*0.3141592653589793E1*time)),2.0))*
   Gamma*sin(0.2E1*0.3141592653589793E1*time)*0.3141592653589793E1;
 \}

\} \textcolor{comment}{// end of ExactSolnForUnsteadyHeat}

\end{DoxyCodeInclude}




 

\hypertarget{index_main}{}\section{The driver code}\label{index_main}
Temporal adaptivity only requires a few straightforward changes to the time-\/stepping loop. Since the number of timesteps required to reach the end of the simulation is not known a priori, we replace the {\ttfamily for} -\/ loop over the fixed number of timesteps, employed in the \href{../../two_d_unsteady_heat/html/index.html}{\tt non-\/adaptive version of the code,} by a {\ttfamily while} -\/ loop that continues the time-\/integration until $ t \ge t_{max}$.

The adaptive timestepper, {\ttfamily Problem\+::adaptive\+\_\+unsteady\+\_\+newton\+\_\+solve}(...) takes two arguments. The first one is a suggestion for the size of the next timestep; the second specifies the target error The adaptive timestepper automatically adjusts the timestep until the error estimate computed by {\ttfamily Problem\+::global\+\_\+temporal\+\_\+error\+\_\+norm()} is less than that target. If the error estimate for the solution computed with the suggested value of {\ttfamily dt} is too large, {\ttfamily dt} is reduced by a factor of 2 and the solution is recomputed. This process is repeated until
\begin{DoxyItemize}
\item the estimated error has become sufficiently small
\end{DoxyItemize}or
\begin{DoxyItemize}
\item {\ttfamily dt} has been reduced below a threshold.
\end{DoxyItemize}The threshold is stored in the private member data {\ttfamily Problem\+::\+Minimum\+\_\+dt} and is initialised to $ 10^{-12} $. This default can be changed with the access function {\ttfamily Problem\+::minimum\+\_\+dt()}. It is also possible to specify a maximum value for the timestep by overwriting the default value $ 10^{12} $ for the corresponding data member, {\ttfamily Problem\+::\+Maximum\+\_\+dt}, using the function {\ttfamily Problem\+::maximum\+\_\+dt()}.

The adaptive unsteady Newton solver returns a suggestion for the size of the next timestep.

Here is the relevant code fragment from the otherwise unchanged {\ttfamily main} function\+:

 
\begin{DoxyCodeInclude}
 \textcolor{comment}{// Target error for adaptive timestepping}
 \textcolor{keywordtype}{double} epsilon\_t=1.0e-4;

 \textcolor{comment}{// Timestepping loop: Don't know how many steps we're going to take}
 \textcolor{comment}{// in advance}
 \textcolor{keywordflow}{while} (problem.time\_pt()->time()<t\_max)
  \{
  
   \textcolor{comment}{// Take an adaptive timestep -- the input dt is the suggested timestep.}
   \textcolor{comment}{// The adaptive timestepper will adjust dt until the required error}
   \textcolor{comment}{// tolerance is satisfied. The function returns a suggestion}
   \textcolor{comment}{// for the timestep that should be taken for the next step. This}
   \textcolor{comment}{// is either the actual timestep taken this time or a larger}
   \textcolor{comment}{// value if the solution was found to be "too accurate". }
   \textcolor{keywordtype}{double} dt\_next=problem.adaptive\_unsteady\_newton\_solve(dt,epsilon\_t);

   \textcolor{comment}{// Use dt\_next as suggestion for the next timestep}
   dt=dt\_next;
 
   \textcolor{comment}{//Output solution}
   problem.doc\_solution(doc\_info,trace\_file);
   
   \textcolor{comment}{//Increment counter for solutions }
   doc\_info.number()++;

  \} \textcolor{comment}{// end of timestepping loop}

\end{DoxyCodeInclude}


The rest of the main function is identical to that in the \href{../../two_d_unsteady_heat/html/index.html}{\tt previous, non-\/adaptive example.}



 

\hypertarget{index_problem}{}\section{The problem class}\label{index_problem}
The problem class contains a single additional member function

 
\begin{DoxyCodeInclude}
 \textcolor{comment}{/// Global error norm for adaptive time-stepping}
 \textcolor{keywordtype}{double} global\_temporal\_error\_norm();

\end{DoxyCodeInclude}


which we will discuss below.



 

\hypertarget{index_constructor}{}\section{The problem constructor}\label{index_constructor}
The problem constructor is almost identical to that in the \href{../../two_d_unsteady_heat/html/index.html}{\tt previous example.} The only difference is that the boolean flag {\ttfamily true} is passed to the constructor of the {\ttfamily B\+D\+F$<$2$>$} timestepper, which means that a predictor step is computed for each timestep, see \href{#back}{\tt background } for more details.



 

\hypertarget{index_destructor}{}\section{The problem destructor}\label{index_destructor}
The problem destructor is identical to that in the \href{../../two_d_unsteady_heat/html/index.html}{\tt previous example.}



 

\hypertarget{index_before_timestep}{}\section{Actions before timestep}\label{index_before_timestep}
This function is identical to that in the \href{../../two_d_unsteady_heat/html/index.html}{\tt previous example.}



 

\hypertarget{index_IC}{}\section{Set initial condition}\label{index_IC}
This function is identical to that in the \href{../../two_d_unsteady_heat2/html/index.html}{\tt previous example.}



 

\hypertarget{index_doc}{}\section{Post-\/processing}\label{index_doc}
The Problem member function {\ttfamily doc\+\_\+solution}(...) is virtually identical to that in the \href{../../two_d_unsteady_heat2/html/index.html}{\tt previous example.} We merely add the timestep {\ttfamily dt} to the trace file.



 

\hypertarget{index_dump}{}\section{Dumping the solution}\label{index_dump}
This function is identical to that in the \href{../../two_d_unsteady_heat2/html/index.html}{\tt previous example,} indicating that the generic {\ttfamily Problem\+::dump()} function can deal with time-\/dependent simulations.



 

\hypertarget{index_read}{}\section{Reading a solution from disk}\label{index_read}
This function is identical to that in the \href{../../two_d_unsteady_heat2/html/index.html}{\tt previous example, }indicating that the generic {\ttfamily Problem\+::read()} function can deal with time-\/dependent simulations.



 

\hypertarget{index_error}{}\section{Defining the global error norm for the adaptive timestepper}\label{index_error}
\hypertarget{index_back}{}\subsection{Background}\label{index_back}
{\ttfamily oomph-\/lib\textquotesingle{}s} adaptive timesteppers employ a predictor-\/corrector scheme to control the size of the timestep. In these schemes a low-\/order explicit timestepper is used to predict the solution at the next timestep. This prediction is compared to the solution computed with the actual (usually implicit) timestepper itself. The difference between the two predictions is then used to derive an estimate of the error (exploiting the different truncation errors of the two timestepping schemes).

Interfaces to the functions that compute the temporal error estimates are defined as broken virtual function in the {\ttfamily Time\+Stepper} base class. Specific {\ttfamily Time\+Steppers} that allow adaptive timestepping therefore overload the broken virtual function


\begin{DoxyCode}
TimeStepper::temporal\_error\_in\_value(data\_pt,i)
\end{DoxyCode}


which computes an estimate of the error of {\ttfamily i} -\/ th value stored in the {\ttfamily Data} object pointed to by {\ttfamily data\+\_\+pt}. In free-\/boundary problems in which the position of the nodes is an unknown, the corresponding function


\begin{DoxyCode}
TimeStepper::temporal\_error\_in\_position(node\_pt,i)
\end{DoxyCode}


may be used to obtain an estimate of the error in the {\ttfamily i} -\/ th nodal coordinate of the {\ttfamily Node} pointed to by {\ttfamily node\+\_\+pt}.

These individual error estimates must be combined into a problem-\/specific, scalar error norm, ${\cal E}$ say, which forms the basis of the adaptive adjustment of the timestep in {\ttfamily Problem\+::adaptive\+\_\+unsteady\+\_\+newton\+\_\+solve}(...).\hypertarget{index_impl}{}\subsection{Implementation}\label{index_impl}
In the present problem, we choose the R\+MS of the errors $ e_j \ (j=1,...,N_{node})$ at the nodes as the global error norm \[ {\cal E} = \sqrt{ \frac{1}{N_{node}} \sum_{j=1}^{N_{node}} e_j^2 }. \] This may be implemented in a few lines of code\+:

 
\begin{DoxyCodeInclude}
\textcolor{comment}{//========start\_of\_global\_temporal\_error\_norm==============================}
\textcolor{comment}{/// Global error norm for adaptive timestepping: RMS error, based on}
\textcolor{comment}{}\textcolor{comment}{/// difference between predicted and actual value at all nodes.}
\textcolor{comment}{}\textcolor{comment}{//=========================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT>
\textcolor{keywordtype}{double} \hyperlink{classUnsteadyHeatProblem_a888e25dd97e89d31e485cb188721dbe1}{UnsteadyHeatProblem<ELEMENT>::global\_temporal\_error\_norm}
      ()
\{
 \textcolor{keywordtype}{double} global\_error = 0.0;
   
 \textcolor{comment}{//Find out how many nodes there are in the problem}
 \textcolor{keywordtype}{unsigned} n\_node = mesh\_pt()->nnode();

 \textcolor{comment}{//Loop over the nodes and calculate the estimated error in the values}
 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} i=0;i<n\_node;i++)
  \{
   \textcolor{comment}{// Get error in solution: Difference between predicted and actual}
   \textcolor{comment}{// value for nodal value 0}
   \textcolor{keywordtype}{double} error = mesh\_pt()->node\_pt(i)->time\_stepper\_pt()->
    temporal\_error\_in\_value(mesh\_pt()->node\_pt(i),0);
   
   \textcolor{comment}{//Add the square of the individual error to the global error}
   global\_error += error*error;
  \}
    
 \textcolor{comment}{// Divide by the number of nodes}
 global\_error /= double(n\_node);

 \textcolor{comment}{// Return square root...}
 \textcolor{keywordflow}{return} sqrt(global\_error);

\} \textcolor{comment}{// end of global\_temporal\_error\_norm}

\end{DoxyCodeInclude}




 

\hypertarget{index_comments}{}\section{Comments and Exercises}\label{index_comments}
As demonstrated above, enabling temporal adaptivity for a given problem is extremely straightforward as it only requires the implementation of the problem-\/specific function {\ttfamily Problem\+::global\+\_\+temporal\+\_\+error\+\_\+norm()}. In most cases, the R\+MS of the nodal errors (or some suitable generalisation for vector-\/valued problems) is an obvious choice. In free-\/boundary problems, the R\+MS of the error estimate for the nodal positions is often a useful error measure.



\hypertarget{index_norm}{}\subsection{How to choose the target for the temporal error norm}\label{index_norm}
Having decided on an error norm, how does one choose the target for the error norm? The answer is the same as in a simulation with a fixed timestep\+: Trial and error, followed by careful convergence tests. We usually employ the following strategy\+:
\begin{DoxyItemize}
\item Implement the function {\ttfamily Problem\+::global\+\_\+temporal\+\_\+error\+\_\+norm()} and perform an initial computation with a fixed timestep, choosing its size heuristically, exploiting prior knowledge that we (usually!) have about our problem. For instance, if we expect a periodic solution with an approximate period $ T $, we may start with a fixed timestep $ dt = T/20,$ say. The computed results are likely to be very inaccurate but the time-\/trace will usually reveal the characteristic features of the solution and thus identify phases during which the solution varies rapidly.
\item Now repeat the simulation with a smaller time-\/step, $ dt = T/40,$ say, and check if any new features develop in the time-\/trace. If the time-\/trace appears to be robust, monitor the temporal error norm, e.\+g. by including the output of {\ttfamily Problem\+::global\+\_\+temporal\+\_\+error\+\_\+norm()} into the trace file.
\item Use the maximum of the temporal error norm observed during the simulation with the fixed timestep as the target in a first simulation with temporal adaptivity. The timestepper should now increase the size of the timestep in regions where the error estimate was small.
\item Now repeat the simulation with smaller and smaller target errors until further reductions do not lead to further changes in the computed results.
\end{DoxyItemize}\hypertarget{index_ex}{}\subsubsection{Exercise\+:}\label{index_ex}
Employ the above procedure to determine the target error $ \hat{\cal E}$ required for the computed solution to be graphically indistinguishable from that obtained with a target error of $ \hat{\cal E}/2$.



\hypertarget{index_restarts}{}\subsection{Restarting from a simulation with temporal adaptivity}\label{index_restarts}
We mentioned above that the data recorded/read by the generic {\ttfamily Problem\+::dump}(...) and {\ttfamily Problem\+::read}(...) functions is sufficient to restart a temporally adaptive simulations as the functions record the history values and the history of previous timesteps. Here is an illustration of a simulation that was started from the restart file produced at $ t=0.175$ in the original run. The solution computed in the restarted run follows that obtained in the original simulation but it does not employ exactly the same timesteps.

 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{restart_trace}
\doxyfigcaption{Time-\/trace of the solution and the timestep chosen by the adaptive timestepper in the original (green) and restarted (red) simulation. }
\end{DoxyImage}
\hypertarget{index_ex}{}\subsubsection{Exercise\+:}\label{index_ex}
Explain why the restarted simulation uses slightly different timesteps and modify the {\ttfamily dump\+\_\+it}(...) and {\ttfamily restart}(...) functions to solve this problem. \mbox{[}{\bfseries Hints\+:} {\bfseries  (i) } Recall that the adaptive timestepper returns a suggestion for the next timestep. This is not recorded in the restart data! {\bfseries  (ii) } If you can\textquotesingle{}t solve the problem, have a look at the \href{../../two_d_unsteady_heat_2adapt/html/index.html}{\tt discussion of {\ttfamily oomph-\/lib\textquotesingle{}s} doubly-\/adaptive unsteady Newton solver} where an improved dump/restart procedure is implemented.\mbox{]}



 

\hypertarget{index_sources}{}\section{Source files for this tutorial}\label{index_sources}

\begin{DoxyItemize}
\item The source files for this tutorial are located in the directory\+: \begin{center} \href{../../../../demo_drivers/unsteady_heat/two_d_unsteady_heat_t_adapt/}{\tt demo\+\_\+drivers/unsteady\+\_\+heat/two\+\_\+d\+\_\+unsteady\+\_\+heat\+\_\+t\+\_\+adapt/ } \end{center} 
\item The driver code is\+: \begin{center} \href{../../../../demo_drivers/unsteady_heat/two_d_unsteady_heat_t_adapt/two_d_unsteady_heat_t_adapt.cc}{\tt demo\+\_\+drivers/unsteady\+\_\+heat/two\+\_\+d\+\_\+unsteady\+\_\+heat\+\_\+t\+\_\+adapt/two\+\_\+d\+\_\+unsteady\+\_\+heat\+\_\+t\+\_\+adapt.\+cc } \end{center} 
\end{DoxyItemize}

 

 \hypertarget{index_pdf}{}\section{P\+D\+F file}\label{index_pdf}
A \href{../latex/refman.pdf}{\tt pdf version} of this document is available. \end{document}
