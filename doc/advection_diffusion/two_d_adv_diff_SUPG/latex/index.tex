In this example we discuss the S\+U\+P\+G-\/stabilised solution of the 2D advection-\/diffusion problem

\begin{center} \tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*{1}{|X[-1]}|}
\hline
\begin{center} {\bfseries Two-\/dimensional advection-\/diffusion problem in a rectangular domain} \end{center}  Solve \[ \mbox{Pe}\ \sum_{i=1}^2 w_i \left(x_1,x_2\right) \frac{\partial u}{\partial x_i} = \sum_{i=1}^2 \frac{\partial^2u}{\partial x_i^2} + f(x_1,x_2), \ \ \ \ \ \ \ \ \ \ (1) \] in the rectangular domain $D =\left\{ (x_1,x_2) \in [0,1] \times [0,2]\right\}$, with Dirichlet boundary conditions \[ \left. u\right|_{\partial D}=u_0, \ \ \ \ \ \ \ \ \ \ (2) \]

where the {\itshape Peclet} {\itshape number}, $ \mbox{Pe} $ the boundary values, $ u_0$, the source function $ f(x_1,x_2),$ and the components of the \char`\"{}wind\char`\"{} $ w_i(x_1,x_2) \ (i=1,2)$ are given.   \\\cline{1-1}
\end{longtabu}
\end{center} 

We set $ f(x_1,x_2)=0$ and assign the boundary conditions such that \[ u_0(x_1,x_2) = \tanh(1-\alpha(x_1 \tan\Phi - x_2)), \ \ \ \ \ \ \ \ \ (3) \] For large values of $ \alpha, $ this boundary data approaches a step, oriented at an angle $\Phi$ against the $x_1-$axis.

In the computations we will impose the \char`\"{}wind\char`\"{} \[ \mathbf{w}\left(x_1,x_2 \right) = \left( \begin{array}{c} \sin(6x_2) \\ \cos(6x_1) \end{array} \right), \ \ \ \ \ \ \ \ \ (4) \] illustrated in this vector plot\+:

 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{wind}
\doxyfigcaption{Plot of the wind. }
\end{DoxyImage}


The figures below show plots of the solution for $\Phi=45^\circ, \ \alpha=50 $ and a Peclet number of $ Pe = 200$, with and without S\+U\+PG stabilisation. The wire-\/mesh plot shows the solution computed on a 10x10 mesh, the shaded surface represents the solution obtained from an unstabilised solution on a 150x150 mesh. Note how S\+U\+PG stabilisation \char`\"{}suppresses the wiggles\char`\"{} on the relatively coarse mesh.

 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{stab}
\doxyfigcaption{Plot of the S\+U\+P\+G-\/stabilised solution at different levels of mesh refinement. }
\end{DoxyImage}


 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{unstab}
\doxyfigcaption{Plot of the unstabilised solution at different levels of mesh refinement. }
\end{DoxyImage}




 

\hypertarget{index_main}{}\section{The driver code}\label{index_main}
Overall, the structure of the driver code is very similar to that used for the \href{../../../advection_diffusion/two_d_adv_diff_adapt/html/index.html}{\tt problem without stabilisation}.\hypertarget{index_todo}{}\subsection{To be written\+:}\label{index_todo}

\begin{DoxyItemize}
\item Discuss S\+U\+PG theory.
\item Implementation and the role of basis, shape and test functions (our equations are isoparametric)
\end{DoxyItemize}Until we get around to completing this example, here\textquotesingle{}s the driver code. Fairly self-\/explanatory, isn\textquotesingle{}t it?


\begin{DoxyCodeInclude}
\textcolor{comment}{//LIC// ====================================================================}
\textcolor{comment}{//LIC// This file forms part of oomph-lib, the object-oriented, }
\textcolor{comment}{//LIC// multi-physics finite-element library, available }
\textcolor{comment}{//LIC// at http://www.oomph-lib.org.}
\textcolor{comment}{//LIC// }
\textcolor{comment}{//LIC//    Version 1.0; svn revision $LastChangedRevision$}
\textcolor{comment}{//LIC//}
\textcolor{comment}{//LIC// $LastChangedDate$}
\textcolor{comment}{//LIC// }
\textcolor{comment}{//LIC// Copyright (C) 2006-2016 Matthias Heil and Andrew Hazel}
\textcolor{comment}{//LIC// }
\textcolor{comment}{//LIC// This library is free software; you can redistribute it and/or}
\textcolor{comment}{//LIC// modify it under the terms of the GNU Lesser General Public}
\textcolor{comment}{//LIC// License as published by the Free Software Foundation; either}
\textcolor{comment}{//LIC// version 2.1 of the License, or (at your option) any later version.}
\textcolor{comment}{//LIC// }
\textcolor{comment}{//LIC// This library is distributed in the hope that it will be useful,}
\textcolor{comment}{//LIC// but WITHOUT ANY WARRANTY; without even the implied warranty of}
\textcolor{comment}{//LIC// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU}
\textcolor{comment}{//LIC// Lesser General Public License for more details.}
\textcolor{comment}{//LIC// }
\textcolor{comment}{//LIC// You should have received a copy of the GNU Lesser General Public}
\textcolor{comment}{//LIC// License along with this library; if not, write to the Free Software}
\textcolor{comment}{//LIC// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA}
\textcolor{comment}{//LIC// 02110-1301  USA.}
\textcolor{comment}{//LIC// }
\textcolor{comment}{//LIC// The authors may be contacted at oomph-lib@maths.man.ac.uk.}
\textcolor{comment}{//LIC// }
\textcolor{comment}{//LIC//====================================================================}
\textcolor{comment}{//Driver for a simple 2D adv diff problem with SUPG stabilisation}

\textcolor{comment}{//Generic routines}
\textcolor{preprocessor}{#include "generic.h"}

\textcolor{comment}{// The Poisson equations}
\textcolor{preprocessor}{#include "advection\_diffusion.h"}

\textcolor{comment}{// The mesh }
\textcolor{preprocessor}{#include "meshes/rectangular\_quadmesh.h"}

\textcolor{keyword}{using namespace }\hyperlink{namespacestd}{std};

\textcolor{keyword}{using namespace }\hyperlink{namespaceoomph}{oomph};


 
\textcolor{comment}{//======start\_of\_namespace============================================}\textcolor{comment}{}
\textcolor{comment}{/// Namespace for global parameters: Unforced problem with}
\textcolor{comment}{/// boundary values corresponding to a steep tanh step profile}
\textcolor{comment}{/// oriented at 45 degrees across the domain.}
\textcolor{comment}{}\textcolor{comment}{//====================================================================}
\textcolor{keyword}{namespace }\hyperlink{namespaceGlobalPhysicalParameters}{GlobalPhysicalParameters}
\{
\textcolor{comment}{}
\textcolor{comment}{ /// Peclet number}
\textcolor{comment}{} \textcolor{keywordtype}{double} Peclet=200.0;
\textcolor{comment}{}
\textcolor{comment}{ /// Parameter for steepness of step in boundary values}
\textcolor{comment}{} \textcolor{keywordtype}{double} Alpha=50.0;
\textcolor{comment}{}
\textcolor{comment}{ /// Parameter for angle of step in boundary values: 45 degrees}
\textcolor{comment}{} \textcolor{keywordtype}{double} TanPhi=1.0;
\textcolor{comment}{}
\textcolor{comment}{ /// Some "solution" for assignment of boundary values}
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{namespaceGlobalPhysicalParameters_a6e1db5726436a705e9d400fedf914cef}{get\_boundary\_values}(\textcolor{keyword}{const} Vector<double>& x, Vector<double>& u)
 \{
  u[0]=tanh(1.0-Alpha*(TanPhi*x[0]-x[1]));
 \}
\textcolor{comment}{}
\textcolor{comment}{ /// Zero source function}
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{namespaceGlobalPhysicalParameters_aa84986d4d50cb043cc8fced56feab45f}{source\_function}(\textcolor{keyword}{const} Vector<double>& x\_vect, \textcolor{keywordtype}{double}& source)
 \{
  source=0.0;
 \}
\textcolor{comment}{}
\textcolor{comment}{ /// Wind}
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{namespaceGlobalPhysicalParameters_a3a17e62bc0096244627f5f1a7f53c859}{wind\_function}(\textcolor{keyword}{const} Vector<double>& x, Vector<double>& wind)
 \{
  wind[0]=sin(6.0*x[1]);
  wind[1]=cos(6.0*x[0]);
 \}

 
\} \textcolor{comment}{// end of namespace}
\textcolor{comment}{}
\textcolor{comment}{//////////////////////////////////////////////////////////////////////}
\textcolor{comment}{//////////////////////////////////////////////////////////////////////}
\textcolor{comment}{//////////////////////////////////////////////////////////////////////}
\textcolor{comment}{}

\textcolor{comment}{//====== start\_of\_problem\_class=======================================}\textcolor{comment}{}
\textcolor{comment}{/// 2D AdvectionDiffusion problem on rectangular domain, discretised }
\textcolor{comment}{/// with refineable 2D QAdvectionDiffusion elements. The specific type}
\textcolor{comment}{/// of element is specified via the template parameter.}
\textcolor{comment}{}\textcolor{comment}{//====================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT> 
\textcolor{keyword}{class }\hyperlink{classSUPGAdvectionDiffusionProblem}{SUPGAdvectionDiffusionProblem} : \textcolor{keyword}{public} Problem
\{

\textcolor{keyword}{public}:
\textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Constructor: Pass pointer to source and wind functions, and}
\textcolor{comment}{ /// flag to indicate if stabilisation is to be used.}
\textcolor{comment}{} \hyperlink{classSUPGAdvectionDiffusionProblem}{SUPGAdvectionDiffusionProblem}(
  AdvectionDiffusionEquations<2>::AdvectionDiffusionSourceFctPt source\_fct\_pt,
  AdvectionDiffusionEquations<2>::AdvectionDiffusionWindFctPt wind\_fct\_pt,
  \textcolor{keyword}{const} \textcolor{keywordtype}{bool}& use\_stabilisation);
\textcolor{comment}{}
\textcolor{comment}{ /// Destructor. Empty}
\textcolor{comment}{} ~\hyperlink{classSUPGAdvectionDiffusionProblem}{SUPGAdvectionDiffusionProblem}()\{\}
\textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Update the problem specs before solve: Reset boundary conditions}
\textcolor{comment}{ /// to the values from the tanh solution and compute stabilisation}
\textcolor{comment}{ /// parameter.}
\textcolor{comment}{} \textcolor{keywordtype}{void} actions\_before\_newton\_solve();
\textcolor{comment}{}
\textcolor{comment}{ /// Update the problem after solve (empty)}
\textcolor{comment}{} \textcolor{keywordtype}{void} actions\_after\_newton\_solve()\{\}
\textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Doc the solution.}
\textcolor{comment}{} \textcolor{keywordtype}{void} doc\_solution();
\textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Overloaded version of the problem's access function to }
\textcolor{comment}{ /// the mesh. Recasts the pointer to the base Mesh object to }
\textcolor{comment}{ /// the actual mesh type.}
\textcolor{comment}{} RectangularQuadMesh<ELEMENT>* mesh\_pt() 
  \{
   \textcolor{keywordflow}{return} \textcolor{keyword}{dynamic\_cast<}RectangularQuadMesh<ELEMENT>*\textcolor{keyword}{>}(
    Problem::mesh\_pt());
  \}

\textcolor{keyword}{private}:
\textcolor{comment}{}
\textcolor{comment}{ /// DocInfo object}
\textcolor{comment}{} DocInfo Doc\_info;
\textcolor{comment}{}
\textcolor{comment}{ /// Pointer to source function}
\textcolor{comment}{} AdvectionDiffusionEquations<2>::AdvectionDiffusionSourceFctPt Source\_fct\_pt;
\textcolor{comment}{}
\textcolor{comment}{ /// Pointer to wind function}
\textcolor{comment}{} AdvectionDiffusionEquations<2>::AdvectionDiffusionWindFctPt Wind\_fct\_pt;
\textcolor{comment}{}
\textcolor{comment}{ /// Flag to indicate if stabilisation is to be used}
\textcolor{comment}{} \textcolor{keywordtype}{bool} Use\_stabilisation;

\}; \textcolor{comment}{// end of problem class}



\textcolor{comment}{//=====start\_of\_constructor===============================================}\textcolor{comment}{}
\textcolor{comment}{/// \(\backslash\)short Constructor for AdvectionDiffusion problem: Pass pointer to }
\textcolor{comment}{/// source function and wind functions and flag to indicate }
\textcolor{comment}{/// if stabilisation is to be used.}
\textcolor{comment}{}\textcolor{comment}{//========================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT>
\hyperlink{classSUPGAdvectionDiffusionProblem_a95aa4192c1b42327b12cdbb75295d192}{SUPGAdvectionDiffusionProblem<ELEMENT>::SUPGAdvectionDiffusionProblem}
      (
 AdvectionDiffusionEquations<2>::AdvectionDiffusionSourceFctPt source\_fct\_pt,
 AdvectionDiffusionEquations<2>::AdvectionDiffusionWindFctPt wind\_fct\_pt,
 \textcolor{keyword}{const} \textcolor{keywordtype}{bool}& use\_stabilisation)
 :  Source\_fct\_pt(source\_fct\_pt), Wind\_fct\_pt(wind\_fct\_pt), 
    Use\_stabilisation(use\_stabilisation)
\{ 

 \textcolor{comment}{// Set output directory}
 \textcolor{keywordflow}{if} (use\_stabilisation)
  \{
   Doc\_info.set\_directory(\textcolor{stringliteral}{"RESLT\_stabilised"});
  \}
 \textcolor{keywordflow}{else}
  \{
   Doc\_info.set\_directory(\textcolor{stringliteral}{"RESLT\_unstabilised"});
  \}

 \textcolor{comment}{// Setup mesh}

 \textcolor{comment}{// # of elements in x-direction}
 \textcolor{keywordtype}{unsigned} n\_x=40;

 \textcolor{comment}{// # of elements in y-direction}
 \textcolor{keywordtype}{unsigned} n\_y=40;

 \textcolor{comment}{// Domain length in x-direction}
 \textcolor{keywordtype}{double} l\_x=1.0;

 \textcolor{comment}{// Domain length in y-direction}
 \textcolor{keywordtype}{double} l\_y=2.0;

 \textcolor{comment}{// Build and assign mesh}
 Problem::mesh\_pt() = 
  \textcolor{keyword}{new} RectangularQuadMesh<ELEMENT>(n\_x,n\_y,l\_x,l\_y);

  
 \textcolor{comment}{// Set the boundary conditions for this problem: All nodes are}
 \textcolor{comment}{// free by default -- only need to pin the ones that have Dirichlet }
 \textcolor{comment}{// conditions here}
 \textcolor{keywordtype}{unsigned} num\_bound = mesh\_pt()->nboundary();
 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} ibound=0;ibound<num\_bound;ibound++)
  \{
   \textcolor{keywordtype}{unsigned} num\_nod= mesh\_pt()->nboundary\_node(ibound);
   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} inod=0;inod<num\_nod;inod++)
    \{
     mesh\_pt()->boundary\_node\_pt(ibound,inod)->pin(0); 
    \}
  \} \textcolor{comment}{// end loop over boundaries}
 
 \textcolor{comment}{// Complete the build of all elements so they are fully functional }

 \textcolor{comment}{// Loop over the elements to set up element-specific }
 \textcolor{comment}{// things that cannot be handled by the (argument-free!) ELEMENT }
 \textcolor{comment}{// constructor: Pass pointer to source function}
 \textcolor{keywordtype}{unsigned} n\_element = mesh\_pt()->nelement();
 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} i=0;i<n\_element;i++)
  \{
   \textcolor{comment}{// Upcast from GeneralsedElement to the present element}
   ELEMENT *el\_pt = \textcolor{keyword}{dynamic\_cast<}ELEMENT*\textcolor{keyword}{>}(mesh\_pt()->element\_pt(i));

   \textcolor{comment}{//Set the source function pointer}
   el\_pt->source\_fct\_pt() = Source\_fct\_pt;

   \textcolor{comment}{//Set the wind function pointer}
   el\_pt->wind\_fct\_pt() = Wind\_fct\_pt;

   \textcolor{comment}{// Set the Peclet number}
   el\_pt->pe\_pt() = &\hyperlink{namespaceGlobalPhysicalParameters_ab7011a8f93f2cbd3d45af00151aee3b2}{GlobalPhysicalParameters::Peclet};
  \}

 \textcolor{comment}{// Setup equation numbering scheme}
 cout <<\textcolor{stringliteral}{"Number of equations: "} << assign\_eqn\_numbers() << std::endl; 

\} \textcolor{comment}{// end of constructor}


\textcolor{comment}{//========================================start\_of\_actions\_before\_newton\_solve===}\textcolor{comment}{}
\textcolor{comment}{/// Update the problem specs before solve: (Re-)set boundary conditions}
\textcolor{comment}{}\textcolor{comment}{//========================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT>
\textcolor{keywordtype}{void} \hyperlink{classSUPGAdvectionDiffusionProblem_affa45863033de517e1fba088aaae7eb5}{SUPGAdvectionDiffusionProblem<ELEMENT>::actions\_before\_newton\_solve}
      ()
\{
 \textcolor{comment}{// How many boundaries are there?}
 \textcolor{keywordtype}{unsigned} num\_bound = mesh\_pt()->nboundary();
 
 \textcolor{comment}{//Loop over the boundaries}
 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} ibound=0;ibound<num\_bound;ibound++)
  \{
   \textcolor{comment}{// How many nodes are there on this boundary?}
   \textcolor{keywordtype}{unsigned} num\_nod=mesh\_pt()->nboundary\_node(ibound);

   \textcolor{comment}{// Loop over the nodes on boundary}
   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} inod=0;inod<num\_nod;inod++)
    \{
     \textcolor{comment}{// Get pointer to node}
     Node* nod\_pt=mesh\_pt()->boundary\_node\_pt(ibound,inod);

     \textcolor{comment}{// Extract nodal coordinates from node:}
     Vector<double> x(2);
     x[0]=nod\_pt->x(0);
     x[1]=nod\_pt->x(1);

     \textcolor{comment}{// Get boundary value}
     Vector<double> u(1);
     \hyperlink{namespaceGlobalPhysicalParameters_a6e1db5726436a705e9d400fedf914cef}{GlobalPhysicalParameters::get\_boundary\_values}(x,u);

     \textcolor{comment}{// Assign the value to the one (and only) nodal value at this node}
     nod\_pt->set\_value(0,u[0]);
    \}
  \} 

 \textcolor{comment}{// Now loop over all elements and set the stabilisation parameter}
 \textcolor{keywordtype}{unsigned} n\_element = mesh\_pt()->nelement();
 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} i=0;i<n\_element;i++)
  \{
   \textcolor{comment}{// Upcast from GeneralsedElement to the present element}
   ELEMENT *el\_pt = \textcolor{keyword}{dynamic\_cast<}ELEMENT*\textcolor{keyword}{>}(mesh\_pt()->element\_pt(i));
   

   \textcolor{comment}{// Use stabilisation?}
   \textcolor{keywordflow}{if} (Use\_stabilisation)
    \{
     \textcolor{comment}{//Compute stabilisation parameter}
     el\_pt->compute\_stabilisation\_parameter();
    \}
   \textcolor{keywordflow}{else}
    \{
     \textcolor{comment}{//Compute stabilisation parameter}
     el\_pt->switch\_off\_stabilisation();
    \}

  \}

\}  \textcolor{comment}{// end of actions before solve}



\textcolor{comment}{//===============start\_of\_doc=============================================}\textcolor{comment}{}
\textcolor{comment}{/// Doc the solution}
\textcolor{comment}{}\textcolor{comment}{//========================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT>
\textcolor{keywordtype}{void} \hyperlink{classSUPGAdvectionDiffusionProblem_a3133ba26f0917f5d210d69ea0ddcb1fe}{SUPGAdvectionDiffusionProblem<ELEMENT>::doc\_solution}
      ()
\{ 

 ofstream some\_file;
 \textcolor{keywordtype}{char} filename[100];

 \textcolor{comment}{// Number of plot points: npts x npts}
 \textcolor{keywordtype}{unsigned} npts=5;

 \textcolor{comment}{// Output solution }
 \textcolor{comment}{//-----------------}
 sprintf(filename,\textcolor{stringliteral}{"%s/soln%i.dat"},Doc\_info.directory().c\_str(),
         Doc\_info.number());
 some\_file.open(filename);
 mesh\_pt()->output(some\_file,npts);
 some\_file.close();

\} \textcolor{comment}{// end of doc}


\textcolor{comment}{//===== start\_of\_main=====================================================}\textcolor{comment}{}
\textcolor{comment}{/// Driver code for 2D AdvectionDiffusion problem}
\textcolor{comment}{}\textcolor{comment}{//========================================================================}
\textcolor{keywordtype}{int} \hyperlink{two__d__adv__diff__SUPG_8cc_ae66f6b31b5ad750f1fe042a706a4e3d4}{main}()
\{

 \textcolor{comment}{//Set up the problem with stabilisation}
 \{
  \textcolor{keywordtype}{bool} use\_stabilisation=\textcolor{keyword}{true};
  
  \textcolor{comment}{// Create the problem with 2D nine-node elements from the}
  \textcolor{comment}{// QAdvectionDiffusionElement family. Pass pointer to }
  \textcolor{comment}{// source and wind function. }
  \hyperlink{classSUPGAdvectionDiffusionProblem}{SUPGAdvectionDiffusionProblem<QSUPGAdvectionDiffusionElement<2,3>}
       > 
   problem(&\hyperlink{namespaceGlobalPhysicalParameters_aa84986d4d50cb043cc8fced56feab45f}{GlobalPhysicalParameters::source\_function},
           &\hyperlink{namespaceGlobalPhysicalParameters_a3a17e62bc0096244627f5f1a7f53c859}{GlobalPhysicalParameters::wind\_function},
           use\_stabilisation);
  
  \textcolor{comment}{// Solve the problem}
  problem.newton\_solve();
  
  \textcolor{comment}{//Output the solution}
  problem.doc\_solution();
  
 \}
 
 
 
 \textcolor{comment}{//Set up the problem without stabilisation}
 \{
  
  \textcolor{keywordtype}{bool} use\_stabilisation=\textcolor{keyword}{false};
  
  \textcolor{comment}{// Create the problem with 2D nine-node elements from the}
  \textcolor{comment}{// QAdvectionDiffusionElement family. Pass pointer to }
  \textcolor{comment}{// source and wind function. }
  \hyperlink{classSUPGAdvectionDiffusionProblem}{SUPGAdvectionDiffusionProblem<QSUPGAdvectionDiffusionElement<2,3>}
       > 
   problem(&\hyperlink{namespaceGlobalPhysicalParameters_aa84986d4d50cb043cc8fced56feab45f}{GlobalPhysicalParameters::source\_function},
           &\hyperlink{namespaceGlobalPhysicalParameters_a3a17e62bc0096244627f5f1a7f53c859}{GlobalPhysicalParameters::wind\_function},
           use\_stabilisation);
  
  \textcolor{comment}{// Solve the problem}
  problem.newton\_solve();
  
  \textcolor{comment}{//Output the solution}
  problem.doc\_solution();
  
 \}


 
\} \textcolor{comment}{// end of main}









\end{DoxyCodeInclude}




 

\hypertarget{index_sources}{}\section{Source files for this tutorial}\label{index_sources}

\begin{DoxyItemize}
\item The source files for this tutorial are located in the directory\+: \begin{center} \href{
../../../../

demo_drivers/advection_diffusion/two_d_adv_diff_SUPG/
}{\tt demo\+\_\+drivers/advection\+\_\+diffusion/two\+\_\+d\+\_\+adv\+\_\+diff\+\_\+\+S\+U\+P\+G/ } \end{center} 
\item The driver code is\+: \begin{center} \href{
../../../../
demo_drivers/advection_diffusion/two_d_adv_diff_SUPG/two_d_adv_diff_SUPG.cc
}{\tt demo\+\_\+drivers/advection\+\_\+diffusion/two\+\_\+d\+\_\+adv\+\_\+diff\+\_\+\+S\+U\+P\+G/two\+\_\+d\+\_\+adv\+\_\+diff\+\_\+\+S\+U\+P\+G.\+cc } \end{center} 
\end{DoxyItemize}



 

 \hypertarget{index_pdf}{}\section{P\+D\+F file}\label{index_pdf}
A \href{../latex/refman.pdf}{\tt pdf version} of this document is available. \end{document}
