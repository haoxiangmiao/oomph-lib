In this document we discuss the solution of time-\/harmonic acoustic fluid-\/structure interaction problems on unstructured meshes.

The driver code is very similar to the one presented in \href{../../acoustic_fsi_annulus/html/index.html}{\tt another tutorial} and we only discuss the changes necessary to deal with the generation of the unstructured mesh for the solid domain and the assignment of different material properties to different parts of the domain.



 

\hypertarget{index_test}{}\section{A test problem}\label{index_test}
The sketch below shows the problem setup\+: A 2D elastic annulus which is reinforced with two T-\/ribs is immersed in a compressible fluid and subjected to a time-\/periodic pressure load of magnitude \[ {\bf t} = P ( \exp(\alpha(\varphi-\pi/4)^2) + \exp(\alpha(\varphi-3\pi/4)^2) ) \] (where $ \varphi $ is the polar angle) along its inner surface. The parameter $ \alpha $ controls the \char`\"{}sharpness\char`\"{} of the pressure load. For $ \alpha=0 $ we obtain a uniform, axisymmetric load; the sketch below shows the pressure distribution (red vectors indicating the traction) for $ \alpha = 200. $

 
\begin{DoxyImage}
\includegraphics[width=0.8\textwidth]{setup}
\doxyfigcaption{Sketch of the problem setup. }
\end{DoxyImage}


The structure is symmetric and we only discretise the right half ( $ x_1 > 0 $) of the domain and apply symmetry conditions (zero horizontal displacement) on the $ x_2-$ axis.



 

\hypertarget{index_results}{}\section{Results}\label{index_results}
The figure below shows an animation of the structure\textquotesingle{}s time-\/harmonic oscillation. The blue shaded region shows the shape of the oscillating structure while the pink region shows its initial configuration. The left half of the plot is used to show the (mirror image of the) adaptive unstructured mesh on which the solution was computed\+:

 
\begin{DoxyImage}
\includegraphics[width=0.8\textwidth]{anim}
\doxyfigcaption{Animation of the time-\/harmonic deformation. }
\end{DoxyImage}


Here is a plot of the corresponding fluid displacement potential, a measure of the fluid pressure\+:

 
\begin{DoxyImage}
\includegraphics[width=0.8\textwidth]{potential_unstr}
\doxyfigcaption{The fluid displacement potential, a measure of the fluid pressure. Elevation\+: real part; contours\+: imaginary part. }
\end{DoxyImage}


This looks very pretty and shows that we can solve acoustic F\+SI problems in non-\/trivial geometries but should you believe the results? Here\textquotesingle{}s an attempt to convince you\+: If we make the rib much softer than the annulus and set its inertia to zero the rib will not offer much structural resistance and the annular region will deform as if the rib was not present. If we then set $ \alpha = 0 $ we apply an axisymmetric forcing onto the structure and would expect the resulting displacement field (at least in the annular region) to be axisymmetric.

The animation of the displacement field for this case, shown below, shows that this is indeed the case\+:

 
\begin{DoxyImage}
\includegraphics[width=0.8\textwidth]{anim_alpha0}
\doxyfigcaption{Animation of the time-\/harmonic deformation for uniform pressure load and a very soft and inertia-\/less rib. }
\end{DoxyImage}


Here is a plot of the corresponding fluid displacement potential, a measure of the fluid pressure\+:

 
\begin{DoxyImage}
\includegraphics[width=0.8\textwidth]{potential_unstr_alpha0}
\doxyfigcaption{The fluid displacement potential, a measure of the fluid pressure for a uniform pressure load and very soft and inertia-\/less rib. Elevation\+: real part; contours\+: imaginary part. }
\end{DoxyImage}




 

\hypertarget{index_num}{}\section{The numerical solution}\label{index_num}
The driver code for this problem is very similar to the one discussed in \href{../../acoustic_fsi_annulus/html/index.html}{\tt another tutorial}. Running {\ttfamily sdiff} on the two driver codes \begin{center} \href{../../../../demo_drivers/interaction/acoustic_fsi/acoustic_fsi.cc}{\tt demo\+\_\+drivers/interaction/acoustic\+\_\+fsi/acoustic\+\_\+fsi.\+cc } \end{center}  and \begin{center} \href{../../../../demo_drivers/interaction/acoustic_fsi/unstructured_acoustic_fsi.cc}{\tt demo\+\_\+drivers/interaction/acoustic\+\_\+fsi/unstructured\+\_\+acoustic\+\_\+fsi.\+cc } \end{center}  shows you the differences, the most important of which are\+:
\begin{DoxyItemize}
\item The use of \href{../../../helmholtz/scattering/html/index.html#ABCs}{\tt approximate/absorbing boundary conditions (A\+B\+Cs)} rather than a \href{../../../helmholtz/scattering/html/index.html#DtN}{\tt Dirichlet-\/to-\/\+Neumann mapping} for the Helmholtz equation, because the boundary along which the Sommerfeld radiation condition is applied is not a full circle. ~\newline
~\newline

\item The provision of multiple elasticity tensors and frequency parameters for the two different regions (the rib and the annulus). ~\newline
~\newline

\item The change of forcing from a prescribed time-\/harmonic displacement to a pressure load on the inside boundary -- this requires yet another mesh of {\ttfamily Face\+Elements}. ~\newline
~\newline

\item The provision of a helper function {\ttfamily complete\+\_\+problem\+\_\+setup()} which rebuilds the elements (by passing the problem parameters to the elements) following the unstructured mesh adaptation. (The need/rationale for such a function is discussed in \href{../../../meshes/mesh_from_inline_triangle/html/index.html}{\tt another tutorial.}) ~\newline
~\newline

\item The mesh generation -- the specification of the curvilinear boundaries and the geometry of the rib is somewhat tedious. We refer to \href{../../../meshes/mesh_from_inline_triangle_internal_boundaries/html/index.html}{\tt another tutorial} for a discussion of how to define the internal mesh boundary that separates the two regions (the rib and the annular region) so that we can assign different material properties to them. ~\newline
~\newline

\end{DoxyItemize}All of this is reasonably straightforward and provides a powerful code that automatically adapts both meshes while respecting the curvilinear boundaries of the domain. Have a look through the driver code and play with it.



 

\hypertarget{index_code}{}\section{Code listing}\label{index_code}
Here\textquotesingle{}s a listing of the complete driver code\+:


\begin{DoxyCodeInclude}
\textcolor{comment}{//LIC// ====================================================================}
\textcolor{comment}{//LIC// This file forms part of oomph-lib, the object-oriented, }
\textcolor{comment}{//LIC// multi-physics finite-element library, available }
\textcolor{comment}{//LIC// at http://www.oomph-lib.org.}
\textcolor{comment}{//LIC// }
\textcolor{comment}{//LIC//    Version 1.0; svn revision $LastChangedRevision$}
\textcolor{comment}{//LIC//}
\textcolor{comment}{//LIC// $LastChangedDate$}
\textcolor{comment}{//LIC// }
\textcolor{comment}{//LIC// Copyright (C) 2006-2016 Matthias Heil and Andrew Hazel}
\textcolor{comment}{//LIC// }
\textcolor{comment}{//LIC// This library is free software; you can redistribute it and/or}
\textcolor{comment}{//LIC// modify it under the terms of the GNU Lesser General Public}
\textcolor{comment}{//LIC// License as published by the Free Software Foundation; either}
\textcolor{comment}{//LIC// version 2.1 of the License, or (at your option) any later version.}
\textcolor{comment}{//LIC// }
\textcolor{comment}{//LIC// This library is distributed in the hope that it will be useful,}
\textcolor{comment}{//LIC// but WITHOUT ANY WARRANTY; without even the implied warranty of}
\textcolor{comment}{//LIC// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU}
\textcolor{comment}{//LIC// Lesser General Public License for more details.}
\textcolor{comment}{//LIC// }
\textcolor{comment}{//LIC// You should have received a copy of the GNU Lesser General Public}
\textcolor{comment}{//LIC// License along with this library; if not, write to the Free Software}
\textcolor{comment}{//LIC// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA}
\textcolor{comment}{//LIC// 02110-1301  USA.}
\textcolor{comment}{//LIC// }
\textcolor{comment}{//LIC// The authors may be contacted at oomph-lib@maths.man.ac.uk.}
\textcolor{comment}{//LIC// }
\textcolor{comment}{//LIC//====================================================================}
\textcolor{comment}{// Driver for Helmholtz/TimeHarmonicTimeHarmonicLinElast coupling}

\textcolor{comment}{//Oomph-lib includes}
\textcolor{preprocessor}{#include "generic.h"}
\textcolor{preprocessor}{#include "helmholtz.h"}
\textcolor{preprocessor}{#include "time\_harmonic\_linear\_elasticity.h"}
\textcolor{preprocessor}{#include "multi\_physics.h"}

\textcolor{comment}{//The meshes}
\textcolor{preprocessor}{#include "meshes/annular\_mesh.h"}
\textcolor{preprocessor}{#include "meshes/triangle\_mesh.h"}

\textcolor{keyword}{using namespace }\hyperlink{namespacestd}{std};
\textcolor{keyword}{using namespace }\hyperlink{namespaceoomph}{oomph};
\textcolor{comment}{}
\textcolor{comment}{///////////////////////////////////////////////////////////////////////}
\textcolor{comment}{///////////////////////////////////////////////////////////////////////}
\textcolor{comment}{}\textcolor{comment}{// Straight line as geometric object}\textcolor{comment}{}
\textcolor{comment}{///////////////////////////////////////////////////////////////////////}
\textcolor{comment}{///////////////////////////////////////////////////////////////////////}
\textcolor{comment}{}


\textcolor{comment}{//=========================================================================}\textcolor{comment}{}
\textcolor{comment}{/// Straight 1D line in 2D space }
\textcolor{comment}{}\textcolor{comment}{//=========================================================================}
\textcolor{keyword}{class }\hyperlink{classMyStraightLine}{MyStraightLine} : \textcolor{keyword}{public} GeomObject
\{

\textcolor{keyword}{public}:
\textcolor{comment}{}
\textcolor{comment}{ /// Constructor:  Pass start and end points}
\textcolor{comment}{} \hyperlink{classMyStraightLine}{MyStraightLine}(\textcolor{keyword}{const} Vector<double>& r\_start, \textcolor{keyword}{const} Vector<double>& r\_end) 
  :  GeomObject(1,2), R\_start(r\_start), R\_end(r\_end)
  \{ \}

\textcolor{comment}{}
\textcolor{comment}{ /// Broken copy constructor}
\textcolor{comment}{} \hyperlink{classMyStraightLine}{MyStraightLine}(\textcolor{keyword}{const} \hyperlink{classMyStraightLine}{MyStraightLine}& dummy) 
  \{ 
   BrokenCopy::broken\_copy(\textcolor{stringliteral}{"MyStraightLine"});
  \} 
 \textcolor{comment}{}
\textcolor{comment}{ /// Broken assignment operator}
\textcolor{comment}{} \textcolor{keywordtype}{void} operator=(\textcolor{keyword}{const} \hyperlink{classMyStraightLine}{MyStraightLine}&) 
  \{
   BrokenCopy::broken\_assign(\textcolor{stringliteral}{"MyStraightLine"});
  \}

\textcolor{comment}{}
\textcolor{comment}{ /// Destructor:  Empty}
\textcolor{comment}{} ~\hyperlink{classMyStraightLine}{MyStraightLine}()\{\}
 \textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Position Vector at Lagrangian coordinate zeta }
\textcolor{comment}{} \textcolor{keywordtype}{void} position(\textcolor{keyword}{const} Vector<double>& zeta, Vector<double>& r)\textcolor{keyword}{ const}
\textcolor{keyword}{  }\{
   \textcolor{comment}{// Position Vector}
   r[0] = R\_start[0]+(R\_end[0]-R\_start[0])*zeta[0];
   r[1] = R\_start[1]+(R\_end[1]-R\_start[1])*zeta[0];
  \}
 
\textcolor{keyword}{private}:
 \textcolor{comment}{}
\textcolor{comment}{ /// Start point of line}
\textcolor{comment}{} Vector<double> R\_start;
 \textcolor{comment}{}
\textcolor{comment}{ /// End point of line}
\textcolor{comment}{} Vector<double> R\_end;

\};


\textcolor{comment}{}
\textcolor{comment}{//////////////////////////////////////////////////////////////////////}
\textcolor{comment}{//////////////////////////////////////////////////////////////////////}
\textcolor{comment}{//////////////////////////////////////////////////////////////////////}
\textcolor{comment}{}

\textcolor{comment}{//=======start\_namespace==========================================}\textcolor{comment}{}
\textcolor{comment}{/// Global variables}
\textcolor{comment}{}\textcolor{comment}{//================================================================}
\textcolor{keyword}{namespace }\hyperlink{namespaceGlobal__Parameters}{Global\_Parameters}
\{
\textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Square of wavenumber for the Helmholtz equation}
\textcolor{comment}{} \textcolor{keywordtype}{double} K\_squared=10.0;
 \textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Radius of outer boundary of Helmholtz domain}
\textcolor{comment}{} \textcolor{keywordtype}{double} Outer\_radius=4.0; 
\textcolor{comment}{}
\textcolor{comment}{ /// Order of absorbing/appproximate boundary condition}
\textcolor{comment}{} \textcolor{keywordtype}{unsigned} ABC\_order=3;
\textcolor{comment}{}
\textcolor{comment}{ /// FSI parameter}
\textcolor{comment}{} \textcolor{keywordtype}{double} Q=0.0;
\textcolor{comment}{}
\textcolor{comment}{ /// Non-dim thickness of elastic coating}
\textcolor{comment}{} \textcolor{keywordtype}{double} H\_coating=0.1; 
 \textcolor{comment}{}
\textcolor{comment}{ /// Poisson's ratio}
\textcolor{comment}{} \textcolor{keywordtype}{double} Nu = 0.3;
\textcolor{comment}{}
\textcolor{comment}{ /// Square of non-dim frequency for the two regions -- dependent variable!}
\textcolor{comment}{} Vector<double> \hyperlink{namespaceGlobal__Parameters_af9e1e178dfb7f5e35b452599bd4c4324}{Omega\_sq}(2,0.0);
  \textcolor{comment}{}
\textcolor{comment}{ /// Density ratio for the two regions: solid to fluid}
\textcolor{comment}{} Vector<double> \hyperlink{namespaceGlobal__Parameters_a517d4c31b8bce6563c2f605266dd9679}{Density\_ratio}(2,0.1);
\textcolor{comment}{}
\textcolor{comment}{ /// The elasticity tensors for the two regions}
\textcolor{comment}{} Vector<TimeHarmonicIsotropicElasticityTensor*> \hyperlink{namespaceGlobal__Parameters_a73c731fa617a9d92851e4195493262e7}{E\_pt};
 \textcolor{comment}{}
\textcolor{comment}{ /// Function to update dependent parameter values}
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{namespaceGlobal__Parameters_ae0f9a80fb7510dbfbbef22582da231b7}{update\_parameter\_values}()
 \{
  \hyperlink{namespaceGlobal__Parameters_af9e1e178dfb7f5e35b452599bd4c4324}{Omega\_sq}[0]=\hyperlink{namespaceGlobal__Parameters_a517d4c31b8bce6563c2f605266dd9679}{Density\_ratio}[0]*\hyperlink{namespaceGlobal__Parameters_a7814fddf663e56168174a42d2cd6b4c1}{Q};
  \hyperlink{namespaceGlobal__Parameters_af9e1e178dfb7f5e35b452599bd4c4324}{Omega\_sq}[1]=\hyperlink{namespaceGlobal__Parameters_a517d4c31b8bce6563c2f605266dd9679}{Density\_ratio}[1]*\hyperlink{namespaceGlobal__Parameters_a7814fddf663e56168174a42d2cd6b4c1}{Q};
 \}
\textcolor{comment}{}
\textcolor{comment}{ /// Uniform pressure}
\textcolor{comment}{} \textcolor{keywordtype}{double} P = 0.1;
\textcolor{comment}{}
\textcolor{comment}{ /// Peakiness parameter for pressure load}
\textcolor{comment}{} \textcolor{keywordtype}{double} Alpha=200.0;
\textcolor{comment}{}
\textcolor{comment}{ /// Pressure load (real and imag part)}
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{namespaceGlobal__Parameters_a0ddb3a77481b907fbb34f2e8d0a6eb9f}{pressure\_load}(\textcolor{keyword}{const} Vector<double> &x,
                    \textcolor{keyword}{const} Vector<double> &n, 
                    Vector<std::complex<double> >&traction)
 \{
  \textcolor{keywordtype}{double} phi=atan2(x[1],x[0]);
  \textcolor{keywordtype}{double} magnitude=exp(-Alpha*pow(phi-0.25*MathematicalConstants::Pi,2));

  \textcolor{keywordtype}{unsigned} dim = traction.size();
  \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} i=0;i<dim;i++)
   \{
    traction[i] = complex<double>(-magnitude*P*n[i],magnitude*P*n[i]);
   \}
 \} \textcolor{comment}{// end\_of\_pressure\_load}

 \textcolor{comment}{// Output directory}
 \textcolor{keywordtype}{string} \hyperlink{namespaceGlobal__Parameters_a301ab922df72030c660b21328d6caf76}{Directory}=\textcolor{stringliteral}{"RESLT"};
 
 \textcolor{comment}{// Multiplier for number of elements}
 \textcolor{keywordtype}{unsigned} \hyperlink{namespaceGlobal__Parameters_a35d5d2ecfff0cec6150a5dc79e5c1ad1}{El\_multiplier}=1;

\} \textcolor{comment}{//end namespace}



\textcolor{comment}{//=============begin\_problem============================================ }\textcolor{comment}{}
\textcolor{comment}{/// Coated disk FSI}
\textcolor{comment}{}\textcolor{comment}{//====================================================================== }
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELASTICITY\_ELEMENT, \textcolor{keyword}{class} HELMHOLTZ\_ELEMENT>
\textcolor{keyword}{class }\hyperlink{classCoatedDiskProblem}{CoatedDiskProblem} : \textcolor{keyword}{public} Problem
\{

\textcolor{keyword}{public}:
\textcolor{comment}{}
\textcolor{comment}{ /// Constructor:}
\textcolor{comment}{} \hyperlink{classCoatedDiskProblem}{CoatedDiskProblem}();
 \textcolor{comment}{}
\textcolor{comment}{ /// Update function (empty)}
\textcolor{comment}{} \textcolor{keywordtype}{void} actions\_before\_newton\_solve() \{\}
\textcolor{comment}{}
\textcolor{comment}{ /// Update function (empty)}
\textcolor{comment}{} \textcolor{keywordtype}{void} actions\_after\_newton\_solve() \{\}
 \textcolor{comment}{}
\textcolor{comment}{ /// Actions before adapt: Wipe the face meshes}
\textcolor{comment}{} \textcolor{keywordtype}{void} actions\_before\_adapt();
\textcolor{comment}{}
\textcolor{comment}{ /// Actions after adapt: Rebuild the face meshes}
\textcolor{comment}{} \textcolor{keywordtype}{void} actions\_after\_adapt();
\textcolor{comment}{}
\textcolor{comment}{ /// Doc the solution}
\textcolor{comment}{} \textcolor{keywordtype}{void} doc\_solution();

\textcolor{keyword}{private}:

 \textcolor{comment}{// Complete problem setup}
 \textcolor{keywordtype}{void} complete\_problem\_setup(); 
\textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Create solid traction elements}
\textcolor{comment}{} \textcolor{keywordtype}{void} create\_solid\_traction\_elements();
\textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Create FSI traction elements}
\textcolor{comment}{} \textcolor{keywordtype}{void} create\_fsi\_traction\_elements();
 \textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Create Helmholtz FSI flux elements}
\textcolor{comment}{} \textcolor{keywordtype}{void} create\_helmholtz\_fsi\_flux\_elements();
\textcolor{comment}{}
\textcolor{comment}{ /// Delete (face) elements in specified mesh }
\textcolor{comment}{} \textcolor{keywordtype}{void} delete\_face\_elements(Mesh* \textcolor{keyword}{const} & boundary\_mesh\_pt);
 \textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Create ABC face elements }
\textcolor{comment}{} \textcolor{keywordtype}{void} create\_helmholtz\_ABC\_elements();
\textcolor{comment}{}
\textcolor{comment}{ /// Setup interaction}
\textcolor{comment}{} \textcolor{keywordtype}{void} setup\_interaction();
\textcolor{comment}{}
\textcolor{comment}{ /// Pointer to refineable solid mesh}
\textcolor{comment}{} RefineableTriangleMesh<ELASTICITY\_ELEMENT>* Solid\_mesh\_pt;
\textcolor{comment}{}
\textcolor{comment}{ /// Pointer to mesh of solid traction elements}
\textcolor{comment}{} Mesh* Solid\_traction\_mesh\_pt;
\textcolor{comment}{}
\textcolor{comment}{ /// Pointer to mesh of FSI traction elements}
\textcolor{comment}{} Mesh* FSI\_traction\_mesh\_pt;
\textcolor{comment}{}
\textcolor{comment}{ /// Pointer to Helmholtz mesh}
\textcolor{comment}{} TreeBasedRefineableMeshBase* Helmholtz\_mesh\_pt;
\textcolor{comment}{}
\textcolor{comment}{ /// Pointer to mesh of Helmholtz FSI flux elements}
\textcolor{comment}{} Mesh* Helmholtz\_fsi\_flux\_mesh\_pt;
 \textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Pointer to mesh containing the ABC elements}
\textcolor{comment}{} Mesh* Helmholtz\_outer\_boundary\_mesh\_pt;
 \textcolor{comment}{}
\textcolor{comment}{ /// Boundary ID of upper symmetry boundary}
\textcolor{comment}{} \textcolor{keywordtype}{unsigned} Upper\_symmetry\_boundary\_id;
\textcolor{comment}{}
\textcolor{comment}{ /// Boundary ID of lower symmetry boundary}
\textcolor{comment}{} \textcolor{keywordtype}{unsigned} Lower\_symmetry\_boundary\_id;
\textcolor{comment}{}
\textcolor{comment}{ /// Boundary ID of upper inner boundary}
\textcolor{comment}{} \textcolor{keywordtype}{unsigned} Upper\_inner\_boundary\_id;
\textcolor{comment}{}
\textcolor{comment}{ /// Boundary ID of lower inner boundary}
\textcolor{comment}{} \textcolor{keywordtype}{unsigned} Lower\_inner\_boundary\_id;
\textcolor{comment}{}
\textcolor{comment}{ /// Boundary ID of outer boundary}
\textcolor{comment}{} \textcolor{keywordtype}{unsigned} Outer\_boundary\_id;

 \textcolor{comment}{// Boundary ID of rib divider}
 \textcolor{keywordtype}{unsigned} Rib\_divider\_boundary\_id;
\textcolor{comment}{}
\textcolor{comment}{ /// DocInfo object for output}
\textcolor{comment}{} DocInfo Doc\_info;
\textcolor{comment}{}
\textcolor{comment}{ /// Trace file}
\textcolor{comment}{} ofstream Trace\_file;

\};


\textcolor{comment}{//===========start\_of\_constructor======================================= }\textcolor{comment}{}
\textcolor{comment}{/// Constructor}
\textcolor{comment}{}\textcolor{comment}{//====================================================================== }
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELASTICITY\_ELEMENT, \textcolor{keyword}{class} HELMHOLTZ\_ELEMENT>
\hyperlink{classCoatedDiskProblem_a9585ca5b422c72dc2b91cbb3e311b736}{CoatedDiskProblem<ELASTICITY\_ELEMENT, HELMHOLTZ\_ELEMENT>::CoatedDiskProblem}
      () 
\{
 \textcolor{comment}{// To suppress boundary warnings (to avoid a lot of warnings) uncomment}
 \textcolor{comment}{// the following code:}
 \textcolor{comment}{//UnstructuredTwoDMeshGeometryBase::}
 \textcolor{comment}{// Suppress\_warning\_about\_regions\_and\_boundaries=true;}

 \textcolor{comment}{// Solid mesh}
 \textcolor{comment}{//-----------}

 \textcolor{comment}{// Start and end coordinates}
 Vector<double> r\_start(2);
 Vector<double> r\_end(2);
 
 \textcolor{comment}{// Outer radius of hull}
 \textcolor{keywordtype}{double} r\_outer = 1.0;

 \textcolor{comment}{// Inner radius of hull}
 \textcolor{keywordtype}{double} r\_inner = r\_outer-\hyperlink{namespaceGlobal__Parameters_ae3cf8878ede839bffda01f79bbe3e819}{Global\_Parameters::H\_coating};

 \textcolor{comment}{// Thickness of rib}
 \textcolor{keywordtype}{double} rib\_thick=0.05;
 
 \textcolor{comment}{// Depth of rib}
 \textcolor{keywordtype}{double} rib\_depth=0.2;

 \textcolor{comment}{// Total width of T}
 \textcolor{keywordtype}{double} t\_width=0.2;

 \textcolor{comment}{// Thickness of T}
 \textcolor{keywordtype}{double} t\_thick=0.05;

 \textcolor{comment}{// Half-opening angle of rib}
 \textcolor{keywordtype}{double} half\_phi\_rib=asin(0.5*rib\_thick/r\_inner);

 \textcolor{comment}{// Pointer to the closed curve that defines the outer boundary}
 TriangleMeshClosedCurve* closed\_curve\_pt=0;
 
 \textcolor{comment}{// Provide storage for pointers to the parts of the curvilinear boundary}
 Vector<TriangleMeshCurveSection*> curvilinear\_boundary\_pt;

 \textcolor{comment}{// Outer boundary}
 \textcolor{comment}{//---------------}
 Ellipse* outer\_boundary\_circle\_pt = \textcolor{keyword}{new} Ellipse(r\_outer,r\_outer);
 \textcolor{keywordtype}{double} zeta\_start=-0.5*MathematicalConstants::Pi;
 \textcolor{keywordtype}{double} zeta\_end=0.5*MathematicalConstants::Pi;
 \textcolor{keywordtype}{unsigned} nsegment=50;
 \textcolor{keywordtype}{unsigned} boundary\_id=curvilinear\_boundary\_pt.size();
 curvilinear\_boundary\_pt.push\_back(
  \textcolor{keyword}{new} TriangleMeshCurviLine(
   outer\_boundary\_circle\_pt,zeta\_start,zeta\_end,nsegment,boundary\_id));

 \textcolor{comment}{// Remember it}
 Outer\_boundary\_id=boundary\_id;
 

 \textcolor{comment}{// Upper straight line segment on symmetry axis}
 \textcolor{comment}{//---------------------------------------------}
 r\_start[0]=0.0;
 r\_start[1]=r\_outer;
 r\_end[0]=0.0;
 r\_end[1]=r\_inner;
 \hyperlink{classMyStraightLine}{MyStraightLine}* upper\_sym\_pt = \textcolor{keyword}{new} \hyperlink{classMyStraightLine}{MyStraightLine}(r\_start,r\_end);
 zeta\_start=0.0;
 zeta\_end=1.0;
 nsegment=1;
 boundary\_id=curvilinear\_boundary\_pt.size();
 curvilinear\_boundary\_pt.push\_back(
  \textcolor{keyword}{new} TriangleMeshCurviLine(
   upper\_sym\_pt,zeta\_start,zeta\_end,nsegment,boundary\_id));
                                                        
 \textcolor{comment}{// Remember it}
 Upper\_symmetry\_boundary\_id=boundary\_id;
 
 \textcolor{comment}{// Upper part of inner boundary}
 \textcolor{comment}{//-----------------------------}
 Ellipse* upper\_inner\_boundary\_pt = 
  \textcolor{keyword}{new} Ellipse(r\_inner,r\_inner);
 zeta\_start=0.5*MathematicalConstants::Pi;
 zeta\_end=half\_phi\_rib;
 nsegment=20;
 boundary\_id=curvilinear\_boundary\_pt.size();
 curvilinear\_boundary\_pt.push\_back(
  \textcolor{keyword}{new} TriangleMeshCurviLine(
   upper\_inner\_boundary\_pt,
   zeta\_start,zeta\_end,nsegment,boundary\_id));

 \textcolor{comment}{// Remember it}
 Upper\_inner\_boundary\_id=boundary\_id;

 \textcolor{comment}{// Data associated with rib}
 \hyperlink{classMyStraightLine}{MyStraightLine}* upper\_inward\_rib\_pt=0;
 \hyperlink{classMyStraightLine}{MyStraightLine}* lower\_inward\_rib\_pt=0;
 TriangleMeshCurviLine* upper\_inward\_rib\_curviline\_pt=0;
 Vector<TriangleMeshOpenCurve*> inner\_boundary\_pt;
 TriangleMeshCurviLine* lower\_inward\_rib\_curviline\_pt=0;
 Vector<double> rib\_center(2);

 \textcolor{comment}{// Upper half of inward rib}
 \textcolor{comment}{//-------------------------}
 r\_start[0]=r\_inner*cos(half\_phi\_rib);
 r\_start[1]=r\_inner*sin(half\_phi\_rib);
 r\_end[0]=r\_start[0]-rib\_depth;
 r\_end[1]=r\_start[1];
 upper\_inward\_rib\_pt = \textcolor{keyword}{new} \hyperlink{classMyStraightLine}{MyStraightLine}(r\_start,r\_end);
 zeta\_start=0.0;
 zeta\_end=1.0;
 nsegment=1;
 boundary\_id=curvilinear\_boundary\_pt.size();
 upper\_inward\_rib\_curviline\_pt=
  \textcolor{keyword}{new} TriangleMeshCurviLine(
   upper\_inward\_rib\_pt,zeta\_start,zeta\_end,nsegment,boundary\_id);
 curvilinear\_boundary\_pt.push\_back(upper\_inward\_rib\_curviline\_pt);

 \textcolor{comment}{// Vertical upper bit of T}
 \textcolor{comment}{//------------------------}
 r\_start[0]=r\_end[0];
 r\_start[1]=r\_end[1];
 r\_end[0]=r\_start[0];
 r\_end[1]=r\_start[1]+0.5*(t\_width-rib\_thick);
 \hyperlink{classMyStraightLine}{MyStraightLine}* vertical\_upper\_t\_rib\_pt = \textcolor{keyword}{new} \hyperlink{classMyStraightLine}{MyStraightLine}(r\_start,r\_end);
 zeta\_start=0.0;
 zeta\_end=1.0;
 nsegment=1;
 boundary\_id=curvilinear\_boundary\_pt.size();
 curvilinear\_boundary\_pt.push\_back(
  \textcolor{keyword}{new} TriangleMeshCurviLine(
   vertical\_upper\_t\_rib\_pt,zeta\_start,zeta\_end,nsegment,boundary\_id));


 \textcolor{comment}{// Horizontal upper bit of T}
 \textcolor{comment}{//-----------==-------------}
 r\_start[0]=r\_end[0];
 r\_start[1]=r\_end[1];
 r\_end[0]=r\_start[0]-t\_thick;
 r\_end[1]=r\_start[1];
 \hyperlink{classMyStraightLine}{MyStraightLine}* horizontal\_upper\_t\_rib\_pt = \textcolor{keyword}{new} \hyperlink{classMyStraightLine}{MyStraightLine}(r\_start,r\_end);
 zeta\_start=0.0;
 zeta\_end=1.0;
 nsegment=1;
 boundary\_id=curvilinear\_boundary\_pt.size();
 curvilinear\_boundary\_pt.push\_back(
  \textcolor{keyword}{new} TriangleMeshCurviLine(
   horizontal\_upper\_t\_rib\_pt,zeta\_start,zeta\_end,nsegment,boundary\_id));

 \textcolor{comment}{// Vertical end of rib end}
 \textcolor{comment}{//------------------------}
 r\_start[0]=r\_end[0];
 r\_start[1]=r\_end[1];
 r\_end[0]=r\_start[0];
 r\_end[1]=-r\_start[1];
 \hyperlink{classMyStraightLine}{MyStraightLine}* inner\_vertical\_rib\_pt = \textcolor{keyword}{new} \hyperlink{classMyStraightLine}{MyStraightLine}(r\_start,r\_end);
 zeta\_start=0.0;
 zeta\_end=1.0;
 nsegment=1;
 boundary\_id=curvilinear\_boundary\_pt.size();
 curvilinear\_boundary\_pt.push\_back(
  \textcolor{keyword}{new} TriangleMeshCurviLine(
   inner\_vertical\_rib\_pt,zeta\_start,zeta\_end,nsegment,boundary\_id));
 

 \textcolor{comment}{// Horizontal lower bit of T}
 \textcolor{comment}{//-----------==-------------}
 r\_start[0]=r\_end[0];
 r\_start[1]=r\_end[1];
 r\_end[0]=r\_start[0]+t\_thick;
 r\_end[1]=r\_start[1];
 \hyperlink{classMyStraightLine}{MyStraightLine}* horizontal\_lower\_t\_rib\_pt = \textcolor{keyword}{new} \hyperlink{classMyStraightLine}{MyStraightLine}(r\_start,r\_end);
 zeta\_start=0.0;
 zeta\_end=1.0;
 nsegment=1;
 boundary\_id=curvilinear\_boundary\_pt.size();
 curvilinear\_boundary\_pt.push\_back(
  \textcolor{keyword}{new} TriangleMeshCurviLine(
   horizontal\_lower\_t\_rib\_pt,zeta\_start,zeta\_end,nsegment,boundary\_id));


 \textcolor{comment}{// Vertical lower bit of T}
 \textcolor{comment}{//------------------------}
 r\_start[0]=r\_end[0];
 r\_start[1]=r\_end[1];
 r\_end[0]=r\_start[0];
 r\_end[1]=r\_start[1]+0.5*(t\_width-rib\_thick);
 \hyperlink{classMyStraightLine}{MyStraightLine}* vertical\_lower\_t\_rib\_pt = \textcolor{keyword}{new} \hyperlink{classMyStraightLine}{MyStraightLine}(r\_start,r\_end);
 zeta\_start=0.0;
 zeta\_end=1.0;
 nsegment=1;
 boundary\_id=curvilinear\_boundary\_pt.size();
 curvilinear\_boundary\_pt.push\_back(
  \textcolor{keyword}{new} TriangleMeshCurviLine(
   vertical\_lower\_t\_rib\_pt,zeta\_start,zeta\_end,nsegment,boundary\_id));


 \textcolor{comment}{// Lower half of inward rib}
 \textcolor{comment}{//-------------------------}
 r\_end[0]=r\_inner*cos(half\_phi\_rib);
 r\_end[1]=-r\_inner*sin(half\_phi\_rib);
 r\_start[0]=r\_end[0]-rib\_depth;
 r\_start[1]=r\_end[1];
 lower\_inward\_rib\_pt = \textcolor{keyword}{new} \hyperlink{classMyStraightLine}{MyStraightLine}(r\_start,r\_end);
 zeta\_start=0.0;
 zeta\_end=1.0;
 nsegment=1;
 boundary\_id=curvilinear\_boundary\_pt.size();
 lower\_inward\_rib\_curviline\_pt=
  \textcolor{keyword}{new} TriangleMeshCurviLine(
   lower\_inward\_rib\_pt,zeta\_start,zeta\_end,nsegment,boundary\_id);
 curvilinear\_boundary\_pt.push\_back(lower\_inward\_rib\_curviline\_pt);


 \textcolor{comment}{// Lower part of inner boundary}
 \textcolor{comment}{//-----------------------------}
 Ellipse* lower\_inner\_boundary\_circle\_pt = \textcolor{keyword}{new} Ellipse(r\_inner,r\_inner);
 zeta\_start=-half\_phi\_rib;
 zeta\_end=-0.5*MathematicalConstants::Pi;
 nsegment=20;
 boundary\_id=curvilinear\_boundary\_pt.size();
 curvilinear\_boundary\_pt.push\_back(
  \textcolor{keyword}{new} TriangleMeshCurviLine(
   lower\_inner\_boundary\_circle\_pt,zeta\_start,zeta\_end,nsegment,boundary\_id)); 
 
 \textcolor{comment}{// Remember it}
 Lower\_inner\_boundary\_id=boundary\_id;

 \textcolor{comment}{// Lower straight line segment on symmetry axis}
 \textcolor{comment}{//---------------------------------------------}
 r\_start[0]=0.0;
 r\_start[1]=-r\_inner;
 r\_end[0]=0.0;
 r\_end[1]=-r\_outer;
 \hyperlink{classMyStraightLine}{MyStraightLine}* lower\_sym\_pt = \textcolor{keyword}{new} \hyperlink{classMyStraightLine}{MyStraightLine}(r\_start,r\_end);
 zeta\_start=0.0;
 zeta\_end=1.0;
 nsegment=1;
 boundary\_id=curvilinear\_boundary\_pt.size();
 curvilinear\_boundary\_pt.push\_back(
  \textcolor{keyword}{new} TriangleMeshCurviLine(
   lower\_sym\_pt,zeta\_start,zeta\_end,nsegment,boundary\_id));
      
 \textcolor{comment}{// Remember it}
 Lower\_symmetry\_boundary\_id=boundary\_id;

 \textcolor{comment}{// Combine to curvilinear boundary}
 \textcolor{comment}{//--------------------------------}
 closed\_curve\_pt=
  \textcolor{keyword}{new} TriangleMeshClosedCurve(curvilinear\_boundary\_pt); 
 
 \textcolor{comment}{// Vertical dividing line across base of T-rib}
 \textcolor{comment}{//--------------------------------------------}
 Vector<TriangleMeshCurveSection*> internal\_polyline\_pt(1);
 r\_start[0]=r\_inner*cos(half\_phi\_rib);
 r\_start[1]=r\_inner*sin(half\_phi\_rib);
 r\_end[0]=r\_inner*cos(half\_phi\_rib);
 r\_end[1]=-r\_inner*sin(half\_phi\_rib);

 Vector<Vector<double> > boundary\_vertices(2);
 boundary\_vertices[0]=r\_start;
 boundary\_vertices[1]=r\_end;
 boundary\_id=100;
 TriangleMeshPolyLine* rib\_divider\_pt=
  \textcolor{keyword}{new} TriangleMeshPolyLine(boundary\_vertices,boundary\_id); 
 internal\_polyline\_pt[0]=rib\_divider\_pt;

 \textcolor{comment}{// Remember it}
 Rib\_divider\_boundary\_id=boundary\_id;

 \textcolor{comment}{// Make connection}
 \textcolor{keywordtype}{double} s\_connect=0.0;
 internal\_polyline\_pt[0]->connect\_initial\_vertex\_to\_curviline(
  upper\_inward\_rib\_curviline\_pt,s\_connect);

 \textcolor{comment}{// Make connection}
 s\_connect=1.0;
 internal\_polyline\_pt[0]->connect\_final\_vertex\_to\_curviline(
  lower\_inward\_rib\_curviline\_pt,s\_connect);

 \textcolor{comment}{// Create open curve that defines internal bondary}
 inner\_boundary\_pt.push\_back(\textcolor{keyword}{new} TriangleMeshOpenCurve(internal\_polyline\_pt));
 
 \textcolor{comment}{// Define coordinates of a point inside the rib}
 rib\_center[0]=r\_inner-rib\_depth;
 rib\_center[1]=0.0;


 \textcolor{comment}{// Now build the mesh}
 \textcolor{comment}{//===================}

 \textcolor{comment}{// Use the TriangleMeshParameters object for helping on the manage of the}
 \textcolor{comment}{// TriangleMesh parameters. The only parameter that needs to take is the}
 \textcolor{comment}{// outer boundary.}
 TriangleMeshParameters triangle\_mesh\_parameters(closed\_curve\_pt);

 \textcolor{comment}{// Target area}
 triangle\_mesh\_parameters.element\_area()=0.2;

 \textcolor{comment}{// Specify the internal open boundary}
 triangle\_mesh\_parameters.internal\_open\_curves\_pt()=inner\_boundary\_pt;

 \textcolor{comment}{// Define the region}
 triangle\_mesh\_parameters.add\_region\_coordinates(1,rib\_center);
 
 \textcolor{comment}{// Build the mesh}
 Solid\_mesh\_pt=\textcolor{keyword}{new} 
  RefineableTriangleMesh<ELASTICITY\_ELEMENT>(triangle\_mesh\_parameters);
 
 \textcolor{comment}{// Helmholtz mesh}
 \textcolor{comment}{//---------------}

 \textcolor{comment}{// Number of elements in azimuthal direction in Helmholtz mesh}
 \textcolor{keywordtype}{unsigned} ntheta\_helmholtz=11*\hyperlink{namespaceGlobal__Parameters_a35d5d2ecfff0cec6150a5dc79e5c1ad1}{Global\_Parameters::El\_multiplier};

 \textcolor{comment}{// Number of elements in radial direction in Helmholtz mesh}
 \textcolor{keywordtype}{unsigned} nr\_helmholtz=3*\hyperlink{namespaceGlobal__Parameters_a35d5d2ecfff0cec6150a5dc79e5c1ad1}{Global\_Parameters::El\_multiplier};

 \textcolor{comment}{// Innermost radius of Helmholtz mesh}
 \textcolor{keywordtype}{double} a=1.0;
 
 \textcolor{comment}{// Thickness of Helmholtz mesh}
 \textcolor{keywordtype}{double} h\_thick\_helmholtz=\hyperlink{namespaceGlobal__Parameters_a88ded445ecd7bd89701409e68fd0b900}{Global\_Parameters::Outer\_radius}-a;

 \textcolor{comment}{// Build mesh}
 \textcolor{keywordtype}{bool} periodic=\textcolor{keyword}{false};
 \textcolor{keywordtype}{double} azimuthal\_fraction=0.5;
 \textcolor{keywordtype}{double} phi=MathematicalConstants::Pi/2.0;
 Helmholtz\_mesh\_pt = \textcolor{keyword}{new} 
  RefineableTwoDAnnularMesh<HELMHOLTZ\_ELEMENT>
  (periodic,azimuthal\_fraction,
   ntheta\_helmholtz,nr\_helmholtz,a,h\_thick\_helmholtz,phi);

 \textcolor{comment}{// Set error estimators}
 Solid\_mesh\_pt->spatial\_error\_estimator\_pt()=\textcolor{keyword}{new} Z2ErrorEstimator;
 Helmholtz\_mesh\_pt->spatial\_error\_estimator\_pt()=\textcolor{keyword}{new} Z2ErrorEstimator;

 \textcolor{comment}{// Mesh containing the Helmholtz ABC}
 \textcolor{comment}{// elements. }
 Helmholtz\_outer\_boundary\_mesh\_pt = \textcolor{keyword}{new} Mesh;

 \textcolor{comment}{// Create elasticity tensors}
 \hyperlink{namespaceGlobal__Parameters_a73c731fa617a9d92851e4195493262e7}{Global\_Parameters::E\_pt}.resize(2);
 \hyperlink{namespaceGlobal__Parameters_a73c731fa617a9d92851e4195493262e7}{Global\_Parameters::E\_pt}[0]=\textcolor{keyword}{new} TimeHarmonicIsotropicElasticityTensor(
    \hyperlink{namespaceGlobal__Parameters_a20fccdcfa2c15ad8b951b9ada3bb1661}{Global\_Parameters::Nu});
 \hyperlink{namespaceGlobal__Parameters_a73c731fa617a9d92851e4195493262e7}{Global\_Parameters::E\_pt}[1]=\textcolor{keyword}{new} TimeHarmonicIsotropicElasticityTensor(
  \hyperlink{namespaceGlobal__Parameters_a20fccdcfa2c15ad8b951b9ada3bb1661}{Global\_Parameters::Nu});

 \textcolor{comment}{// Complete build of solid elements}
 complete\_problem\_setup();

 \textcolor{comment}{// Same for Helmholtz mesh}
 \textcolor{keywordtype}{unsigned} n\_element =Helmholtz\_mesh\_pt->nelement();
 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} i=0;i<n\_element;i++)
  \{
   \textcolor{comment}{//Cast to a solid element}
   HELMHOLTZ\_ELEMENT *el\_pt = 
    \textcolor{keyword}{dynamic\_cast<}HELMHOLTZ\_ELEMENT*\textcolor{keyword}{>}(Helmholtz\_mesh\_pt->element\_pt(i));

   \textcolor{comment}{//Set the pointer to square of Helmholtz wavenumber}
   el\_pt->k\_squared\_pt() = &\hyperlink{namespaceGlobal__Parameters_a91a3fa265abaf9e724c668ee800ffb29}{Global\_Parameters::K\_squared};
  \}

 \textcolor{comment}{// Output meshes and their boundaries so far so we can double }
 \textcolor{comment}{// check the boundary enumeration}
 Solid\_mesh\_pt->output(\textcolor{stringliteral}{"solid\_mesh.dat"});
 Helmholtz\_mesh\_pt->output(\textcolor{stringliteral}{"helmholtz\_mesh.dat"});
 Solid\_mesh\_pt->output\_boundaries(\textcolor{stringliteral}{"solid\_mesh\_boundary.dat"});
 Helmholtz\_mesh\_pt->output\_boundaries(\textcolor{stringliteral}{"helmholtz\_mesh\_boundary.dat"});

 \textcolor{comment}{// Create FaceElement meshes for boundary conditions}
 \textcolor{comment}{//---------------------------------------------------}

 \textcolor{comment}{// Construct the solid traction element mesh}
 Solid\_traction\_mesh\_pt=\textcolor{keyword}{new} Mesh;
 create\_solid\_traction\_elements(); 

 \textcolor{comment}{// Construct the fsi traction element mesh}
 FSI\_traction\_mesh\_pt=\textcolor{keyword}{new} Mesh;
 create\_fsi\_traction\_elements(); 

 \textcolor{comment}{// Construct the Helmholtz fsi flux element mesh}
 Helmholtz\_fsi\_flux\_mesh\_pt=\textcolor{keyword}{new} Mesh;
 create\_helmholtz\_fsi\_flux\_elements();

 \textcolor{comment}{// Create ABC elements on outer boundary of Helmholtz mesh}
 create\_helmholtz\_ABC\_elements();


 \textcolor{comment}{// Combine sub meshes}
 \textcolor{comment}{//-------------------}

 \textcolor{comment}{// Solid mesh is first sub-mesh}
 add\_sub\_mesh(Solid\_mesh\_pt);

 \textcolor{comment}{// Add solid traction sub-mesh}
 add\_sub\_mesh(Solid\_traction\_mesh\_pt);

 \textcolor{comment}{// Add FSI traction sub-mesh}
 add\_sub\_mesh(FSI\_traction\_mesh\_pt);

 \textcolor{comment}{// Add Helmholtz mesh}
 add\_sub\_mesh(Helmholtz\_mesh\_pt);

 \textcolor{comment}{// Add Helmholtz FSI flux mesh}
 add\_sub\_mesh(Helmholtz\_fsi\_flux\_mesh\_pt);

 \textcolor{comment}{// Add Helmholtz ABC mesh}
 add\_sub\_mesh(Helmholtz\_outer\_boundary\_mesh\_pt); 

 \textcolor{comment}{// Build combined "global" mesh}
 build\_global\_mesh();
 

 \textcolor{comment}{// Setup fluid-structure interaction}
 \textcolor{comment}{//----------------------------------}
 setup\_interaction();

 \textcolor{comment}{// Assign equation  numbers}
 oomph\_info << \textcolor{stringliteral}{"Number of unknowns: "} << assign\_eqn\_numbers() << std::endl; 

 \textcolor{comment}{// Set output directory}
 Doc\_info.set\_directory(\hyperlink{namespaceGlobal__Parameters_a301ab922df72030c660b21328d6caf76}{Global\_Parameters::Directory});

 \textcolor{comment}{// Open trace file}
 \textcolor{keywordtype}{char} filename[100];
 sprintf(filename,\textcolor{stringliteral}{"%s/trace.dat"},Doc\_info.directory().c\_str());
 Trace\_file.open(filename);
  

\} \textcolor{comment}{//end of constructor}


\textcolor{comment}{//=====================start\_of\_actions\_before\_adapt======================}\textcolor{comment}{}
\textcolor{comment}{/// Actions before adapt: Wipe the meshes face elements}
\textcolor{comment}{}\textcolor{comment}{//========================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELASTICITY\_ELEMENT, \textcolor{keyword}{class} HELMHOLTZ\_ELEMENT>
\textcolor{keywordtype}{void} \hyperlink{classCoatedDiskProblem_a89e972df172b024b1358f0fac7646d6d}{CoatedDiskProblem<ELASTICITY\_ELEMENT,HELMHOLTZ\_ELEMENT>::}
\hyperlink{classCoatedDiskProblem_a89e972df172b024b1358f0fac7646d6d}{actions\_before\_adapt}()
\{
 \textcolor{comment}{// Kill the solid traction elements and wipe surface mesh}
 delete\_face\_elements(Solid\_traction\_mesh\_pt);

 \textcolor{comment}{// Kill the fsi traction elements and wipe surface mesh}
 delete\_face\_elements(FSI\_traction\_mesh\_pt);
 
 \textcolor{comment}{// Kill Helmholtz FSI flux elements}
 delete\_face\_elements(Helmholtz\_fsi\_flux\_mesh\_pt);
 
 \textcolor{comment}{// Kill Helmholtz BC elements }
 delete\_face\_elements(Helmholtz\_outer\_boundary\_mesh\_pt);
 
 \textcolor{comment}{// Rebuild the Problem's global mesh from its various sub-meshes}
 rebuild\_global\_mesh();

\}\textcolor{comment}{// end of actions\_before\_adapt}



\textcolor{comment}{//=====================start\_of\_actions\_after\_adapt=======================}\textcolor{comment}{}
\textcolor{comment}{///  Actions after adapt: Rebuild the meshes of face elements}
\textcolor{comment}{}\textcolor{comment}{//========================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELASTICITY\_ELEMENT, \textcolor{keyword}{class} HELMHOLTZ\_ELEMENT>
\textcolor{keywordtype}{void} \hyperlink{classCoatedDiskProblem_a93f9d34cd24f08ca1ec726ae0057b939}{CoatedDiskProblem<ELASTICITY\_ELEMENT,HELMHOLTZ\_ELEMENT>::}
\hyperlink{classCoatedDiskProblem_a93f9d34cd24f08ca1ec726ae0057b939}{actions\_after\_adapt}()
\{
 \textcolor{comment}{// Complete problem setup}
 complete\_problem\_setup(); 

 \textcolor{comment}{// Construct the solid traction elements}
 create\_solid\_traction\_elements(); 

 \textcolor{comment}{// Create fsi traction elements from all elements that are }
 \textcolor{comment}{// adjacent to FSI boundaries and add them to surface meshes}
 create\_fsi\_traction\_elements();
 
 \textcolor{comment}{// Create Helmholtz fsi flux elements}
 create\_helmholtz\_fsi\_flux\_elements();
 
 \textcolor{comment}{// Create ABC elements from all elements that are }
 \textcolor{comment}{// adjacent to the outer boundary of Helmholtz mesh}
 create\_helmholtz\_ABC\_elements();
   
 \textcolor{comment}{// Setup interaction}
 setup\_interaction();
 
 \textcolor{comment}{// Rebuild the Problem's global mesh from its various sub-meshes}
 rebuild\_global\_mesh();
 
\}\textcolor{comment}{// end of actions\_after\_adapt}




\textcolor{comment}{//=====================start\_of\_complete\_problem\_setup=======================}\textcolor{comment}{}
\textcolor{comment}{/// Complete problem setup: Apply boundary conditions and set}
\textcolor{comment}{/// physical properties}
\textcolor{comment}{}\textcolor{comment}{//========================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELASTICITY\_ELEMENT, \textcolor{keyword}{class} HELMHOLTZ\_ELEMENT>
\textcolor{keywordtype}{void} \hyperlink{classCoatedDiskProblem_a4d63252d3916bda71f28b637d6590627}{CoatedDiskProblem<ELASTICITY\_ELEMENT,HELMHOLTZ\_ELEMENT>::}
\hyperlink{classCoatedDiskProblem_a4d63252d3916bda71f28b637d6590627}{complete\_problem\_setup}()
\{

 \textcolor{comment}{// Solid boundary conditions:}
 \textcolor{comment}{//---------------------------}
 \textcolor{comment}{// Pin real and imag part of horizontal displacement components }
 \textcolor{comment}{//-------------------------------------------------------------}
 \textcolor{comment}{// on vertical boundaries}
 \textcolor{comment}{//-----------------------}
 \{  
  \textcolor{comment}{//Loop over the nodes to pin and assign boundary displacements on }
  \textcolor{comment}{//solid boundary}
  \textcolor{keywordtype}{unsigned} n\_node = Solid\_mesh\_pt->nboundary\_node(Upper\_symmetry\_boundary\_id);
  \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} i=0;i<n\_node;i++)
   \{
    Node* nod\_pt=Solid\_mesh\_pt->boundary\_node\_pt(Upper\_symmetry\_boundary\_id,i);
    
    \textcolor{comment}{// Real part of x-displacement }
    nod\_pt->pin(0);
    nod\_pt->set\_value(0,0.0);
    
    \textcolor{comment}{// Imag part of x-displacement}
    nod\_pt->pin(2);
    nod\_pt->set\_value(2,0.0);
   \}
 \}
 \{
  \textcolor{comment}{//Loop over the nodes to pin and assign boundary displacements on }
  \textcolor{comment}{//solid boundary}
  \textcolor{keywordtype}{unsigned} n\_node = Solid\_mesh\_pt->nboundary\_node(Lower\_symmetry\_boundary\_id);
  \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} i=0;i<n\_node;i++)
   \{
    Node* nod\_pt=Solid\_mesh\_pt->boundary\_node\_pt(Lower\_symmetry\_boundary\_id,i);

    \textcolor{comment}{// Real part of x-displacement }
    nod\_pt->pin(0);
    nod\_pt->set\_value(0,0.0);
    
    \textcolor{comment}{// Imag part of x-displacement}
    nod\_pt->pin(2);
    nod\_pt->set\_value(2,0.0);
   \}
 \}



 \textcolor{comment}{//Assign the physical properties to the elements}
 \textcolor{comment}{//----------------------------------------------}
 \textcolor{keywordtype}{unsigned} nreg=Solid\_mesh\_pt->nregion();
 \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} r=0;r<nreg;r++)
  \{
   \textcolor{keywordtype}{unsigned} nel=Solid\_mesh\_pt->nregion\_element(r);
   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} e=0;e<nel;e++)
    \{     
     \textcolor{comment}{//Cast to a solid element}
     ELASTICITY\_ELEMENT *el\_pt = 
      \textcolor{keyword}{dynamic\_cast<}ELASTICITY\_ELEMENT*\textcolor{keyword}{>}(Solid\_mesh\_pt->
                                        region\_element\_pt(r,e));
     
     \textcolor{comment}{// Set the constitutive law}
     el\_pt->elasticity\_tensor\_pt() = \hyperlink{namespaceGlobal__Parameters_a73c731fa617a9d92851e4195493262e7}{Global\_Parameters::E\_pt}[r];
     
     \textcolor{comment}{// Square of non-dim frequency}
     el\_pt->omega\_sq\_pt()= &Global\_Parameters::Omega\_sq[r];
    \}
  \}    
\}

\textcolor{comment}{//============start\_of\_delete\_face\_elements================}\textcolor{comment}{}
\textcolor{comment}{/// Delete face elements and wipe the mesh}
\textcolor{comment}{}\textcolor{comment}{//==========================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELASTICITY\_ELEMENT, \textcolor{keyword}{class} HELMHOLTZ\_ELEMENT>
\textcolor{keywordtype}{void} \hyperlink{classCoatedDiskProblem_a55b4cead41e01ab5fd728b607f62bb74}{CoatedDiskProblem<ELASTICITY\_ELEMENT,HELMHOLTZ\_ELEMENT>::}
\hyperlink{classCoatedDiskProblem_a55b4cead41e01ab5fd728b607f62bb74}{delete\_face\_elements}(Mesh* \textcolor{keyword}{const} & boundary\_mesh\_pt)
\{
 \textcolor{comment}{// How many surface elements are in the surface mesh}
 \textcolor{keywordtype}{unsigned} n\_element = boundary\_mesh\_pt->nelement();

 \textcolor{comment}{// Loop over the surface elements}
 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} e=0;e<n\_element;e++)
  \{
   \textcolor{comment}{//   Kill surface element}
   \textcolor{keyword}{delete} boundary\_mesh\_pt->element\_pt(e);
  \}
 
 \textcolor{comment}{// Wipe the mesh}
 boundary\_mesh\_pt->flush\_element\_and\_node\_storage();
 
\} \textcolor{comment}{// end of delete\_face\_elements}



\textcolor{comment}{//============start\_of\_create\_solid\_traction\_elements====================}\textcolor{comment}{}
\textcolor{comment}{/// Create solid traction elements }
\textcolor{comment}{}\textcolor{comment}{//=======================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELASTICITY\_ELEMENT, \textcolor{keyword}{class} HELMHOLTZ\_ELEMENT>
\textcolor{keywordtype}{void} \hyperlink{classCoatedDiskProblem_a31c3707de78a720e3936e3b34e70b1ba}{CoatedDiskProblem<ELASTICITY\_ELEMENT,HELMHOLTZ\_ELEMENT>::}
\hyperlink{classCoatedDiskProblem_a31c3707de78a720e3936e3b34e70b1ba}{create\_solid\_traction\_elements}()
\{
 \textcolor{comment}{// Loop over pressure loaded boundaries}
 \textcolor{keywordtype}{unsigned} b=0;
 \textcolor{keywordtype}{unsigned} nb=3;
 \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} i=0;i<nb;i++) 
  \{
   \textcolor{keywordflow}{switch}(i)
    \{
    \textcolor{keywordflow}{case} 0:
     b=Upper\_inner\_boundary\_id;
     \textcolor{keywordflow}{break};
     
    \textcolor{keywordflow}{case} 1:
     b=Lower\_inner\_boundary\_id;
     \textcolor{keywordflow}{break};
     
    \textcolor{keywordflow}{case} 2:
     b=Rib\_divider\_boundary\_id;
     \textcolor{keywordflow}{break};
    \}
   
   \textcolor{comment}{// We're attaching face elements to region 0}
   \textcolor{keywordtype}{unsigned} r=0;
   
   \textcolor{comment}{// How many bulk elements are adjacent to boundary b?}
   \textcolor{keywordtype}{unsigned} n\_element = Solid\_mesh\_pt->nboundary\_element\_in\_region(b,r);
   
   \textcolor{comment}{// Loop over the bulk elements adjacent to boundary b}
   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} e=0;e<n\_element;e++)
    \{
     \textcolor{comment}{// Get pointer to the bulk element that is adjacent to boundary b}
     ELASTICITY\_ELEMENT* bulk\_elem\_pt = \textcolor{keyword}{dynamic\_cast<}ELASTICITY\_ELEMENT*\textcolor{keyword}{>}(
      Solid\_mesh\_pt->boundary\_element\_in\_region\_pt(b,r,e));
     
     \textcolor{comment}{//Find the index of the face of element e along boundary b}
     \textcolor{keywordtype}{int} face\_index = Solid\_mesh\_pt->face\_index\_at\_boundary\_in\_region(b,r,e);
     
     \textcolor{comment}{// Create element}
     TimeHarmonicLinearElasticityTractionElement<ELASTICITY\_ELEMENT>* el\_pt=
      \textcolor{keyword}{new} TimeHarmonicLinearElasticityTractionElement<ELASTICITY\_ELEMENT>
      (bulk\_elem\_pt,face\_index);   
     
     \textcolor{comment}{// Add to mesh}
     Solid\_traction\_mesh\_pt->add\_element\_pt(el\_pt);
     
     \textcolor{comment}{// Associate element with bulk boundary (to allow it to access}
     \textcolor{comment}{// the boundary coordinates in the bulk mesh)}
     el\_pt->set\_boundary\_number\_in\_bulk\_mesh(b); 
     
     \textcolor{comment}{//Set the traction function}
     el\_pt->traction\_fct\_pt() = \hyperlink{namespaceGlobal__Parameters_a0ddb3a77481b907fbb34f2e8d0a6eb9f}{Global\_Parameters::pressure\_load};  
    \}
  \}
\} \textcolor{comment}{// end of create\_traction\_elements}




\textcolor{comment}{//============start\_of\_create\_fsi\_traction\_elements======================}\textcolor{comment}{}
\textcolor{comment}{/// Create fsi traction elements }
\textcolor{comment}{}\textcolor{comment}{//=======================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELASTICITY\_ELEMENT, \textcolor{keyword}{class} HELMHOLTZ\_ELEMENT>
\textcolor{keywordtype}{void} \hyperlink{classCoatedDiskProblem_a143908e8db74ad6bd8b7efaaa26c78c3}{CoatedDiskProblem<ELASTICITY\_ELEMENT,HELMHOLTZ\_ELEMENT>::}
\hyperlink{classCoatedDiskProblem_a143908e8db74ad6bd8b7efaaa26c78c3}{create\_fsi\_traction\_elements}()
\{
 \textcolor{comment}{// We're on the outer boundary of the solid mesh}
 \textcolor{keywordtype}{unsigned} b=Outer\_boundary\_id;

 \textcolor{comment}{// How many bulk elements are adjacent to boundary b?}
 \textcolor{keywordtype}{unsigned} n\_element = Solid\_mesh\_pt->nboundary\_element(b);
 
 \textcolor{comment}{// Loop over the bulk elements adjacent to boundary b}
 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} e=0;e<n\_element;e++)
  \{
   \textcolor{comment}{// Get pointer to the bulk element that is adjacent to boundary b}
   ELASTICITY\_ELEMENT* bulk\_elem\_pt = \textcolor{keyword}{dynamic\_cast<}ELASTICITY\_ELEMENT*\textcolor{keyword}{>}(
    Solid\_mesh\_pt->boundary\_element\_pt(b,e));
   
   \textcolor{comment}{//Find the index of the face of element e along boundary b}
   \textcolor{keywordtype}{int} face\_index = Solid\_mesh\_pt->face\_index\_at\_boundary(b,e);
   
   \textcolor{comment}{// Create element}
   TimeHarmonicLinElastLoadedByHelmholtzPressureBCElement
    <ELASTICITY\_ELEMENT,HELMHOLTZ\_ELEMENT>* el\_pt=
    \textcolor{keyword}{new} TimeHarmonicLinElastLoadedByHelmholtzPressureBCElement
    <ELASTICITY\_ELEMENT,HELMHOLTZ\_ELEMENT>(bulk\_elem\_pt,
                                           face\_index);   
   \textcolor{comment}{// Add to mesh}
   FSI\_traction\_mesh\_pt->add\_element\_pt(el\_pt);
   
   \textcolor{comment}{// Associate element with bulk boundary (to allow it to access}
   \textcolor{comment}{// the boundary coordinates in the bulk mesh)}
   el\_pt->set\_boundary\_number\_in\_bulk\_mesh(b); 
   
   \textcolor{comment}{// Set FSI parameter}
   el\_pt->q\_pt()=&\hyperlink{namespaceGlobal__Parameters_a7814fddf663e56168174a42d2cd6b4c1}{Global\_Parameters::Q};          
  \}
 
\} \textcolor{comment}{// end of create\_traction\_elements}





\textcolor{comment}{//============start\_of\_create\_helmholtz\_fsi\_flux\_elements================}\textcolor{comment}{}
\textcolor{comment}{/// Create Helmholtz fsi flux elements }
\textcolor{comment}{}\textcolor{comment}{//=======================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELASTICITY\_ELEMENT, \textcolor{keyword}{class} HELMHOLTZ\_ELEMENT>
\textcolor{keywordtype}{void} \hyperlink{classCoatedDiskProblem_a34f61c03b152f2ac06e1e771b0dbe09b}{CoatedDiskProblem<ELASTICITY\_ELEMENT,HELMHOLTZ\_ELEMENT>::}
\hyperlink{classCoatedDiskProblem_a34f61c03b152f2ac06e1e771b0dbe09b}{create\_helmholtz\_fsi\_flux\_elements}()
\{
 
 \textcolor{comment}{// Attach to inner boundary of Helmholtz mesh (0)}
 \textcolor{keywordtype}{unsigned} b=0;

 \textcolor{comment}{// How many bulk elements are adjacent to boundary b?}
 \textcolor{keywordtype}{unsigned} n\_element = Helmholtz\_mesh\_pt->nboundary\_element(b);
 
 \textcolor{comment}{// Loop over the bulk elements adjacent to boundary b}
 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} e=0;e<n\_element;e++)
  \{
   \textcolor{comment}{// Get pointer to the bulk element that is adjacent to boundary b}
   HELMHOLTZ\_ELEMENT* bulk\_elem\_pt = \textcolor{keyword}{dynamic\_cast<}HELMHOLTZ\_ELEMENT*\textcolor{keyword}{>}(
    Helmholtz\_mesh\_pt->boundary\_element\_pt(b,e));
   
   \textcolor{comment}{//Find the index of the face of element e along boundary b}
   \textcolor{keywordtype}{int} face\_index = Helmholtz\_mesh\_pt->face\_index\_at\_boundary(b,e);
   
   \textcolor{comment}{// Create element}
   HelmholtzFluxFromNormalDisplacementBCElement
    <HELMHOLTZ\_ELEMENT,ELASTICITY\_ELEMENT>* el\_pt=
    \textcolor{keyword}{new} HelmholtzFluxFromNormalDisplacementBCElement
    <HELMHOLTZ\_ELEMENT,ELASTICITY\_ELEMENT>(bulk\_elem\_pt,
                                           face\_index);
   
   \textcolor{comment}{// Add to mesh}
   Helmholtz\_fsi\_flux\_mesh\_pt->add\_element\_pt(el\_pt);
   
   \textcolor{comment}{// Associate element with bulk boundary (to allow it to access}
   \textcolor{comment}{// the boundary coordinates in the bulk mesh)}
   el\_pt->set\_boundary\_number\_in\_bulk\_mesh(b); 
  \}  
  
\} \textcolor{comment}{// end of create\_helmholtz\_flux\_elements}



\textcolor{comment}{//============start\_of\_create\_ABC\_elements==============================}\textcolor{comment}{}
\textcolor{comment}{/// Create ABC elements on the outer boundary of }
\textcolor{comment}{/// the Helmholtz mesh}
\textcolor{comment}{}\textcolor{comment}{//===========================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELASTICITY\_ELEMENT, \textcolor{keyword}{class} HELMHOLTZ\_ELEMENT>
\textcolor{keywordtype}{void} \hyperlink{classCoatedDiskProblem_ade4e1e8fd2e8b0f7592f26514f3d18cc}{CoatedDiskProblem<ELASTICITY\_ELEMENT,HELMHOLTZ\_ELEMENT>::}
\hyperlink{classCoatedDiskProblem_ade4e1e8fd2e8b0f7592f26514f3d18cc}{create\_helmholtz\_ABC\_elements}()
\{
 \textcolor{comment}{// We're on boundary 2 of the Helmholtz mesh}
 \textcolor{keywordtype}{unsigned} b=2;

 \textcolor{comment}{// How many bulk elements are adjacent to boundary b?}
 \textcolor{keywordtype}{unsigned} n\_element = Helmholtz\_mesh\_pt->nboundary\_element(b);
 
 \textcolor{comment}{// Loop over the bulk elements adjacent to boundary b?}
 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} e=0;e<n\_element;e++)
  \{
   \textcolor{comment}{// Get pointer to the bulk element that is adjacent to boundary b}
   HELMHOLTZ\_ELEMENT* bulk\_elem\_pt = \textcolor{keyword}{dynamic\_cast<}HELMHOLTZ\_ELEMENT*\textcolor{keyword}{>}(
    Helmholtz\_mesh\_pt->boundary\_element\_pt(b,e));
   
   \textcolor{comment}{//Find the index of the face of element e along boundary b }
   \textcolor{keywordtype}{int} face\_index = Helmholtz\_mesh\_pt->face\_index\_at\_boundary(b,e);
   
   \textcolor{comment}{// Build the corresponding ABC element}
   HelmholtzAbsorbingBCElement<HELMHOLTZ\_ELEMENT>* flux\_element\_pt = \textcolor{keyword}{new} 
    HelmholtzAbsorbingBCElement<HELMHOLTZ\_ELEMENT>(bulk\_elem\_pt,face\_index);

   \textcolor{comment}{// Set pointer to outer radius of artificial boundary}
   flux\_element\_pt->outer\_radius\_pt()=&\hyperlink{namespaceGlobal__Parameters_a88ded445ecd7bd89701409e68fd0b900}{Global\_Parameters::Outer\_radius};
   
   \textcolor{comment}{// Set order of absorbing boundary condition}
   flux\_element\_pt->abc\_order\_pt()=&\hyperlink{namespaceGlobal__Parameters_ae16eb10039cab2098b02ec7dff946277}{Global\_Parameters::ABC\_order};   

   \textcolor{comment}{//Add the flux boundary element to the  helmholtz\_outer\_boundary\_mesh}
   Helmholtz\_outer\_boundary\_mesh\_pt->add\_element\_pt(flux\_element\_pt);
  \}

\} \textcolor{comment}{// end of create\_helmholtz\_ABC\_elements}



\textcolor{comment}{//=====================start\_of\_setup\_interaction======================}\textcolor{comment}{}
\textcolor{comment}{/// Setup interaction between two fields}
\textcolor{comment}{}\textcolor{comment}{//========================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELASTICITY\_ELEMENT, \textcolor{keyword}{class} HELMHOLTZ\_ELEMENT>
\textcolor{keywordtype}{void} \hyperlink{classCoatedDiskProblem_ad24d43389155a6a9f2f66faf4b239c26}{CoatedDiskProblem<ELASTICITY\_ELEMENT,HELMHOLTZ\_ELEMENT>::}
\hyperlink{classCoatedDiskProblem_ad24d43389155a6a9f2f66faf4b239c26}{setup\_interaction}()
\{

 \textcolor{comment}{// Setup Helmholtz "pressure" load on traction elements}
 \textcolor{keywordtype}{unsigned} boundary\_in\_helmholtz\_mesh=0;

 \textcolor{comment}{// Doc boundary coordinate for Helmholtz}
 ofstream the\_file;
 the\_file.open(\textcolor{stringliteral}{"boundary\_coordinate\_hh.dat"});
 Helmholtz\_mesh\_pt->Mesh::doc\_boundary\_coordinates<HELMHOLTZ\_ELEMENT>
  (boundary\_in\_helmholtz\_mesh, the\_file);
 the\_file.close();

  Multi\_domain\_functions::setup\_bulk\_elements\_adjacent\_to\_face\_mesh
  <HELMHOLTZ\_ELEMENT,2>
  (\textcolor{keyword}{this},boundary\_in\_helmholtz\_mesh,Helmholtz\_mesh\_pt,FSI\_traction\_mesh\_pt);

 \textcolor{comment}{// Setup Helmholtz flux from normal displacement interaction}
 \textcolor{keywordtype}{unsigned} boundary\_in\_solid\_mesh=Outer\_boundary\_id;

 \textcolor{comment}{// Doc boundary coordinate for solid mesh}
 the\_file.open(\textcolor{stringliteral}{"boundary\_coordinate\_solid.dat"});
 Solid\_mesh\_pt->Mesh::template doc\_boundary\_coordinates<ELASTICITY\_ELEMENT>
  (boundary\_in\_solid\_mesh, the\_file);
 the\_file.close();

 Multi\_domain\_functions::setup\_bulk\_elements\_adjacent\_to\_face\_mesh
  <ELASTICITY\_ELEMENT,2>(
   \textcolor{keyword}{this},boundary\_in\_solid\_mesh,Solid\_mesh\_pt,Helmholtz\_fsi\_flux\_mesh\_pt);
\}



\textcolor{comment}{//==============start\_doc===========================================}\textcolor{comment}{}
\textcolor{comment}{/// Doc the solution}
\textcolor{comment}{}\textcolor{comment}{//==================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELASTICITY\_ELEMENT, \textcolor{keyword}{class} HELMHOLTZ\_ELEMENT>
\textcolor{keywordtype}{void} \hyperlink{classCoatedDiskProblem_af8e103d494f526c0e24c0c4ccef4ea6b}{CoatedDiskProblem<ELASTICITY\_ELEMENT,HELMHOLTZ\_ELEMENT>::doc\_solution}
      ()
\{

 ofstream some\_file,some\_file2;
 \textcolor{keywordtype}{char} filename[100];

 \textcolor{comment}{// Number of plot points}
 \textcolor{keywordtype}{unsigned} n\_plot=5; 

 \textcolor{comment}{// Compute/output the radiated power}
 \textcolor{comment}{//----------------------------------}
 sprintf(filename,\textcolor{stringliteral}{"%s/power%i.dat"},Doc\_info.directory().c\_str(),
         Doc\_info.number());
 some\_file.open(filename);

 \textcolor{comment}{// Accumulate contribution from elements}
 \textcolor{keywordtype}{double} power=0.0;
 \textcolor{keywordtype}{unsigned} nn\_element=Helmholtz\_outer\_boundary\_mesh\_pt->nelement(); 
 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} e=0;e<nn\_element;e++)
  \{
   HelmholtzBCElementBase<HELMHOLTZ\_ELEMENT> *el\_pt = 
    \textcolor{keyword}{dynamic\_cast<}HelmholtzBCElementBase<HELMHOLTZ\_ELEMENT>*\textcolor{keyword}{>}(
     Helmholtz\_outer\_boundary\_mesh\_pt->element\_pt(e)); 
   power += el\_pt->global\_power\_contribution(some\_file);
  \}
 some\_file.close();
 oomph\_info << \textcolor{stringliteral}{"Step: "} << Doc\_info.number() 
            << \textcolor{stringliteral}{": Q="} << \hyperlink{namespaceGlobal__Parameters_a7814fddf663e56168174a42d2cd6b4c1}{Global\_Parameters::Q}  << \textcolor{stringliteral}{"\(\backslash\)n"}
            << \textcolor{stringliteral}{" k\_squared="} << \hyperlink{namespaceGlobal__Parameters_a91a3fa265abaf9e724c668ee800ffb29}{Global\_Parameters::K\_squared}  << \textcolor{stringliteral}{"\(\backslash\)n"}
            << \textcolor{stringliteral}{" density ratio (annulus) ="} 
            << \hyperlink{namespaceGlobal__Parameters_a517d4c31b8bce6563c2f605266dd9679}{Global\_Parameters::Density\_ratio}[0]  << \textcolor{stringliteral}{"\(\backslash\)n"}
            << \textcolor{stringliteral}{" density ratio (rib)     ="} 
            << \hyperlink{namespaceGlobal__Parameters_a517d4c31b8bce6563c2f605266dd9679}{Global\_Parameters::Density\_ratio}[1]  << \textcolor{stringliteral}{"\(\backslash\)n"}
            << \textcolor{stringliteral}{" omega\_sq (annulus)="} << Global\_Parameters::Omega\_sq[0]  << \textcolor{stringliteral}{"\(\backslash\)n"}
            << \textcolor{stringliteral}{" omega\_sq (rib    )="} << Global\_Parameters::Omega\_sq[1]  << \textcolor{stringliteral}{"\(\backslash\)n"}
            << \textcolor{stringliteral}{" Total radiated power "} << power  << \textcolor{stringliteral}{"\(\backslash\)n"}
            << std::endl; 


 \textcolor{comment}{// Write trace file}
 Trace\_file << \hyperlink{namespaceGlobal__Parameters_a7814fddf663e56168174a42d2cd6b4c1}{Global\_Parameters::Q} << \textcolor{stringliteral}{" "} 
            << \hyperlink{namespaceGlobal__Parameters_a91a3fa265abaf9e724c668ee800ffb29}{Global\_Parameters::K\_squared} << \textcolor{stringliteral}{" "}
            << \hyperlink{namespaceGlobal__Parameters_a517d4c31b8bce6563c2f605266dd9679}{Global\_Parameters::Density\_ratio}[0] << \textcolor{stringliteral}{" "}
            << \hyperlink{namespaceGlobal__Parameters_a517d4c31b8bce6563c2f605266dd9679}{Global\_Parameters::Density\_ratio}[1] << \textcolor{stringliteral}{" "}
            << Global\_Parameters::Omega\_sq[0] << \textcolor{stringliteral}{" "}
            << Global\_Parameters::Omega\_sq[1] << \textcolor{stringliteral}{" "}
            << power << \textcolor{stringliteral}{" "} 
            << std::endl;
  
 std::ostringstream case\_string;
 case\_string << \textcolor{stringliteral}{"TEXT X=10,Y=90, T=\(\backslash\)"Q="} 
             <<  \hyperlink{namespaceGlobal__Parameters_a7814fddf663e56168174a42d2cd6b4c1}{Global\_Parameters::Q} 
             << \textcolor{stringliteral}{",  k<sup>2</sup> = "}
             <<  \hyperlink{namespaceGlobal__Parameters_a91a3fa265abaf9e724c668ee800ffb29}{Global\_Parameters::K\_squared}
             << \textcolor{stringliteral}{",  density ratio = "}
             <<  \hyperlink{namespaceGlobal__Parameters_a517d4c31b8bce6563c2f605266dd9679}{Global\_Parameters::Density\_ratio}[0] << \textcolor{stringliteral}{" and "}
             <<  \hyperlink{namespaceGlobal__Parameters_a517d4c31b8bce6563c2f605266dd9679}{Global\_Parameters::Density\_ratio}[1] 
             << \textcolor{stringliteral}{",  omega\_sq = "}
             <<  Global\_Parameters::Omega\_sq[0] << \textcolor{stringliteral}{" and "} 
             <<  Global\_Parameters::Omega\_sq[1] << \textcolor{stringliteral}{" "} 
             << \textcolor{stringliteral}{"\(\backslash\)"\(\backslash\)n"};


 \textcolor{comment}{// Output displacement field}
 \textcolor{comment}{//--------------------------}
 sprintf(filename,\textcolor{stringliteral}{"%s/elast\_soln%i.dat"},Doc\_info.directory().c\_str(),
         Doc\_info.number());
 some\_file.open(filename);
 Solid\_mesh\_pt->output(some\_file,n\_plot);
 some\_file.close();

 \textcolor{comment}{// Output solid traction elements}
 \textcolor{comment}{//--------------------------------}
 sprintf(filename,\textcolor{stringliteral}{"%s/solid\_traction\_soln%i.dat"},Doc\_info.directory().c\_str(),
         Doc\_info.number());
 some\_file.open(filename);
 Solid\_traction\_mesh\_pt->output(some\_file,n\_plot);
 some\_file.close();

 \textcolor{comment}{// Output fsi traction elements}
 \textcolor{comment}{//----------------------------- }
 sprintf(filename,\textcolor{stringliteral}{"%s/traction\_soln%i.dat"},Doc\_info.directory().c\_str(),
         Doc\_info.number());
 some\_file.open(filename);
 FSI\_traction\_mesh\_pt->output(some\_file,n\_plot);
 some\_file.close();


 \textcolor{comment}{// Output Helmholtz fsi flux elements}
 \textcolor{comment}{//----------------------------------- }
 sprintf(filename,\textcolor{stringliteral}{"%s/flux\_bc\_soln%i.dat"},Doc\_info.directory().c\_str(),
         Doc\_info.number());
 some\_file.open(filename);
 Helmholtz\_fsi\_flux\_mesh\_pt->output(some\_file,n\_plot);
 some\_file.close();


 \textcolor{comment}{// Output Helmholtz}
 \textcolor{comment}{//-----------------}
 sprintf(filename,\textcolor{stringliteral}{"%s/helmholtz\_soln%i.dat"},Doc\_info.directory().c\_str(),
         Doc\_info.number());
 some\_file.open(filename);
 Helmholtz\_mesh\_pt->output(some\_file,n\_plot);
 some\_file << case\_string.str();
 some\_file.close();
 
 \textcolor{comment}{// Output regions of solid mesh}
 \textcolor{comment}{//-----------------------------}
 \textcolor{keywordtype}{unsigned} nreg=Solid\_mesh\_pt->nregion();
 \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} r=0;r<nreg;r++)
  \{
   sprintf(filename,\textcolor{stringliteral}{"%s/region%i\_%i.dat"},Doc\_info.directory().c\_str(),
           r,Doc\_info.number());   
   some\_file.open(filename);   
   \textcolor{keywordtype}{unsigned} nel=Solid\_mesh\_pt->nregion\_element(r);
   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} e=0;e<nel;e++)
    \{     
     FiniteElement* el\_pt=Solid\_mesh\_pt->region\_element\_pt(r,e);
     el\_pt->output(some\_file,n\_plot);
    \}
   some\_file.close();
  \}
 
 
 \textcolor{comment}{// Do animation of Helmholtz solution}
 \textcolor{comment}{//-----------------------------------}
 \textcolor{keywordtype}{unsigned} nstep=40;
 \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} i=0;i<nstep;i++)
  \{
   sprintf(filename,\textcolor{stringliteral}{"%s/helmholtz\_animation%i\_frame%i.dat"},
           Doc\_info.directory().c\_str(),
           Doc\_info.number(),i);
   some\_file.open(filename);
   \textcolor{keywordtype}{double} phi=2.0*MathematicalConstants::Pi*double(i)/double(nstep-1);
   \textcolor{keywordtype}{unsigned} nelem=Helmholtz\_mesh\_pt->nelement();
   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} e=0;e<nelem;e++)
    \{
     HELMHOLTZ\_ELEMENT* el\_pt=\textcolor{keyword}{dynamic\_cast<}HELMHOLTZ\_ELEMENT*\textcolor{keyword}{>}(
      Helmholtz\_mesh\_pt->element\_pt(e));
     el\_pt->output\_real(some\_file,phi,n\_plot);    
    \}
   some\_file.close();
  \}

 cout << \textcolor{stringliteral}{"Doced for Q="} << \hyperlink{namespaceGlobal__Parameters_a7814fddf663e56168174a42d2cd6b4c1}{Global\_Parameters::Q} << \textcolor{stringliteral}{" (step "}
      << Doc\_info.number() << \textcolor{stringliteral}{")\(\backslash\)n"};
 
\textcolor{comment}{// Increment label for output files}
 Doc\_info.number()++;
 
\} \textcolor{comment}{//end doc}



\textcolor{comment}{//=======start\_of\_main==================================================}\textcolor{comment}{}
\textcolor{comment}{/// Driver for acoustic fsi problem}
\textcolor{comment}{}\textcolor{comment}{//======================================================================}
\textcolor{keywordtype}{int} \hyperlink{acoustic__fsi_8cc_a3c04138a5bfe5d72780bb7e82a18e627}{main}(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char} **argv)
\{

 \textcolor{comment}{// Store command line arguments}
 CommandLineArgs::setup(argc,argv);

 \textcolor{comment}{// Define possible command line arguments and parse the ones that}
 \textcolor{comment}{// were actually specified}
 
 \textcolor{comment}{// Output directory}
 CommandLineArgs::specify\_command\_line\_flag(\textcolor{stringliteral}{"--dir"},
                                            &\hyperlink{namespaceGlobal__Parameters_a301ab922df72030c660b21328d6caf76}{Global\_Parameters::Directory});
 
 \textcolor{comment}{// Peakiness parameter for loading}
 CommandLineArgs::specify\_command\_line\_flag(\textcolor{stringliteral}{"--alpha"},
                                            &\hyperlink{namespaceGlobal__Parameters_afbe27ad463a1fb23cb99d029a9fac731}{Global\_Parameters::Alpha});

 \textcolor{comment}{// Multiplier for number of elements in solid mesh}
 CommandLineArgs::specify\_command\_line\_flag(\textcolor{stringliteral}{"--el\_multiplier"},
                            &\hyperlink{namespaceGlobal__Parameters_a35d5d2ecfff0cec6150a5dc79e5c1ad1}{Global\_Parameters::El\_multiplier});
 
 \textcolor{comment}{// Outer radius of Helmholtz domain}
 CommandLineArgs::specify\_command\_line\_flag(\textcolor{stringliteral}{"--outer\_radius"},
                            &\hyperlink{namespaceGlobal__Parameters_a88ded445ecd7bd89701409e68fd0b900}{Global\_Parameters::Outer\_radius});
  
 \textcolor{comment}{// Validaton run?}
 CommandLineArgs::specify\_command\_line\_flag(\textcolor{stringliteral}{"--validation"});
 
 \textcolor{comment}{// Max. number of adaptations}
 \textcolor{keywordtype}{unsigned} max\_adapt=3;
 CommandLineArgs::specify\_command\_line\_flag(\textcolor{stringliteral}{"--max\_adapt"},&max\_adapt);
 
 \textcolor{comment}{// Parse command line}
 CommandLineArgs::parse\_and\_assign(); 
 
 \textcolor{comment}{// Doc what has actually been specified on the command line}
 CommandLineArgs::doc\_specified\_flags();

 \textcolor{comment}{//Set up the problem}
 \hyperlink{classCoatedDiskProblem}{CoatedDiskProblem}<ProjectableTimeHarmonicLinearElasticityElement
                   <TTimeHarmonicLinearElasticityElement<2,3> >,
                   RefineableQHelmholtzElement<2,3> > problem; 


 \textcolor{comment}{// Set values for parameter values}
 \hyperlink{namespaceGlobal__Parameters_a7814fddf663e56168174a42d2cd6b4c1}{Global\_Parameters::Q}=5.0; 
 \hyperlink{namespaceGlobal__Parameters_a517d4c31b8bce6563c2f605266dd9679}{Global\_Parameters::Density\_ratio}[0]=0.1; 
 \hyperlink{namespaceGlobal__Parameters_a517d4c31b8bce6563c2f605266dd9679}{Global\_Parameters::Density\_ratio}[1]=0.1; 
 \hyperlink{namespaceGlobal__Parameters_ae0f9a80fb7510dbfbbef22582da231b7}{Global\_Parameters::update\_parameter\_values}();
 
 \textcolor{comment}{//Parameter study}
 \textcolor{keywordtype}{unsigned} nstep=3; 
 \textcolor{keywordflow}{if} (CommandLineArgs::command\_line\_flag\_has\_been\_set(\textcolor{stringliteral}{"--validation"}))
  \{
   nstep=1;
   max\_adapt=2;
  \}
 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} i=0;i<nstep;i++)
  \{
   \textcolor{comment}{// Solve the problem with Newton's method, allowing}
   \textcolor{comment}{// up to max\_adapt mesh adaptations after every solve.}
   problem.newton\_solve(max\_adapt);

   \textcolor{comment}{// Doc solution}
   problem.doc\_solution();

   \textcolor{comment}{// Make rib a lot heavier but keep its stiffness}
   \textcolor{keywordflow}{if} (i==0)
    \{
     \hyperlink{namespaceGlobal__Parameters_a73c731fa617a9d92851e4195493262e7}{Global\_Parameters::E\_pt}[1]->update\_constitutive\_parameters(
      \hyperlink{namespaceGlobal__Parameters_a20fccdcfa2c15ad8b951b9ada3bb1661}{Global\_Parameters::Nu},1.0);
     \hyperlink{namespaceGlobal__Parameters_a517d4c31b8bce6563c2f605266dd9679}{Global\_Parameters::Density\_ratio}[1]=10.0; 
     \hyperlink{namespaceGlobal__Parameters_ae0f9a80fb7510dbfbbef22582da231b7}{Global\_Parameters::update\_parameter\_values}();
    \}

   \textcolor{comment}{// Make rib very soft and inertia-less}
   \textcolor{keywordflow}{if} (i==1)
    \{
     \hyperlink{namespaceGlobal__Parameters_a73c731fa617a9d92851e4195493262e7}{Global\_Parameters::E\_pt}[1]->update\_constitutive\_parameters(
      \hyperlink{namespaceGlobal__Parameters_a20fccdcfa2c15ad8b951b9ada3bb1661}{Global\_Parameters::Nu},1.0e-16);
     \hyperlink{namespaceGlobal__Parameters_a517d4c31b8bce6563c2f605266dd9679}{Global\_Parameters::Density\_ratio}[1]=0.0; 
     \hyperlink{namespaceGlobal__Parameters_ae0f9a80fb7510dbfbbef22582da231b7}{Global\_Parameters::update\_parameter\_values}();
    \}
   
   
  \}
 
\} \textcolor{comment}{//end of main}








\end{DoxyCodeInclude}




 

\hypertarget{index_sources}{}\section{Source files for this tutorial}\label{index_sources}

\begin{DoxyItemize}
\item The source files for this tutorial are located in the directory\+:~\newline
~\newline
 \begin{center} \href{../../../../demo_drivers/interaction/acoustic_fsi}{\tt demo\+\_\+drivers/interaction/acoustic\+\_\+fsi/ } \end{center} ~\newline

\item The driver code is\+: ~\newline
~\newline
 \begin{center} \href{../../../../demo_drivers/interaction/acoustic_fsi/unstructured_acoustic_fsi.cc}{\tt demo\+\_\+drivers/interaction/acoustic\+\_\+fsi/unstructured\+\_\+acoustic\+\_\+fsi.\+cc } \end{center} 
\end{DoxyItemize}



 

 \hypertarget{index_pdf}{}\section{P\+D\+F file}\label{index_pdf}
A \href{../latex/refman.pdf}{\tt pdf version} of this document is available. \end{document}
