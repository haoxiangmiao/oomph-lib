\mainpage A discussion on oomph-lib's Block Preconditioning Framework


In this document we discuss \c oomph-libs block preconditioning
framework. We describe the functionality of the framework by starting with 
discussing the implementation of a simple block diagonal
preconditioner, ...


ADD: HOW TO USE (PASS MESH)

The aim of the block preconditioning framework is to provide a simple 
environment to facilitate the implementation of distributed block 
preconditioners which in particular allows existing (block) preconditioners to 
be reused to create in hierarchical fashion new block preconditioners for 
multi-physics problems. In some examples we will reuse existing general purpose
block preconditioners for the subsidiary problems.


\section theory Theoretical Background

In \c oomph-lib, all problems are solved by Newton's method,
which requires the repeated solution of linear systems of the form

\f[
J\;{\bf \delta x}=-{\bf r}
\f]

for the Newton correction \f$\bf \delta x\f$ where \f$J\f$ is the
Jacobian matrix and \f$\bf r\f$ is the vector of residuals. (Left) 
preconditioning represents a transformation of the original linear system to

\f[
P^{-1}J\;{\bf \delta x}=-P^{-1}{\bf r}
\f]

introduced with the aim of accelerating the convergence of Krylov subspace 
iterative methods such as GMRES or CG. The application of the preconditioner 
requires the solution of

\f[
P{\bf z}={\bf y}
\f]

for \f$\bf z\f$ at each Krylov iteration.

Block preconditioning requires special enumeration schemes for the unknowns 
(equivalent to reordering the linear systems) where all the unknowns 
corresponding to each type of DOF are grouped together and enumerated 
consecutively. This leads to a natural block structure of the linear systems.

For instance, linear elasticity problems (discussed 
<a href="../../../linear_elasticity/periodic_load/html/index.html">here</A>) 
involve the solid (the nodal positions in the solid domain) degrees of
freedom (DOFs). Consider the two-dimensional case, we begin by
reordering the linear system to group together the two types of DOF

\f[
\left[ 
\begin{array}{cc}
S_{xx}&S_{xy}\\
S_{xy}&S_{yy}
\end{array}
\right]
\left[ 
\begin{array}{c}
\bf \delta x_x\\
\bf \delta x_y\\
\end{array}
\right]
=
-
\left[
\begin{array}{c}
\bf r_x\\
\bf r_y\\
\end{array}
\right],
\f]

The block diagonal preconditiner of the form 
\f[
P_{diag}=
\left[
\begin{array}{cc}
S_{xx}& \\
      &S_{yy}
\end{array}
\right]
\f]
is obtained by omitting the off-diagonal blocks from the Jacobian.

The application of the preconditioner requires the solution of the linear system

\f[
\left[
\begin{array}{cc}
S_{xx}& \\
      &S_{yy}
\end{array}
\right]
\left[
\begin{array}{c}
\bf z_x\\
\bf z_y\\
\end{array}
\right]
=
\left[
\begin{array}{c}
\bf y_x\\
\bf y_y
\end{array}
\right],
\f]

the two sub-blocks are solved directly.

\section generic_implementation Framework Overview

The above example shows that the application of block preconditioners
typically require several generic steps:

-# The classification of the DOFs.
-# The application of subsidiary preconditioning operators such as 
   the solution of linear systems or the evaluation of matrix-vector 
   products with some of the blocks that are extracted from the
   original linear system.
   

The following subsections describe how these tasks are performed
within \c oomph-lib's block preconditioning framework.

\subsection block_preconditionable_elements Block Preconditionable Elements

The classification of DOFs is implemented at an elemental level. 
The class \c GeneralisedElement
contains two broken virtual methods that must be re-implemented to
label the DOFs with their type. The methods are:

- \c GeneralisedElement::ndof_types() must return the number of DOF types
  associated with an element.
- \c GeneralisedElement::get_dof_numbers_for_unknowns(...) must return
  a list of pairs comprising a map from global equation number to 
  DOF type for all unknowns in the element.

These are already implemented for many elements. If not, the functions
are easy to write. For instance, \c oomph-lib's linear elasticity
elements can easily be made block-preconditionable with a wrapper around the element:

\dontinclude two_d_linear_elasticity_with_simple_block_diagonal_preconditioner.cc
\skipline  start_of_mylinearelasticityelement
\until };
Thus, in the two-dimensional \c MyLinearElasticityElement<2> we 
have two types of DOF, corresponding to the displacements in the 
\f$x\f$ and \f$y\f$ directions. They are enumerated \c 0 and \c 1, respectively.

\subsection dof_types_and_block_types DOF Types and Block Types

In the block diagonal preconditioner for the two-dimensional linear
elasticity problem, we have DOF types that correspond directly to
the blocks in the (re-ordered) Jacobian matrix. However, it is
possible to combine the blocks associated with multiple DOFs into a
single block in which case the number of blocks is smaller than the
number of DOF types. The relationship between DOF types, block types, 
the elemental DOF type classification and meshes are as follows

- \b Elemental \b DOF \b type \b classification: Each element
  classifies its own DOF type  in the function 
  \c get_dof_numbers_for_unknowns(...). In the case of
  \c MyLinearElasticityElement<2> elements, the DOF types are classified
  as \c 0 and \c 1; for \c QTaylorHoodElement<2> Navier-Stokes 
  elements, the DOF types
  are classified as \c 0 and \c 1 for the \f$x\f$ and \f$y
  \f$-velocities, and \c 2 for the pressure \f$p\f$; etc
  .
- \b Role \b of \b meshes: When classifying the degrees of freedom into
  DOF types and blocks types, the block preconditioning framework
  visits all elements that make contributions to the Jacobian matrix
  and associates the global equation number with the DOF type
  specified by the element. The block preconditioning framework is
  given access to the elements via (possibly multiple) meshes (here
  simply interpreted as containers for elements), each of 
  which is assumed to contain elements of a single type. The total
  number of DOF types in the block preconditioner is the
  sum of the DOF types of the elements in the meshes. For
  instance, in a 2D fluid-structure interaction problem we have two
  different element types, the solid elements (which contain the
  x- and y- solid-displacements, u_x and u_y, respectively, assumed to be 
  enumerated as DOF types
  0 and 1 by these elements) and the fluid elements (which contain the
  x- and y- fluid velocities, v_x and v_y,  and the pressure, p, assumed to 
  be enumerated as DOF types
  0, 1 and 2 by these elements). Assuming the mesh of solid elements
  is specified as mesh 0 and the mesh of fluid elements is mesh 1, the
  block preconditioner has a total of five DOF types which represent,
  in order, u_x, u_y, v_x, v_y, p. Note that if certain degrees of
  freedom are classified by multiple elements the most recent
  assignment of the DOF type over-writes previous assignments.
  The order in which meshes are specified therefore matters. 
  .
- \b Block \b types: The block types are the sub-blocks of the system matrix
  (the Jacobian matrix from the Newton method) that the block
  preconditioner works with. They may contain more than one
  DOF type or be as fine grained as the number of DOF types (though
  there can not be more block types than there are DOF types in the
  block preconditioner). For example, in case of the the Navier-Stokes LSC
  preconditioner (in 2D) we have three DOF types (\f$x\f$ and
  \f$y\f$-velocities and pressure), but the preconditioner works with 
  just two block types (forming the velocity and pressure blocks). The setup
  of the block types is handled by the function \c block_setup(...) discussed
  below.

\section multi_poisson Simple preconditioner examples

We will now illustrate the capabilities of the block preconditioning
framework by considering a system of \f$ N \f$ coupled PDEs 
\f[ 
\left( \frac{\partial^2 u_i}{\partial x_j^2} 
+ \beta \sum_{k=1}^{N} u_k \right)  = f_i(x_j) \ \ \ \ i=1,...,N
\ \ \ \ \ \ \ \ \ \ \ \ @E[eqn:multi_poisson_pde]@
\f]
for the  \f$ N \f$ fields  \f$ u_i(x_j) \f$. If  \f$ \beta=0 \f$,
the system represents  \f$ N \f$ (uncoupled) Poisson equations,
each with their own source function  \f$ f_i(x_j). \f$ If  \f$ \beta
\ne 0 \f$ the PDE for \f$ u_i(x_j) \f$ is affected by all other
fields via the Helmholtz-like second term on the left-hand-side.


The \c MultiPoissonElements implement a discretise the equations 
with standard Galerkin-type finite elements in which each field
is treated as its own DOF type. If  \f$ N = 5, \f$ the linear system 
to be solved in the course of the Newton method,
\f[
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ 
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ 
{\bf J} \ \delta {\bf x} = -{\bf r},
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ 
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ 
@E[eqn:newton_system]@
\f]
has a \f$5 \times 5\f$  block structure implying that, following a re-numbering
of the unknowns, the matrix and the vectors can be written as
\f[
\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\;
\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:
{\bf J} = 
\left(
\begin{array}{ccccc}
J_{11} & J_{12} & J_{13} & J_{14} & J_{15} \\
J_{21} & J_{22} & J_{23} & J_{24} & J_{25} \\
J_{31} & J_{32} & J_{33} & J_{34} & J_{35} \\
J_{41} & J_{42} & J_{43} & J_{44} & J_{45} \\
J_{51} & J_{52} & J_{53} & J_{54} & J_{55} \\
\end{array}
\right),
 \ \
\delta {\bf x} = 
\left(
\begin{array}{c}
\delta x_{1}  \\
\delta x_{2}  \\
\delta x_{3}  \\
\delta x_{4}  \\
\delta x_{5}  \\
\end{array}
\right)
 \ \mbox{ and } \ 
{\bf r} = 
\left(
\begin{array}{c}
r_{1}  \\
r_{2}  \\
r_{3}  \\
r_{4}  \\
r_{5}  \\
\end{array}
\right).
\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:
\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:
@E[eqn:orig_linear_system]@
\f]
We wish to solve this linear system by preconditioned Krylov subspace methods,
using a block preconditioner \f${\bf P}\f$ formed (formally) 
from the blocks of the system matrix \f${\bf }J\f$. As
discussed above, the
application of the preconditioner (typically once per iteration of the
Krylov solver) then requires the solution of linear systems of the form
\f$
{\bf P} {\bf y} = {\bf z},
\f$ 
for \f${\bf y}\f$. The preconditioning operation can also be written as
\f$
{\bf y} = {\bf P}^{-1} {\bf z}
\f$ 
where the operator \f${\bf P}^{-1}\f$ represents 
the application of the preconditioner to a vector \f${\bf z}\f$. 
Formally, the operator \f${\bf P}^{-1}\f$ represents the inverse of 
the matrix \f${\bf P}\f$ but its application may, of course, be performed  
approximately by another ``subsidiary'' preconditioner/inexact solver
e.g. by performing a small number of multigrid cycles, say.
(Note that we say ``formally'' because the preconditioner does not
actually have to be associated with a specific matrix -- it simply has
to act as a linear operator that ``turns \f${\bf z}\f$ into \f${\bf y}\f$'').

A specific block preconditioner must be derived from the
\c BlockPreconditioner base class and must implement two 
pure virtual member functions of the underlying \c Preconditioner
class:
- \c void \c Preconditioner::setup(): This function is
called once during the solution of a given linear system
by any of \c oomph-lib 's Krylov subspace solvers. It typically 
extracts a  certain number of blocks from the matrix \f${\bf J}\f$, possibly 
manipulates its local copies of these blocks, and performs any 
preliminary computations required 
to allow the rapid subsequent application of \f${\bf P}^{-1}\f$.
- \c void \c Preconditioner::preconditioner_solve(\f$\bf{z}\f$,\f$\bf{y}\f$):
This function applies \f${\bf P}^{-1}\f$ to the input argument
\f${\bf z}\f$ and returns \f${\bf y}\f$, typically using some data that has
been pre-computed in the \c setup() function.

We will discuss the implementation of these functions (and associated
capabilities of the block preconditioning framework)
in a number of increasingly complex block preconditioners
for the solution of the \f$5 \times 5\f$ linear system 
defined by equations (@R[eqn:newton_system]@) and
(@R[eqn:orig_linear_system]@). We stress that the purpose
of this exercise is not the development of particularly clever
preconditioners but simply an excuse to demonstrate the use of the
available ``machinery''. Specifically we will demonstrate how to:

- extract selected blocks from the system matrix (the Jacobian matrix).

- perform matrix vector products with selected off-diagonal blocks.

- solve linear systems associated with selected blocks, using either a
  direct solver and/or subsidiary preconditioners, including cases where the
  subsidiary preconditioners are block preconditioners themselves.

- replace and modify selected blocks and how to make make such
  modified blocks available to subsidiary block preconditioners.

- concatenate and coarsen blocks.




*** hierher how to call *** 

hierher kill below

These will be illustrated through the following preconditioners (and
associated sub-preconditioners):

- \ref diagonal

 - Extraction of selected blocks from the Jacobian. 

 - Exact solvers.

- \ref upper_triangular, making use of:

 - Extraction of selected blocks from the Jacobian.

 - Off diagonal matrix vector products.

 - Exact solvers.

- \ref two_plus_three, making use of:
 - Extraction of selected blocks from the Jacobian.
 - Exact solvers.

- \ref two_plus_three_upper_triangular, making use of:

 - Extraction of selected blocks from the Jacobian.

 - Off diagonal matrix vector products.

 - Exact solvers.

- \ref two_plus_three_upper_triangular_with_sub, making use of:

 - Extraction of selected blocks from the Jacobian.

 - Subsidiary block preconditioner.

 - Off diagonal matrix vector products.

 - Exact solvers.

- \ref two_plus_three_upper_triangular_with_replace, making use of:

 - Extraction of selected blocks from the Jacobian.

 - Replacement.

 - Concatenation.

 - Off diagonal matrix vector products.

 - Exact solvers.

 - Subsidiary block preconditioner.

- \ref coarse_two_plus_two_plus_one, making
 use of:

 - Subsidiary block preconditioner.

 - Exact solvers.

 - Extraction of selected blocks from the Jacobian.

 - Concatenation.
 
 - Coarsening.


hierher kill above


#####################################################################
#####################################################################


<HR>
<HR>


#####################################################################
#####################################################################


\subsection diagonal A Block Diagonal Preconditioner

NEW BITS: How to extract matrix blocks and corresponding block vectors
from their full-size counterparts.

\subsubsection diag_theory Theory

The simplest possible block preconditioner is a block-diagonal 
preconditioner, formed by retaining only the diagonal blocks of
\f${\bf J}\f$, so that
\f[

\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:
\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:
\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:
{\bf P} = 
\left(
\begin{array}{ccccc}
J_{11} & & & & \\
& J_{22} &  &  & \\
 & & J_{33} & & \\
 & & & J_{44} & \\
 &  & &  & J_{55} \\
\end{array}
\right).
\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:
\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:
\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:
@E[eqn:diag_reordered_linear_system]@
\f]
The application of this preconditioner (i.e. the solution of the
linear system \f${\bf P} {\bf
  y} ={\bf z}\f$ for \f${\bf y}\f$) requires the solution of the 
five much smaller linear systems
\f[
\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:
\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:
\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:
\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:
\begin{array}{c}
{\bf J}_{11} \ {\bf y}_1 = {\bf z}_1, \\
{\bf J}_{22} \ {\bf y}_2 = {\bf z}_2, \\
{\bf J}_{33} \ {\bf y}_3 = {\bf z}_3, \\
{\bf J}_{44} \ {\bf y}_4 = {\bf z}_4, \\
{\bf J}_{55} \ {\bf y}_5 = {\bf z}_5, \\
\end{array}
\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:
\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:
\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:
@E[eqn:diag_prec]@
\f]
where we have assumed that the two vectors \f${\bf y}\f$ and \f${\bf z}\f$
are re-ordered into ``block vectors'' in the same way as 
the vectors \f$\delta {\bf x}\f$ and \f${\bf r}\f$ in 
"the original linear system" (@R[eqn:newton_system]@) are re-ordered into
the ``block vectors'' in (@R[eqn:orig_linear_system]@).

The implementation of the preconditioning operations in 
(@R[eqn:diag_prec]@)  can naturally be subdivided into two
distinct \c setup() and \c preconditioner\_solve(...) phases.
Assuming that the linear systems in (@R[eqn:diag_prec]@) are solved exactly 
by a direct solver (an ``exact preconditioner'') that 
can pre-compute and store the LU decomposition of the diagonal matrix blocks,
the \c setup() phase involves the following operations
[text in square brackets refers to their \c oomph-lib specific 
implementation]:
- Set up any data structures/lookup tables that are required to 
extract matrix blocks from the original matrix
\f${\bf J}\f$ [by calling
the \c BlockPreconditioner::block\_setup() function]. 
- Extract the five diagonal blocks \f${\bf J}_{ii}\f$ 
(for \f$i=1,...,5\f$) [using the 
\c BlockPreconditioner::get\_block(...) function].
- Compute and store the LU decomposition of the diagonal blocks
to allow the rapid solution of the systems \f${\bf J}_{ii} \ {\bf y}_i = 
{\bf z}_i\f$ (for \f$i=1,...,5\f$) during the \c preconditioner\_solve(...)
phase by back-substitution. [This is done by calling the \c setup(...)
function of the subsidiary preconditioner/inexact solver. Following this,
the diagonal matrix blocks are longer required and can be deleted.]

Once the \c setup() phase has been completed, the solution of the linear
system \f${\bf P} {\bf y} = {\bf z}\f$ by the \c preconditioner\_solve(...) 
function involves the following steps:
- Extract the five ``block vectors'' \f${\bf z}_i\f$ (for \f$i=1,...,5\f$)
from the vector \f${\bf z}\f$ [using the 
\c BlockPreconditioner::get\_block\_vectors(...) function].
- Solve the linear systems \f${\bf J}_{ii} \ {\bf y}_i = 
{\bf z}_i\f$ for the vectors \f${\bf y}_i\f$ (for \f$i=1,...,5\f$)  using 
the LU decomposition of the diagonal blocks \f${\bf J}_{ii}\f$ 
(for \f$i=1,...,5\f$) created during the \c setup() phase.
- Combine the five ``block vectors'' \f${\bf y}_i\f$ (for \f$i=1,...,5\f$)
to the full-length vector \f${\bf y}\f$ [using the 
\c BlockPreconditioner::return\_block\_vectors(...) function].

\subsubsection diag_implementation Implementation as a BlockPreconditioner
Here is a sample implementation of the diagonal block preconditioner
as a class \c Diagonal, derived from the \c BlockPreconditioner base 
class. The class provides storage for the subsidiary preconditioners
that solve the linear systems associated with the diagonal blocks, 
implements the \c setup() and \c preconditioner\_solve(...)
functions, and provides a helper function \c clean\_up\_my\_memory()
which does what it says.

\dontinclude multi_poisson_block_preconditioners.h
\skipline start_of_diagonal_class
\until };


\subsubsection diag_setup The setup() function

As mentioned above, a \c Preconditioner's \c setup() function is
called at the beginning of the \c IterativeLinearSolver's 
\c solve(...) function. In time-dependent and/or nonlinear
problems many (different) linear systems have to be solved by the same
linear solver (and the associated preconditioner) throughout the code 
execution. To avoid memory leaks it is therefore 
important to free up any memory that may have been allocated in
previous uses of the preconditioner. The \c setup() function of 
all block preconditioner should therefore always 
start by freeing up such memory. This is best done by using a helper
function that can also be called from the destructor. 

\skip start_of_setup_for_simple
\until this->clean_up_my_memory();

Next we call the \c block_setup() function to set up the internal data
structures and lookup tables required to extract blocks from the
system matrix.

\skip //
\until this->block_setup();

We create five subsidiary preconditioners (all exact solvers -- SuperLU
in its incarnation as a preconditioner) for the solution of the
linear systems involving the diagonal blocks:

\skip //
\until }


Next we set up the subsidiary preconditioner by
extracting the diagonal blocks from the system matrix
and passing them to the subsidiary preconditioners. 

Note that each preconditioner is expected to retain a copy
of whatever data it needs to subsequently perform its 
\c preconditioner_solve(...)
function. The deep copy of the block that is returned by the
\c get\_block(...) function can therefore be deleted (here simply
go out of scope) once the subsidiary preconditioner has been set up.
(In the specific case of the \c SuperLUPreconditioner, the \c setup(...)
function computes and stores the LU decomposition of the matrix;
the matrix itself is then no longer required). 

\skip //
\until }


\subsubsection diag_solve The preconditioner_solve() function

To apply the preconditioner to a given vector, r, we first
extract the five block-vectors whose sizes (and permutations) match
that of the diagonal matrix blocks, using the
\c get_block_vectors(...) function.


\skip //======
\until this->get_block

We then provide storage for the five solution vectors and obtain them
by applying the subsidiary preconditioners' \c
preconditioner_solve(...) function:

\skip //
\until }

Finally the solutions in \c block_z are returned into the 
full-length solution vector \c z via a call to 
\c return_block_vectors(...). 

\skip //
\until }

\subsubsection diag_clean The clean_up_my_memory() function
The clean-up function (which is called by the \c setup()
function and the destructor) frees the memory that is
allocated when a new linear system is solved -- here the
subsidiary preconditioners and their associated data (the
LU decompositions of the diagonal blocks).


\skip //
\until // End of clean_up_my_memory function.

\subsubsection diag_comments Comments and Exercises

- \c The function \c get_block_vectors(r,block_r) extracts the five
  (or, in general, \c nblock_type() ) block vectors \c block_r from the
  full-length vector \c r. The sizes of the block vectors (and the 
  permutation of their entries relative
  to their order in the full length vector \c r) match that of the
  matrix blocks. There is an alternative function \c get_block_vector(...)
  (note the missing s) which extracts a single block vector; see ***
  hierher *** for an example of its use.
  An equivalent version exists for the \c return_block_vector[s]
  functions. hierher why shoudldn't we "mix them"?
- In the example above we used an "exact preconditioner" (direct solver)
  to solve the five linear systems associated with the diagonal blocks.
  However, the (approximate) solution of these linear systems can 
  be performed by any other matrix-based preconditioner, such as 
  \c oomph-lib's diagonal preconditioner, \c
  MatrixBasedDiagPreconditioner, discussed in 
  <a href="../../../linear_solvers/html/index.html">another tutorial</a>.
  hierher actually mention it there. The setup and application of this
  preconditioner is obviously much faster than for the \c
  SuperLUPreconditioner. Its setup merely requires the extraction of the 
  diagonal  entries and storage of their inverses (rather than the
  computation of the LU decomposition), while the application 
  simply requires the multiplication of the input vector by the 
  pre-computed inverses of the diagonal entries (rather than a
  back-substitution). However, the preconditioner is clearly not
  "as good" and therefore results in a larger number of iterations
  in the iterative linear solver. In fact, using the diagonal preconditioner
  for the approximate solution of the five linear systems involving the
  diagonal blocks is mathematically equivalent to using the
  diagonal preconditioner on the entire matrix. Try it out! 
  hierher tony can this be re-instated?


#####################################################################
#####################################################################


<HR>
<HR>


#####################################################################
#####################################################################


\subsection upper_triangular A Block Upper Triangular Preconditioner

NEW BITS: How to set up matrix vector products with off-diagonal blocks

\subsubsection upper_triangular_theory Theory

Next we consider the implementation of an upper triangular
preconditioner, formed by retaining only the blocks in the upper right
hand part of \f${\bf J}\f$, including the diagonals.
\f[
\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:
\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:
\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:
{\bf P} = 
\left(
\begin{array}{ccccc}
J_{11} & J_{12} & J_{13} & J_{14} & J_{15} \\
& J_{22} &  J_{23} &  J_{24} & J_{25} \\
 & & J_{33} & J_{34} & J_{35} \\
 & & & J_{44} & J_{45} \\
 &  & &  & J_{55} \\
\end{array}
\right).
\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:
\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:
\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:
@E[eqn:upper_triangular_reordered_linear_system]@
\f]
The application of this preconditioner (i.e. the solution of the
linear system \f${\bf P} {\bf
  y} ={\bf z}\f$ for \f${\bf y}\f$) again requires the solution of 
five much smaller linear systems
\f[

\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:
\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:
\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:
\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:
\begin{array}{l}
{\bf J}_{11} \ {\bf y}_1 = {\bf z}_1 - {\bf J}_{15} \ {\bf y}_5 - {\bf J}_{14} \ {\bf y}_4 - {\bf J}_{13} \ {\bf y}_3 - {\bf J}_{12} \ {\bf y}_2, \\
{\bf J}_{22} \ {\bf y}_2 = {\bf z}_2 - {\bf J}_{25} \ {\bf y}_5 - {\bf J}_{24} \ {\bf y}_4 - {\bf J}_{23} \ {\bf y}_3, \\
{\bf J}_{33} \ {\bf y}_3 = {\bf z}_3 - {\bf J}_{35} \ {\bf y}_5 - {\bf J}_{34} \ {\bf y}_4, \\
{\bf J}_{44} \ {\bf y}_4 = {\bf z}_4 - {\bf J}_{45} \ {\bf y}_5, \\
{\bf J}_{55} \ {\bf y}_5 = {\bf z}_5, \\
\end{array}
\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:
\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:
\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:
@E[eqn:upper_triangular_prec]@
\f]
where we have again assumed that the two vectors 
\f${\bf y}\f$ and \f${\bf z}\f$
are re-ordered into ``block vectors'' in the same way as 
the vectors \f$\delta {\bf x}\f$ and \f${\bf r}\f$ in 
"the original linear system" (@R[eqn:newton_system]@) are re-ordered into
the ``block vectors'' in (@R[eqn:orig_linear_system]@).

The main difference to the block diagonal preconditioner considered
before is that the right hand sides of the linear systems have to be
modified. We start by solving the final equation for \f$ {\bf y}_5
\f$. We then multiply this vector by the off-diagonal block \f$ {\bf J}_{45}
\f$, subtract the result from \f$ {\bf z}_4 \f$ and use the result of
this operation as the right-hand-side for the linear system that determines
\f$ {\bf y}_4\f$,  etc.

The implementation of the preconditioning operations in 
(@R[eqn:upper_triangular_prec]@)  can again be subdivided into two
distinct \c setup() and \c preconditioner\_solve(...) phases.
Assuming that the linear systems in (@R[eqn:upper_triangular_prec]@)
are solved exactly by a direct solver (an ``exact preconditioner'')
that can pre-compute and store the LU decomposition of the diagonal
matrix blocks, the \c setup() phase involves the following operations
[text in square brackets refers to their \c oomph-lib specific 
implementation]:
- Set up any data structures/lookup tables that are required to 
extract matrix blocks from the original matrix
\f${\bf J}\f$ [by calling
the \c BlockPreconditioner::block\_setup() function]. 
- Extract the five diagonal blocks \f${\bf J}_{ii}\f$ 
(for \f$i=1,...,5\f$) [using the 
\c BlockPreconditioner::get\_block(...) function].
- Compute and store the LU decomposition of the diagonal blocks
to allow the rapid solution of the systems \f${\bf J}_{ii} \ {\bf y}_i = 
{\bf z}_i\f$ (for \f$i=1,...,5\f$) during the \c preconditioner\_solve(...)
phase by back-substitution. [This is done by calling the \c setup(...)
function of the subsidiary preconditioner/inexact solver. Following this,
the diagonal matrix blocks are longer required and can be deleted.]
- Extract the relevant off-diagonal blocks from \f${\bf J}\f$ and create 
\c MatrixVectorProduct operators. [The matrix vector products are 
set up using the 
\c setup_matrix_vector_product(...) function. As with the subsidiary
preconditioners, the \c MatrixVectorProduct operators retain their own
copy of any required data, so the off-diagonal matrix blocks can be
deleted (or be allowed to go out of scope) following the setup.]

\subsubsection upper_triangular_implementation Implementation as a BlockPreconditioner
Here is a sample implementation of the upper triangular block preconditioner
as a class \c UpperTriangular, derived from the \c BlockPreconditioner base 
class. The class provides storage for the subsidiary preconditioners
that solve the linear systems associated with the diagonal blocks, and
the \c MatrixVectorProduct operators. We also implement the \c
setup() and \c preconditioner\_solve(...) functions, and provide a
helper function \c clean\_up\_my\_memory() which does what it says.

\dontinclude multi_poisson_block_preconditioners.h
\skipline start_of_upper_triangular_class
\until };

\subsubsection upper_triangular_setup The setup() function
As before, we start by cleaning up the memory and set up
the generic block preconditioner functionality by calling 
\c block_setup().

\skip start_of_setup_for_upper_triangular
\until this->block_setup();

We provide storage for the (pointers to the) matrix vector products
and the subsidiary preconditioners.

\skip //
\until Block_preconditioner_pt.resize(nblock_types);

Next we create the subsidiary preconditioners which we will use to 
solve the linear systems involving the diagonal blocks.

\until end of brace

We then extract the relevant off-diagonal blocks (those above the
diagonal) from the full matrix, create a \c MatrixVectorProduct 
operator for each and 
use the \c BlockPreconditioner::setup_matrix_vector_product(...) function
to make them fully functional. Note that the final argument to this
function (the column index of the off-diagonal block in its block enumeration
within the current preconditioner) is required to set up additional lookup
tables that are required to ensure the correct operation of this object
in cases when the preconditioner operates in parallel. The details are
messy and not worth explaining here -- just do it!


*** hierher COMMENT: forward reference to hand-built compound matrix ***

\skip //
\until // End setup

\subsubsection upper_triangular_solve The preconditioner_solve() function
As in the block diagonal preconditioner, we start by extracting the
block vectors from the full-length vector, \c r.

\skip //======
\until this->get_block

Next we provide storage for the solution vectors and 
work backwards through the (block)-rows of the (block-)linear
system (@R[eqn:upper_triangular_prec]@). Following each linear solve
we update the right-hand-side of the next linear system, as discussed
above.

\skip //
\until // End for over i

Finally, the solutions in \c block_z are combined via \c
return_block_vectors(...) which places the results back
into the full-length vector \c z that is returned by this function.

\skip //
\until }

\subsubsection upper_triangular_clean The clean_up_my_memory() function
The clean up memory functions again deletes any data that was
allocated in the setup function -- here the subsidiary preconditioners
(and their LU decompositions) and the matrix-vector product operators.

\skip //
\until // End of clean_up_my_memory function.




#####################################################################
#####################################################################


<HR>
<HR>


#####################################################################
#####################################################################

\subsection two_plus_three Combining multiple dof types into compound blocks. Part 1

NEW BITS: How to combine multi dof types into compound blocks

\subsubsection two_plus_three_theory Theory
So far we have illustrated how to implement block preconditioners 
for cases where the DOF types (as identified by the elements) 
correspond directly to 
the block types. This is appropriate for our model PDE system 
(@R[eqn:multi_poisson_pde]@) in which the five fields (and the governing
equations) are all of the same type. In many applications,
particularly in multi-physics problems, it
may be desireable to combine similar/related DOF types into single
blocks. For instance, in a 2D fluid-structure interaction problem,
we may wish to distinguish between the two solid (x and y solid
displacements) and three fluid (x and y fluid velocities and the pressure)
DOFs and employ subsidiary preconditioners that act directly on 
the two distinct solid and fluid blocks. A basic block diagonal 
preconditioner for such a problem that ignores the coupling between 
fluid and solid DOFs has the following structure 
\f[
\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:
\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:
\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:
{\bf P} = 
\left(
\begin{array}{cc|ccc}
J_{11} & J_{12} & & & \\
J_{21} & J_{22} &  &  & \\
\hline 
 & & J_{33} & J_{34} & J_{35} \\
 & & J_{43} & J_{44} & J_{45} \\
 & & J_{53} & J_{54}  & J_{55} \\
\end{array}
\right)
=
\left(
\begin{array}{c|c}
B_{11}  & \\
\hline
        & B_{22} \\
\end{array}
\right)
\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:
\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:
\f]
where \f$ B_{11} \f$ and \f$ B_{22} \f$ are the blocks
formed from the corresponding "DOF blocks" (the \f$
J_{ij} \f$ matrices).
The application of this preconditioner (i.e. the solution of the
linear system \f${\bf P} {\bf
  y} ={\bf z}\f$ for \f${\bf y}\f$) requires the solution of the 
two smaller linear systems
\f[
\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:
\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:
\left(
\begin{array}{cc}
J_{11} & J_{12} \\
J_{21} & J_{22} \\
\end{array}
\right) \left(
\begin{array}{c}
y_1 \\
y_2 \\
\end{array}
\right) = \left(
\begin{array}{c}
z_1 \\ 
z_2 \\
\end{array}
\right)
\mbox{\ \ \ \ \ \ \ or \ \ \ \ \ \ }
B_{11} \ Y_1 = Z_1
\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:
\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:
\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:
@E[eqn:two_plus_three_prec1]@
\f]
and
\f[
\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:
\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:
\left(
\begin{array}{ccc}
J_{33} & J_{34} & J_{35} \\
J_{43} & J_{44} & J_{45} \\
J_{53} & J_{54} & J_{55} \\
\end{array}
\right) \left(
\begin{array}{c}
y_3 \\
y_4 \\
y_5 \\
\end{array}
\right) = \left(
\begin{array}{c}
z_3 \\ 
z_4 \\
z_5 \\
\end{array}
\right)
\mbox{\ \ \ \ \ \ \ or \ \ \ \ \ \ }
B_{22} \ Y_2 = Z_2.
\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:
\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:
@E[eqn:two_plus_three_prec2]@
\f]

A key feature of the block preconditioning framework is the ability
to combine DOF types in this manner so that the preconditioner can 
operate directly with blocks \f$ B_{11} \f$ and \f$ B_{22} \f$ and
the corresponding block vectors  \f$ Y_1, Y_2, Z_1 \f$ and \f$ Z_2 \f$.

Assuming again that the linear systems in
(@R[eqn:two_plus_three_prec1]@) and (@R[eqn:two_plus_three_prec2]@) are
solved exactly by a direct solver (an ``exact preconditioner'') that 
can pre-compute and store the LU decomposition of the diagonal matrix blocks,
\f$ B_{11} \f$ and \f$ B_{22} \f$, 
the \c setup() phase involves the following operations
[text in square brackets refers to their \c oomph-lib specific 
implementation]:
- Set up any data structures/lookup tables that are required to 
extract the matrix blocks \f$ B_{11} \f$ and \f$ B_{22} \f$ and
the associated block vectors [by calling
the \c BlockPreconditioner::block\_setup(...) function -- this time 
with arguments that specify the mapping between "DOF types" and 
"block types"]. 
- Extract the two diagonal blocks, \f$ B_{11} \f$ and \f$ B_{22}\f$  [using the 
\c BlockPreconditioner::get\_block(...) function].
- Compute and store the LU decomposition of the diagonal blocks
to allow the rapid solution of the systems during the
 \c preconditioner\_solve(...)
phase by back-substitution.[This is done by calling the \c setup(...)
function of the subsidiary preconditioner/inexact solver. Following this,
the diagonal matrix blocks are longer required and can be deleted.]

Once the \c setup() phase has been completed, the solution of the linear
system \f${\bf P} {\bf y} = {\bf z}\f$ by the \c preconditioner\_solve(...) 
function involves the following steps:
- Extract the two ``block vectors'' \f${\bf Z}_i\f$ (for \f$i=1,2\f$)
from the vector \f${\bf z}\f$ [using the 
\c BlockPreconditioner::get\_block\_vectors(...) function].
- Solve the linear systems \f${\bf B}_{ii} \ {\bf Y}_i = 
{\bf Z}_i\f$ for the vectors \f${\bf Y}_i\f$ (for \f$i=1,2\f$)  using 
the LU decomposition of the diagonal blocks \f${\bf B}_{ii}\f$ 
(for \f$i=1,2\f$) created during the \c setup() phase.
- Combine the two ``block vectors'' \f${\bf Y}_i\f$ (for \f$i=1,...,2\f$)
to the full-length vector \f${\bf y}\f$ [using the 
\c BlockPreconditioner::return\_block\_vectors(...) function].

\subsubsection two_plus_three_implementation Implementation as a BlockPreconditioner

The implementation of the preconditioner closely follows that of the 
block diagonal preconditioner discussed above, the main difference
being that the current preconditioner only ever operates 
with exactly two blocks. Therefore store pointers to the two 
subsidiary preconditioners (rather than a vector of pointers 
that can store an arbitrary number of these).

\skip start_of_two_plus_three_class
\until };

\subsubsection two_plus_three_setup The setup() function

As usual, we start by freeing up any previously allocated memory. 
Since this preconditioner assumes explicity that the problem involves
five DOF types we check that this is actually the case.

\skip start_of_setup_for_two_plus_three
\until #endif

To indicate that several DOF types are to be combined into 
single blocks, we specify the mapping between DOF types and block types
as an argument to the \c block_setup(...) function
This is done by creating vector of length \c ndof_type()
in which each entry indicates the block that the corresponding
DOF is supposed to end up in:

\skip //
\until this->block_setup(dof_to_block_map);

To show that this actually worked, we output the number of blocks
(which should be -- and indeed is -- equal to two).

\skip Show that it 
\until types

Next we create the two subsidiary preconditioners and call their
\c setup(...) functions, passing the two diagonal blocks
 \f${\bf B}_{11} \f$  and \f${\bf B}_{22} \f$  to them.

\skip // Create the subsidiary preconditioners
\until // End of setup

\subsubsection two_plus_three_solve The preconditioner_solve() function

The \c preconditioner_solve(...) function is equivalent to that
in the \c Diagonal preconditioner discussed above, though here it simply
acts on a 2x2 block system. 



\skip //======
\until }

\subsubsection two_plus_three_clean The clean_up_my_memory() function

The clean up memory functions again deletes the allocated storage --
here the subsidiary preconditioners.

\skip //
\until // End of clean_up_my_memory function.



#####################################################################
#####################################################################


<HR>
<HR>


#####################################################################
#####################################################################


\subsection two_plus_three_upper_triangular Combining multiple dof types into compound blocks. Part 2: How to deal with off-diagonal blocks



NEW BITS: How to setup matrix vector products when multiple dof types
have been combined into single blocks

\subsubsection two_plus_three_upper_triangular_theory Theory
The extension of the preconditioner introduced in the
previous section to block-triangular form is
straightforward: We use the same dof-to-block mapping as before but 
now retain the off-diagonal block \f$ B_{12} \f$ so that the 
preconditioner has the structure:
\f[
\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:
\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:
\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:
{\bf P} = 
\left(
\begin{array}{cc|ccc}
J_{11} & J_{12} & J_{13} & J_{14} & J_{15} \\
J_{21} & J_{22} & J_{13} & J_{14} & J_{15} \\
\hline
 & & J_{33} & J_{34} & J_{35} \\
 & & J_{43} & J_{44} & J_{45} \\
 & & J_{53} & J_{54} & J_{55} \\
\end{array}
\right)
=
\left(
\begin{array}{c|c}
B_{11}  & B_{12}\\
\hline
        & B_{22} \\
\end{array}
\right).
\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:
\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:
\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:
@E[eqn:two_plus_three_upper_triangular_reordered_linear_system]@
\f]

In the FSI context where \f$ B_{11} \f$  and \f$ B_{22} \f$ 
represent the solid and fluid sub-blocks, respectively, the inclusion
of the off-diagonal block \f$ B_{12} \f$ incorporates the effect of
fluid DOFs (via pressure and shear stress) onto the solid equations.
Since this captures "more of the physics" the preconditioner can be
expected to be better than its block diagonal counterpart.

The application of the preconditioner (i.e. the solution of the
linear system \f${\bf P} {\bf
  y} ={\bf z}\f$ for \f${\bf y}\f$) requires the solution of the 
two smaller linear systems
\f[
\ \ \ \ \
\left(
\begin{array}{cc}
J_{11} & J_{12} \\
J_{21} & J_{22} \\
\end{array}
\right) \left(
\begin{array}{c}
y_1 \\
y_2 \\
\end{array}
\right) = \left(
\begin{array}{c}
z_1 \\ 
z_2 \\
\end{array}
\right) - \left(
\begin{array}{ccc}
J_{13} & J_{14} & J_{15} \\
J_{23} & J_{24} & J_{25}  \\
\end{array}
\right) \left(
\begin{array}{c}
y_3 \\
y_4 \\
y_5 \\
\end{array}
\right)
\mbox{\ \ \ \ \ \ \ \ \ or \ \ \ \ \ \  \ \ }
B_{11} Y_1 =  Z_1 - B_{12} Y_2
\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:
@E[eqn:two_plus_three_upper_triangular_prec1]@
\f]
and 
\f[
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \  
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ 
\left(
\begin{array}{ccc}
J_{33} & J_{34} & J_{35} \\
J_{43} & J_{44} & J_{45} \\
J_{53} & J_{54} & J_{55} \\
\end{array}
\right) \left(
\begin{array}{c}
y_3 \\
y_4 \\
y_5 \\
\end{array}
\right) = \left(
\begin{array}{c}
z_3 \\ 
z_4 \\
z_5 \\
\end{array}
\right)
\mbox{\ \ \ \ \ \ \ \ \ or \ \ \ \ \ \  \ \ }
B_{22} Y_2 =  Z_2.
\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:
\ \ \ 
@E[eqn:two_plus_three_upper_triangular_prec2]@
\f]

\subsubsection two_plus_three_upper_triangular_implementation Implementation as a BlockPreconditioner

The implementation is very similar to that in the previous example --
we simply provide additional storage for the (single) matrix vector
product operator required for the multiplication with \f$ B_{12} \f$
when updating the right-hand-side in equation
(@R[eqn:two_plus_three_upper_triangular_prec1]@).

\skip start_of_two_plus_three_upper_triangular_class
\until }; 


\subsubsection two_plus_three_upper_triangular_setup The setup() function

As before, we start by freeing up any previously allocated memory
and check that the number of DOF types is correct.

\skip start_of_setup_for_two_plus_three_upper_triangular
\until #endif

The block setup is again performed with a dof-to-block mapping
that results in a block preconditioner with 2x2 blocks.

\skip //
\until this->block_setup(dof_to_block_map);

We create the two subsidiary preconditioners and pass the 
two diagonal blocks \f$ B_{11} \f$ and  \f$ B_{22} \f$
to their \c setup() functions. As before, the deep copies
of these matrices is then allowed to go out of scope, freeing
up the memory, since the subsidiary preconditioners retain whatever
information they require.

\skip // Create the subsidiary preconditioners
\until end setup of last

Finally we create and set up the off-diagonal vector product. Note
that the block column index refers to the block enumeration, 
so the block column index of \f$ B_{12} \f$ is 1 (in a C++ zero-based
enumeration!). 

\skip //
\until }


\subsubsection two_plus_three_upper_triangular_solve The preconditioner_solve() function

The application of the preconditioner is the exact equivalent of that
of the general-purpose block triangular preconditioner discussed
above, restricted to a 2x2 system:

\skip //======
\until }

\subsubsection two_plus_three_upper_triangular_clean The clean_up_my_memory() function

As before, this function frees up any memory that has been allocated
in the \c setup() function.

\skip //
\until // End of clean_up_my_memory function.


##################################################################
##################################################################
<HR>
<HR>
##################################################################
##################################################################


\subsection two_plus_three_upper_triangular_with_sub Using subsidiary block preconditioners

NEW BITS: How to use subsidiary block preconditioners to
(approximately) solve linear systems constructed from subsets of
dof-blocks.
 
\subsubsection two_plus_three_upper_triangular_with_sub_theory Theory

The two previous examples were motivated by the observation that in 
multi-physics problems (such as fluid-structure interaction) it is
natural to combine "related" DOF blocks into compound block
matrices. We showed that the block preconditioning framework makes
it easy to extract such matrices from the original
system matrix and demonstrated how to solve linear systems involving these 
matrices with separate subsidiary preconditioners.  
One problem with this approach is that, once a compound matrix
has been created (by the \c get_block(...) function), all 
information about its DOF types is lost, making it impossible to 
employ block preconditioners as subsidiary preconditioners. 

We will now revisit the 2x2 block triangular preconditioner 
described in the previous example and demonstrate how to employ
subsidiary block preconditioners to (approximately) solve linear
systems involving matrices formed (formally) by compound matrices
that are constructed from multiple DOF-level blocks. From a
mathematical point of view, the structure of
the preconditioner therefore remains unchanged and is given by
\f[
\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:
\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:
\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:
{\bf P} = 
\left(
\begin{array}{cc|ccc}
J_{11} & J_{12} & J_{13} & J_{14} & J_{15} \\
J_{21} & J_{22} & J_{13} & J_{14} & J_{15} \\
\hline
 & & J_{33} & J_{34} & J_{35} \\
 & & J_{43} & J_{44} & J_{45} \\
 & & J_{53} & J_{54} & J_{55} \\
\end{array}
\right)=
\left(
\begin{array}{c|c}
B_{11}  & B_{12}\\
\hline
        & B_{22} \\
\end{array}
\right).
\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:
\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:
\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:
@E[eqn:two_plus_three_upper_triangular_with_sub]@
\f]
We will continue to use a dof-to-block mapping to view this as
the 2x2 block matrix shown on the right. This makes it easy to 
extract the compound off-diagonal block  \f$ B_{12} \f$ from the
system matrix when setting up the matrix-vector product (as before).
The setup of the subsidiary block preconditioners used to (approximately)
solve the linear systems involving \f$ B_{11} \f$ and \f$ B_{22}\f$ 
is handled differently:
- When calling the subsidiary block preconditioner's 
  \c setup(...) function we pass a pointer to the 
  entire system matrix, i.e. the matrix containing, formally, 
  all the DOF-level blocks in equation (@R[eqn:orig_linear_system]@).
.
- We then turn the preconditioner into a subsidiary block
  preconditioner, using its member function 
  \c turn_into_subsidiary_block_preconditioner(...) whose arguments 
  specify which of the DOF-level blocks in the current (master) 
  preconditioner are to be used by the subsidiary block preconditioner.
.
The subsidiary block preconditioner is thus given access to all
the information required to extract the relevant data directly from the
original system matrix (and any associated full-length vectors).
It is in fact a key design principle of the block preconditiong
framework that <b>subsidiary block preconditioners
are given access to the "full size" matrices and vectors, but only
operate on the subset of data that they are "in charge of".</b>
*** hierher harmonise this with discussion in replacement ***

When employing subsidiary block preconditioners for the approximate 
solution of the two smaller linear systems
\f[
\begin{array}{c}
\underbrace{
\left(
\begin{array}{cc}
J_{11} & J_{12} \\
J_{21} & J_{22} \\
\end{array}
\right) 
}_{B_{11}}
\underbrace{
\left(
\begin{array}{c}
y_1 \\
y_2 \\
\end{array}
\right)
}_{Y_{1}}
 = 
\underbrace{
\left(
\begin{array}{c}
z_1 \\ 
z_2 \\
\end{array}
\right)
}_{{\bf Z}_1} - 
\underbrace{
\left(
\begin{array}{ccc}
J_{13} & J_{14} & J_{15} \\
J_{23} & J_{24} & J_{25}  \\
\end{array}
\right)
}_{B_{12}}
\underbrace{
\left(
\begin{array}{c}
y_3 \\
y_4 \\
y_5 \\
\end{array}
\right)
}_{{\bf Y}_2}
\\
\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:
\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:
\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:
\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:
\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:
\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:
\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:
@E[eqn:two_plus_three_upper_triangular_with_sub_prec]@
\\
\underbrace{
\left(
\begin{array}{ccc}
J_{33} & J_{34} & J_{35} \\
J_{43} & J_{44} & J_{45} \\
J_{53} & J_{54} & J_{55} \\
\end{array}
\right)
}_{B_{22}}
\underbrace{
\left(
\begin{array}{c}
y_3 \\
y_4 \\
y_5 \\
\end{array}
\right)
}_{{\bf Y}_2}
 = 
\underbrace{
\left(
\begin{array}{c}
z_3 \\ 
z_4 \\
z_5 \\
\end{array}
\right)
}_{{\bf Z}_2},
\end{array}
\f]
the subsidiary preconditioners that operate on 
the linear systems involving \f$ B_{11} \f$ and \f$ B_{22} \f$ 
therefore retain access to the 
relevant DOF-level blocks. Hence, if we employ the block triangular 
preconditioner discussed above to (approximately) solve the
two linear systems in equation 
(@R[eqn:two_plus_three_upper_triangular_with_sub_prec]@),
the complete preconditioning operation is described by the
following equations:
\f[
\begin{array}{c}
\left(
\begin{array}{cc}
J_{11} & J_{12} \\
 & J_{22} \\
\end{array}
\right) 
\left(
\begin{array}{c}
y_1 \\
y_2 \\
\end{array}
\right) 
= 
\underbrace{
\underbrace{
\left(
\begin{array}{c}
z_1 \\ 
z_2 \\
\end{array}
\right)
}_{{\bf Z}_1}
 - 
\underbrace{
\left(
\begin{array}{ccc}
J_{13} & J_{14} & J_{15} \\
J_{23} & J_{24} & J_{25}  \\
\end{array}
\right)
}_{B_{12}}
\underbrace{
\left(
\begin{array}{c}
y_3 \\
y_4 \\
y_5 \\
\end{array}
\right)
}_{{\bf Y}_2}
}_{\widehat{\bf Z}_1}
\\
\left(
\begin{array}{ccc}
J_{33} & J_{34} & J_{35} \\
 & J_{44} & J_{45} \\
 &  & J_{55} \\
\end{array}
\right) \left(
\begin{array}{c}
y_3 \\
y_4 \\
y_5 \\
\end{array}
\right) = \left(
\begin{array}{c}
z_3 \\ 
z_4 \\
z_5 \\
\end{array}
\right).
\end{array}
\f]
Note that when we wrote the block triangular preconditioner 
we did not have to be aware of the fact that it may subsequently be used
as a subsidiary block preconditioner. The
internal data structures implemented in the \c BlockPreconditioner
base class ensure that when we call \c get_block(0,0,block_matrix)
in the subsidiary block preconditioner acting on \f$ B_{22} \f$, 
\c block_matrix will 
receive a deep copy of \f$ J_{33} \f$, extracted from the full system matrix. 
Similarly, a call to \c get_block_vectors(r,block_r) will
extract the three block vectors \f$ {\bf r}_3, {\bf r}_4 \f$
and \f${\bf r}_5 \f$ from the full-length vector \f$ {\bf r} \f$,
while \c return_block_vectors(block_z,z) will return the
three solution vectors \f$ {\bf z_3}, {\bf z_4} \f$ and 
\f$ {\bf z_5} \f$ to the appropriate entries in the full-length
vector \f$ {\bf z}. \f$


The implementation of the preconditioning operations
can again be subdivided into two
distinct \c setup() and \c preconditioner\_solve(...) phases.
- Set up the data structures/lookup tables that map DOF types
  0 and 1 to block 0 and DOF types 2, 3 and 4 to block 1 [by calling
  the \c BlockPreconditioner::block\_setup(...) function
  with arguments that specify the mapping between "DOF types" and 
  "block types" as before]. 
- Create two instances of the block triangular preconditioner
  (or any other block preconditioner) and turn them into the 
  subsidiary preconditioners for the current (master) preconditioner,
  specifying which DOF types in the master preconditioner the
  subsidiary block preconditioners are to work with.
- Extract the compound off-diagonal block \f$ B_{12}\f$  and create 
  a \c MatrixVectorProduct operator. 

Once the \c setup() phase has been completed, the solution of the linear
system \f${\bf P} {\bf y} = {\bf z}\f$ by the \c preconditioner\_solve(...) 
function involves the following steps:
- Solve the linear systems \f$ {\bf B}_{22} \ {\bf Y}_2 = 
{\bf Z}_2\f$ using the subsidiary block preconditioner that works
with  \f$ {\bf B}_{22} \f$. [The subsidiary block preconditioner's
\c preconditioner_solve(...) function is given access to the 
full-size vectors \f$ {\bf z} \f$ and \f$ {\bf y} \f$ and
extracts/returns \f$ {\bf Z}_2 \f$
and \f$ {\bf Y}_2\f$ directly from/into these.]
- Extract the solution vector \f$ {\bf Y}_2 \f$ from the just udated full-length
vector \f$ {\bf y} \f$, perform the matrix vector product with
\f$ B_{12} \f$ and store the result in a temporary vector \f$ {\bf t} \f$.
- Extract the block vector \f$ {\bf Z}_1\f$ from the full-length
vector \f$ {\bf z} \f$, subtract \f$ {\bf t} \f$
from it, and return the result, \f$ \widehat{\bf Z}_1 = 
{\bf Z}_1 - B_{12} {\bf Z}_2 \f$
into the appropriate entries into the
full-length vector \f$ {\bf z} \f$.
- Solve the linear systems \f$ {\bf B}_{11} \ {\bf Y}_1 = 
\widehat{\bf Z}_1 = {\bf Z}_1 - B_{12} {\bf Z}_2 \f$ using the subsidiary block 
preconditioner that works
with  \f$ {\bf B}_{11} \f$. [The subsidiary block preconditioner's
\c preconditioner_solve(...) function is given access to the 
full-size vectors \f$ {\bf z} \f$ and \f$ {\bf y} \f$ and
extracts/returns \f$ \widehat{\bf Z}_1 \f$
and \f$ {\bf Y}_1\f$ directly from/into these; recall that the 
relevant entries in \f$ {\bf z}\f$ have been over-written 
in the previous step so that \f$ \widehat{\bf Z}_1 \f$ contains 
the updated right hand side.]


\subsubsection two_plus_three_upper_triangular_with_sub_implementation Implementation as a BlockPreconditioner

The implementation of the preconditioner is completely equivalent to the
corresponding block triangular preconditioner considered in the
previous example:

\skip start_of_two_plus_three_upper_triangular_with_sub_class
\until }; 



\subsubsection two_plus_three_upper_triangular_with_sub_setup The setup() function
As usual we free up any memory and check that the number of dof types
is appropriate for this preconditioner:

\skip start_of_setup_for_two_plus_three_upper_triangular
\until #endif

Next we define the block structure of the preconditioner, using
a dof-to-block mapping to combine dofs 0 and 1 into block 0,
and dofs 2, 3 and 4 into block 1:

\skip //
\until this->block_setup(dof_to_block_map);
 
Next we create the block triangular preconditioner used
to (approximately) solve linear systems involving 
the compound "top left" 2x2 block:
\skip // Create the subsidiary block preconditioners
\until First_sub

We turn this preconditioner into a subsidiary block preconditioner, specifying
the pointer to the current (master) preconditioner and the
mapping between dof types in the present and the subsidiary
block preconditioners (here the identity):
\until turn_into_subsid
 
When calling the subsidiary block preconditioners \c setup(...)
function we pass a pointer to the full matrix:
\until }


The second subsidiary block preconditioner (for the 3x3 "bottom right"
compound matrix) is created similarly,  though the mapping between
dof-types is now no longer the identity but maps dof types 2, 3 and 4
in the current (master) preconditioner to dof types 0, 1 and 2
in the subsidiary block preconditioner:
\until }

The setup of the matrix-vector product with the off-diagonal matrix 
is unchanged from the previous example:

\skip //
\until }
\until }

\subsubsection two_plus_three_upper_triangular_with_sub_solve The preconditioner_solve() function

As discussed in the theory section, we start by (approximately)
solving the system \f$ B_{22} Y_2 = Z_2 \f$, using the second
subsidiary block preconditioner which automatically 
extracts \f$ Z_2 \f$ from the full length vector \c z
and returns the result \f$ Y_2 \f$ into the appropriate entries
of the full length vector \c y.

\skip //
\until Second_subsidiary_preconditioner_pt->preconditioner_solve(z,y);

We now extract the block vector \f$ Y_2 \f$ from the full-length
vector \c y,
\until get_block_vector

multiply it by \f$ B_{12} \f$, using the \c MatrixVectorProduct
operator,
\until Off_diagonal

and subtract the result from \f$ Z_1 \f$ (which we extract from the
full length vector \c z ):

\skip //
\until block_z -= temp; 

\c block_z now contains the updated right hand side, \f$ \widehat{{\bf
Z}_1}\f$, for the linear system to be (approximately) solved by the
first subsidiary block preconditioner. We therefore return 
\f$ \widehat{{\bf Z}_1}\f$ to the appropriate entries into a full
length vector of the same size as right hand side vector \c z:

\until return_block_vector

We then pass this vector to first subsidiary preconditoner which 
updates the appropriate entires in the full-length solution vector \c
y which can therefore be returned directly by this function:

\skip //
\until }

\subsubsection two_plus_three_upper_triangular_with_sub_clean The clean_up_my_memory() function

As usual, we use this helper function to free up any memory 
allocated in the \c setup() function to avoid memory leaks.

\skip //
\until // End of clean_up_my_memory function.


#####################################################################
#####################################################################


<HR>
<HR>


#####################################################################
#####################################################################


\subsection two_plus_three_upper_triangular_with_replace Replacing/modifying blocks
\subsubsection two_plus_three_upper_triangular_with_replace_theory Theory

So far, we have demonstrated how to extract matrix blocks from the
full-sized system matrix (typically the Jacobian matrix used in 
Newton's method) and how to apply a preconditioner via operatations
involving these blocks. Many preconditioners do not operate directly
with the matrix blocks themselves, but on matrices that are derived from them.
For instance, <c>oomph-lib</c>'s  Schur complement Navier-Stokes preconditioner
*** link *** operates on an (approximate) Schur complement;
augmentation preconditioners involve
operations on a matrices that are obtained by the addition of a diagonal
matrix to some of the matrix blocks; etc. Within a given
preconditioner such derived matrices are typically pre-computed 
by the preconditioner's \c setup() function and then stored as 
private member data which makes them available to the \c
preconditioner_solve() function. Unfortunately, this approach does not 
work if the modified block is to be used in a subsidiary block preconditioner
because, as discussed in the previous example, 
*** hierher harmonise this with earlier discussion  ***
by default the subsidiary block preconditioner will extract its block
matrices directly from the full-size system matrix and will therefore
ignore any (local) modifications made by its master preconditoner(s). 
What is therefore required is a method that indicates to the block 
preconditioning framework that a given sub-block is not to be 
extracted from the full system matrix but to be represented by suitable 
replacement matrix.

We demonstrate this methodology by re-visiting the preconditioner
considered in the previous example, namely
\f[
\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:
\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:
\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:
{\bf P}_{\rm previous} = 
\left(
\begin{array}{cc|ccc}
J_{11} & J_{12} & J_{13} & J_{14} & J_{15} \\
J_{21} & J_{22} & J_{13} & J_{14} & J_{15} \\
\hline
 & & J_{33} & J_{34} & J_{35} \\
 & & J_{43} & J_{44} & J_{45} \\
 & & J_{53} & J_{54} & J_{55} \\
\end{array}
\right).
\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:
\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:
\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:
@E[eqn:two_plus_three_upper_triangular_with_sub_again]@
\f]
However, here we want to modify the off-diagonal blocks by
"replacing" each block \f$J_{ij}\f$ (for \f$ i \ne j \f$) by 
a "replacement matrix" \f$R_{ij}\f$ so that the preconditioner becomes
\f[
{\bf P} = 
\left(
\begin{array}{cc|ccc}
J_{11} & R_{12} & R_{13} & R_{14} & R_{15} \\
R_{21} & J_{22} & R_{23} & R_{24} & R_{25} \\
\hline
 & & J_{33} & R_{34} & R_{35} \\
 & & R_{43} & J_{44} & R_{45} \\
 & & R_{53} & R_{54} & J_{55} \\
\end{array}
\right) =
\left(
\begin{array}{c|c}
B_{11}  & B_{12}\\
\hline
        & B_{22} \\
\end{array}
\right).
\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:
\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:
\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:
\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:
\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:
\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:
@E[eqn:two_plus_three_reordered_linear_system]@
\f]
The application of this preconditioner (i.e. the solution of the
linear system \f${\bf P} {\bf
  y} ={\bf z}\f$ for \f${\bf y}\f$) still requires the solution of the 
two smaller linear systems
\f[
\begin{array}{c}
\underbrace{
\left(
\begin{array}{cc}
J_{11} & R_{12} \\
R_{21} & J_{22} \\
\end{array}
\right)
}_{B_{11}}
\left(
\begin{array}{c}
y_1 \\
y_2 \\
\end{array}
\right) = \left(
\begin{array}{c}
z_1 \\ 
z_2 \\
\end{array}
\right) - 
\underbrace{
\left(
\begin{array}{ccc}
R_{13} & R_{14} & R_{15} \\
R_{23} & R_{24} & R_{25} \\
\end{array}
\right)
}_{B_{12}}
\left(
\begin{array}{c}
z_3 \\
z_4 \\
z_5 \\
\end{array}
\right)
\\
\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:
\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:
\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:
\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:
\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:
\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:
\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:
@E[eqn:two_plus_three_prec]@
\\
\underbrace{
\left(
\begin{array}{ccc}
J_{33} & R_{34} & R_{35} \\
R_{43} & J_{44} & R_{45} \\
R_{53} & R_{54} & J_{55} \\
\end{array}
\right) 
}_{B_{22}}
\left(
\begin{array}{c}
y_3 \\
y_4 \\
y_5 \\
\end{array}
\right) = \left(
\begin{array}{c}
z_3 \\ 
z_4 \\
z_5 \\
\end{array}
\right)
\end{array}
\f]
where we have again assumed that the two vectors \f${\bf y}\f$ and \f${\bf z}\f$
are re-ordered into ``block vectors'' in the same way as 
the vectors \f$\delta {\bf x}\f$ and \f${\bf r}\f$ in 
"the original linear system" (@R[eqn:orig_linear_system]@) are re-ordered into
the ``block vectors'' in
(@R[eqn:two_plus_three_prec]@).
We wish to continue to solve the linear systems involving
the compound matrices \f$ B_{11}  \f$ and \f$ B_{22} \f$ 
(which involve "replaced" blocks) by two subsidiary block 
preconditioners (which operate on 3x3 and 2x2 dof blocks, 
respectively).


In the specific example below we replace all of the diagonal 
matrices by suitably sized zero matrices, so that the actual 
preconditioning operation is defined by the following
linear systems
\f[
\begin{array}{c}
\underbrace{
\left(
\begin{array}{cc}
J_{11} &  \\
& J_{22} \\
\end{array}
\right) 
}_{B_{11}}
\left(
\begin{array}{c}
y_1 \\
y_2 \\
\end{array}
\right) = \left(
\begin{array}{c}
z_1 \\ 
z_2 \\
\end{array}
\right) - 
\underbrace{
\left(
\begin{array}{ccc}
& &  \\
 & &  \\
\end{array}
\right) 
}_{B_{12}}
\left(
\begin{array}{c}
z_3 \\
z_4 \\
z_5 \\
\end{array}
\right)
\\
\underbrace{
\left(
\begin{array}{ccc}
J_{33} & &  \\
& J_{44} &  \\
 &  & J_{55} \\
\end{array}
\right) 
}_{B_{22}}
\left(
\begin{array}{c}
y_3 \\
y_4 \\
y_5 \\
\end{array}
\right) = \left(
\begin{array}{c}
z_3 \\ 
z_4 \\
z_5 \\
\end{array}
\right)
\end{array}
\f]
which, in effect, turns the preconditioner into the 
block-diagonal preconditioner considered at the very
beginning of this tutorial.

\subsubsection two_plus_three_upper_triangular_with_replace_implementation Implementation as a BlockPreconditioner

The implementation of the preconditioner is completely equivalent to the
preconditioner considered in the previous example. The only additional
feature is the provision a matrix of pointers to the
replacement matrices, \c Replacement_matrix_pt.

\skip start_of_two_plus_three_upper_triangular_with_replace_class
\until }; 



\subsubsection two_plus_three_upper_triangular_with_replace_setup The setup() function

As usual, we start by cleaning up any memory using a call to a
\c clean_up_my_memory() function.

\skip start_of_setup_for_two_plus_three_upper_triangular_with_replace
\until this->clean_up_my_memory();

Next we check that the number of dof types is 5, as the
preconditioner is designed to only work for that number. 

\skip How many dof types do we have
\until #endif

The block setup follows exactly the same pattern as in the previous
example: Dof types 0 and 1 are combined into compound block 0, while
dof types 2, 3 and 4 are combined into compound block 1.  
On return from the block setup function we should therefore have
two block types:
\skip Call block setup
\until #endif

Now we perform the replacement of the off-diagonal dof blocks.
(Note that there are still five of these. Dof-blocks and compound
blocks are not the same -- if you get them confused you will get into
trouble!). We allocate storage for the pointers to the replacement 
matrices and loop over the off-diagonal blocks:

\skip //
\until (i!=j)
\until {

  
Given that the replacement matrices are zero matrices, we could
simple create them without ever looking at the original blocks.
Sadly the creation of zero matrices turns out to be slightly
more painful than one would wish because they have
to be created as (possibly distributed) CRDoubleMatrices. The 
relevant code is contained in the source code but we won't discuss 
it here since the more common situation is one where we actually
want to modify an existing block matrix. This is much more straightforward
(unless you want to create new, originally zero entries, for which
no storage exists in the existing CRDoubleMatrix; in that case you'll
have to read up on how to interact with a CRDoubleMatrix.)
Here we simply extract the matrix and set its nonzero entries
to zero (yes, really -- it's just a demonstration!):

\until this is just an example!

We then pass the pointer to the replacement block to the
block preconditioner

\skip Replace
\until loop of i

The rest of the setup works exactly as in the previous example, only
this time, the subsidiary preconditioners and the matrix vector 
products will work with the replacement dof blocks that we've just
defined.

We create and set up the first subsidiary block preconditioner 
which operates on our dof types 0 and 1 (and treats them as its own
dof  types 0 and 1):
\skip First subsidiary precond
\until }

The second  subsidiary block preconditioner 
which operates on our dof types 2, 3 and 4 (and treats them as its own
dof  types 0, 1 and 2):

\skip Second subsidiary precond 
\until }

Finally, we create the matrix vector product operator:
\skip Next setup the off diagonal mat vec operators:
\until }
\until }



\subsubsection two_plus_three_upper_triangular_with_replace_solve The preconditioner_solve() function

The \c preconditioner_solve() function is completely identical to the
one used in the previous preconditioner, so we omit the code
listing -- the subsidiary preconditioners and the matrix vector 
product operator work in the same way but now simply operate on 
the replacement dof blocks where they have been set.

\subsubsection two_plus_three_upper_triangular_with_replace_clean The clean_up_my_memory() function

Memory is cleaned up as before, so we omit the code listing.

##################################################################
##################################################################
<HR>
<HR>
##################################################################
##################################################################


\subsection coarse_two_plus_two_plus_one Coarsening/combining dof types

\subsubsection coarse_two_plus_two_plus_one_theory Theory

In the examples presented so far we have demonstrated how
to combine various dof-blocks into compound blocks in order to 
facilitate the application of certain preconditioning operations.
For instance, in many of the previous examples we performed a matrix
vector product using the compound matrix \f$ B_{12} \f$ that was
(formally) formed by the concatenation of the 2x3 "top right"
off-diagonal dof blocks in the full-sized system.

We also showed how subsidiary block preconditioners which operate on
a specific number of dof blocks can be instructed to operate on 
selected dof types from the full-sized system. Our standard
example for this was a 2D Navier-Stokes preconditioner which operates on
three dof types (two fluid velocities and one pressure) and 
is used as a subsidiary block preconditioner in an FSI problem that 
also involves additional dofs associated with the solid mechanics
(e.g. the two solid displacement components). This was done
by informing the subsdiary preconditioner which of the dof types
in the full-sized system to regard as "its own" when calling
its \c turn_into_subsidiary_block_preconditioner(...) function.
This implies that the subsidiary block preconditioner remains unaware of any 
 compound blocks that may have been formed in its master 
 preconditioner. The functionality presented so far only allows us
to associate dof-blocks in the master preconditioner with dof
blocks in the subdsidiary block preconditioner.
It is therefore not possible (without further functionality which we explain
in this example) to use a subsidiary block preconditioner if the dof-types
in the master preconditioner are "too fine-grained". This arises,
for instance, in Navier-Stokes problems where the master preconditioner
sub-divides the two components of the fluid velocity into degrees of freedom
on the domain boundary and those in the interior. It is then necessary
to make the subsidiary preconditioner act on the combined 
dof types, a process that we describe as "coarsening"... *** do/must we ? ***



We illustrate the procedure by returning, yet again, to our 5x5 block
linear system that we wish to precondition with
\f[
\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:
\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:
\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:
{\bf P}_{\rm previous} = 
\left(
\begin{array}{cc|ccc}
J_{11} & J_{12} & J_{13} & J_{14} & J_{15} \\
J_{21} & J_{22} & J_{13} & J_{14} & J_{15} \\
\hline
 & & J_{33} & J_{34} & J_{35} \\
 & & J_{43} & J_{44} & J_{45} \\
 & & J_{53} & J_{54} & J_{55} \\
\end{array}
\right) =
\left(
\begin{array}{c|c}
B_{11}  & B_{12}\\
\hline
        & B_{22} \\
\end{array}
\right).
\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:
\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:
\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:
@E[eqn:two_plus_three_upper_triangular_coarsen]@
\f]
However, now we wish to solve the linear systems involving
\f$ B_{11} \f$ and \f$ B_{22} \f$ with a 2x2 upper triangular subsidiary block
preconditioner. To make this possible, we "coarsen" the dof types 
such that the subsidiary  block preconditioner acting on 
\f$ B_{22}\f$ treats the global dof types 3 and 4 as a single dof type.


*** end matthias new intro
 
In this example, we want to coarsen blocks, this allows us
to act upon it with a subsidiary block preconditioner, whilst the
subsidiary sees the coarsened blocks as a single block.

The original form selected by the preconditioner from the Jacobian is:
\f[
{\bf P} = 
\left(
\begin{array}{ccccc}
J_{11} & J_{12} & J_{13} & J_{14} & J_{15} \\
J_{21} & J_{22} & J_{23} & J_{24} & J_{25} \\
 & & J_{33} & J_{34} & J_{35} \\
 & & J_{43} & J_{44} & J_{45} \\
 & & J_{53} & J_{54} & J_{55} \\
\end{array}
\right).
\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:
\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:
\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:
\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:
\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:
\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:
@E[eqn:coarse_two_plus_two_plus_one_reordered_linear_system]@
\f]

This is then treated by upper triangular subsidiary systems, both of
which see the blocks as 2x2, as the bottom right 3x3 block is
coarsened into a 2x2 system.

Both take the 2x2 system, do an upper triangular solve on each of the
diagonal blocks, which for the purposes of the blocks is equivalent to
an LU decomposition, with modification of the right hand side as
apropriate for the off-diagonal block. 
\f[
{\bf P} = 
\left(
\begin{array}{cc}
J_{11} & J_{12} \\
 & J_{22} \\
\end{array}
\right).
\f]

The end result is almost equivalent to the upper triangular system
with the J_{34} being able to be trivially repalced if the solution is
wished to be compared:

\f[
{\bf P} = 
\left(
\begin{array}{ccccc}
J_{11} & J_{12} & J_{13} & J_{14} & J_{15} \\
J_{21} & J_{22} & J_{23} & J_{24} & J_{25} \\
 & & J_{33} & J_{34} & J_{35} \\
 & & J_{34} & J_{44} & J_{45} \\
 & & & & J_{55} \\
\end{array}
\right).
\f]



\subsubsection coarse_two_plus_two_plus_one_setup The setup() function

The first thing that must be called at the beginning of every \c
setup(...) function is \c clean_up_my_memory(). This cleans up any
dynamically allocated memory.

\skip start_of_setup_for_coarse_two_plus_two_plus_one
\until this->clean_up_my_memory();

Next we check that the number of degrees of freedom is 5, as the
preconditioner is designed to only work for that number. The check is
only necessary if \c OOMPH-LIB is complied with the \c PARANOID flag,
and as such is inside an \c #ifdef statement.

\skip //
\until #endif

Next, \c this->block_setup() is called, to set up any data structures
and/or lookup tables required to extract the desired blocks from the
Jacobian.

\skip //
\until this->block_setup();

In order to replace blocks it is necessary to loop over those that are not wanted.

\skip //
\until {
\until {

The parts of the block that are still required are retrieved and stored and replacement parts constructed. These are then used to create a new matrix, stored in a \c DenseMatrix that's private data such that it may be cleaned up when no longer in use. This is because the replacement matrix needs to be stored by the preconditioner that does the replacement. It does not directly replace parts of the Jacobian, for you may not wish preconditioners master to the ones you are replacing in to be using the replaced blocks.

\skip //
\until replacement_column_index, replacement_row_start);

The replacement matrix is then passed to the \c set_replacement_dof_block matrix.

\skip //
\until }// End of i loop.

The first preconditioner is created and setup. Then the second one is created.

\skip //
\until  Second_subsidiary_preconditioner_pt=block_prec_pt;

We desire the second preconditioner to act on a coarsened system, as such we first need to setup the mapping to the new corase system.

The first thing that requires is a \c Vector<Vector<unsigned>>. The first \c Vector indicates the "coarse" blocks that will be created in the subsidiary preconditioner.

The second \c Vector indicates the DOFs in the master preconditioner that go into the "coarse" blocks specified by the first \c Vector; ie the blocks in the subsidiary preconditioner.

\skip unsigned n_sub_dof_types=2;
\until doftype_coarsen_map_coarse[1][0]

However the \c unsigned values stored do not directly refer to the
DOF types in the master preconditioner, instead they go via a secondary
\c Vector. The values in the \c doftype_coarsen_map_coarse refer to
the index of \c doftype_in_master_coarse. This means that if \c doftype_in_master_coarse[0] is 1 then if
\c doftype_coarsen_map_coarse[i][j]=0 the ith "coarse" block in the
subsidiary preconditioner contains at least j of the master's blocks,
and the jth block in the ith "coarse" block is the DOF of the master
preconditioner stored in \c doftype_in_master_coarse[0], which in this example is 1.

\skip Vector<unsigned> doftype_in_master_coarse
\until doftype_in_master_coarse[2]

The subsidiary preconditioner is then turned into a subsidiary by passing the master preconditioner and the two \c Vector.

\skip block_prec_pt->
\until  doftype_coarsen_map_coarse);

The preconditioner and concatenated off-digonals are then setup as per normal.

\skip //
\until }// End of setup

\subsubsection coarse_two_plus_two_plus_one_solve The preconditioner_solve() function

Firstly the second preconditioner's result is ascertained, so that it
can be back substituted later.

\skip //
\until _subsidiary_preconditioner_pt

Then the \c Vector \c r and \c Vector \c z are retrieved using an identical
coarsening scheme to that used in \c setup().

\skip //
\until this->get_concatenated_block_vector(block1_vec_number,z,z_1);

The rest of the solve is done as per normal for a 2 plus 3 system with
an off-diagonal, using subsidiary preconditioners.

\skip //
\until }

\subsubsection coarse_two_plus_two_plus_one_clean The clean_up_my_memory() function

The clean up memory functions purpose is to delete any existing
private data (and null it for safety purposes).

\skip //
\until // End of clean_up_my_memory function.

The reason that this is required is the preconditioner is called as
part of a linear solver program and may be used multiple times for
various nonlinear solves over the course of the program. An obvious
example of this is a time dependent problem. 

Therefore to stop the build-up of unnecessary memory \c
clean_up_my_memory() is called twice. Once at the beginning of 
\c setup() to avoid leakage if the preconditioner is reused, and the
second time is in the destructor (\c ~Diagonal()) to avoid memory leaks
if potential loops create and destroy the preconditioner, either
through \c new and \c delete or the preconditioner going out of scope.

