In this document we discuss the spatially-\/adaptive finite-\/element-\/based solution of the 3D Helmholtz equation in cylindrical polar coordinates, using a Fourier-\/decomposition of the solution in the azimuthal direction.

The driver code is very similar to the one discussed in \href{../../sphere_scattering/html/index.html}{\tt another tutorial } -- the main purpose of the current tutorial is to demonstrate the use of spatial adaptivity on unstructured meshes.



 

\hypertarget{index_scattering}{}\section{A specific example}\label{index_scattering}
We will solve the azimuthally Fourier-\/decomposed Helmholtz equation \[ \nabla^2 {u_{N}}(r,z) + \left(k^2-\frac{N^2}{r^2}\right) u_N(r,z) = 0, \ \ \ \ \ \ \ \ \ \ \ \ (1) \] where $ N $ is the azimuthal wavenumber, in the finite domain $ 1 < \sqrt{r^2 + z^2} < 3 $. We impose the Sommerfeld radiation condition at the outer boundary of the computational domain at $ \sqrt{r^2 + z^2} = 3$, using a Dirichlet-\/to-\/\+Neumann mapping, and apply flux boundary condition on the surface of the unit-\/sphere (where $ \sqrt{r^2 + z^2} = 1 $) such that the exact solution is given by \[ u_N(r,z)=u_N^{[exact]}(r,z)=\sum_{l=N}^{N_{\rm terms}} h_{l}^{(1)}(k\sqrt{r^2+z^2}) \ P_{l}^{N}\left(\frac{z}{\sqrt{r^2+z^2}}\right). \] This solution corresponds to the superposition of several outgoing waves that emerge from the unit sphere.

The two plots below show a comparison between the exact and computed solutions for $ N_{\rm terms}=6 $ , a Fourier wavenumber of $ N=1 $ , and a (squared) Helmholtz wavenumber of $ k^2 = 10 $.

 
\begin{DoxyImage}
\includegraphics[width=0.6\textwidth]{re}
\doxyfigcaption{Plot of the exact (green) and computed (red) real parts of the solution of the Fourier-\/decomposed Helmholtz equation for N=1 and a wavenumber of k$^\wedge$2 = 10. }
\end{DoxyImage}


 
\begin{DoxyImage}
\includegraphics[width=0.6\textwidth]{im}
\doxyfigcaption{Plot of the exact (green) and computed (red) imaginary parts of the solution of the Fourier-\/decomposed Helmholtz equation for N=1 and a wavenumber of k$^\wedge$2 = 10. }
\end{DoxyImage}




 

\hypertarget{index_num_soln}{}\section{The numerical solution}\label{index_num_soln}
The driver code for this problem is very similar to the one discussed in \href{../../sphere_scattering/html/index.html}{\tt another tutorial. }

Running {\ttfamily sdiff} on the driver codes \begin{center} \href{../../../../demo_drivers/fourier_decomposed_helmholtz/sphere_scattering/sphere_scattering.cc}{\tt demo\+\_\+drivers/fourier\+\_\+decomposed\+\_\+helmholtz/sphere\+\_\+scattering/sphere\+\_\+scattering.\+cc } \end{center}  and \begin{center} \href{../../../../demo_drivers/fourier_decomposed_helmholtz/sphere_scattering/unstructured_sphere_scattering.cc}{\tt demo\+\_\+drivers/fourier\+\_\+decomposed\+\_\+helmholtz/sphere\+\_\+scattering/unstructured\+\_\+sphere\+\_\+scattering.\+cc } \end{center}  shows the main differences required to discretise the computational domain with an adaptive, unstructured mesh\+:
\begin{DoxyItemize}
\item The provision of the functions {\ttfamily actions\+\_\+before/after\+\_\+adapt}() to detach/re-\/attach the {\ttfamily Face\+Elements} that are used to enforce the Neumann boundary conditions before and after every spatial adaptation, and to pass the physical parameters to the newly created bulk elements. ~\newline
~\newline

\item The generation of an unstructured mesh whose curvilinear boundaries are represented by {\ttfamily Geom\+Objects} -- this ensures that the domain boundaries become increasingly well resolved under mesh refinement.
\end{DoxyItemize}That\textquotesingle{}s all!



 

\hypertarget{index_code}{}\section{Code listing}\label{index_code}
Here\textquotesingle{}s a listing of the complete driver code\+:


\begin{DoxyCodeInclude}
\textcolor{comment}{//LIC// ====================================================================}
\textcolor{comment}{//LIC// This file forms part of oomph-lib, the object-oriented, }
\textcolor{comment}{//LIC// multi-physics finite-element library, available }
\textcolor{comment}{//LIC// at http://www.oomph-lib.org.}
\textcolor{comment}{//LIC// }
\textcolor{comment}{//LIC//    Version 1.0; svn revision $LastChangedRevision$}
\textcolor{comment}{//LIC//}
\textcolor{comment}{//LIC// $LastChangedDate$}
\textcolor{comment}{//LIC// }
\textcolor{comment}{//LIC// Copyright (C) 2006-2016 Matthias Heil and Andrew Hazel}
\textcolor{comment}{//LIC// }
\textcolor{comment}{//LIC// This library is free software; you can redistribute it and/or}
\textcolor{comment}{//LIC// modify it under the terms of the GNU Lesser General Public}
\textcolor{comment}{//LIC// License as published by the Free Software Foundation; either}
\textcolor{comment}{//LIC// version 2.1 of the License, or (at your option) any later version.}
\textcolor{comment}{//LIC// }
\textcolor{comment}{//LIC// This library is distributed in the hope that it will be useful,}
\textcolor{comment}{//LIC// but WITHOUT ANY WARRANTY; without even the implied warranty of}
\textcolor{comment}{//LIC// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU}
\textcolor{comment}{//LIC// Lesser General Public License for more details.}
\textcolor{comment}{//LIC// }
\textcolor{comment}{//LIC// You should have received a copy of the GNU Lesser General Public}
\textcolor{comment}{//LIC// License along with this library; if not, write to the Free Software}
\textcolor{comment}{//LIC// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA}
\textcolor{comment}{//LIC// 02110-1301  USA.}
\textcolor{comment}{//LIC// }
\textcolor{comment}{//LIC// The authors may be contacted at oomph-lib@maths.man.ac.uk.}
\textcolor{comment}{//LIC// }
\textcolor{comment}{//LIC//====================================================================}
\textcolor{comment}{//Driver for Fourier-decomposed  Helmholtz problem }

\textcolor{preprocessor}{#include <complex>}
\textcolor{preprocessor}{#include <cmath>}

\textcolor{comment}{//Generic routines}
\textcolor{preprocessor}{#include "generic.h"}

\textcolor{comment}{// The Helmholtz equations}
\textcolor{preprocessor}{#include "fourier\_decomposed\_helmholtz.h"}
 
\textcolor{comment}{// The mesh}
\textcolor{preprocessor}{#include "meshes/triangle\_mesh.h"}

\textcolor{comment}{// Get the Bessel functions}
\textcolor{preprocessor}{#include "oomph\_crbond\_bessel.h"}

\textcolor{keyword}{using namespace }\hyperlink{namespaceoomph}{oomph};
\textcolor{keyword}{using namespace }\hyperlink{namespacestd}{std};

\textcolor{comment}{}
\textcolor{comment}{/////////////////////////////////////////////////////////////////////}
\textcolor{comment}{/////////////////////////////////////////////////////////////////////}
\textcolor{comment}{/////////////////////////////////////////////////////////////////////}
\textcolor{comment}{}

\textcolor{comment}{//===== start\_of\_namespace\_planar\_wave=================================}\textcolor{comment}{}
\textcolor{comment}{/// Namespace to test representation of planar wave in spherical}
\textcolor{comment}{/// polars}
\textcolor{comment}{}\textcolor{comment}{//=====================================================================}
\textcolor{keyword}{namespace }\hyperlink{namespacePlanarWave}{PlanarWave}
\{
\textcolor{comment}{}
\textcolor{comment}{ /// Number of terms in series}
\textcolor{comment}{} \textcolor{keywordtype}{unsigned} N\_terms=100;
\textcolor{comment}{}
\textcolor{comment}{ /// Wave number}
\textcolor{comment}{} \textcolor{keywordtype}{double} K=3.0*MathematicalConstants::Pi;
\textcolor{comment}{}
\textcolor{comment}{ /// Imaginary unit }
\textcolor{comment}{} std::complex<double> \hyperlink{namespacePlanarWave_a541691caf71477c8c389062797c0fdab}{I}(0.0,1.0); 
\textcolor{comment}{}
\textcolor{comment}{ /// Exact solution as a Vector of size 2, containing real and imag parts}
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{namespacePlanarWave_a00f252bcf0181187c656a58ce36b07b5}{get\_exact\_u}(\textcolor{keyword}{const} Vector<double>& x, Vector<double>& u)
 \{
  \textcolor{comment}{// Switch to spherical coordinates}
  \textcolor{keywordtype}{double} R=sqrt(x[0]*x[0]+x[1]*x[1]);
  
  \textcolor{keywordtype}{double} theta;
  theta=atan2(x[0],x[1]);
  
  \textcolor{comment}{// Argument for Bessel/Hankel functions}
  \textcolor{keywordtype}{double} kr = K*R;  
  
  \textcolor{comment}{// Need half-order Bessel functions}
  \textcolor{keywordtype}{double} bessel\_offset=0.5;

  \textcolor{comment}{// Evaluate Bessel/Hankel functions}
  Vector<double> jv(N\_terms);
  Vector<double> yv(N\_terms);
  Vector<double> djv(N\_terms);
  Vector<double> dyv(N\_terms);
  \textcolor{keywordtype}{double} order\_max\_in=double(N\_terms-1)+bessel\_offset;
  \textcolor{keywordtype}{double} order\_max\_out=0;
  
  \textcolor{comment}{// This function returns vectors containing }
  \textcolor{comment}{// J\_k(x), Y\_k(x) and their derivatives}
  \textcolor{comment}{// up to k=order\_max, with k increasing in}
  \textcolor{comment}{// integer increments starting with smallest}
  \textcolor{comment}{// positive value. So, e.g. for order\_max=3.5}
  \textcolor{comment}{// jv[0] contains J\_\{1/2\}(x),}
  \textcolor{comment}{// jv[1] contains J\_\{3/2\}(x),}
  \textcolor{comment}{// jv[2] contains J\_\{5/2\}(x),}
  \textcolor{comment}{// jv[3] contains J\_\{7/2\}(x).}
  CRBond\_Bessel::bessjyv(order\_max\_in,
                         kr,
                         order\_max\_out,
                         &jv[0],&yv[0],
                         &djv[0],&dyv[0]);
  
  
  \textcolor{comment}{// Assemble  exact solution (actually no need to add terms}
  \textcolor{comment}{// below i=N\_fourier as Legendre polynomial would be zero anyway)}
  complex<double> u\_ex(0.0,0.0);
  \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} i=0;i<\hyperlink{namespacePlanarWave_a56abdb2474ccaffd88346ee3607d8672}{N\_terms};i++)
   \{
    \textcolor{comment}{//Associated\_legendre\_functions}
    \textcolor{keywordtype}{double} p=Legendre\_functions\_helper::plgndr2(i,0,cos(theta));
    
    \textcolor{comment}{// Set exact solution}
    u\_ex+=(2.0*i+1.0)*pow(\hyperlink{namespacePlanarWave_a541691caf71477c8c389062797c0fdab}{I},i)*
     sqrt(MathematicalConstants::Pi/(2.0*kr))*jv[i]*p;
   \}
  
  \textcolor{comment}{// Get the real & imaginary part of the result}
  u[0]=u\_ex.real();
  u[1]=u\_ex.imag();
  
 \}\textcolor{comment}{//end of get\_exact\_u}

\textcolor{comment}{}
\textcolor{comment}{ /// Plot }
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{namespacePlanarWave_afe1e9812d1b1dc40a89f7a1f18d1165f}{plot}()
 \{
  \textcolor{keywordtype}{unsigned} nr=20;
  \textcolor{keywordtype}{unsigned} nz=100;
  \textcolor{keywordtype}{unsigned} nt=40;

  ofstream some\_file(\textcolor{stringliteral}{"planar\_wave.dat"});

  \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} i\_t=0;i\_t<nt;i\_t++)
   \{
    \textcolor{keywordtype}{double} t=2.0*MathematicalConstants::Pi*double(i\_t)/double(nt-1);

    some\_file << \textcolor{stringliteral}{"ZONE I="}<< nz << \textcolor{stringliteral}{", J="}<< nr << std::endl;
    
    Vector<double> x(2);
    Vector<double> u(2);
    \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} i=0;i<nr;i++)
     \{
      x[0]=0.001+double(i)/double(nr-1);
      \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} j=0;j<nz;j++)
       \{
        x[1]=double(j)/double(nz-1);
        \hyperlink{namespacePlanarWave_a00f252bcf0181187c656a58ce36b07b5}{get\_exact\_u}(x,u); 
        complex<double> uu=complex<double>(u[0],u[1])*exp(-\hyperlink{namespacePlanarWave_a541691caf71477c8c389062797c0fdab}{I}*t);
        some\_file << x[0] << \textcolor{stringliteral}{" "} << x[1] << \textcolor{stringliteral}{" "} 
                  << uu.real() << \textcolor{stringliteral}{" "} << uu.imag() << \textcolor{stringliteral}{"\(\backslash\)n"};
       \}
     \} 
   \}
 \}
 
\}

\textcolor{comment}{}
\textcolor{comment}{/////////////////////////////////////////////////////////////////////}
\textcolor{comment}{/////////////////////////////////////////////////////////////////////}
\textcolor{comment}{/////////////////////////////////////////////////////////////////////}
\textcolor{comment}{}

\textcolor{comment}{//===== start\_of\_namespace=============================================}\textcolor{comment}{}
\textcolor{comment}{/// Namespace for the Fourier decomposed Helmholtz problem parameters}
\textcolor{comment}{}\textcolor{comment}{//=====================================================================}
\textcolor{keyword}{namespace }\hyperlink{namespaceProblemParameters}{ProblemParameters}
\{\textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Square of the wavenumber}
\textcolor{comment}{} \textcolor{keywordtype}{double} K\_squared=10.0;
 \textcolor{comment}{}
\textcolor{comment}{ /// Fourier wave number}
\textcolor{comment}{} \textcolor{keywordtype}{int} N\_fourier=3;
 \textcolor{comment}{}
\textcolor{comment}{ /// Number of terms in computation of DtN boundary condition}
\textcolor{comment}{} \textcolor{keywordtype}{unsigned} Nterms\_for\_DtN=6;
\textcolor{comment}{}
\textcolor{comment}{ /// Number of terms in the exact solution}
\textcolor{comment}{} \textcolor{keywordtype}{unsigned} N\_terms=6; 
 \textcolor{comment}{}
\textcolor{comment}{ /// Coefficients in the exact solution}
\textcolor{comment}{} Vector<double> \hyperlink{namespaceProblemParameters_acb1788444ef78fe2adec824504f24246}{Coeff}(N\_terms,1.0);
\textcolor{comment}{}
\textcolor{comment}{ /// Imaginary unit }
\textcolor{comment}{} std::complex<double> \hyperlink{namespacePlanarWave_a541691caf71477c8c389062797c0fdab}{I}(0.0,1.0); 
\textcolor{comment}{}
\textcolor{comment}{ /// Exact solution as a Vector of size 2, containing real and imag parts}
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{namespacePlanarWave_a00f252bcf0181187c656a58ce36b07b5}{get\_exact\_u}(\textcolor{keyword}{const} Vector<double>& x, Vector<double>& u)
 \{
  \textcolor{comment}{// Switch to spherical coordinates}
  \textcolor{keywordtype}{double} R=sqrt(x[0]*x[0]+x[1]*x[1]);
  
  \textcolor{keywordtype}{double} theta;
  theta=atan2(x[0],x[1]);
  
  \textcolor{comment}{// Argument for Bessel/Hankel functions}
  \textcolor{keywordtype}{double} kr = sqrt(K\_squared)*R;  
  
  \textcolor{comment}{// Need half-order Bessel functions}
  \textcolor{keywordtype}{double} bessel\_offset=0.5;

  \textcolor{comment}{// Evaluate Bessel/Hankel functions}
  Vector<double> jv(N\_terms);
  Vector<double> yv(N\_terms);
  Vector<double> djv(N\_terms);
  Vector<double> dyv(N\_terms);
  \textcolor{keywordtype}{double} order\_max\_in=double(N\_terms-1)+bessel\_offset;
  \textcolor{keywordtype}{double} order\_max\_out=0;
  
  \textcolor{comment}{// This function returns vectors containing }
  \textcolor{comment}{// J\_k(x), Y\_k(x) and their derivatives}
  \textcolor{comment}{// up to k=order\_max, with k increasing in}
  \textcolor{comment}{// integer increments starting with smallest}
  \textcolor{comment}{// positive value. So, e.g. for order\_max=3.5}
  \textcolor{comment}{// jv[0] contains J\_\{1/2\}(x),}
  \textcolor{comment}{// jv[1] contains J\_\{3/2\}(x),}
  \textcolor{comment}{// jv[2] contains J\_\{5/2\}(x),}
  \textcolor{comment}{// jv[3] contains J\_\{7/2\}(x).}
  CRBond\_Bessel::bessjyv(order\_max\_in,
                         kr,
                         order\_max\_out,
                         &jv[0],&yv[0],
                         &djv[0],&dyv[0]);
  
  
  \textcolor{comment}{// Assemble  exact solution (actually no need to add terms}
  \textcolor{comment}{// below i=N\_fourier as Legendre polynomial would be zero anyway)}
  complex<double> u\_ex(0.0,0.0);
  \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} i=N\_fourier;i<\hyperlink{namespacePlanarWave_a56abdb2474ccaffd88346ee3607d8672}{N\_terms};i++)
   \{
    \textcolor{comment}{//Associated\_legendre\_functions}
    \textcolor{keywordtype}{double} p=Legendre\_functions\_helper::plgndr2(i,N\_fourier,
                                                cos(theta));
    \textcolor{comment}{// Set exact solution}
    u\_ex+=\hyperlink{namespaceProblemParameters_acb1788444ef78fe2adec824504f24246}{Coeff}[i]*sqrt(MathematicalConstants::Pi/(2.0*kr))*(jv[i]+\hyperlink{namespacePlanarWave_a541691caf71477c8c389062797c0fdab}{I}*yv[i])*p;
   \}
  
  \textcolor{comment}{// Get the real & imaginary part of the result}
  u[0]=u\_ex.real();
  u[1]=u\_ex.imag();
  
 \}\textcolor{comment}{//end of get\_exact\_u}

 \textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Get -du/dr (spherical r) for exact solution. Equal to prescribed}
\textcolor{comment}{ /// flux on inner boundary.}
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{namespaceProblemParameters_aa544d1f3e384d3283f7113512931ea8f}{exact\_minus\_dudr}(\textcolor{keyword}{const} Vector<double>& x, std::complex<double>& flux)
 \{
  \textcolor{comment}{// Initialise flux}
  flux=std::complex<double>(0.0,0.0);
  
  \textcolor{comment}{// Switch to spherical coordinates}
  \textcolor{keywordtype}{double} R=sqrt(x[0]*x[0]+x[1]*x[1]);
  
  \textcolor{keywordtype}{double} theta;
  theta=atan2(x[0],x[1]);
  
  \textcolor{comment}{// Argument for Bessel/Hankel functions}
  \textcolor{keywordtype}{double} kr=sqrt(K\_squared)*R;  

  \textcolor{comment}{// Helmholtz wavenumber}
  \textcolor{keywordtype}{double} k=sqrt(K\_squared);

  \textcolor{comment}{// Need half-order Bessel functions}
  \textcolor{keywordtype}{double} bessel\_offset=0.5;

  \textcolor{comment}{// Evaluate Bessel/Hankel functions}
  Vector<double> jv(N\_terms);
  Vector<double> yv(N\_terms);
  Vector<double> djv(N\_terms);
  Vector<double> dyv(N\_terms);
  \textcolor{keywordtype}{double} order\_max\_in=double(N\_terms-1)+bessel\_offset;
  \textcolor{keywordtype}{double} order\_max\_out=0;
  
  \textcolor{comment}{// This function returns vectors containing }
  \textcolor{comment}{// J\_k(x), Y\_k(x) and their derivatives}
  \textcolor{comment}{// up to k=order\_max, with k increasing in}
  \textcolor{comment}{// integer increments starting with smallest}
  \textcolor{comment}{// positive value. So, e.g. for order\_max=3.5}
  \textcolor{comment}{// jv[0] contains J\_\{1/2\}(x),}
  \textcolor{comment}{// jv[1] contains J\_\{3/2\}(x),}
  \textcolor{comment}{// jv[2] contains J\_\{5/2\}(x),}
  \textcolor{comment}{// jv[3] contains J\_\{7/2\}(x).}
  CRBond\_Bessel::bessjyv(order\_max\_in,
                         kr,
                         order\_max\_out,
                         &jv[0],&yv[0],
                         &djv[0],&dyv[0]);
  
  
  \textcolor{comment}{// Assemble  exact solution (actually no need to add terms}
  \textcolor{comment}{// below i=N\_fourier as Legendre polynomial would be zero anyway)}
  complex<double> u\_ex(0.0,0.0);
  \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} i=N\_fourier;i<\hyperlink{namespacePlanarWave_a56abdb2474ccaffd88346ee3607d8672}{N\_terms};i++)
   \{
    \textcolor{comment}{//Associated\_legendre\_functions}
    \textcolor{keywordtype}{double} p=Legendre\_functions\_helper::plgndr2(i,N\_fourier,
                                                cos(theta));
    \textcolor{comment}{// Set flux of exact solution}
    flux-=\hyperlink{namespaceProblemParameters_acb1788444ef78fe2adec824504f24246}{Coeff}[i]*sqrt(MathematicalConstants::Pi/(2.0*kr))*p*
     ( k*(djv[i]+\hyperlink{namespacePlanarWave_a541691caf71477c8c389062797c0fdab}{I}*dyv[i]) - (0.5*(jv[i]+\hyperlink{namespacePlanarWave_a541691caf71477c8c389062797c0fdab}{I}*yv[i])/R) );
   \}
  
 \}\textcolor{comment}{// end of exact\_normal\_derivative}
 
 

\} \textcolor{comment}{// end of namespace}


\textcolor{comment}{}
\textcolor{comment}{/////////////////////////////////////////////////////////////////////}
\textcolor{comment}{/////////////////////////////////////////////////////////////////////}
\textcolor{comment}{/////////////////////////////////////////////////////////////////////}
\textcolor{comment}{}

\textcolor{comment}{//========= start\_of\_problem\_class=====================================}\textcolor{comment}{}
\textcolor{comment}{/// Problem class }
\textcolor{comment}{}\textcolor{comment}{//=====================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT> 
\textcolor{keyword}{class }\hyperlink{classFourierDecomposedHelmholtzProblem}{FourierDecomposedHelmholtzProblem} : \textcolor{keyword}{public} Problem
\{
 
\textcolor{keyword}{public}:
 \textcolor{comment}{}
\textcolor{comment}{ /// Constructor}
\textcolor{comment}{} \hyperlink{classFourierDecomposedHelmholtzProblem}{FourierDecomposedHelmholtzProblem}();
 \textcolor{comment}{}
\textcolor{comment}{ /// Destructor (empty)}
\textcolor{comment}{} ~\hyperlink{classFourierDecomposedHelmholtzProblem}{FourierDecomposedHelmholtzProblem}()\{\}
 \textcolor{comment}{}
\textcolor{comment}{ /// Update the problem specs before solve (empty)}
\textcolor{comment}{} \textcolor{keywordtype}{void} actions\_before\_newton\_solve()\{\}
 \textcolor{comment}{}
\textcolor{comment}{ /// Update the problem after solve (empty)}
\textcolor{comment}{} \textcolor{keywordtype}{void} actions\_after\_newton\_solve()\{\}
 \textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Doc the solution. DocInfo object stores flags/labels for where the}
\textcolor{comment}{ /// output gets written to}
\textcolor{comment}{} \textcolor{keywordtype}{void} doc\_solution(DocInfo& doc\_info);
  \textcolor{comment}{}
\textcolor{comment}{ /// Recompute gamma integral before checking Newton residuals}
\textcolor{comment}{} \textcolor{keywordtype}{void} actions\_before\_newton\_convergence\_check()
  \{
   \textcolor{keywordflow}{if} (!CommandLineArgs::command\_line\_flag\_has\_been\_set(\textcolor{stringliteral}{"--square\_domain"}))
    \{
     Helmholtz\_outer\_boundary\_mesh\_pt->setup\_gamma();
    \}
  \}
\textcolor{comment}{}
\textcolor{comment}{ /// Actions before adapt: Wipe the mesh of prescribed flux elements}
\textcolor{comment}{} \textcolor{keywordtype}{void} actions\_before\_adapt();
 \textcolor{comment}{}
\textcolor{comment}{ /// Actions after adapt: Rebuild the mesh of prescribed flux elements}
\textcolor{comment}{} \textcolor{keywordtype}{void} actions\_after\_adapt();
 \textcolor{comment}{}
\textcolor{comment}{ /// Check gamma computation}
\textcolor{comment}{} \textcolor{keywordtype}{void} check\_gamma(DocInfo& doc\_info);
  
\textcolor{keyword}{private}:
 \textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Create BC elements on outer boundary}
\textcolor{comment}{} \textcolor{keywordtype}{void} create\_outer\_bc\_elements();
 \textcolor{comment}{}
\textcolor{comment}{ /// Create flux elements on inner boundary}
\textcolor{comment}{} \textcolor{keywordtype}{void} create\_flux\_elements\_on\_inner\_boundary();
 
 \textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Delete boundary face elements and wipe the surface mesh}
\textcolor{comment}{} \textcolor{keywordtype}{void} delete\_face\_elements( Mesh* \textcolor{keyword}{const} & boundary\_mesh\_pt)
  \{
   \textcolor{comment}{// Loop over the surface elements}
   \textcolor{keywordtype}{unsigned} n\_element = boundary\_mesh\_pt->nelement();
   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} e=0;e<n\_element;e++)
    \{
     \textcolor{comment}{// Kill surface element}
     \textcolor{keyword}{delete}  boundary\_mesh\_pt->element\_pt(e);
    \}
   
   \textcolor{comment}{// Wipe the mesh}
   boundary\_mesh\_pt->flush\_element\_and\_node\_storage();
   
  \} 

\textcolor{preprocessor}{#ifdef ADAPTIVE}
\textcolor{comment}{}
\textcolor{comment}{ /// Pointer to the "bulk" mesh}
\textcolor{comment}{} RefineableTriangleMesh<ELEMENT>* Bulk\_mesh\_pt;

\textcolor{preprocessor}{#else}
\textcolor{comment}{}
\textcolor{comment}{ /// Pointer to the "bulk" mesh}
\textcolor{comment}{} TriangleMesh<ELEMENT>* Bulk\_mesh\_pt;

\textcolor{preprocessor}{#endif}
  \textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Pointer to mesh containing the DtN boundary}
\textcolor{comment}{ /// condition elements}
\textcolor{comment}{} FourierDecomposedHelmholtzDtNMesh<ELEMENT>* Helmholtz\_outer\_boundary\_mesh\_pt;
\textcolor{comment}{}
\textcolor{comment}{ /// on the inner boundary}
\textcolor{comment}{} Mesh* Helmholtz\_inner\_boundary\_mesh\_pt;
\textcolor{comment}{}
\textcolor{comment}{ /// Trace file}
\textcolor{comment}{} ofstream Trace\_file;

\}; \textcolor{comment}{// end of problem class}



\textcolor{comment}{//=====================start\_of\_actions\_before\_adapt======================}\textcolor{comment}{}
\textcolor{comment}{/// Actions before adapt: Wipe the mesh of face elements}
\textcolor{comment}{}\textcolor{comment}{//========================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT>
\textcolor{keywordtype}{void} \hyperlink{classFourierDecomposedHelmholtzProblem_acbc6f3c692463e5a098ccec7fe9029c1}{FourierDecomposedHelmholtzProblem<ELEMENT>::actions\_before\_adapt}
      ()
\{ 
 \textcolor{comment}{// Kill the flux elements and wipe the boundary meshs}
 \textcolor{keywordflow}{if} (!CommandLineArgs::command\_line\_flag\_has\_been\_set(\textcolor{stringliteral}{"--square\_domain"}))
  \{
   delete\_face\_elements(Helmholtz\_outer\_boundary\_mesh\_pt);
  \}
 delete\_face\_elements(Helmholtz\_inner\_boundary\_mesh\_pt);

 \textcolor{comment}{// Rebuild the Problem's global mesh from its various sub-meshes}
 rebuild\_global\_mesh();

\}\textcolor{comment}{// end of actions\_before\_adapt}


\textcolor{comment}{//=====================start\_of\_actions\_after\_adapt=======================}\textcolor{comment}{}
\textcolor{comment}{///  Actions after adapt: Rebuild the face element meshes}
\textcolor{comment}{}\textcolor{comment}{//========================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT>
\textcolor{keywordtype}{void} \hyperlink{classFourierDecomposedHelmholtzProblem_a3258e3817d8747aac0409eca1a24d14b}{FourierDecomposedHelmholtzProblem<ELEMENT>::actions\_after\_adapt}
      ()
\{


 \textcolor{comment}{// Complete the build of all elements so they are fully functional}
 
 \textcolor{comment}{// Loop over the Helmholtz bulk elements to set up element-specific }
 \textcolor{comment}{// things that cannot be handled by constructor: Pass pointer to }
 \textcolor{comment}{// wave number squared}
 \textcolor{keywordtype}{unsigned} n\_element = Bulk\_mesh\_pt->nelement();
 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} e=0;e<n\_element;e++)
  \{
   \textcolor{comment}{// Upcast from GeneralisedElement to Helmholtz bulk element}
   ELEMENT *el\_pt = \textcolor{keyword}{dynamic\_cast<}ELEMENT*\textcolor{keyword}{>}(Bulk\_mesh\_pt->element\_pt(e));
   
   \textcolor{comment}{//Set the k\_squared  pointer}
   el\_pt->k\_squared\_pt() = &\hyperlink{namespaceProblemParameters_aa5362de1af9e257fde4317c367158a93}{ProblemParameters::K\_squared};

   \textcolor{comment}{// Set pointer to Fourier wave number}
   el\_pt->fourier\_wavenumber\_pt()=&\hyperlink{namespaceProblemParameters_aaa674958a1ca6ee0b99de3377288c93f}{ProblemParameters::N\_fourier};
  \}

 \textcolor{comment}{// Create prescribed-flux elements and BC elements }
 \textcolor{comment}{// from all elements that are adjacent to the boundaries and add them to }
 \textcolor{comment}{// Helmholtz\_boundary\_meshes}
 create\_flux\_elements\_on\_inner\_boundary();
 \textcolor{keywordflow}{if} (!CommandLineArgs::command\_line\_flag\_has\_been\_set(\textcolor{stringliteral}{"--square\_domain"}))
  \{
   create\_outer\_bc\_elements();
  \}

 \textcolor{comment}{// Rebuild the Problem's global mesh from its various sub-meshes}
 rebuild\_global\_mesh();
  
\}\textcolor{comment}{// end of actions\_after\_adapt}


\textcolor{comment}{//=======start\_of\_constructor=============================================}\textcolor{comment}{}
\textcolor{comment}{/// Constructor for Fourier-decomposed Helmholtz problem}
\textcolor{comment}{}\textcolor{comment}{//========================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT>
\hyperlink{classFourierDecomposedHelmholtzProblem_ab368ed8fe04d4e3db67d13bab9e7b52e}{FourierDecomposedHelmholtzProblem<ELEMENT>::}
\hyperlink{classFourierDecomposedHelmholtzProblem_ab368ed8fe04d4e3db67d13bab9e7b52e}{FourierDecomposedHelmholtzProblem}()
\{ 

 \textcolor{comment}{// Open trace file}
 Trace\_file.open(\textcolor{stringliteral}{"RESLT/trace.dat"});
 
 \textcolor{comment}{// Create circles representing inner and outer boundary}
 \textcolor{keywordtype}{double} x\_c=0.0;
 \textcolor{keywordtype}{double} y\_c=0.0;
 \textcolor{keywordtype}{double} r\_min=1.0;
 \textcolor{keywordtype}{double} r\_max=3.0;
 Circle* inner\_circle\_pt=\textcolor{keyword}{new} Circle(x\_c,y\_c,r\_min);
 Circle* outer\_circle\_pt=\textcolor{keyword}{new} Circle(x\_c,y\_c,r\_max);
 
 \textcolor{comment}{// Edges/boundary segments making up outer boundary}
 \textcolor{comment}{//-------------------------------------------------}
 Vector<TriangleMeshCurveSection*> outer\_boundary\_line\_pt(4);
 
 \textcolor{comment}{// Number of segments used for representing the curvilinear boundaries}
 \textcolor{keywordtype}{unsigned} n\_segments = 20;
 
 \textcolor{comment}{// All poly boundaries are defined by two vertices}
 Vector<Vector<double> > boundary\_vertices(2);
 

 \textcolor{comment}{// Bottom straight boundary on symmetry line}
 \textcolor{comment}{//------------------------------------------}
 boundary\_vertices[0].resize(2);
 boundary\_vertices[0][0]=0.0;
 boundary\_vertices[0][1]=-r\_min;
 boundary\_vertices[1].resize(2);
 boundary\_vertices[1][0]=0.0;
 boundary\_vertices[1][1]=-r\_max;

 \textcolor{keywordtype}{unsigned} boundary\_id=0;
 outer\_boundary\_line\_pt[0]=
  \textcolor{keyword}{new} TriangleMeshPolyLine(boundary\_vertices,boundary\_id);


 \textcolor{keywordflow}{if} (CommandLineArgs::command\_line\_flag\_has\_been\_set(\textcolor{stringliteral}{"--square\_domain"}))
  \{
   \textcolor{comment}{// Square outer boundary:}
   \textcolor{comment}{//-----------------------}

   Vector<Vector<double> > boundary\_vertices(4);
   boundary\_vertices[0].resize(2);
   boundary\_vertices[0][0]=0.0;
   boundary\_vertices[0][1]=-r\_max;
   boundary\_vertices[1].resize(2);
   boundary\_vertices[1][0]=r\_max;
   boundary\_vertices[1][1]=-r\_max;
   boundary\_vertices[2].resize(2);
   boundary\_vertices[2][0]=r\_max;
   boundary\_vertices[2][1]=r\_max;
   boundary\_vertices[3].resize(2);
   boundary\_vertices[3][0]=0.0;
   boundary\_vertices[3][1]=r\_max;

   boundary\_id=1;
   outer\_boundary\_line\_pt[1]=
    \textcolor{keyword}{new} TriangleMeshPolyLine(boundary\_vertices,boundary\_id);
  \}
 \textcolor{keywordflow}{else}
  \{
   \textcolor{comment}{// Outer circular boundary:}
   \textcolor{comment}{//-------------------------}
   \textcolor{comment}{// The intrinsic coordinates for the beginning and end of the curve}
   \textcolor{keywordtype}{double} s\_start = -0.5*MathematicalConstants::Pi;
   \textcolor{keywordtype}{double} s\_end   =  0.5*MathematicalConstants::Pi;
   
   boundary\_id = 1;
   outer\_boundary\_line\_pt[1]=
    \textcolor{keyword}{new} TriangleMeshCurviLine(outer\_circle\_pt,
                              s\_start,
                              s\_end,
                              n\_segments,
                              boundary\_id);
  \}


 \textcolor{comment}{// Top straight boundary on symmetry line}
 \textcolor{comment}{//---------------------------------------}
 boundary\_vertices[0][0]=0.0;
 boundary\_vertices[0][1]=r\_max;
 boundary\_vertices[1][0]=0.0;
 boundary\_vertices[1][1]=r\_min;

 boundary\_id=2;
 outer\_boundary\_line\_pt[2]=
  \textcolor{keyword}{new} TriangleMeshPolyLine(boundary\_vertices,boundary\_id);
 

 \textcolor{comment}{// Inner circular boundary:}
 \textcolor{comment}{//-------------------------}
 
 \textcolor{comment}{// The intrinsic coordinates for the beginning and end of the curve}
 \textcolor{keywordtype}{double} s\_start =  0.5*MathematicalConstants::Pi;
 \textcolor{keywordtype}{double} s\_end   =  -0.5*MathematicalConstants::Pi;
 
 boundary\_id = 3;
 outer\_boundary\_line\_pt[3]=
  \textcolor{keyword}{new} TriangleMeshCurviLine(inner\_circle\_pt,
                            s\_start,
                            s\_end,
                            n\_segments,
                            boundary\_id);
 
 
 \textcolor{comment}{// Create closed curve that defines outer boundary}
 \textcolor{comment}{//------------------------------------------------}
 TriangleMeshClosedCurve *outer\_boundary\_pt =
  \textcolor{keyword}{new} TriangleMeshClosedCurve(outer\_boundary\_line\_pt);
 

 \textcolor{comment}{// Use the TriangleMeshParameters object for helping on the manage of the}
 \textcolor{comment}{// TriangleMesh parameters. The only parameter that needs to take is the}
 \textcolor{comment}{// outer boundary.}
 TriangleMeshParameters triangle\_mesh\_parameters(outer\_boundary\_pt);
 
 \textcolor{comment}{// Specify maximum element area}
 \textcolor{keywordtype}{double} element\_area = 0.1; 
 triangle\_mesh\_parameters.element\_area() = element\_area;
 
\textcolor{preprocessor}{#ifdef ADAPTIVE}
 
 \textcolor{comment}{// Build "bulk" mesh}
 Bulk\_mesh\_pt=\textcolor{keyword}{new} RefineableTriangleMesh<ELEMENT>(triangle\_mesh\_parameters);

 \textcolor{comment}{// Create/set error estimator}
 Bulk\_mesh\_pt->spatial\_error\_estimator\_pt()=\textcolor{keyword}{new} Z2ErrorEstimator;
 
 \textcolor{comment}{// Choose error tolerances to force some uniform refinement}
 Bulk\_mesh\_pt->min\_permitted\_error()=0.00004;
 Bulk\_mesh\_pt->max\_permitted\_error()=0.0001;

\textcolor{preprocessor}{#else}

 \textcolor{comment}{// Pass the TriangleMeshParameters object to the TriangleMesh one}
 Bulk\_mesh\_pt= \textcolor{keyword}{new} TriangleMesh<ELEMENT>(triangle\_mesh\_parameters);

\textcolor{preprocessor}{#endif}

 \textcolor{comment}{// Check what we've built so far...}
 Bulk\_mesh\_pt->output(\textcolor{stringliteral}{"mesh.dat"});
 Bulk\_mesh\_pt->output\_boundaries(\textcolor{stringliteral}{"boundaries.dat"});
 

 \textcolor{keywordflow}{if} (!CommandLineArgs::command\_line\_flag\_has\_been\_set(\textcolor{stringliteral}{"--square\_domain"}))
  \{
   \textcolor{comment}{// Create mesh for DtN elements on outer boundary}
   Helmholtz\_outer\_boundary\_mesh\_pt=
    \textcolor{keyword}{new} FourierDecomposedHelmholtzDtNMesh<ELEMENT>(
     r\_max,\hyperlink{namespaceProblemParameters_aa529b33b7feb959e0c044447bf0f6c6f}{ProblemParameters::Nterms\_for\_DtN});
   
   \textcolor{comment}{// Populate it with elements}
   create\_outer\_bc\_elements();
  \}

 \textcolor{comment}{// Create flux elements on inner boundary}
 Helmholtz\_inner\_boundary\_mesh\_pt=\textcolor{keyword}{new} Mesh;
 create\_flux\_elements\_on\_inner\_boundary();
 
 \textcolor{comment}{// Add the several sub meshes to the problem}
 add\_sub\_mesh(Bulk\_mesh\_pt); 
 add\_sub\_mesh(Helmholtz\_inner\_boundary\_mesh\_pt); 
 \textcolor{keywordflow}{if} (!CommandLineArgs::command\_line\_flag\_has\_been\_set(\textcolor{stringliteral}{"--square\_domain"}))
  \{
   add\_sub\_mesh(Helmholtz\_outer\_boundary\_mesh\_pt); 
  \}

 \textcolor{comment}{// Build the Problem's global mesh from its various sub-meshes}
 build\_global\_mesh();

 \textcolor{comment}{// Complete the build of all elements so they are fully functional}
 \textcolor{keywordtype}{unsigned} n\_element = Bulk\_mesh\_pt->nelement();
 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} i=0;i<n\_element;i++)
  \{
   \textcolor{comment}{// Upcast from GeneralsedElement to the present element}
   ELEMENT *el\_pt = \textcolor{keyword}{dynamic\_cast<}ELEMENT*\textcolor{keyword}{>}(Bulk\_mesh\_pt->element\_pt(i));
   
   \textcolor{comment}{//Set the k\_squared pointer}
   el\_pt->k\_squared\_pt()=&\hyperlink{namespaceProblemParameters_aa5362de1af9e257fde4317c367158a93}{ProblemParameters::K\_squared};
   
   \textcolor{comment}{// Set pointer to Fourier wave number}
   el\_pt->fourier\_wavenumber\_pt()=&\hyperlink{namespaceProblemParameters_aaa674958a1ca6ee0b99de3377288c93f}{ProblemParameters::N\_fourier};
  \}
 
 \textcolor{comment}{// Setup equation numbering scheme}
 cout <<\textcolor{stringliteral}{"Number of equations: "} << assign\_eqn\_numbers() << std::endl; 

\} \textcolor{comment}{// end of constructor}



\textcolor{comment}{//=================================start\_of\_check\_gamma===================}\textcolor{comment}{}
\textcolor{comment}{/// Check gamma computation: \(\backslash\)f$ \(\backslash\)gamma = -du/dn \(\backslash\)f$}
\textcolor{comment}{}\textcolor{comment}{//========================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT>
\textcolor{keywordtype}{void} \hyperlink{classFourierDecomposedHelmholtzProblem_ac4f3f737660b11e8762a61bca999eb0f}{FourierDecomposedHelmholtzProblem<ELEMENT>::check\_gamma}
      (DocInfo& doc\_info)
\{
 
 \textcolor{comment}{// Compute gamma stuff}
 Helmholtz\_outer\_boundary\_mesh\_pt->setup\_gamma();
 
 ofstream some\_file;
 \textcolor{keywordtype}{char} filename[100];

 sprintf(filename,\textcolor{stringliteral}{"%s/gamma\_test%i.dat"},doc\_info.directory().c\_str(),
         doc\_info.number());
 some\_file.open(filename);
  
 \textcolor{comment}{//first loop over elements e}
 \textcolor{keywordtype}{unsigned} nel=Helmholtz\_outer\_boundary\_mesh\_pt->nelement();
 \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} e=0;e<nel;e++)
  \{
   \textcolor{comment}{// Get a pointer to element}
   FourierDecomposedHelmholtzDtNBoundaryElement<ELEMENT>* el\_pt=
    \textcolor{keyword}{dynamic\_cast<}FourierDecomposedHelmholtzDtNBoundaryElement<ELEMENT>*\textcolor{keyword}{>}
    (Helmholtz\_outer\_boundary\_mesh\_pt->element\_pt(e));
   
   \textcolor{comment}{//Set the value of n\_intpt}
   \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} n\_intpt =el\_pt->integral\_pt()->nweight();
   
   \textcolor{comment}{// Get gamma at all gauss points in element}
   Vector<std::complex<double> > gamma(
    Helmholtz\_outer\_boundary\_mesh\_pt->gamma\_at\_gauss\_point(el\_pt));
   
   \textcolor{comment}{//Loop over the integration points}
   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} ipt=0;ipt<n\_intpt;ipt++)
    \{
     \textcolor{comment}{//Allocate and initialise coordiante}
     Vector<double> x(el\_pt->dim()+1,0.0);
     
     \textcolor{comment}{//Set the Vector to hold local coordinates}
     \textcolor{keywordtype}{unsigned} n=el\_pt->dim();
     Vector<double> s(n,0.0);
     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} i=0;i<n;i++)
      \{
       s[i]=el\_pt->integral\_pt()->knot(ipt,i);
      \}
     
     \textcolor{comment}{//Get the coordinates of the integration point}
     el\_pt->interpolated\_x(s,x);
     
     complex<double> flux;
     \hyperlink{namespaceProblemParameters_aa544d1f3e384d3283f7113512931ea8f}{ProblemParameters::exact\_minus\_dudr}(x,flux);
     some\_file << atan2(x[0],x[1]) << \textcolor{stringliteral}{" "} 
               << gamma[ipt].real() << \textcolor{stringliteral}{" "}
               << gamma[ipt].imag() << \textcolor{stringliteral}{" "}
               << flux.real() << \textcolor{stringliteral}{" "} 
               << flux.imag() << \textcolor{stringliteral}{" "} 
               << std::endl;
     
    \}\textcolor{comment}{// end of loop over integration points}
   
  \}\textcolor{comment}{// end of loop over elements}
 
 some\_file.close();
  
\}\textcolor{comment}{//end of output\_gamma}


\textcolor{comment}{//===============start\_of\_doc=============================================}\textcolor{comment}{}
\textcolor{comment}{/// Doc the solution: doc\_info contains labels/output directory etc.}
\textcolor{comment}{}\textcolor{comment}{//========================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT>
\textcolor{keywordtype}{void} \hyperlink{classFourierDecomposedHelmholtzProblem_a893efb01f8f1d254315201121766d882}{FourierDecomposedHelmholtzProblem<ELEMENT>::doc\_solution}
      (DocInfo& doc\_info)
\{ 

 ofstream some\_file;
 \textcolor{keywordtype}{char} filename[100];

 \textcolor{comment}{// Number of plot points: npts x npts}
 \textcolor{keywordtype}{unsigned} npts=5;
  
 \textcolor{comment}{// Output solution }
 \textcolor{comment}{//-----------------}
 sprintf(filename,\textcolor{stringliteral}{"%s/soln%i.dat"},doc\_info.directory().c\_str(),
         doc\_info.number());
 some\_file.open(filename);
 Bulk\_mesh\_pt->output(some\_file,npts);
 some\_file.close();


 \textcolor{comment}{// Output exact solution }
 \textcolor{comment}{//----------------------}
 sprintf(filename,\textcolor{stringliteral}{"%s/exact\_soln%i.dat"},doc\_info.directory().c\_str(),
         doc\_info.number());
 some\_file.open(filename);
 Bulk\_mesh\_pt->output\_fct(some\_file,npts,\hyperlink{namespaceProblemParameters_af750b29069b29bd38b5220ecf534e7f7}{ProblemParameters::get\_exact\_u}); 
 some\_file.close();
 
 
 \textcolor{comment}{// Doc error and return of the square of the L2 error}
 \textcolor{comment}{//---------------------------------------------------}
 \textcolor{keywordtype}{double} error,norm;
 sprintf(filename,\textcolor{stringliteral}{"%s/error%i.dat"},doc\_info.directory().c\_str(),
         doc\_info.number());
 some\_file.open(filename);
 Bulk\_mesh\_pt->compute\_error(some\_file,\hyperlink{namespaceProblemParameters_af750b29069b29bd38b5220ecf534e7f7}{ProblemParameters::get\_exact\_u},
                             error,norm); 
 some\_file.close();
 
 \textcolor{comment}{// Doc L2 error and norm of solution}
 cout << \textcolor{stringliteral}{"\(\backslash\)nNorm of error   : "} << sqrt(error) << std::endl; 
 cout << \textcolor{stringliteral}{"Norm of solution: "} << sqrt(norm) << std::endl << std::endl;
 

 \textcolor{comment}{// Write norm of solution to trace file}
 Bulk\_mesh\_pt->compute\_norm(norm); 
 Trace\_file  << norm << std::endl;


 \textcolor{keywordflow}{if} (!CommandLineArgs::command\_line\_flag\_has\_been\_set(\textcolor{stringliteral}{"--square\_domain"}))
  \{
   \textcolor{comment}{// Check gamma computation}
   check\_gamma(doc\_info);
  \}

\} \textcolor{comment}{// end of doc}



\textcolor{comment}{//============start\_of\_create\_outer\_bc\_elements==============================}\textcolor{comment}{}
\textcolor{comment}{/// Create BC elements on outer boundary}
\textcolor{comment}{}\textcolor{comment}{//========================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT>
\textcolor{keywordtype}{void} \hyperlink{classFourierDecomposedHelmholtzProblem_a359d402bb4aed7d83973248d82085efb}{FourierDecomposedHelmholtzProblem<ELEMENT>::create\_outer\_bc\_elements}
      ()
\{

 \textcolor{comment}{// Outer boundary is boundary 1:}
 \textcolor{keywordtype}{unsigned} b=1;

 \textcolor{comment}{// Loop over the bulk elements adjacent to boundary b?}
 \textcolor{keywordtype}{unsigned} n\_element = Bulk\_mesh\_pt->nboundary\_element(b);
 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} e=0;e<n\_element;e++)
  \{
   \textcolor{comment}{// Get pointer to the bulk element that is adjacent to boundary b}
   ELEMENT* bulk\_elem\_pt = \textcolor{keyword}{dynamic\_cast<}ELEMENT*\textcolor{keyword}{>}(
    Bulk\_mesh\_pt->boundary\_element\_pt(b,e));
   
   \textcolor{comment}{//Find the index of the face of element e along boundary b }
   \textcolor{keywordtype}{int} face\_index = Bulk\_mesh\_pt->face\_index\_at\_boundary(b,e);
   
   \textcolor{comment}{// Build the corresponding DtN element}
   FourierDecomposedHelmholtzDtNBoundaryElement<ELEMENT>* flux\_element\_pt = \textcolor{keyword}{new} 
    FourierDecomposedHelmholtzDtNBoundaryElement<ELEMENT>(bulk\_elem\_pt,
                                                          face\_index);
   
   \textcolor{comment}{//Add the flux boundary element to the  helmholtz\_outer\_boundary\_mesh}
   Helmholtz\_outer\_boundary\_mesh\_pt->add\_element\_pt(flux\_element\_pt);

   \textcolor{comment}{// Set pointer to the mesh that contains all the boundary condition}
   \textcolor{comment}{// elements on this boundary}
   flux\_element\_pt->
    set\_outer\_boundary\_mesh\_pt(Helmholtz\_outer\_boundary\_mesh\_pt);
  \}

\} \textcolor{comment}{// end of create\_outer\_bc\_elements}



\textcolor{comment}{//============start\_of\_create\_flux\_elements=================}\textcolor{comment}{}
\textcolor{comment}{/// Create flux elements on inner boundary}
\textcolor{comment}{}\textcolor{comment}{//==========================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT>
\textcolor{keywordtype}{void}  \hyperlink{classFourierDecomposedHelmholtzProblem_a81d64611f2de2492cec6b0621d8124b0}{FourierDecomposedHelmholtzProblem<ELEMENT>::}
\hyperlink{classFourierDecomposedHelmholtzProblem_a81d64611f2de2492cec6b0621d8124b0}{create\_flux\_elements\_on\_inner\_boundary}()
\{
 \textcolor{comment}{// Apply flux bc on inner boundary (boundary 3)}
 \textcolor{keywordtype}{unsigned} b=3;

\textcolor{comment}{// Loop over the bulk elements adjacent to boundary b}
 \textcolor{keywordtype}{unsigned} n\_element = Bulk\_mesh\_pt->nboundary\_element(b);
 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} e=0;e<n\_element;e++)
  \{
   \textcolor{comment}{// Get pointer to the bulk element that is adjacent to boundary b}
   ELEMENT* bulk\_elem\_pt = \textcolor{keyword}{dynamic\_cast<}ELEMENT*\textcolor{keyword}{>}(
    Bulk\_mesh\_pt->boundary\_element\_pt(b,e));
   
   \textcolor{comment}{//Find the index of the face of element e along boundary b }
   \textcolor{keywordtype}{int} face\_index = Bulk\_mesh\_pt->face\_index\_at\_boundary(b,e);
   
   \textcolor{comment}{// Build the corresponding prescribed incoming-flux element}
   FourierDecomposedHelmholtzFluxElement<ELEMENT>* flux\_element\_pt = \textcolor{keyword}{new} 
    FourierDecomposedHelmholtzFluxElement<ELEMENT>(bulk\_elem\_pt,face\_index);
   
   \textcolor{comment}{//Add the prescribed incoming-flux element to the surface mesh}
   Helmholtz\_inner\_boundary\_mesh\_pt->add\_element\_pt(flux\_element\_pt);
   
   \textcolor{comment}{// Set the pointer to the prescribed flux function}
   flux\_element\_pt->flux\_fct\_pt() = &\hyperlink{namespaceProblemParameters_aa544d1f3e384d3283f7113512931ea8f}{ProblemParameters::exact\_minus\_dudr}
      ;

  \} \textcolor{comment}{//end of loop over bulk elements adjacent to boundary b}
 
\} \textcolor{comment}{// end of create flux elements on inner boundary}



\textcolor{comment}{//===== start\_of\_main=====================================================}\textcolor{comment}{}
\textcolor{comment}{/// Driver code for Fourier decomposed Helmholtz problem}
\textcolor{comment}{}\textcolor{comment}{//========================================================================}
\textcolor{keywordtype}{int} \hyperlink{sphere__scattering_8cc_a3c04138a5bfe5d72780bb7e82a18e627}{main}(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char} **argv)
\{
 \textcolor{comment}{// Store command line arguments}
 CommandLineArgs::setup(argc,argv);

 \textcolor{comment}{// Define possible command line arguments and parse the ones that}
 \textcolor{comment}{// were actually specified}
 
 \textcolor{comment}{// Square domain without DtN}
 CommandLineArgs::specify\_command\_line\_flag(\textcolor{stringliteral}{"--square\_domain"});

 \textcolor{comment}{// Parse command line}
 CommandLineArgs::parse\_and\_assign(); 
 
 \textcolor{comment}{// Doc what has actually been specified on the command line}
 CommandLineArgs::doc\_specified\_flags();

 \textcolor{comment}{// Check if the claimed representation of a planar wave in}
 \textcolor{comment}{// the tutorial is correct -- of course it is!}
 \textcolor{comment}{//PlanarWave::plot();}

 \textcolor{comment}{// Test Bessel/Hankel functions}
 \textcolor{comment}{//-----------------------------}
 \{
  \textcolor{comment}{// Number of Bessel functions to be computed}
  \textcolor{keywordtype}{unsigned} n=3;
  
  \textcolor{comment}{// Offset of Bessel function order (less than 1!)}
  \textcolor{keywordtype}{double} bessel\_offset=0.5;
  
  ofstream bessely\_file(\textcolor{stringliteral}{"besselY.dat"});
  ofstream bessely\_deriv\_file(\textcolor{stringliteral}{"dbesselY.dat"});
  
  ofstream besselj\_file(\textcolor{stringliteral}{"besselJ.dat"});
  ofstream besselj\_deriv\_file(\textcolor{stringliteral}{"dbesselJ.dat"});
  
  \textcolor{comment}{// Evaluate Bessel/Hankel functions}
  Vector<double> jv(n+1);
  Vector<double> yv(n+1);
  Vector<double> djv(n+1);
  Vector<double> dyv(n+1);
  \textcolor{keywordtype}{double} x\_min=0.5;
  \textcolor{keywordtype}{double} x\_max=5.0;
  \textcolor{keywordtype}{unsigned} nplot=100;
  \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} i=0;i<nplot;i++)
   \{
    \textcolor{keywordtype}{double} x=x\_min+(x\_max-x\_min)*\textcolor{keywordtype}{double}(i)/double(nplot-1);
    \textcolor{keywordtype}{double} order\_max\_in=double(n)+bessel\_offset;
    \textcolor{keywordtype}{double} order\_max\_out=0;
    
    \textcolor{comment}{// This function returns vectors containing }
    \textcolor{comment}{// J\_k(x), Y\_k(x) and their derivatives}
    \textcolor{comment}{// up to k=order\_max, with k increasing in}
    \textcolor{comment}{// integer increments starting with smallest}
    \textcolor{comment}{// positive value. So, e.g. for order\_max=3.5}
    \textcolor{comment}{// jv[0] contains J\_\{1/2\}(x),}
    \textcolor{comment}{// jv[1] contains J\_\{3/2\}(x),}
    \textcolor{comment}{// jv[2] contains J\_\{5/2\}(x),}
    \textcolor{comment}{// jv[3] contains J\_\{7/2\}(x).}
    CRBond\_Bessel::bessjyv(order\_max\_in,x,
                           order\_max\_out,
                           &jv[0],&yv[0],
                           &djv[0],&dyv[0]);
    bessely\_file << x << \textcolor{stringliteral}{" "};
    \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} j=0;j<=n;j++)
     \{
      bessely\_file << yv[j] << \textcolor{stringliteral}{" "};
     \}
    bessely\_file << std::endl;
    
    besselj\_file << x << \textcolor{stringliteral}{" "};
    \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} j=0;j<=n;j++)
     \{
      besselj\_file << jv[j] << \textcolor{stringliteral}{" "};
     \}
    besselj\_file << std::endl;
    
    bessely\_deriv\_file << x << \textcolor{stringliteral}{" "};
    \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} j=0;j<=n;j++)
     \{
      bessely\_deriv\_file << dyv[j] << \textcolor{stringliteral}{" "};
     \}
    bessely\_deriv\_file << std::endl;
    
    besselj\_deriv\_file << x << \textcolor{stringliteral}{" "};
    \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} j=0;j<=n;j++)
     \{
      besselj\_deriv\_file << djv[j] << \textcolor{stringliteral}{" "};
     \}
    besselj\_deriv\_file << std::endl;
    
   \}
  bessely\_file.close();
  besselj\_file.close();
  bessely\_deriv\_file.close();
  besselj\_deriv\_file.close();
 \}
 
 
 \textcolor{comment}{// Test Legrendre Polynomials}
 \textcolor{comment}{//---------------------------}
 \{
  \textcolor{comment}{// Number of lower indices}
  \textcolor{keywordtype}{unsigned} n=3;
    
  ofstream some\_file(\textcolor{stringliteral}{"legendre3.dat"});
  \textcolor{keywordtype}{unsigned} nplot=100;
  \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} i=0;i<nplot;i++)
   \{
    \textcolor{keywordtype}{double} x=double(i)/double(nplot-1);

    some\_file << x << \textcolor{stringliteral}{" "};
    \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} j=0;j<=n;j++)
     \{
      some\_file <<  Legendre\_functions\_helper::plgndr2(n,j,x) << \textcolor{stringliteral}{" "};
     \}
    some\_file << std::endl;
   \}
  some\_file.close();
 \}

 
\textcolor{preprocessor}{#ifdef ADAPTIVE}

 \textcolor{comment}{// Create the problem with 2D six-node elements from the}
 \textcolor{comment}{// TFourierDecomposedHelmholtzElement family. }
 \hyperlink{classFourierDecomposedHelmholtzProblem}{FourierDecomposedHelmholtzProblem}<
      ProjectableFourierDecomposedHelmholtzElement<
  TFourierDecomposedHelmholtzElement<3> > > problem;
 
\textcolor{preprocessor}{#else}
 
 \textcolor{comment}{// Create the problem with 2D six-node elements from the}
 \textcolor{comment}{// TFourierDecomposedHelmholtzElement family. }
 \hyperlink{classFourierDecomposedHelmholtzProblem}{FourierDecomposedHelmholtzProblem<TFourierDecomposedHelmholtzElement<3>}
       > 
  problem;
 
\textcolor{preprocessor}{#endif}

 \textcolor{comment}{// Create label for output}
 DocInfo doc\_info;
 
 \textcolor{comment}{// Set output directory}
 doc\_info.set\_directory(\textcolor{stringliteral}{"RESLT"});
 
 \textcolor{comment}{// Solve for a few Fourier wavenumbers}
 \textcolor{keywordflow}{for} (\hyperlink{namespaceProblemParameters_aaa674958a1ca6ee0b99de3377288c93f}{ProblemParameters::N\_fourier}=0;
      \hyperlink{namespaceProblemParameters_aaa674958a1ca6ee0b99de3377288c93f}{ProblemParameters::N\_fourier}<4;
      \hyperlink{namespaceProblemParameters_aaa674958a1ca6ee0b99de3377288c93f}{ProblemParameters::N\_fourier}++)
  \{
   \textcolor{comment}{// Step number}
   doc\_info.number()=\hyperlink{namespaceProblemParameters_aaa674958a1ca6ee0b99de3377288c93f}{ProblemParameters::N\_fourier};
   


\textcolor{preprocessor}{#ifdef ADAPTIVE}

 \textcolor{comment}{// Max. number of adaptations}
 \textcolor{keywordtype}{unsigned} max\_adapt=1;
 
   \textcolor{comment}{// Solve the problem with Newton's method, allowing}
   \textcolor{comment}{// up to max\_adapt mesh adaptations after every solve.}
   problem.newton\_solve(max\_adapt);

\textcolor{preprocessor}{#else}

   \textcolor{comment}{// Solve the problem}
   problem.newton\_solve();

\textcolor{preprocessor}{#endif}
   
   \textcolor{comment}{//Output the solution}
   problem.\hyperlink{classFourierDecomposedHelmholtzProblem_a893efb01f8f1d254315201121766d882}{doc\_solution}(doc\_info);
  \}
 
\} \textcolor{comment}{//end of main}







\end{DoxyCodeInclude}




 

\hypertarget{index_sources}{}\section{Source files for this tutorial}\label{index_sources}

\begin{DoxyItemize}
\item The source files for this tutorial are located in the directory\+:~\newline
~\newline
 \begin{center} \href{../../../../demo_drivers/fourier_decomposed_helmholtz/sphere_scattering}{\tt demo\+\_\+drivers/fourier\+\_\+decomposed\+\_\+helmholtz/sphere\+\_\+scattering/ } \end{center} ~\newline

\item The driver code is\+: ~\newline
~\newline
 \begin{center} \href{../../../../demo_drivers/fourier_decomposed_helmholtz/sphere_scattering/unstructured_sphere_scattering.cc}{\tt demo\+\_\+drivers/fourier\+\_\+decomposed\+\_\+helmholtz/sphere\+\_\+scattering/unstructured\+\_\+sphere\+\_\+scattering.\+cc } \end{center} 
\end{DoxyItemize}



 

 \hypertarget{index_pdf}{}\section{P\+D\+F file}\label{index_pdf}
A \href{../latex/refman.pdf}{\tt pdf version} of this document is available. \end{document}
