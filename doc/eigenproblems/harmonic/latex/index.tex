In this document, we demonstrate how to solve a 1D eigenproblem (eigenvalues of the 1D Laplace operator in a bounded domain) by creating custom elements. The tutorial is similar in spirit to the \href{../../../quick_guide/html/index.html}{\tt quick guide } but far less detailed. \begin{center} \tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*{1}{|X[-1]}|}
\hline
\begin{center} {\bfseries One-\/dimensional model eigenvalue problem} \end{center}  Solve \[ \frac{\partial^2u}{\partial x_1^2} + \lambda u = 0, \ \ \ \ \ \ \ \ \ \ (1) \] in the domain $D =\left\{ x_1 \in [0,1] \right\}$, with homogeneous Dirichlet boundary conditions \[ \left. u\right|_{\partial D}=0. \ \ \ \ \ \ \ \ \ \ (2) \]   \\\cline{1-1}
\end{longtabu}
\end{center} 

An eigenfunction must be non-\/zero by definition and so the exact solutions are given by the countably infinite set\+: \[ u_{n} = \sin (\sqrt{\lambda}_{n} x_{1}), \ \ \ \ \ \ \ \lambda_{n} = n^{2}\pi^{2}. \]

We provide a detailed discussion of the driver code \href{../../../../demo_drivers/eigenproblems/harmonic/harmonic.cc}{\tt harmonic.\+cc} which solves the problem for the first four eigenvalues.

In {\ttfamily oomph-\/lib} all eigenproblems are solved by using interfaces to third-\/party libraries. The default is L\+A\+P\+A\+CK\textquotesingle{}s (direct) QZ solver which is included with the library. An interface is also provided to the serial version of A\+R\+P\+A\+CK, an iterative solver, but we are not allowed to redistribute the source code, so it must be downloaded separately. That said, much of the functionality of A\+R\+P\+A\+CK has been superseded by the A\+N\+A\+S\+A\+ZI solver that is part of The Trilinos Project. Thus, if you want to solve small problems, use the default QZ solver; for larger problems, we recommend using A\+N\+A\+S\+A\+ZI.



 

\hypertarget{index_theory}{}\section{Overview of the theory}\label{index_theory}
A discrete (linear) eigenproblem takes the form \[ J_{ij} V_{j} = \lambda M_{ij} V_{j}, \ \ \ \ \ \ \ \ (3) \] where $ V_{j} $ is the vector of discrete unknowns, $ \lambda $ is the eigenvalue, and $ J_{ij} $ and $ M_{ij} $ are two matrices\+: $ J_{ij} $ (often denoted $ K_{ij} $ in the literature) is known as the stiffness matrix and $ M_{ij} $ is termed the mass matrix. The third-\/party libraries mentioned above all solve systems of the form (3), and within {\ttfamily oomph-\/lib} we must simply provide the required mass and stiffness matrices.\hypertarget{index_linear_stab}{}\subsection{Linear Stability Theory}\label{index_linear_stab}
In many cases, eigenproblems arise from linear stability analyses of steady solutions to our set of nonlinear residuals. For example, if we have a time-\/dependent system of equations \[ \frac{\partial u}{\partial t} = \mathcal{F}(u), \] then the residual formulation is \[ \mathcal{R}(u) = \mathcal{F}(u) - \frac{\partial u}{\partial t} = 0; \ \ \ \ \ \ \ (4) \] and steady solutions, $ u_{s} $ are found by setting $ \partial u / \partial t = 0 $. Note that in a nonlinear system there may be many possible steady solutions for the same set of parameter values.

A linear stability analysis proceeds by assuming that the steady solution is perturbed by a small amount, so that $ u = u_{s} + \epsilon \hat{u} $, where $ |\epsilon| \ll 1$. If we substitute this expression into the governing equation (4) and neglect terms that involve $ \epsilon^{2} $ (on the assumption that they are really small) then we obtain the equation\+: \[ \mathcal{F}(u_{s}) + \epsilon \left[\frac{\partial \mathcal{F}(u_{s})}{\partial u} \hat{u} - \frac{\partial \hat{u}}{\partial t} \right] \approx 0. \] Note that we have used a Taylor expansion of $ \mathcal{F} $, so we are assuming that such an operation \char`\"{}makes sense\char`\"{}. The solution $ u_{s} $ is a steady state, so by definition $\mathcal{F}(u_{s}) = 0$ and then we are left with the {\bfseries linear} equation \[ \frac{\partial \mathcal{F} (u_{s})}{\partial u} \hat{u} = \mathcal{J}(u_{s}) \hat{u} = \frac{\partial \hat{u}}{\partial t}. \ \ \ \ \ \ \ \ \ (5) \] The Jacobian $ \mathcal{J} $ is exactly the same as that required by the Newton method when solving the steady set of equations, $ \mathcal{F}(u) = 0.$

The general solution of equation (5) takes the form $ \hat{u} = \mbox{e}^{\lambda t} v$ because the only function that is proportional to its derivative is the exponential. The necessary functional form of the solution means that equation (5) becomes \[ \mathcal{J}(u_{s}) v = \lambda v, \] which is an eigenproblem in which the mass \char`\"{}matrix\char`\"{} is the identity. Thus, in order to assess the stability of a solution to our nonlinear system we must solve an eigenproblem using the Jacobian matrix, which is why we used the notation $ J_{ij} $ rather than $ K_{ij} $ in equation (3). The solution is said to be linearly stable if the real part of all eigenvalues is negative because then the perturbation decays as $ t \to \infty$, but it is linearly unstable if even a single eigenvalue has positive real part. Note that in even more general equations the mass \char`\"{}matrix\char`\"{} is not necessarily the identity.\hypertarget{index_weak}{}\subsection{Weak formulation of the problem}\label{index_weak}
If we wish to solve the problem (1) using finite elements, we must first derive the weak form, which follows from the standard procedure of multiplication by a test function and integration by parts \[ \int_{D} \frac{\partial u}{\partial x_{1}} \frac{\partial \phi^{(test)}}{\partial x_{1}}\,\mbox{d} x_{1} = \lambda \int_{D} u\, \phi^{(test)}\,\mbox{d} x_{1}. \] Note that the boundary terms are neglected as a consequence of the Dirichlet boundary conditions.

If we expand the $ u(x_{1}) = V_{j} \psi_{j}(x_{1}) $ in terms of known basis functions $ \psi_{j} $ and use the same basis functions as our test functions (Galerkin method), then the weak form becomes \[ \int_{D} \frac{\partial \psi_{j}}{\partial x_{1}} \frac{\partial \psi_{i}}{\partial x_{1}}\,\mbox{d} x_{1} V_{j} = \lambda \int_{D} \psi_{i} \psi_{j}\,\mbox{d} x_{1} V_{j}. \] On comparison with equation (3), we identify the Jacobian and mass matrices \[ J_{ij} = \int_{D} \frac{\partial \psi_{j}}{\partial x_{1}} \frac{\partial \psi_{i}}{\partial x_{1}}\,\mbox{d} x_{1}, \ \ \ \ \ M_{ij} = \int_{D} \psi_{i} \psi_{j}\,\mbox{d} x_{1}. \ \ \ \ \ (6) \]



 

\hypertarget{index_impl}{}\section{Implementation}\label{index_impl}
In {\ttfamily oomph-\/lib}, eigenproblems are formulated on an element-\/by-\/element basis in a similar way to standard problems. Eigenproblems make use of the function 
\begin{DoxyCode}
GeneralisedElement::get\_jacobian\_and\_mass\_matrix(
  Vector<double> &residuals, 
  DenseMatrix<double> &jacobian,
  DenseMatrix<double> &mass\_matrix);
\end{DoxyCode}
 where the Jacobian is the matrix $J_{ij}$ and the mass matrix is $M_{ij}$ in equation (3). The residuals need not be returned when solving an eigenproblem, but the interface is chosen so that linear stability of solutions to the nonlinear system can easily be calculated without reformulating the problem.

Once again, to avoid reinitialisation in multi-\/physics problems, the helper function 
\begin{DoxyCode}
GeneralisedElement::fill\_in\_contribution\_to\_jacobian\_and\_mass\_matrix(
  Vector<double> &residuals, 
  DenseMatrix<double> &jacobian,
  DenseMatrix<double> &mass\_matrix);
\end{DoxyCode}
 is used and this will be overloaded in our custom elements below.\hypertarget{index_equations}{}\subsection{Creating the elements}\label{index_equations}
For generality, we implement the mathematics to assemble contributions to the Jacobian and mass matrices defined in equations (6) in the class {\ttfamily \hyperlink{classHarmonicEquations}{Harmonic\+Equations}} that inherits from {\ttfamily Finite\+Element}. This construction mirrors that in our standard equation classes and allows a clean separation between the equations and the choice of basis function.

 
\begin{DoxyCodeInclude}
\textcolor{comment}{/// A class for all elements that solve the simple one-dimensional}
\textcolor{comment}{/// eigenvalue problem}
\textcolor{comment}{}\textcolor{comment}{/// \(\backslash\)f[ }
\textcolor{comment}{}\textcolor{comment}{/// \(\backslash\)frac\{\(\backslash\)partial^2 u\}\{\(\backslash\)partial x\_i^2\}  + \(\backslash\)lambda u = 0}
\textcolor{comment}{}\textcolor{comment}{/// \(\backslash\)f] }
\textcolor{comment}{}\textcolor{comment}{/// These elements are very closely related to the Poisson}
\textcolor{comment}{}\textcolor{comment}{/// elements and could inherit from them. They are here developed}
\textcolor{comment}{}\textcolor{comment}{/// from scratch for pedagogical purposes.}
\textcolor{comment}{}\textcolor{comment}{/// This class  contains the generic maths. Shape functions, geometric}
\textcolor{comment}{}\textcolor{comment}{/// mapping etc. must get implemented in derived class.}
\textcolor{comment}{}\textcolor{comment}{//================================================================}
\textcolor{keyword}{class }\hyperlink{classHarmonicEquations}{HarmonicEquations} : \textcolor{keyword}{public} \textcolor{keyword}{virtual} FiniteElement
\{

\textcolor{keyword}{public}:\textcolor{comment}{}
\textcolor{comment}{ /// Empty Constructor}
\textcolor{comment}{} \hyperlink{classHarmonicEquations_a288d1c0777b2cf5360e1310d48f8c217}{HarmonicEquations}() \{\}

\end{DoxyCodeInclude}


The unknowns that represent the discretised eigenfunction are assumed to be stored at the nodes.


\begin{DoxyCodeInclude}
 \textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Access function: Eigenfunction value at local node n}
\textcolor{comment}{ /// Note that solving the eigenproblem does not assign values}
\textcolor{comment}{ /// to this storage space. It is used for output purposes only.}
\textcolor{comment}{} \textcolor{keyword}{virtual} \textcolor{keyword}{inline} \textcolor{keywordtype}{double} u(\textcolor{keyword}{const} \textcolor{keywordtype}{unsigned}& n)\textcolor{keyword}{ const }
\textcolor{keyword}{  }\{\textcolor{keywordflow}{return} nodal\_value(n,0);\}

\end{DoxyCodeInclude}


The class contains functions to output the eigenfunction; interpolate the nodal unknown; and provides interfaces for the shape functions and their derivatives. The key function is {\ttfamily fill\+\_\+in\+\_\+contribution\+\_\+to\+\_\+jacobian\+\_\+and\+\_\+mass\+\_\+matrix} which implements the calculation of the equations (6). The residuals vector is not filled in and does not need to be unless we also wish to solve an associated (non-\/eigen) problem.


\begin{DoxyCodeInclude}
 \textcolor{keywordtype}{void} fill\_in\_contribution\_to\_jacobian\_and\_mass\_matrix(
  Vector<double> &residuals,
  DenseMatrix<double> &jacobian, DenseMatrix<double> &mass\_matrix)
  \{
   \textcolor{comment}{//Find out how many nodes there are}
   \textcolor{keywordtype}{unsigned} n\_node = nnode();
   
   \textcolor{comment}{//Set up memory for the shape functions and their derivatives}
   Shape psi(n\_node);
   DShape dpsidx(n\_node,1);

   \textcolor{comment}{//Set the number of integration points}
   \textcolor{keywordtype}{unsigned} n\_intpt = integral\_pt()->nweight();
   
   \textcolor{comment}{//Integers to store the local equation and unknown numbers}
   \textcolor{keywordtype}{int} local\_eqn=0, local\_unknown=0;
   
   \textcolor{comment}{//Loop over the integration points}
   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} ipt=0;ipt<n\_intpt;ipt++)
    \{
     \textcolor{comment}{//Get the integral weight}
     \textcolor{keywordtype}{double} w = integral\_pt()->weight(ipt);
     
     \textcolor{comment}{//Call the derivatives of the shape and test functions}
     \textcolor{keywordtype}{double} J = dshape\_eulerian\_at\_knot(ipt,psi,dpsidx);
     
     \textcolor{comment}{//Premultiply the weights and the Jacobian}
     \textcolor{keywordtype}{double} W = w*J;

     \textcolor{comment}{//Assemble the contributions to the mass matrix}
     \textcolor{comment}{//Loop over the test functions}
     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} l=0;l<n\_node;l++)
      \{
       \textcolor{comment}{//Get the local equation number}
       local\_eqn = u\_local\_eqn(l);
       \textcolor{comment}{/*IF it's not a boundary condition*/}
       \textcolor{keywordflow}{if}(local\_eqn >= 0)
        \{
         \textcolor{comment}{//Loop over the shape functions}
         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} l2=0;l2<n\_node;l2++)
          \{ 
           local\_unknown = u\_local\_eqn(l2);
           \textcolor{comment}{//If at a non-zero degree of freedom add in the entry}
           \textcolor{keywordflow}{if}(local\_unknown >= 0)
            \{
             jacobian(local\_eqn,local\_unknown) += dpsidx(l,0)*dpsidx(l2,0)*W;
             mass\_matrix(local\_eqn, local\_unknown) += psi(l)*psi(l2)*W;
            \}
          \}
        \}
      \}
    \}
  \} \textcolor{comment}{//end\_of\_fill\_in\_contribution\_to\_jacobian\_and\_mass\_matrix}

\end{DoxyCodeInclude}


The shape functions are specified in the {\ttfamily \hyperlink{classQHarmonicElement}{Q\+Harmonic\+Element}} class that inherits from our standard one-\/dimensional Lagrange elements {\ttfamily Q\+Element$<$1,\+N\+N\+O\+D\+E\+\_\+1\+D$>$} as well as {\ttfamily \hyperlink{classHarmonicEquations}{Harmonic\+Equations}}. The number of unknowns (one) is specified and the output functions and shape functions are overloaded as required\+: the output functions are specified in the {\ttfamily \hyperlink{classHarmonicEquations}{Harmonic\+Equations}} class, whereas the shape functions are provided by the {\ttfamily Q\+Element$<$1,\+N\+N\+O\+D\+E\+\_\+1\+D$>$} class.


\begin{DoxyCodeInclude}
\textcolor{keyword}{template} <\textcolor{keywordtype}{unsigned} NNODE\_1D>
\textcolor{keyword}{class }\hyperlink{classQHarmonicElement}{QHarmonicElement} : \textcolor{keyword}{public} \textcolor{keyword}{virtual} QElement<1,NNODE\_1D>, 
                         \textcolor{keyword}{public} \hyperlink{classHarmonicEquations}{HarmonicEquations}
\{
 
  \textcolor{keyword}{public}:
\textcolor{comment}{}
\textcolor{comment}{ ///\(\backslash\)short  Constructor: Call constructors for QElement and }
\textcolor{comment}{ /// Poisson equations}
\textcolor{comment}{} \hyperlink{classQHarmonicElement_a0e7480a0064b51e87ba197551bb10373}{QHarmonicElement}() : QElement<1,NNODE\_1D>(), \hyperlink{classHarmonicEquations}{HarmonicEquations}() \{\}
\textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short  Required  # of `values' (pinned or dofs) }
\textcolor{comment}{ /// at node n}
\textcolor{comment}{} \textcolor{keyword}{inline} \textcolor{keywordtype}{unsigned} \hyperlink{classQHarmonicElement_a8574a452983b15fb2b4d40ec4ef3e890}{required\_nvalue}(\textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} &n)\textcolor{keyword}{ const }\{\textcolor{keywordflow}{return} 1;\}
\textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Output function overloaded from HarmonicEquations}
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{classQHarmonicElement_a8b38012f3d62ef419c359f5e545e5f85}{output}(ostream &outfile) 
  \{\hyperlink{classHarmonicEquations_abe34292042ce1394f8979618ee10f354}{HarmonicEquations::output}(outfile);\}
\textcolor{comment}{}
\textcolor{comment}{ ///  \(\backslash\)short Output function overloaded from HarmonicEquations}
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{classQHarmonicElement_a8b38012f3d62ef419c359f5e545e5f85}{output}(ostream &outfile, \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} &Nplot) 
  \{\hyperlink{classHarmonicEquations_abe34292042ce1394f8979618ee10f354}{HarmonicEquations::output}(outfile,Nplot);\}


\textcolor{keyword}{protected}:
\textcolor{comment}{}
\textcolor{comment}{/// Shape, test functions & derivs. w.r.t. to global coords. Return Jacobian.}
\textcolor{comment}{} \textcolor{keyword}{inline} \textcolor{keywordtype}{double} \hyperlink{classQHarmonicElement_a206b7334e82cb563d7d575deb9f755b1}{dshape\_eulerian}(\textcolor{keyword}{const} Vector<double> &s, 
                               Shape &psi, 
                               DShape &dpsidx)\textcolor{keyword}{ const}
\textcolor{keyword}{  }\{\textcolor{keywordflow}{return} QElement<1,NNODE\_1D>::dshape\_eulerian(s,psi,dpsidx);\}
 
\textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Shape, test functions & derivs. w.r.t. to global coords. at}
\textcolor{comment}{ /// integration point ipt. Return Jacobian.}
\textcolor{comment}{} \textcolor{keyword}{inline} \textcolor{keywordtype}{double} \hyperlink{classQHarmonicElement_a6b11b5a42bd20c4e1d1e9840ba22a80a}{dshape\_eulerian\_at\_knot}(\textcolor{keyword}{const} \textcolor{keywordtype}{unsigned}& ipt,
                                       Shape &psi, 
                                       DShape &dpsidx)\textcolor{keyword}{ const}
\textcolor{keyword}{  }\{\textcolor{keywordflow}{return} QElement<1,NNODE\_1D>::dshape\_eulerian\_at\_knot(ipt,psi,dpsidx);\}

\}; \textcolor{comment}{//end\_of\_QHarmonic\_class\_definition}

\end{DoxyCodeInclude}
\hypertarget{index_main}{}\section{The driver code}\label{index_main}
In order to solve the 1D eigenproblem using {\ttfamily oomph-\/lib}, we represent the mathematical problem defined by equations (1) and (2) in a specific {\ttfamily Problem} object, {\ttfamily \hyperlink{classHarmonicProblem}{Harmonic\+Problem}}, which is templated by the element type and the eigensolver. We use {\ttfamily Q\+Harmonic\+Element$<$3$>$}, a quadratic element and our three different eigensolvers, including timing statements to compare the three approaches. Note that if you do not have Trilinos or A\+R\+P\+A\+CK installed then only the L\+A\+P\+A\+C\+K\+\_\+\+QZ solver will do anything.

The problem class takes a single argument corresponding to the number of elements used to discretise the domain and contains a member function {\ttfamily solve} that takes an integer used for documentation purposes.


\begin{DoxyCodeInclude}
 \textcolor{keywordtype}{unsigned} n\_element=100; \textcolor{comment}{//Number of elements}

 clock\_t t\_start1 = clock();
 \textcolor{comment}{//Solve with ARPACK}
 \{
  \hyperlink{classHarmonicProblem}{HarmonicProblem<QHarmonicElement<3>},ARPACK> 
   problem(n\_element);
  
  std::cout << \textcolor{stringliteral}{"Matrix size "} << problem.ndof() << std::endl;
  
  problem.solve(1);
 \}
 clock\_t t\_end1 = clock();

\end{DoxyCodeInclude}


The same problem is then solved with a different solver


\begin{DoxyCodeInclude}
 clock\_t t\_start2 = clock();
 \textcolor{comment}{//Solve with LAPACK\_QZ}
 \{
  \hyperlink{classHarmonicProblem}{HarmonicProblem<QHarmonicElement<3>},LAPACK\_QZ> 
   problem(n\_element);
  
  problem.solve(2);
 \}
 clock\_t t\_end2 = clock();

\end{DoxyCodeInclude}


and again with the Trilinos A\+N\+A\+S\+A\+ZI solver if it is installed.



 

\hypertarget{index_problem}{}\section{The problem class}\label{index_problem}
The {\ttfamily \hyperlink{classHarmonicProblem}{Harmonic\+Problem}} is derived from {\ttfamily oomph-\/lib\textquotesingle{}s} generic {\ttfamily Problem} class and the specific element type and eigensolver are specified as template parameters to make it easy for the \char`\"{}user\char`\"{} to change either of these from the driver code.

 
\begin{DoxyCodeInclude}
\textcolor{comment}{//==start\_of\_problem\_class============================================}
\textcolor{comment}{/// 1D Harmonic problem in unit interval.}
\textcolor{comment}{}\textcolor{comment}{//====================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT,\textcolor{keyword}{class} EIGEN\_SOLVER> 
\textcolor{keyword}{class }\hyperlink{classHarmonicProblem}{HarmonicProblem} : \textcolor{keyword}{public} Problem

\end{DoxyCodeInclude}


The problem class has four member functions\+:
\begin{DoxyItemize}
\item the constructor {\ttfamily \hyperlink{classHarmonicProblem}{Harmonic\+Problem}}(...)
\item the destructor {\ttfamily $\sim$\+Harmonic\+Problem()} 
\item the function {\ttfamily solve}(...)
\item the function {\ttfamily doc\+\_\+solution}(...)
\end{DoxyItemize}The destructor merely cleans up the memory by deleting the objects that are allocated in the constructor, so we shall not discuss it further here. The {\ttfamily doc\+\_\+solution} function is also simple and writes the eigenfunction to a file.



 

\hypertarget{index_constructor}{}\section{The Problem constructor}\label{index_constructor}
In the {\ttfamily Problem} constructor, we start by creating the eigensolver specified by the second template parameter. We then discretise the domain using {\ttfamily oomph-\/lib\textquotesingle{}s} {\ttfamily 1\+D\+Mesh} object. The arguments of this object\textquotesingle{}s constructor are the number of elements (whose type is specified by the template parameter), and the domain length. Next, we pin the nodal values on the domain boundaries, which corresponds to applying the Dirichlet boundary conditions. Finally we call the generic {\ttfamily Problem\+::assign\+\_\+eqn\+\_\+numbers()} routine to set up the equation numbers.

 
\begin{DoxyCodeInclude}
\textcolor{comment}{//=====start\_of\_constructor===============================================}
\textcolor{comment}{/// \(\backslash\)short Constructor for 1D Harmonic problem in unit interval.}
\textcolor{comment}{}\textcolor{comment}{/// Discretise the 1D domain with n\_element elements of type ELEMENT.}
\textcolor{comment}{}\textcolor{comment}{/// Specify function pointer to source function. }
\textcolor{comment}{}\textcolor{comment}{//========================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT,\textcolor{keyword}{class} EIGEN\_SOLVER>
\hyperlink{classHarmonicProblem_a77a25847f00ae50c83218530149e3e57}{HarmonicProblem<ELEMENT,EIGEN\_SOLVER>::HarmonicProblem}
      (
 \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned}& n\_element)
\{ 
 \textcolor{comment}{//Create the eigen solver}
 this->eigen\_solver\_pt() = \textcolor{keyword}{new} EIGEN\_SOLVER;
 
 \textcolor{comment}{//Get the positive eigenvalues, shift is zero by default}
 \textcolor{keyword}{static\_cast<}EIGEN\_SOLVER*\textcolor{keyword}{>}(eigen\_solver\_pt())
  ->get\_eigenvalues\_right\_of\_shift(); 

 \textcolor{comment}{//Set domain length }
 \textcolor{keywordtype}{double} L=1.0;

 \textcolor{comment}{// Build mesh and store pointer in Problem}
 Problem::mesh\_pt() = \textcolor{keyword}{new} OneDMesh<ELEMENT>(n\_element,L);
 
 \textcolor{comment}{// Set the boundary conditions for this problem: By default, all nodal}
 \textcolor{comment}{// values are free -- we only need to pin the ones that have }
 \textcolor{comment}{// Dirichlet conditions. }

 \textcolor{comment}{// Pin the single nodal value at the single node on mesh }
 \textcolor{comment}{// boundary 0 (= the left domain boundary at x=0)}
 mesh\_pt()->boundary\_node\_pt(0,0)->pin(0);
 
 \textcolor{comment}{// Pin the single nodal value at the single node on mesh }
 \textcolor{comment}{// boundary 1 (= the right domain boundary at x=1)}
 mesh\_pt()->boundary\_node\_pt(1,0)->pin(0);
 
 \textcolor{comment}{// Setup equation numbering scheme}
 assign\_eqn\_numbers();

\} \textcolor{comment}{// end of constructor}

\end{DoxyCodeInclude}




 

\hypertarget{index_solve}{}\section{Solving the problem}\label{index_solve}
The {\ttfamily solve}(...) function is where all the action happens and takes a single unsigned integer argument which is used as a label to distinguish the output from different eigensolvers.

The function {\ttfamily Problem\+::solve\+\_\+eigenproblem}(...) plays an equivalent role to {\ttfamily Problem\+::newton\+\_\+solve}(...) in eigenproblems. Here, additional storage must be allocated for the eigenvalues (a vector of complex numbers) and eigenvectors (a vector of double vectors). The vectors will be resized internally depending on the number of eigenvalues returned. The number is not always the same as the number of eigenvalues requested because both parts of a complex conjugate pair of eigenvalues are always returned. In the {\ttfamily solve}(..) function we first allocate the required storage, specify the desired number of eigenvalues and then solve the eigenproblem\+:


\begin{DoxyCodeInclude}
\textcolor{comment}{//=======================start\_of\_solve==============================}
\textcolor{comment}{/// Solve the eigenproblem }
\textcolor{comment}{}\textcolor{comment}{//===================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT,\textcolor{keyword}{class} EIGEN\_SOLVER>
\textcolor{keywordtype}{void} \hyperlink{classHarmonicProblem_aba2b3fd58a67f03ca0481e426d385c5d}{HarmonicProblem<ELEMENT,EIGEN\_SOLVER>::}
\hyperlink{classHarmonicProblem_aba2b3fd58a67f03ca0481e426d385c5d}{solve}(\textcolor{keyword}{const} \textcolor{keywordtype}{unsigned}& label)
\{ 
 \textcolor{comment}{//Set external storage for the eigenvalues}
 Vector<complex<double> > eigenvalues;
 \textcolor{comment}{//Set external storage for the eigenvectors}
 Vector<DoubleVector> eigenvectors;
 \textcolor{comment}{//Desired number eigenvalues}
 \textcolor{keywordtype}{unsigned} n\_eval=4;

 \textcolor{comment}{//Solve the eigenproblem}
 this->solve\_eigenproblem(n\_eval,eigenvalues,eigenvectors);

\end{DoxyCodeInclude}


The rest of the function post-\/processes the output from the eigensolver. In order to ensure repeatability of the output for our self-\/tests the eigenvalues are sorted on the size of their real part. The eigenfunction associated with the second smallest eigenvalue is normalised to have unit length and then output to a file.

In order to output the eigenfunction the values must be transferred to the nodal values so that it can be interpolated. This is performed by the function {\ttfamily Problem\+::assign\+\_\+eigenvector\+\_\+to\+\_\+dofs}(...). Note that this function overwrites the existing nodal data, so a backup must be taken if it is important. This can be done using the function {\ttfamily Problem\+::store\+\_\+current\+\_\+dof\+\_\+values()} and the stored values can be recovered via {\ttfamily Problem\+::restore\+\_\+dof\+\_\+values()}.

Finally, the sorted eigenvalues are reported and also saved to a file.


\begin{DoxyCodeInclude}

 \textcolor{comment}{//We now need to sort the output based on the size of the real part}
 \textcolor{comment}{//of the eigenvalues.}
 \textcolor{comment}{//This is because the solver does not necessarily sort the eigenvalues}
 Vector<complex<double> > sorted\_eigenvalues = eigenvalues;
 sort(sorted\_eigenvalues.begin(),sorted\_eigenvalues.end(),
      \hyperlink{classComplexLess}{ComplexLess<double>}());

 \textcolor{comment}{//Read out the second smallest eigenvalue}
 complex<double> temp\_evalue = sorted\_eigenvalues[1];
 \textcolor{keywordtype}{unsigned} second\_smallest\_index=0;
 \textcolor{comment}{//Loop over the unsorted eigenvalues and find the entry that corresponds}
 \textcolor{comment}{//to our second smallest eigenvalue.}
 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} i=0;i<eigenvalues.size();i++)
  \{
   \textcolor{comment}{//Note that equality tests for doubles are bad, but it was just}
   \textcolor{comment}{//sorted data, so should be fine}
   \textcolor{keywordflow}{if}(eigenvalues[i] == temp\_evalue) \{second\_smallest\_index=i; \textcolor{keywordflow}{break};\}
  \}

 \textcolor{comment}{//Normalise the eigenvector }
 \{
  \textcolor{comment}{//Get the dimension of the eigenvector}
  \textcolor{keywordtype}{unsigned} dim = eigenvectors[second\_smallest\_index].nrow();
  \textcolor{keywordtype}{double} length=0.0;
  \textcolor{comment}{//Loop over all the entries}
  \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} i=0;i<dim;i++)
   \{
    \textcolor{comment}{//Add the contribution to the length}
    length += std::pow(eigenvectors[second\_smallest\_index][i],2.0);
   \}
  \textcolor{comment}{//Now take the magnitude}
  length = sqrt(length);
  \textcolor{comment}{//Fix the sign}
  \textcolor{keywordflow}{if}(eigenvectors[second\_smallest\_index][0] < 0) \{length *= -1.0;\}
  \textcolor{comment}{//Finally normalise}
  \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} i=0;i<dim;i++)
   \{
    eigenvectors[second\_smallest\_index][i] /= length;
   \}
 \}

 \textcolor{comment}{//Now assign the second eigenvector to the dofs of the problem}
 this->assign\_eigenvector\_to\_dofs(eigenvectors[second\_smallest\_index]);
 \textcolor{comment}{//Output solution for this case (label output files with "1")}
 this->\hyperlink{classHarmonicProblem_a95e94f87cf4f63e332c09bd9f1bbae7c}{doc\_solution}(label);

 \textcolor{keywordtype}{char} filename[100];
 sprintf(filename,\textcolor{stringliteral}{"eigenvalues%i.dat"},label);
 
 \textcolor{comment}{//Open an output file for the sorted eigenvalues}
 ofstream evalues(filename);
 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} i=0;i<n\_eval;i++)
  \{
   \textcolor{comment}{//Print to screen}
   cout << sorted\_eigenvalues[i].real() << \textcolor{stringliteral}{" "} 
        << sorted\_eigenvalues[i].imag() << std::endl;
   \textcolor{comment}{//Send to file}
   evalues << sorted\_eigenvalues[i].real() << \textcolor{stringliteral}{" "} 
           << sorted\_eigenvalues[i].imag() << std::endl;
  \}
 
 evalues.close();
\} \textcolor{comment}{//end\_of\_solve}

\end{DoxyCodeInclude}




 

\hypertarget{index_exercises}{}\section{Comments and exercises}\label{index_exercises}

\begin{DoxyEnumerate}
\item Modify the code to compute a different number of eigenvalues. What is the maximum number of eigenvalues that could be computed?
\item Write a function to calculate the error between the numerical and exact solutions to the eigenproblem. How does the error vary with changes in the number of elements?
\item Compare the errors for each different eigenfunction. What happens to the error as the eigenvalue increase? Can you explain why?
\item Repeat the above experiments with {\ttfamily Q\+Harmonic\+Element$<$2$>$}. What happens?
\item Modify the problem to include a convective-\/like term $ \mu \frac{\partial u}{\partial x_{1}} $. Compare the computed results to the analytic solution. What happens to the eigenvalues and eigenfunctions?
\end{DoxyEnumerate}

 

\hypertarget{index_sources}{}\section{Source files for this tutorial}\label{index_sources}

\begin{DoxyItemize}
\item The source files for this tutorial are located in the directory\+: \begin{center} \href{../../../../demo_drivers/eigenproblems/harmonic/}{\tt demo\+\_\+drivers/eigenproblems/harmonic/ } \end{center} 
\item The driver code is\+: \begin{center} \href{../../../../demo_drivers/eigenproblems/harmonic/harmonic.cc}{\tt demo\+\_\+drivers/eigenproblems/harmonic/harmonic.\+cc } \end{center} 
\end{DoxyItemize}



 

 \hypertarget{index_pdf}{}\section{P\+D\+F file}\label{index_pdf}
A \href{../latex/refman.pdf}{\tt pdf version} of this document is available. \end{document}
