In this document, we demonstrate how to solve a 1D eigenproblem (eigenvalues of the shifted 1D Laplace operator in a bounded domain) by creating custom elements. The tutorial is related to the \href{../../harmonic/html/index.html}{\tt harmonic eigenproblem }, which you should read first. The fundamental difference in this case, is that we treat the eigenproblem as two coupled first-\/order equations which ensures that many of the eigenvalues are complex. \begin{center} \tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*{1}{|X[-1]}|}
\hline
\begin{center} {\bfseries One-\/dimensional model eigenvalue problem with complex eigenvalues} \end{center}  Solve \[ \frac{\partial u}{\partial x} = (\lambda - \mu) w, \quad \frac{\partial w}{\partial x} = \lambda u \ \ \ \ \ \ \ \ \ \ (1) \] in the domain $D =\left\{ x_1 \in [0,1] \right\}$, with homogeneous Dirichlet boundary conditions \[ \left. u\right|_{\partial D}=0. \ \ \ \ \ \ \ \ \ \ (2) \]   \\\cline{1-1}
\end{longtabu}
\end{center} 

We shall treat $ \lambda$ as an eigenvalue (unknown), but the other parameter $ \mu $ is a {\bfseries shift}, which is used to modify the spectrum of the operator. The two first-\/order equations may be combined into a single second-\/order equation \[ \frac{\partial^{2} u}{\partial x^{2}} = (\lambda - \mu) \frac{\partial w}{\partial x} = (\lambda - \mu) \lambda u \quad \Rightarrow\quad \frac{\partial^{2} u}{\partial x^{2}} + (\mu - \lambda) \lambda u = 0, \] which is exactly the same equation as the \href{../../harmonic/html/index.html}{\tt harmonic eigenproblem }, but with a redefinition of the eigenvalues. Hence, the exact solutions are given by the countably infinite set\+: \[ u_{n} = \sin (\Lambda_{n} x_{1}), \ \ \ \ \ \ \ \Lambda_{n} = n \pi = \sqrt{\lambda_{n}(\mu - \lambda_{n})}, \] which yields \[ \lambda_{n} = \frac{\mu}{2} \pm \sqrt{\mu^{2}/4 - n^{2}\pi^{2}}. \ \ \ \ \ \ \ \ \ \ (3) \] If the shift $\mu = 0$, then the eigenvalues are all imaginary and consist of the complex conjugate pairs given by $ \lambda{n} = \pm n \pi\, \mbox{i} $.

If $ \mu^{2}/4 > \pi^{2}$ $ \Rightarrow $ $ \mu > 2\pi $, then the first complex conjugate pair of imaginary eigenvalues becomes two distinct real eigenvalues because the term under the square root in (3) becomes positive. As $ \mu $ increases further subsequent complex eigenvalues merge to be real. Thus, we can control the spectrum by modifying the parameter $ \mu $.

We now provide a detailed discussion of the driver code \href{../../../../demo_drivers/eigenproblems/harmonic/complex_harmonic.cc}{\tt complex\+\_\+harmonic.\+cc} which solves the problem for the first four eigenvalues, when $ \mu = 6.5 > 2\pi. $



 

\hypertarget{index_theory}{}\section{Overview of the theory}\label{index_theory}
\hypertarget{index_weak}{}\subsection{Weak formulation of the problem}\label{index_weak}
If we wish to solve the problem (1) using finite elements, we simply multiply each equation by a test function, but do not integrate by parts. We shall use the same test functions for each variable and thus our governing equations become \[ \int_{D} \frac{\partial u}{\partial x} \phi^{(test)} \,\mbox{d} x = (\lambda -\mu) \int_{D} w\, \phi^{(test)}\,\mbox{d} x, \quad\quad \int_{D} \frac{\partial w}{\partial x} \phi^{(test)} \,\mbox{d} x = \lambda \int_{D} u\, \phi^{(test)}\,\mbox{d} x, \quad \]

If we expand $ u(x) = U_{j} \psi_{j}(x) $ and $ w(x) = W_{j} \psi_{j}(x) $ in terms of known basis functions $ \psi_{j} $ and use the same basis functions as our test functions (Galerkin method), then the weak form becomes \[ \int_{D} \frac{\partial \psi_{j}}{\partial x} \psi_{i} \,\mbox{d} x U_{j} = (\lambda - \mu) \int_{D} \psi_{i} \psi_{j}\,\mbox{d} x W_{j},\quad\quad \int_{D} \frac{\partial \psi_{j}}{\partial x} \psi_{i} \,\mbox{d} x W_{j} = \lambda \int_{D} \psi_{i} \psi_{j}\,\mbox{d} x U_{j}. \] Thus, in order to form the discrete eigenproblem $ J_{ij} v_{j} = \lambda M_{ij} v_{j} $, we choose to order the unknowns in the form $ v = [ U | W ]^{T} $, leading to the block Jacobian and mass matrices \[ J = \left[\begin{array}{c|c} 0 & A \\\hline A & \mu B \end{array}\right],\quad M = \left[\begin{array}{c|c} B & 0 \\\hline 0 & B \end{array}\right], \] where \[ A_{ij} = \int_{D} \frac{\partial \psi_{j}}{\partial x} \psi_{i} \,\mbox{d} x , \quad\quad B_{ij} = \int_{D} \psi_{i} \psi_{j}\,\mbox{d} x. \]



 

\hypertarget{index_impl}{}\section{Implementation}\label{index_impl}
The implementation closely follows that in the \href{../../harmonic/html/index.html}{\tt harmonic eigenproblem }, and so we shall concentrate on the differences from that problem.\hypertarget{index_equations}{}\subsection{Creating the elements}\label{index_equations}
For generality, we implement the mathematics to assemble contributions to the Jacobian and mass matrices defined above in the class {\ttfamily \hyperlink{classComplexHarmonicEquations}{Complex\+Harmonic\+Equations}} that inherits from {\ttfamily Finite\+Element}.

 
\begin{DoxyCodeInclude}
\textcolor{comment}{/// A class for all elements that solve the eigenvalue problem}
\textcolor{comment}{/// \(\backslash\)f[ }
\textcolor{comment}{}\textcolor{comment}{/// \(\backslash\)frac\{\(\backslash\)partial w\}\{\(\backslash\)partial x\}  = \(\backslash\)lambda u}
\textcolor{comment}{}\textcolor{comment}{/// \(\backslash\)f] }
\textcolor{comment}{}\textcolor{comment}{/// \(\backslash\)f[}
\textcolor{comment}{}\textcolor{comment}{/// \(\backslash\)frac\{\(\backslash\)partial u\}\{\(\backslash\)partial x\} = (\(\backslash\)lambda - \(\backslash\)mu) w}
\textcolor{comment}{}\textcolor{comment}{/// \(\backslash\)f]}
\textcolor{comment}{}\textcolor{comment}{/// This class  contains the generic maths. Shape functions, geometric}
\textcolor{comment}{}\textcolor{comment}{/// mapping etc. must get implemented in derived class.}
\textcolor{comment}{}\textcolor{comment}{//================================================================}
\textcolor{keyword}{class }\hyperlink{classComplexHarmonicEquations}{ComplexHarmonicEquations} : \textcolor{keyword}{public} \textcolor{keyword}{virtual} FiniteElement
\{

\textcolor{keyword}{public}:\textcolor{comment}{}
\textcolor{comment}{ /// Empty Constructor}
\textcolor{comment}{} \hyperlink{classComplexHarmonicEquations_aa93feb265f731b0d82c3c1c4c29f183d}{ComplexHarmonicEquations}() \{\}

\end{DoxyCodeInclude}


The unknowns that represent the discretised eigenfunction are assumed to be stored at the nodes, but there are now two unknowns\+: $u$ is assumed to be the first and $w$ is the second.


\begin{DoxyCodeInclude}
 \textcolor{comment}{/// \(\backslash\)short Access function: First eigenfunction value at local node n}
\textcolor{comment}{ /// Note that solving the eigenproblem does not assign values}
\textcolor{comment}{}\textcolor{comment}{ /// to this storage space. It is used for output purposes only.}
\textcolor{comment}{} \textcolor{keyword}{virtual} \textcolor{keyword}{inline} \textcolor{keywordtype}{double} u(\textcolor{keyword}{const} \textcolor{keywordtype}{unsigned}& n)\textcolor{keyword}{ const }
\textcolor{keyword}{  }\{\textcolor{keywordflow}{return} nodal\_value(n,0);\}
\textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Second eigenfunction value at local node n}
\textcolor{comment}{} \textcolor{keyword}{virtual} \textcolor{keyword}{inline} \textcolor{keywordtype}{double} w(\textcolor{keyword}{const} \textcolor{keywordtype}{unsigned}& n)\textcolor{keyword}{ const }
\textcolor{keyword}{  }\{\textcolor{keywordflow}{return} nodal\_value(n,1);\}

\end{DoxyCodeInclude}


As before, the key function is {\ttfamily fill\+\_\+in\+\_\+contribution\+\_\+to\+\_\+jacobian\+\_\+and\+\_\+mass\+\_\+matrix} which implements the calculation of the equations.


\begin{DoxyCodeInclude}
 \textcolor{keywordtype}{void} fill\_in\_contribution\_to\_jacobian\_and\_mass\_matrix(
  Vector<double> &residuals,
  DenseMatrix<double> &jacobian, DenseMatrix<double> &mass\_matrix)
  \{
   \textcolor{comment}{//Find out how many nodes there are}
   \textcolor{keywordtype}{unsigned} n\_node = nnode();
   
   \textcolor{comment}{//Set up memory for the shape functions and their derivatives}
   Shape psi(n\_node);
   DShape dpsidx(n\_node,1);

   \textcolor{comment}{//Set the number of integration points}
   \textcolor{keywordtype}{unsigned} n\_intpt = integral\_pt()->nweight();
   
   \textcolor{comment}{//Integers to store the local equation and unknown numbers}
   \textcolor{keywordtype}{int} local\_eqn=0, local\_unknown=0;
   
   \textcolor{comment}{//Loop over the integration points}
   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} ipt=0;ipt<n\_intpt;ipt++)
    \{
     \textcolor{comment}{//Get the integral weight}
     \textcolor{keywordtype}{double} w = integral\_pt()->weight(ipt);
     
     \textcolor{comment}{//Call the derivatives of the shape and test functions}
     \textcolor{keywordtype}{double} J = dshape\_eulerian\_at\_knot(ipt,psi,dpsidx);
     
     \textcolor{comment}{//Premultiply the weights and the Jacobian}
     \textcolor{keywordtype}{double} W = w*J;

     \textcolor{comment}{//Assemble the contributions to the mass matrix}
     \textcolor{comment}{//Loop over the test functions}
     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} l=0;l<n\_node;l++)
      \{
       \textcolor{comment}{//Get the local equation number}
       local\_eqn = u\_local\_eqn(l,0);
       \textcolor{comment}{//If it's not a boundary condition}
       \textcolor{keywordflow}{if}(local\_eqn >= 0)
        \{
         \textcolor{comment}{//Loop over the shape functions}
         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} l2=0;l2<n\_node;l2++)
          \{ 
           local\_unknown = u\_local\_eqn(l2,0);
           \textcolor{comment}{//If at a non-zero degree of freedom add in the entry}
           \textcolor{keywordflow}{if}(local\_unknown >= 0)
            \{
             \textcolor{comment}{//This corresponds to the top left B block}
             mass\_matrix(local\_eqn, local\_unknown) += psi(l2)*psi(l)*W;
            \}
           local\_unknown = u\_local\_eqn(l2,1);
           \textcolor{comment}{//If at a non-zero degree of freedom add in the entry}
           \textcolor{keywordflow}{if}(local\_unknown >= 0)
            \{
             \textcolor{comment}{//This corresponds to the top right A block}
             jacobian(local\_eqn,local\_unknown) += dpsidx(l2,0)*psi(l)*W;
            \}
          \}
        \}

       \textcolor{comment}{//Get the local equation number}
       local\_eqn = u\_local\_eqn(l,1);
       \textcolor{comment}{//IF it's not a boundary condition}
       \textcolor{keywordflow}{if}(local\_eqn >= 0)
        \{
         \textcolor{comment}{//Loop over the shape functions}
         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} l2=0;l2<n\_node;l2++)
          \{ 
           local\_unknown = u\_local\_eqn(l2,0);
           \textcolor{comment}{//If at a non-zero degree of freedom add in the entry}
           \textcolor{keywordflow}{if}(local\_unknown >= 0)
            \{
             \textcolor{comment}{//This corresponds to the lower left A block}
             jacobian(local\_eqn,local\_unknown) += dpsidx(l2,0)*psi(l)*W;
            \}
           local\_unknown = u\_local\_eqn(l2,1);
           \textcolor{comment}{//If at a non-zero degree of freedom add in the entry}
           \textcolor{keywordflow}{if}(local\_unknown >= 0)
            \{
             \textcolor{comment}{//This corresponds to the lower right B block}
             mass\_matrix(local\_eqn, local\_unknown) += psi(l2)*psi(l)*W;
             \textcolor{comment}{//This corresponds to the lower right \(\backslash\)mu B block}
             jacobian(local\_eqn,local\_unknown) += 
              \hyperlink{namespaceEigenproblemShift_a82e816b5ecba937123c65c5bd953a2fb}{EigenproblemShift::Mu}*psi(l2)*psi(l)*W;
            \}
          \}
        \}
      \}
    \}
 \} \textcolor{comment}{//end\_of\_fill\_in\_contribution\_to\_jacobian\_and\_mass\_matrix}

\end{DoxyCodeInclude}


Note that the {\bfseries shift} $\mu$ is implemented in a global namespace as {\ttfamily \hyperlink{namespaceEigenproblemShift_a82e816b5ecba937123c65c5bd953a2fb}{Eigenproblem\+Shift\+::\+Mu}}.

The shape functions are specified in the {\ttfamily \hyperlink{classQComplexHarmonicElement}{Q\+Complex\+Harmonic\+Element}} class that inherits from our standard one-\/dimensional Lagrange elements {\ttfamily Q\+Element$<$1,\+N\+N\+O\+D\+E\+\_\+1\+D$>$} as well as {\ttfamily \hyperlink{classHarmonicEquations}{Harmonic\+Equations}}. The number of unknowns (two) is specified and the output functions and shape functions are overloaded as required\+: the output functions are specified in the {\ttfamily \hyperlink{classComplexHarmonicEquations}{Complex\+Harmonic\+Equations}} class, whereas the shape functions are provided by the {\ttfamily Q\+Element$<$1,\+N\+N\+O\+D\+E\+\_\+1\+D$>$} class.


\begin{DoxyCodeInclude}
\textcolor{keyword}{template} <\textcolor{keywordtype}{unsigned} NNODE\_1D>
\textcolor{keyword}{class }\hyperlink{classQComplexHarmonicElement}{QComplexHarmonicElement} : \textcolor{keyword}{public} \textcolor{keyword}{virtual} QElement<1,NNODE\_1D>, 
                         \textcolor{keyword}{public} \hyperlink{classComplexHarmonicEquations}{ComplexHarmonicEquations}
\{
 
  \textcolor{keyword}{public}:
\textcolor{comment}{}
\textcolor{comment}{ ///\(\backslash\)short  Constructor: Call constructors for QElement and }
\textcolor{comment}{ /// Poisson equations}
\textcolor{comment}{} \hyperlink{classQComplexHarmonicElement_a9f1e88c4b5c7031d77c6f6dd3758de2a}{QComplexHarmonicElement}() : QElement<1,NNODE\_1D>(), 
                             \hyperlink{classComplexHarmonicEquations}{ComplexHarmonicEquations}() \{\}
\textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short  Required  # of `values' (pinned or dofs) }
\textcolor{comment}{ /// at node n. Here there are two (u and w)}
\textcolor{comment}{} \textcolor{keyword}{inline} \textcolor{keywordtype}{unsigned} \hyperlink{classQComplexHarmonicElement_a3f1d68324e9d8b9e143044d716c72a87}{required\_nvalue}(\textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} &n)\textcolor{keyword}{ const }\{\textcolor{keywordflow}{return} 2;\}
\textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Output function overloaded from ComplexHarmonicEquations}
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{classQComplexHarmonicElement_a8c45d7281a7bc7e2e2d53a7f87339ca4}{output}(ostream &outfile) 
  \{\hyperlink{classComplexHarmonicEquations_a9185e07b984e735c1c45b6f5a6c02b5f}{ComplexHarmonicEquations::output}(outfile);\}
\textcolor{comment}{}
\textcolor{comment}{ ///  \(\backslash\)short Output function overloaded from ComplexHarmonicEquations}
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{classQComplexHarmonicElement_a8c45d7281a7bc7e2e2d53a7f87339ca4}{output}(ostream &outfile, \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} &Nplot) 
  \{\hyperlink{classComplexHarmonicEquations_a9185e07b984e735c1c45b6f5a6c02b5f}{ComplexHarmonicEquations::output}(outfile,Nplot);\}


\textcolor{keyword}{protected}:
\textcolor{comment}{}
\textcolor{comment}{/// Shape, test functions & derivs. w.r.t. to global coords. Return Jacobian.}
\textcolor{comment}{} \textcolor{keyword}{inline} \textcolor{keywordtype}{double} \hyperlink{classQComplexHarmonicElement_a7c97d4e8c5433a44640d30c936d69ffb}{dshape\_eulerian}(\textcolor{keyword}{const} Vector<double> &s, 
                               Shape &psi, 
                               DShape &dpsidx)\textcolor{keyword}{ const}
\textcolor{keyword}{  }\{\textcolor{keywordflow}{return} QElement<1,NNODE\_1D>::dshape\_eulerian(s,psi,dpsidx);\}
 
\textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Shape, test functions & derivs. w.r.t. to global coords. at}
\textcolor{comment}{ /// integration point ipt. Return Jacobian.}
\textcolor{comment}{} \textcolor{keyword}{inline} \textcolor{keywordtype}{double} \hyperlink{classQComplexHarmonicElement_a3f8d1d9396135d4d86f416dcf6c23904}{dshape\_eulerian\_at\_knot}(\textcolor{keyword}{const} \textcolor{keywordtype}{unsigned}& ipt,
                                       Shape &psi, 
                                       DShape &dpsidx)\textcolor{keyword}{ const}
\textcolor{keyword}{  }\{\textcolor{keywordflow}{return} QElement<1,NNODE\_1D>::dshape\_eulerian\_at\_knot(ipt,psi,dpsidx);\}

\}; \textcolor{comment}{//end\_of\_QComplexHarmonic\_class\_definition}

\end{DoxyCodeInclude}
\hypertarget{index_main}{}\section{The driver code}\label{index_main}
The driver code is identical to that of the \href{../../harmonic/html/index.html}{\tt harmonic eigenproblem }.



 

\hypertarget{index_problem}{}\section{The problem class}\label{index_problem}
The {\ttfamily \hyperlink{classComplexHarmonicProblem}{Complex\+Harmonic\+Problem}} is derived from {\ttfamily oomph-\/lib\textquotesingle{}s} generic {\ttfamily Problem} class and the specific element type and eigensolver are specified as template parameters to make it easy for the \char`\"{}user\char`\"{} to change either of these from the driver code. Once again, it is very similar to the {\ttfamily \hyperlink{classHarmonicProblem}{Harmonic\+Problem}} class in the \href{../../harmonic/html/index.html}{\tt harmonic eigenproblem }. The only member function with any differences is the {\ttfamily solve}(...) function, which requests 7 rather than 4 eigenvalues to be computed and outputs the eigenfunction associated with eigenvalue of smallest magnitude (which is real).



 

\hypertarget{index_exercises}{}\section{Comments and exercises}\label{index_exercises}

\begin{DoxyEnumerate}
\item Modify the code to compute a different number of eigenvalues. What is the maximum number of eigenvalues that could be computed?
\item Confirm that the eigenvalues agree with the analytic result and that a transition from real to complex values occurs when $ \mu = 2\pi $.
\item Explain why there are always two eigenvalues with the values $\lambda = \mu$. What are the corresponding eigenfunctions?
\item When the output is a complex conjugate pair of eigenvalues, the two associated eigenvectors are the real and imaginary parts of the eigenvector corresponding to the first eigenvalue. The complex conjugate eigenvalue has a complex conjugate eigenvector (can you prove this?), so no more information is required. Modify the output function to examine the real and imaginary parts of a complex eigenvalue. Are the results what you expect?
\end{DoxyEnumerate}

 

\hypertarget{index_sources}{}\section{Source files for this tutorial}\label{index_sources}

\begin{DoxyItemize}
\item The source files for this tutorial are located in the directory\+: \begin{center} \href{../../../../demo_drivers/eigenproblems/harmonic/}{\tt demo\+\_\+drivers/eigenproblems/harmonic/ } \end{center} 
\item The driver code is\+: \begin{center} \href{../../../../demo_drivers/eigenproblems/harmonic/harmonic.cc}{\tt demo\+\_\+drivers/eigenproblems/harmonic/harmonic.\+cc } \end{center} 
\end{DoxyItemize}



 

 \hypertarget{index_pdf}{}\section{P\+D\+F file}\label{index_pdf}
A \href{../latex/refman.pdf}{\tt pdf version} of this document is available. \end{document}
