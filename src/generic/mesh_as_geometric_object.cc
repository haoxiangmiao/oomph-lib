//LIC// ====================================================================
//LIC// This file forms part of oomph-lib, the object-oriented, 
//LIC// multi-physics finite-element library, available 
//LIC// at http://www.oomph-lib.org.
//LIC// 
//LIC//           Version 0.90. August 3, 2009.
//LIC// 
//LIC// Copyright (C) 2006-2009 Matthias Heil and Andrew Hazel
//LIC// 
//LIC// This library is free software; you can redistribute it and/or
//LIC// modify it under the terms of the GNU Lesser General Public
//LIC// License as published by the Free Software Foundation; either
//LIC// version 2.1 of the License, or (at your option) any later version.
//LIC// 
//LIC// This library is distributed in the hope that it will be useful,
//LIC// but WITHOUT ANY WARRANTY; without even the implied warranty of
//LIC// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//LIC// Lesser General Public License for more details.
//LIC// 
//LIC// You should have received a copy of the GNU Lesser General Public
//LIC// License along with this library; if not, write to the Free Software
//LIC// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
//LIC// 02110-1301  USA.
//LIC// 
//LIC// The authors may be contacted at oomph-lib@maths.man.ac.uk.
//LIC// 
//LIC//====================================================================
// Templated functions for MeshAsGeomObject
// Config header generated by autoconfig
#ifdef HAVE_CONFIG_H
  #include <oomph-lib-config.h>
#endif

//oomph-lib headers
#include "mesh.h"
#include "mesh_as_geometric_object.h"
#include "multi_domain.h"

#include <cstdio>

namespace oomph
{

 //==========================================================================
 /// \short Globally set-able (sorry!) flag to indicate that MeshAsGeomObject
 /// is to use Eulerian coordinates when setting up bin.
 //==========================================================================
 bool MeshAsGeomObject::Use_eulerian_coordinates_during_setup=false;


//========================================================================
 /// \short Counter for overall number of bins allocated -- used to
 /// issue warning if this exceeds a threshhold. (Default assignment
 /// of 100^DIM bins per MeshAsGeomObject can be a killer if there
 /// are huge numbers of sub-meshes (e.g. in unstructured FSI).
//========================================================================
 unsigned long MeshAsGeomObject::Total_nbin_cells_counter=0;
 

//========================================================================
 /// \short Total number of bins above which warning is issued.
 /// (Default assignment of 100^DIM bins per MeshAsGeomObject can 
 /// be a killer if there are huge numbers of sub-meshes (e.g. in 
 /// unstructured FSI).
//========================================================================
 unsigned long MeshAsGeomObject::Threshold_for_total_bin_cell_number_warning=
  50000000;

//========================================================================
 /// \short Boolean to supppress warnings about large number of bins
//========================================================================
 bool MeshAsGeomObject::Suppress_warning_about_large_total_number_of_bins=false;


//========================================================================
 /// \short Boolean flag to make sure that warning about large number
/// of bin cells only gets triggered once.
//========================================================================
 bool MeshAsGeomObject::Already_warned_about_large_number_of_bin_cells=false;

//========================================================================
 /// \short Number elements/bin that triggers a warning when it gets
 /// too large, i.e. too many elements per bin, which can lead to very slow
 /// computations. Sart at 100
//========================================================================
 unsigned MeshAsGeomObject::Threshold_for_elements_per_bin_warning = 100;

//========================================================================
 /// \short Boolean to supppress warnings about small number of bins
//========================================================================
 bool MeshAsGeomObject::Suppress_warning_about_small_number_of_bins=false;

//========================================================================
 /// \short Boolean flag to make sure that warning about small number
/// of bin cells only gets triggered once.
//========================================================================
 bool MeshAsGeomObject::Already_warned_about_small_number_of_bin_cells=false;


//========================================================================
/// Helper function for constructor: Pass the pointer to the mesh, 
/// communicator and boolean
/// to specify whether to calculate coordinate extrema or not
/// The dimensions for the GeomObject are read out from the elements and
/// nodes of the mesh. Bin dimensions are specified in
/// Multi_domain_functions:N{x,y,z}_bin.
//========================================================================
 void MeshAsGeomObject::construct_it
 (Mesh* const &mesh_pt,
  const bool& compute_extreme_bin_coords)
 {
#ifdef OOMPH_HAS_MPI
   // Set communicator
  Communicator_pt=mesh_pt->communicator_pt();
#endif

  // Remember how bin was (or rather: will have been) set up
  Have_used_eulerian_coordinates_during_setup=
   MeshAsGeomObject::Use_eulerian_coordinates_during_setup;
  
  //Storage for the Lagrangian and Eulerian dimension
  int dim[2]={0,0};

  //Set the Lagrangian dimension from the dimension of the first element
  //if it exists (if not the Lagrangian dimension will be zero)
  if(mesh_pt->nelement()!=0) 
   {dim[0] = mesh_pt->finite_element_pt(0)->dim();}
 
  //Read out the Eulerian dimension from the first node, if it exists.
  //(if not the Eulerian dimension will be zero);
  if(mesh_pt->nnode()!=0)
   {dim[1] = mesh_pt->node_pt(0)->ndim();}

  // Need to do an Allreduce to ensure that the dimension is consistent
  // even when no elements are assigned to a certain processor
#ifdef OOMPH_HAS_MPI
  //Only a problem if the mesh has been distributed
  if(mesh_pt->is_mesh_distributed())
   {
    //Need a non-null communicator
    if(Communicator_pt!=0)
     {
      int n_proc=Communicator_pt->nproc();
      if (n_proc > 1)
       {
        int dim_reduce[2];
        MPI_Allreduce(&dim,&dim_reduce,2,MPI_INT,
                      MPI_MAX,Communicator_pt->mpi_comm());
        
        dim[0] = dim_reduce[0]; 
        dim[1] = dim_reduce[1];
       }
     }
   }
#endif

   //Set the Lagrangian and Eulerian dimensions within this geometric object
   this->set_nlagrangian_and_ndim(static_cast<unsigned>(dim[0]),
                                  static_cast<unsigned>(dim[1]));


   // Create temporary storage for geometric Data (don't count 
   // Data twice!
   std::set<Data*> tmp_geom_data;
   
   //Copy all the elements in the mesh into local storage
   //N.B. elements must be able to have a geometric object representation.
   unsigned n_sub_object = mesh_pt->nelement();
   Sub_geom_object_pt.resize(n_sub_object);
   for(unsigned e=0;e<n_sub_object;e++)
    {

     // (Try to) cast to a finite element:
     Sub_geom_object_pt[e]=
      dynamic_cast<FiniteElement*>(mesh_pt->element_pt(e));

#ifdef PARANOID
     if (Sub_geom_object_pt[e]==0)
      {
       std::ostringstream error_message;
       error_message 
        << "Unable to dynamic cast element: " << std::endl
        << "into a FiniteElement: GeomObject representation is not possible\n";
       throw OomphLibError(
        error_message.str(),
        OOMPH_CURRENT_FUNCTION,
        OOMPH_EXCEPTION_LOCATION);
      }
#endif

     // Add the geometric Data of each element into set
     unsigned ngeom_data=Sub_geom_object_pt[e]->ngeom_data();
     for (unsigned i=0;i<ngeom_data;i++)
      {
       tmp_geom_data.insert(Sub_geom_object_pt[e]->geom_data_pt(i));
      }
    }

   // Now copy unique geom Data values across into vector
   unsigned ngeom=tmp_geom_data.size();
   Geom_data_pt.resize(ngeom);
   typedef std::set<Data*>::iterator IT;
   unsigned count=0;
   for (IT it=tmp_geom_data.begin();it!=tmp_geom_data.end();it++)
    {
     Geom_data_pt[count]=*it;
     count++;
    }

   // Set storage for minimum and maximum coordinates
   const unsigned dim_lagrangian = this->nlagrangian();
   Min_coords.resize(dim_lagrangian);
   Max_coords.resize(dim_lagrangian);

   // Get the default parameters for the number of bins in each 
   // dimension from the Multi_domain_functions namespace
   Nbin_x=Multi_domain_functions::Nx_bin;
   Nbin_y=Multi_domain_functions::Ny_bin;
   Nbin_z=Multi_domain_functions::Nz_bin;

   // Are we computing the extreme bin coordinates here?
   if (compute_extreme_bin_coords)
    {
     // Find the maximum and minimum coordinates for the mesh
     get_min_and_max_coordinates(mesh_pt);
    }
   else
    { 
#ifdef PARANOID
   // Check X_min is less than X_max
   if (Multi_domain_functions::X_min >= Multi_domain_functions::X_max)
    {
     std::ostringstream error_stream;
     error_stream << "Minimum coordinate in the X direction of the bin\n"
                  << "to be used in the multi-domain method is greater\n"
                  << "than or equal to the maximum coordinate.\n"
                  << "  X_min=" << Multi_domain_functions::X_min 
                  << ", X_max=" << Multi_domain_functions::X_max << "\n";
     throw OomphLibError
      (error_stream.str(),
       OOMPH_CURRENT_FUNCTION,
       OOMPH_EXCEPTION_LOCATION);
    }
   if (dim_lagrangian>=2)
    {
     // Check Y_min is less than Y_max
     if (Multi_domain_functions::Y_min >= Multi_domain_functions::Y_max)
      {
       std::ostringstream error_stream;
       error_stream << "Minimum coordinate in the Y direction of the bin\n"
                    << "to be used in the multi-domain method is greater\n"
                    << "than or equal to the maximum coordinate.\n"
                    << "  Y_min=" << Multi_domain_functions::Y_min 
                    << ", Y_max=" << Multi_domain_functions::Y_max << "\n";
       throw OomphLibError
        (error_stream.str(),
         OOMPH_CURRENT_FUNCTION,
         OOMPH_EXCEPTION_LOCATION);
      }
    }
   if (dim_lagrangian==3)
    {
     // Check Z_min is less than Z_max
     if (Multi_domain_functions::Z_min >= Multi_domain_functions::Z_max)
      {
       std::ostringstream error_stream;
       error_stream << "Minimum coordinate in the Z direction of the bin\n"
                    << "to be used in the multi-domain method is greater\n"
                    << "than or equal to the maximum coordinate.\n"
                    << "  Z_min=" << Multi_domain_functions::Z_min 
                    << ", Z_max=" << Multi_domain_functions::Z_max << "\n";
       throw OomphLibError
        (error_stream.str(),
         OOMPH_CURRENT_FUNCTION,
         OOMPH_EXCEPTION_LOCATION);
      }
    }
#endif
   
     Min_coords[0] = Multi_domain_functions::X_min-
      Multi_domain_functions::Percentage_offset*(
       Multi_domain_functions::X_max-Multi_domain_functions::X_min);
     Max_coords[0] = Multi_domain_functions::X_max+
      Multi_domain_functions::Percentage_offset*(
       Multi_domain_functions::X_max-Multi_domain_functions::X_min);
     if (nlagrangian()>1)
      {
       Min_coords[1] = Multi_domain_functions::Y_min-
        Multi_domain_functions::Percentage_offset*(
         Multi_domain_functions::Y_max-Multi_domain_functions::Y_min);
       Max_coords[1] = Multi_domain_functions::Y_max+
        Multi_domain_functions::Percentage_offset*(
         Multi_domain_functions::Y_max-Multi_domain_functions::Y_min);
       if (nlagrangian()>2)
        {
         Min_coords[2] = Multi_domain_functions::Z_min-
          Multi_domain_functions::Percentage_offset*(
           Multi_domain_functions::Z_max-Multi_domain_functions::Z_min);
         Max_coords[2] = Multi_domain_functions::Z_max+
          Multi_domain_functions::Percentage_offset*(
           Multi_domain_functions::Z_max-Multi_domain_functions::Z_min);
        }
      }
    }

   // Create the bin structure, passing in the number of elements in 
   // the mesh
   create_bins_of_objects(mesh_pt->nelement());
 }



 //=================================================================
 /// Sort the sampling points in the specified bin by distance from 
 /// sampling point
 //=================================================================
 void MeshAsGeomObject::sort_the_bin(const Vector<double>& zeta,
                                     Vector<std::pair<FiniteElement*,
                                     Vector<double> > >& sample_point_pairs)
 {

  OomphLibWarning("Multi_domain_functions::Sort_bin_entries is currently disabled\n",
                  OOMPH_CURRENT_FUNCTION,
                  OOMPH_EXCEPTION_LOCATION);

  // // Set current zeta coordinate
  // Multi_domain_functions::Zeta_coords_for_further_away_comparison=zeta;

  // // Sort the bin
  // std::sort(sample_point_pairs.begin(),
  //           sample_point_pairs.end(),
  //           Multi_domain_functions::first_closer_than_second);

 }




 //=================================================================
 /// Get the number of the bin containing the specified coordinate; also
 /// return the contents of that bin. Bin number is negative if 
 /// the coordinate is outside the bin structure.
 //=================================================================
 void MeshAsGeomObject::get_bin(const Vector<double>& zeta, int& bin_number,
  Vector<std::pair<FiniteElement*,Vector<double> > >& sample_point_pairs)
 {

  // Default for point not found
  sample_point_pairs.clear();
  bin_number=-1;
  
  get_bin(zeta,bin_number);
  if (bin_number>=0)
   {
    sample_point_pairs=Bin_object_coord_pairs[unsigned(bin_number)];
   }
 }


 //=================================================================
 /// Get the number of the bin containing the specified coordinate.
 /// Bin number is negative if the coordinate is outside
 /// the bin structure.
 //=================================================================
 void MeshAsGeomObject::get_bin(const Vector<double>& zeta, int& bin_number)
 {
  
  // Default for point not found
  bin_number=-1;
  
  //Get the lagrangian dimension
  const unsigned n_lagrangian = this->nlagrangian();
  
  // Does the zeta coordinate lie within the current bin structure?
  
  //Loop over the lagrangian dimension
  for(unsigned i=0;i<n_lagrangian;i++)
   {
    //If the i-th coordinate is less than the minimum
    if(zeta[i] < Min_coords[i]) 
     {
      return; 
     }
    //Otherwise coordinate may be bigger than the maximum
    else if(zeta[i] > Max_coords[i])
     {
      return; 
     }
   }
  
  // Use the min and max coords of the bin structure, to find
  // the bin structure containing the current zeta cooordinate

  // Initialise for subsequent computation
  bin_number=0; 

  //Offset for rows/matrices in higher dimensions
  unsigned multiplier=1;
  unsigned Nbin[3]={Nbin_x,Nbin_y,Nbin_z};
  
  // Loop over the dimension
  for(unsigned i=0;i<n_lagrangian;i++)
   {
    //Find the bin number of the current coordinate
    unsigned bin_number_i = 
     int(Nbin[i]*((zeta[i]-Min_coords[i])/
                  (Max_coords[i] - Min_coords[i])));
     //Buffer the case when we are exactly on the edge
     if(bin_number_i==Nbin[i]) {bin_number_i -= 1;}
     //Now add to the bin number using the multiplier
     bin_number += multiplier*bin_number_i;
     //Increase the current row/matrix multiplier for the next loop
     multiplier *= Nbin[i];
    }


#ifdef PARANOID

  // Tolerance for "out of bin" test
  double tol=1.0e-10;

  unsigned nvertex=pow(2,n_lagrangian);
  Vector<Vector<double> > bin_vertex(nvertex);
  for (unsigned j=0;j<nvertex;j++)
   {
    bin_vertex[j].resize(n_lagrangian);
   }
  get_bin_vertices(bin_number, bin_vertex);
  for (unsigned i=0;i<n_lagrangian;i++)
   {
    double min_vertex_coord=DBL_MAX;
    double max_vertex_coord=-DBL_MAX;
    for (unsigned j=0;j<nvertex;j++)
     {
      if (bin_vertex[j][i]<min_vertex_coord) min_vertex_coord=bin_vertex[j][i];
      if (bin_vertex[j][i]>max_vertex_coord) max_vertex_coord=bin_vertex[j][i];
     }
    if (zeta[i]<min_vertex_coord-tol)
     {
      std::ostringstream error_message_stream;                           
      error_message_stream                                        
       << "Trouble! " << i << " -th coordinate of sample point, "
       << zeta[i] << " , isn't actually between limits, "
       << min_vertex_coord << " and " << max_vertex_coord 
       << " [it's below by more than " << tol << " !] " << std::endl; 
      throw OomphLibError(error_message_stream.str(),
                          OOMPH_CURRENT_FUNCTION,
                          OOMPH_EXCEPTION_LOCATION);
     }

    if (zeta[i]>max_vertex_coord+tol)
     {
      std::ostringstream error_message_stream;                           
      error_message_stream                                        
       << "Trouble! " << i << " -th coordinate of sample point, "
       << zeta[i] << " , isn't actually between limits, "
       << min_vertex_coord << " and " << max_vertex_coord 
       << " [it's above by more than " << tol << "!] " << std::endl; 
      throw OomphLibError(error_message_stream.str(),
                          OOMPH_CURRENT_FUNCTION,
                          OOMPH_EXCEPTION_LOCATION);
     }
   }

#endif

 }
 


//========================================================================
/// Fill bin by diffusion, populating each empty bin with the same content
/// as the first non-empty bin found during a spiral-based search 
/// up to the specified "radius" (default 1)
//========================================================================
 void MeshAsGeomObject::fill_bin_by_diffusion(const unsigned& 
                                              bin_diffusion_radius)
 {
  // Loop over all bins to check if they're empty
  std::list<unsigned> empty_bins;
  unsigned nbin=total_nbin(); 
  std::vector<bool> was_empty_until_current_iteration(nbin,false);
  for (unsigned i=0;i<nbin;i++)
   {
    if (Bin_object_coord_pairs[i].size()==0)
     {
      empty_bins.push_front(i);
      was_empty_until_current_iteration[i]=true;
     }
   }

  // Now keep processing the empty bins until there are none left
  unsigned iter=0;
  Vector<unsigned> newly_filled_bin;
  while (empty_bins.size()!=0)
   {
    newly_filled_bin.clear();
    newly_filled_bin.reserve(empty_bins.size());
    for (std::list<unsigned>::iterator it=empty_bins.begin();
         it!=empty_bins.end();it++)
     {
      unsigned bin=(*it);

      // Look for immediate neighbours within the specified "bin radius"
      unsigned level=bin_diffusion_radius;
      Vector<unsigned> neighbour_bin;
      get_neighbouring_bins_helper(bin,level,neighbour_bin);
      unsigned n_neigh=neighbour_bin.size();


      // Find closest pair
      double min_dist=DBL_MAX;
      std::pair<FiniteElement*,Vector<double> > closest_pair;
      for (unsigned i=0;i<n_neigh;i++)
       {
        unsigned neigh_bin=neighbour_bin[i];

        // Only allow to re-populate from bins that were already filled at
        // previous iteration, otherwise things can progate too fast
        if (!was_empty_until_current_iteration[neigh_bin])
         {
          unsigned nbin_content=Bin_object_coord_pairs[neigh_bin].size();
          for (unsigned j=0;j<nbin_content;j++)
           {
            FiniteElement* el_pt=Bin_object_coord_pairs[neigh_bin][j].first;
            Vector<double> s(Bin_object_coord_pairs[neigh_bin][j].second);
            Vector<double> x(2);
            el_pt->interpolated_x(s,x);
            // Get minimum distance of sample point from any of the vertices
            // of current bin
            double dist=min_distance(bin,x);
            if (dist<min_dist)
             {
              min_dist=dist;
              closest_pair=Bin_object_coord_pairs[neigh_bin][j];
             }
           }
         }
       }


      // Have we filled the bin?
      if (min_dist!=DBL_MAX)
       {
        Vector<std::pair<FiniteElement*,Vector<double> > > new_entry;
        new_entry.push_back(closest_pair);
        Bin_object_coord_pairs.set_value(bin,new_entry); 
        
        // Record that we've filled it.
        newly_filled_bin.push_back(bin);
        
        // Wipe entry without breaking the linked list (Andrew's trick -- nice!)
        std::list<unsigned>::iterator it_to_be_deleted=it;
        it--;
        empty_bins.erase(it_to_be_deleted);
        
       }
     }

    // Get ready for next iteration on remaining empty bins
    iter++;

    // Now update the vector that records which bins were empty up to now
    unsigned n=newly_filled_bin.size();
    for (unsigned i=0;i<n;i++)
     {
      was_empty_until_current_iteration[newly_filled_bin[i]]=false;
     }
   }


#ifdef PARANOID
  // Loop over all bins to check if they're empty
  nbin=total_nbin(); 
  for (unsigned i=0;i<nbin;i++)
   {
    if (Bin_object_coord_pairs[i].size()==0)
     {
      std::ostringstream error_message_stream;                           
      error_message_stream                                        
       << "Bin " << i << " is still empty\n"
       << "after trying to fill it by diffusion\n";
      throw OomphLibError(error_message_stream.str(),
                          OOMPH_CURRENT_FUNCTION,
                          OOMPH_EXCEPTION_LOCATION);
     }
   }  
#endif


 }

//========================================================================
/// \short Find the sub geometric object and local coordinate therein that
/// corresponds to the intrinsic coordinate zeta. If sub_geom_object_pt=0
/// on return from this function, none of the constituent sub-objects 
/// contain the required coordinate.
/// Setting the final bool argument to true means that we only search
/// for matching element within a a certain number of "spirals" within
/// the bin structure.
//========================================================================
 void MeshAsGeomObject::spiraling_locate_zeta
 (const Vector<double>& zeta,GeomObject*& sub_geom_object_pt,
  Vector<double>& s, const bool &called_within_spiral)
  {
   // Initialise return to null -- if it's still null when we're
   // leaving we've failed!
   sub_geom_object_pt=0;

   //Get the lagrangian dimension
   const unsigned n_lagrangian = this->nlagrangian();

   // Does the zeta coordinate lie within the current bin structure?

   //Loop over the lagrangian dimension
   for(unsigned i=0;i<n_lagrangian;i++)
    {
     //If the i-th coordinate is less than the minimum
     if(zeta[i] < Min_coords[i]) 
      {
       return; 
      }
     //Otherwise coordinate may be bigger than the maximum
     else if(zeta[i] > Max_coords[i])
      {
       return; 
      }
    }
   
   // Use the min and max coords of the bin structure, to find
   // the bin structure containing the current zeta cooordinate
   unsigned bin_number=0;
   //Offset for rows/matrices in higher dimensions
   unsigned multiplier=1;
   unsigned Nbin[3]={Nbin_x,Nbin_y,Nbin_z};

   // Loop over the dimension
   for(unsigned i=0;i<n_lagrangian;i++)
    {
     //Find the bin number of the current coordinate
     unsigned bin_number_i = 
      int(Nbin[i]*((zeta[i]-Min_coords[i])/
                   (Max_coords[i] - Min_coords[i])));
     //Buffer the case when we are exactly on the edge
     if(bin_number_i==Nbin[i]) {bin_number_i -= 1;}
     //Now add to the bin number using the multiplier
     bin_number += multiplier*bin_number_i;
     //Increase the current row/matrix multiplier for the next loop
     multiplier *= Nbin[i];
    }

   if (called_within_spiral)
    {
     // Loop over spirals that are to be visited in one go
     Vector<unsigned> neighbour_bin;
     for (unsigned i_level=current_min_spiral_level();
          i_level<=current_max_spiral_level();i_level++)
      {
       // Call helper function to find the neighbouring bins at this level
       get_neighbouring_bins_helper(bin_number,i_level,neighbour_bin);
      }

     // Total number of bins to be visited
     unsigned n_nbr_bin=neighbour_bin.size();

     // Set bool for finding zeta
     bool found_zeta=false;
     for (unsigned i_nbr=0;i_nbr<n_nbr_bin;i_nbr++)
      {
       // Only search if bin is within the max. radius
       if (min_distance(neighbour_bin[i_nbr],zeta)<Max_search_radius)
        {         
         // Get the number of element-sample point pairs in this bin
         unsigned n_sample=
          Bin_object_coord_pairs[neighbour_bin[i_nbr]].size();
         
         // Don't do anything if this bin has no sample points
         if (n_sample>0)
          {

           // Sort the bin if required
           if (Multi_domain_functions::Sort_bin_entries)
            {
             OomphLibWarning("Multi_domain_functions::Sort_bin_entries is currently disabled\n",
                             OOMPH_CURRENT_FUNCTION,
                             OOMPH_EXCEPTION_LOCATION);
             //sort_the_bin(zeta,Bin_object_coord_pairs[neighbour_bin[i_nbr]]);
            }
           
           for (unsigned i_sam=0;i_sam<n_sample;i_sam++)
            {
             // Get the element
             FiniteElement* el_pt=Bin_object_coord_pairs
              [neighbour_bin[i_nbr]][i_sam].first;
             
             // Get the local coordinate
             s=Bin_object_coord_pairs[neighbour_bin[i_nbr]][i_sam].second;
             
             // Use this coordinate as the initial guess
             bool use_coordinate_as_initial_guess=true;
             
             // Attempt to find zeta within a sub-object
             el_pt->locate_zeta(zeta,sub_geom_object_pt,s,
                                use_coordinate_as_initial_guess);
             
#ifdef OOMPH_HAS_MPI
             // Dynamic cast the result to a FiniteElement
             FiniteElement* test_el_pt=
              dynamic_cast<FiniteElement*>(sub_geom_object_pt);
             if (test_el_pt!=0)
              {
               // We only want to exit if this is a non-halo element
               if (test_el_pt->is_halo()) {sub_geom_object_pt=0;}
              }
#endif
             
             // If the FiniteElement is non-halo and has been located, exit
             if (sub_geom_object_pt!=0)
              {
               found_zeta=true;
               break;
              }
            } // end loop over sample points
          }
         
         if (found_zeta)
          {
           break;
          }

        } //end of don't search if outside search radius
       else
        {
         //oomph_info << "Terminating: Outside search radius [1]\n";
        }
      } // end loop over bins at this level

    }
   else
    {
     // Not called from within a spiral procedure
     // (i.e. the loop in multi_domain.h), so do the spiralling here

     // Loop over all levels... maximum of N*_bin
     unsigned n_level=Nbin[0];
     for(unsigned i=1;i<n_lagrangian;i++)
      {
       if(n_level < Nbin[i]) {n_level = Nbin[i];}
      }
     
     // Also limit to max. spiral level
     n_level=std::min(n_level,max_spiral_level());

     // Set bool for finding zeta
     bool found_zeta=false;
     for (unsigned i_level=0;i_level<n_level;i_level++)
      {
       // Call helper function to find the neighbouring bins at this level
       Vector<unsigned> neighbour_bin;
       get_neighbouring_bins_helper(bin_number,i_level,neighbour_bin);
       unsigned n_nbr_bin=neighbour_bin.size();
       
       // Loop over neighbouring bins
       for (unsigned i_nbr=0;i_nbr<n_nbr_bin;i_nbr++)
        {
         
         // Only search if bin is within the max. radius
         if (min_distance(neighbour_bin[i_nbr],zeta)<Max_search_radius)
          {         
           // Get the number of element-sample point pairs in this bin
           unsigned n_sample=
            Bin_object_coord_pairs[neighbour_bin[i_nbr]].size();
           
           // Don't do anything if this bin has no sample points
           if (n_sample>0)
            {

             // Sort the bin if required
             if (Multi_domain_functions::Sort_bin_entries)
              {
               OomphLibWarning("Multi_domain_functions::Sort_bin_entries is currently disabled\n",
                               OOMPH_CURRENT_FUNCTION,
                               OOMPH_EXCEPTION_LOCATION);
               //sort_the_bin(zeta,Bin_object_coord_pairs[neighbour_bin[i_nbr]]);
              }
                          
             for (unsigned i_sam=0;i_sam<n_sample;i_sam++)
              {
               // Get the element
               FiniteElement* el_pt=Bin_object_coord_pairs
                [neighbour_bin[i_nbr]][i_sam].first;
               
               // Get the local coordinate
               s=Bin_object_coord_pairs[neighbour_bin[i_nbr]][i_sam].second;
               
               // Use this coordinate as the initial guess in locate_zeta
               bool use_coordinate_as_initial_guess=true;
               
               // Attempt to loacte the correct sub-object
               el_pt->locate_zeta(zeta,sub_geom_object_pt,s,
                                  use_coordinate_as_initial_guess);
               
               // If it was found then break
               if (sub_geom_object_pt!=0)
                {
                 found_zeta=true;
                 break;
                }
              } // end loop over sample points
            }
           
           // Break out of the bin loop if locate was successful
           if (found_zeta)
            {
             break;
            }
          } //end of don't search if outside search radius
         else
          {
           //oomph_info << "Terminating: Outside search radius [2]\n";
          }

        } // end loop over bins at this level

       // Break out of the spiral loop if locate was successful
       if (found_zeta)
        {
         break;
        }

      } // end loop over levels

    } // end if (called_within_spiral)

  }

//========================================================================
///Get the min and max coordinates for the mesh, in each dimension
//========================================================================
 void MeshAsGeomObject::
 get_min_and_max_coordinates(Mesh* const &mesh_pt)
  {
   //Get the lagrangian dimension
   int n_lagrangian = this->nlagrangian();

   // Storage locally (i.e. in parallel on each processor)
   // for the minimum and maximum coordinates
   double zeta_min_local[n_lagrangian]; double zeta_max_local[n_lagrangian];
   for(int i=0;i<n_lagrangian;i++)
    {zeta_min_local[i] = DBL_MAX; zeta_max_local[i] = -DBL_MAX;}
   
   // Loop over the elements of the mesh
   unsigned n_el=mesh_pt->nelement();
   for (unsigned e=0;e<n_el;e++)
    {
     FiniteElement* el_pt = mesh_pt->finite_element_pt(e);
   
     // Get the number of vertices (nplot=2 does the trick)
     unsigned n_plot=2;
     unsigned n_plot_points=el_pt->nplot_points(n_plot);

     // Loop over the number of plot points
     for (unsigned iplot=0;iplot<n_plot_points;iplot++)
      {
       Vector<double> s_local(n_lagrangian);
       Vector<double> zeta_global(n_lagrangian);

       // Get the local s
       el_pt->get_s_plot(iplot,n_plot,s_local);

       // Now interpolate to global coordinates
       if (MeshAsGeomObject::Use_eulerian_coordinates_during_setup)
        {         
         el_pt->interpolated_x(s_local,zeta_global);
        }
       else
        {
         el_pt->interpolated_zeta(s_local,zeta_global);
        }

       // Check the max and min in each direction
       for(int i=0;i<n_lagrangian;i++)
        {
         //Is the coordinate less than the minimum?
         if(zeta_global[i] < zeta_min_local[i]) 
          {zeta_min_local[i] = zeta_global[i];}
         //Is the coordinate bigger than the maximum?
         if(zeta_global[i] > zeta_max_local[i]) 
          {zeta_max_local[i] = zeta_global[i];}
        }
      }
    }

   // Global extrema - in parallel, need to get max/min across all processors
   double zeta_min[n_lagrangian]; double zeta_max[n_lagrangian];
   for(int i=0;i<n_lagrangian;i++) {zeta_min[i] = 0.0; zeta_max[i] = 0.0;}

#ifdef OOMPH_HAS_MPI
   // If the mesh has been distributed and we want consistent bins
   // across all processors
   if ( mesh_pt->is_mesh_distributed() && 
        (!Suppress_synchronisation_of_bins) )
    {
     // .. we need a non-null communicator!
     if (Communicator_pt!=0)
      {
       int n_proc=Communicator_pt->nproc();
       if (n_proc>1)
        {
         //Get the minima and maxima over all processors
         MPI_Allreduce(zeta_min_local,zeta_min,n_lagrangian,MPI_DOUBLE,MPI_MIN,
                       Communicator_pt->mpi_comm());
         MPI_Allreduce(zeta_max_local,zeta_max,n_lagrangian,MPI_DOUBLE,MPI_MAX,
                       Communicator_pt->mpi_comm());
        }
      }
     else // Null communicator - throw an error
      {
       std::ostringstream error_message_stream;                           
       error_message_stream                                        
        << "Communicator not set for a MeshAsGeomObject\n"
        << "that was created from a distributed Mesh";
       throw OomphLibError(error_message_stream.str(),
                           OOMPH_CURRENT_FUNCTION,
                           OOMPH_EXCEPTION_LOCATION);
      }
    }
   else // If the mesh hasn't been distributed then the 
        // max and min are the same on all processors
    {
     for(int i=0;i<n_lagrangian;i++) 
      {
       zeta_min[i] = zeta_min_local[i];
       zeta_max[i] = zeta_max_local[i];
      }
    }
#else // If we're not using MPI then the mesh can't be distributed
   for(int i=0;i<n_lagrangian;i++) 
    {
     zeta_min[i] = zeta_min_local[i];
     zeta_max[i] = zeta_max_local[i];
    }
#endif

   // Decrease/increase min and max to allow for any overshoot in
   // meshes that may move around
   // There's no point in doing this for DIM_LAGRANGIAN==1
   double percentage_offset=Multi_domain_functions::Percentage_offset;
   for(int i=0;i<n_lagrangian;i++)
    {
     double length = zeta_max[i] - zeta_min[i];
     zeta_min[i] -= ((percentage_offset/100.0)*length);
     zeta_max[i] += ((percentage_offset/100.0)*length);
    }

   // Set the entries as the Min/Max_coords vector
   for(int i=0;i<n_lagrangian;i++) 
    {
     Min_coords[i] = zeta_min[i]; 
     Max_coords[i] = zeta_max[i];
    }
  }



//========================================================================
 /// Provide some stats on the fill level of the associated bin
//========================================================================
 void MeshAsGeomObject::get_fill_stats(unsigned& n_bin,
                                       unsigned& max_n_entry,
                                       unsigned& min_n_entry,
                                       unsigned& tot_n_entry,
                                       unsigned& n_empty) const
 {
  // Total number of bins
  n_bin=total_nbin();
  n_empty=n_bin-Bin_object_coord_pairs.nnz();

  // Get pointer to map-based representation
  const std::map<unsigned,Vector<std::pair<FiniteElement*,Vector<double> > > >*
   map_pt=Bin_object_coord_pairs.map_pt();

  // Initialise
  max_n_entry=0;
  min_n_entry=UINT_MAX;
  tot_n_entry=0;

  // Do stats
  typedef std::map<unsigned,Vector<
   std::pair<FiniteElement*,Vector<double> > > >::const_iterator IT;
  for (IT it=map_pt->begin();it!=map_pt->end();it++)
   {
    unsigned nentry=(*it).second.size();
    if (nentry>max_n_entry) max_n_entry=nentry;
    if (nentry<min_n_entry) min_n_entry=nentry;
    tot_n_entry+=nentry;
   }

 }
 


//========================================================================
///Initialise the "bin" structure for locating coordinates
///The number of elements in the mesh is passed in only for an error check
///about the number of elements / bin.
//========================================================================
 void MeshAsGeomObject::create_bins_of_objects(
  const unsigned long &n_mesh_element)
  {
   //Store the lagrangian dimension
   const unsigned n_lagrangian = this->nlagrangian();

   // Output message regarding bin structure setup if required
   if (Multi_domain_functions::Doc_stats)
    {
     oomph_info << "============================================" << std::endl;
     oomph_info << " MeshAsGeomObject: set up bin search with:" << std::endl;
     oomph_info << "   Nbin_x=" << Nbin_x << "  ";
     if (n_lagrangian>=2)
      {
       oomph_info << "Nbin_y=" << Nbin_y << "  ";
      }
     if (n_lagrangian==3)
      {
       oomph_info << "Nbin_z=" << Nbin_z;
      }
     oomph_info << std::endl;
     oomph_info << "  Xminmax=" << Min_coords[0] << " " << Max_coords[0] 
                << "  ";
     if (n_lagrangian>=2)
      {
       oomph_info << "Yminmax=" << Min_coords[1] << " " << Max_coords[1]
                  << "  ";
      }
     if (n_lagrangian==3)
      {
       oomph_info << "Zminmax=" << Min_coords[2] << " " << Max_coords[2] 
                  << "  ";
      }
     oomph_info << std::endl;
     oomph_info << "============================================" << std::endl;
    }

   /// Flush all objects out of the bin structure
   flush_bins_of_objects();

   // Temporary storage in bin
   std::map<unsigned,Vector<std::pair<FiniteElement*,Vector<double> > > >
    tmp_bin_object_coord_pairs;

   unsigned Nbin[3] ={Nbin_x, Nbin_y, Nbin_z};

   // Total number of bins
   unsigned ntotalbin=total_nbin();
   
   // Issue warning about small number of bins
   if (!Suppress_warning_about_small_number_of_bins)
    {
     //Calculate the (nearest integer) number of elements per bin
     unsigned elements_per_bin = n_mesh_element / ntotalbin;
     //If it is above the threshold then issue a warning
     if (elements_per_bin > Threshold_for_elements_per_bin_warning)
      {
       if (!Already_warned_about_small_number_of_bin_cells)
        {
         Already_warned_about_small_number_of_bin_cells=true;
         std::ostringstream warn_message;
         warn_message 
          << "The average (integer) number of elements per bin is \n\n"
          << elements_per_bin 
          << ", which is more than \n\n"
          << "   MeshAsGeomObject::Threshold_for_elements_per_bin_warning="
          << MeshAsGeomObject::Threshold_for_elements_per_bin_warning 
          << "\n\nIf the lookup seems slow (and you have the memory), consider increasing\n"
          << "Multi_domain_functions::N{x,y,z}_bin from their current\n"
          << "values of { " 
          << Multi_domain_functions::Nx_bin << " "
          << Multi_domain_functions::Ny_bin << " "
          << Multi_domain_functions::Nz_bin << " }.\n"
          << "\nNOTE: You can suppress this warning by increasing\n\n"
          << "   MeshAsGeomObject::Threshold_for_elements_per_bin_warning\n\n"
          << "or by setting \n\n   MeshAsGeomObject::Suppress_warning_about_small_number_of_bins\n\n"
          << "to true (both are public static data).\n\n";
         OomphLibWarning(
          warn_message.str(),
          "MeshAsGeomObject::create_bins_of_objects()",
          OOMPH_EXCEPTION_LOCATION);
        }
      }
    }



   // Increase overall counter
   Total_nbin_cells_counter+=ntotalbin;

   // Issue warning?
   if (!Suppress_warning_about_large_total_number_of_bins)
    {
     if (Total_nbin_cells_counter>Threshold_for_total_bin_cell_number_warning)
      {
       if (!Already_warned_about_large_number_of_bin_cells)
        {
         Already_warned_about_large_number_of_bin_cells=true;
         std::ostringstream warn_message;
         warn_message 
          << "Have allocated \n\n"
          << "   MeshAsGeomObject::Total_nbin_cells_counter="
          << MeshAsGeomObject::Total_nbin_cells_counter 
          << "\n\nbin cells, which is more than \n\n"
          << "   MeshAsGeomObject::Threshold_for_total_bin_cell_number_warning="
          << MeshAsGeomObject::Threshold_for_total_bin_cell_number_warning 
          << "\n\nIf you run out of memory, consider reducing\n"
          << "Multi_domain_functions::N{x,y,z}_bin from their current\n"
          << "values of { " 
          << Multi_domain_functions::Nx_bin << " "
          << Multi_domain_functions::Ny_bin << " "
          << Multi_domain_functions::Nz_bin << " }.\n"
          << "\nNOTE: You can suppress this warning by increasing\n\n"
          << "   MeshAsGeomObject::Threshold_for_total_bin_cell_number_warning\n\n"
          << "or by setting \n\n   MeshAsGeomObject::Suppress_warning_about_large_total_number_of_bins\n\n"
          << "to true (both are public static data).\n\n"
          << "NOTE: I'll only issues this warning once -- total number of\n"
          << "bins may grow yet further!\n";
         OomphLibWarning(
          warn_message.str(),
          "MeshAsGeomObject::create_bins_of_objects()",
          OOMPH_EXCEPTION_LOCATION);
        }
      }
    }

   ///Loop over subobjects (elements) to decide which bin they belong in...
   unsigned n_sub=Sub_geom_object_pt.size();

   // Some stats
   if (Multi_domain_functions::Doc_stats)
    {
     oomph_info << "There are " << n_sub << " element[s] to be put into bins"
                << std::endl << std::endl;
    }

   for (unsigned e=0;e<n_sub;e++)
    {
     // Cast to the element (sub-object) first
     FiniteElement* el_pt=dynamic_cast<FiniteElement*>(Sub_geom_object_pt[e]);

     // Get specified number of points within the element
     unsigned n_plot_points=
      el_pt->nplot_points(Multi_domain_functions::Nsample_points);

     for (unsigned iplot=0;iplot<n_plot_points;iplot++)
      {
       // Storage for local and global coordinates
       Vector<double> local_coord(n_lagrangian,0.0);
       Vector<double> global_coord(n_lagrangian,0.0);

       // Get local coordinate and interpolate to global
       el_pt->get_s_plot(iplot,
                         Multi_domain_functions::Nsample_points,local_coord);
       
       // Now get appropriate global coordinate
       if (MeshAsGeomObject::Use_eulerian_coordinates_during_setup) 
        {         
         el_pt->interpolated_x(local_coord,global_coord);
        }
       else
        {
         el_pt->interpolated_zeta(local_coord,global_coord);
        }

       //Which bin are the global coordinates in?
       unsigned bin_number=0;
       unsigned multiplier=1;
       // Loop over the dimension
       for(unsigned i=0;i<n_lagrangian;i++)
        {
#ifdef PARANOID
         if ((global_coord[i]<Min_coords[i])||
             (global_coord[i]>Max_coords[i]))
          {
           std::ostringstream error_message;
           error_message 
            << "Bin sample point " << iplot << " in element " << e << "\n"
            << "is outside bin limits in coordinate direction " << i << ":\n"
            << "Sample point coordinate: " << global_coord[i] << "\n"
            << "Max bin coordinate     : " << Max_coords[i] << "\n"
            << "Min bin coordinate     : " << Min_coords[i] << "\n"
            << "You should either setup the bin boundaries manually\n"
            << "or increase the percentage offset by which the\n"
            << "automatically computed bin limits are increased \n"
            << "beyond their sampled max/mins. This is defined in\n"
            << "the (public) namespace member\n\n"
            << "Multi_domain_functions::Percentage_offset \n\n which \n"
            << "currently has the value: "
            << Multi_domain_functions::Percentage_offset << "\n";
           throw OomphLibError(
            error_message.str(),
            OOMPH_CURRENT_FUNCTION,
            OOMPH_EXCEPTION_LOCATION);
          }
          
#endif
         unsigned bin_number_i = 
          int(Nbin[i]*(
               (global_coord[i] - Min_coords[i])/
               (Max_coords[i] - Min_coords[i])));

         //Buffer the case when the global coordinate is the maximum
         //value
         if(bin_number_i==Nbin[i]) {bin_number_i -= 1;}

         //Add to the bin number
         bin_number += multiplier*bin_number_i;

         //Sort out the multiplier
         multiplier *= Nbin[i];
        }
       
       // //Add element-sample local coord pair to the calculated bin
       // Bin_object_coord_pairs[bin_number].push_back
       //  (std::make_pair(el_pt,local_coord));


       //Add element-sample local coord pair to the calculated bin
       tmp_bin_object_coord_pairs[bin_number].push_back
        (std::make_pair(el_pt,local_coord));

      }
    }


   // Finally copy filled vectors across -- wiping memory from temporary
   // map as we go along is good and wouldn't be possible if we 
   // filled the SparseVector's internal map within that class.
   typedef std::map<unsigned,Vector<
    std::pair<FiniteElement*,Vector<double> > > >::iterator IT;
   for (IT it=tmp_bin_object_coord_pairs.begin();
        it!=tmp_bin_object_coord_pairs.end();it++)
    {
     Bin_object_coord_pairs.set_value((*it).first,
                                      (*it).second);
     // Make space immediately
     (*it).second.clear();
    }

  }

//========================================================================
/// Output bins
//========================================================================
 void MeshAsGeomObject::output_bins(std::ofstream& outfile)
 {
  // Spatial dimension of bin
  const unsigned n_lagrangian = this->nlagrangian();
  
  unsigned nbin_x=Nbin_x;
  unsigned nbin_y=1;
  if (n_lagrangian>1) nbin_y=Nbin_y; 
  unsigned nbin_z=1;
  if (n_lagrangian>2) nbin_z=Nbin_z;

  unsigned b=0;
  for (unsigned iz=0;iz<nbin_z;iz++)
   {
    for (unsigned iy=0;iy<nbin_y;iy++)
     {
      for (unsigned ix=0;ix<nbin_x;ix++)
       {
        unsigned nentry=Bin_object_coord_pairs[b].size();
        for (unsigned e=0;e<nentry;e++)
         {
          FiniteElement* el_pt=Bin_object_coord_pairs[b][e].first;
          Vector<double> s(Bin_object_coord_pairs[b][e].second);
          unsigned dim=this->nlagrangian();
          Vector<double> zeta(dim);
          if (Have_used_eulerian_coordinates_during_setup) 
           {         
            el_pt->interpolated_x(s,zeta);
           }
          else
           {
            el_pt->interpolated_zeta(s,zeta);
           }
          for (unsigned i=0;i<dim;i++)
           {
            outfile << zeta[i] << " ";
           }
          outfile << ix << " " 
                  << iy << " " 
                  << iz << " " 
                  << b  << " " 
                  << std::endl;
         }
        b++;
       }
     }
   }
 }
  
  
//========================================================================
/// Compute the minimum distance of any vertex in the specified bin
/// from the specified Lagrangian coordinate zeta.
//========================================================================
 double MeshAsGeomObject::min_distance(const unsigned& i_bin,
                                       const Vector<double>& zeta)
 {
  // Spatial dimension of bin
  const unsigned n_lagrangian = this->nlagrangian();
  
  // Get bin vertices
  Vector<Vector<double> > bin_vertex;
  get_bin_vertices(i_bin, bin_vertex);

  double min_dist=DBL_MAX;
  unsigned nvertex=bin_vertex.size();
  for (unsigned v=0;v<nvertex;v++)
   {
    double dist=0.0;
    for (unsigned i=0;i<n_lagrangian;i++)
     {
      dist+=pow(bin_vertex[v][i]-zeta[i],2);
     }
    dist=sqrt(dist);
    if (dist<min_dist) min_dist=dist;
   }
  return min_dist;
 }



//========================================================================
/// Output bin vertices (allowing display of bins as zones). 
/// Final argument specifies the coordinates of a point
/// and output includes the minimum distance of any of
/// the bin vertices to this point. 
//========================================================================
 void MeshAsGeomObject::output_bin_vertices(std::ostream& outfile,
  const Vector<double>& zeta)
 {
  
  // Spatial dimension of bin
  const unsigned n_lagrangian = this->nlagrangian();
  
  unsigned nbin=Nbin_x;
  if (n_lagrangian>1) nbin*=Nbin_y; 
  if (n_lagrangian>2) nbin*=Nbin_z;

  for (unsigned i_bin=0;i_bin<nbin;i_bin++)
   {
    // Get bin vertices
    Vector<Vector<double> > bin_vertex;
    get_bin_vertices(i_bin, bin_vertex);
    switch(n_lagrangian)
     {
     case 1:
      outfile << "ZONE I=2\n";
      break;

     case 2:
      outfile << "ZONE I=2, J=2\n";
      break;

     case 3:
      outfile << "ZONE I=2, J=2, K=2\n";
      break;
     }

    unsigned nvertex=bin_vertex.size();
    for (unsigned i=0;i<nvertex;i++)
     {
      for (unsigned j=0;j<n_lagrangian;j++)
       {
        outfile 
         << bin_vertex[i][j] << " ";
       }
      outfile << i_bin << " "
              << min_distance(i_bin,zeta) << "\n";
     }
   }
 }


//========================================================================
/// Output bin vertices of specified bin (allowing display of bins as zones). 
/// Final argument specifies the coordinates of a point 
/// and output includes the minimum distance of any of
/// the bin vertices to this point. 
//========================================================================
 void MeshAsGeomObject::output_bin_vertices(std::ostream& outfile,
                                            const unsigned& i_bin,
                                            const Vector<double>& zeta)
 {
  
  // Spatial dimension of bin
  const unsigned n_lagrangian = this->nlagrangian();
  
  // Get bin vertices
  Vector<Vector<double> > bin_vertex;
  get_bin_vertices(i_bin, bin_vertex);
  switch(n_lagrangian)
   {
   case 1:
    outfile << "ZONE I=2\n";
    break;
    
   case 2:
    outfile << "ZONE I=2, J=2\n";
    break;
    
   case 3:
    outfile << "ZONE I=2, J=2, K=2\n";
    break;
   }
  
  unsigned nvertex=bin_vertex.size();
  for (unsigned i=0;i<nvertex;i++)
   {
    for (unsigned j=0;j<n_lagrangian;j++)
     {
      outfile 
       << bin_vertex[i][j] << " ";
     }
    outfile << i_bin << " "
            << min_distance(i_bin,zeta) << "\n";
   }
 }



//========================================================================
/// Get vector of vectors containing the coordinates of the
/// vertices of the i_bin-th bin: bin_vertex[j][i] contains the
/// i-th coordinate of the j-th vertex.
//========================================================================
 void MeshAsGeomObject::get_bin_vertices(const unsigned& i_bin,
                                         Vector<Vector<double> >& bin_vertex)
 {
 
  // Spatial dimension of bin
  const unsigned n_lagrangian = this->nlagrangian();
  
  // How many vertices do we have?
  unsigned n_vertices=1;
  for (unsigned i=0;i<n_lagrangian;i++)
   {
    n_vertices*=2;
   }
  bin_vertex.resize(n_vertices);
  
  // Vectors for min [0] and max [1] coordinates of the bin in each 
  // coordinate direction
  Vector<Vector<double> > zeta_vertex_bin(2);
  zeta_vertex_bin[0].resize(n_lagrangian);
  zeta_vertex_bin[1].resize(n_lagrangian);
  
  unsigned Nbin[3]={Nbin_x,Nbin_y,Nbin_z};
  Vector<double> dzeta;
  unsigned count=0;
  Vector<unsigned> i_1d;

  // Deal with different spatial dimensions separately
  switch (n_lagrangian)
   {
    
   case 1:
    
    // Assign vertex coordinates of the bin directly
    dzeta.resize(1);
    dzeta[0]=(Max_coords[0]-Min_coords[0])/double(Nbin[0]);
    bin_vertex[0].resize(1);
    bin_vertex[0][0]=Min_coords[0]+double(i_bin)*dzeta[0];
    bin_vertex[1].resize(1);
    bin_vertex[1][0]=Min_coords[0]+double(i_bin+1)*dzeta[0];

    break;

   case 2:

    dzeta.resize(2);
    dzeta[0]=(Max_coords[0]-Min_coords[0])/double(Nbin[0]);
    dzeta[1]=(Max_coords[1]-Min_coords[1])/double(Nbin[1]);

    i_1d.resize(2);
    i_1d[0]=i_bin%Nbin[0];
    i_1d[1]=(i_bin-i_1d[0])/Nbin[0];

    // Max/min coordinates of the bin
    for (unsigned i=0;i<n_lagrangian;i++)
     {
      zeta_vertex_bin[0][i]=Min_coords[i]+double(i_1d[i])*dzeta[i];
      zeta_vertex_bin[1][i]=Min_coords[i]+double(i_1d[i]+1)*dzeta[i];
     }

    // Build 4 vertex coordinates
    count=0;
    for (unsigned i_min_max=0;i_min_max<2;i_min_max++)
     {
      for (unsigned j_min_max=0;j_min_max<2;j_min_max++)
       {
        bin_vertex[count].resize(2);
        bin_vertex[count][0]=zeta_vertex_bin[i_min_max][0];
        bin_vertex[count][1]=zeta_vertex_bin[j_min_max][1];
        count++;
       }
     }

    break;

   case 3:

    dzeta.resize(3);
    dzeta[0]=(Max_coords[0]-Min_coords[0])/double(Nbin[0]);
    dzeta[1]=(Max_coords[1]-Min_coords[1])/double(Nbin[1]);
    dzeta[2]=(Max_coords[2]-Min_coords[2])/double(Nbin[2]);

    i_1d.resize(3);
    i_1d[0]=i_bin%Nbin[0];
    i_1d[1]=((i_bin-i_1d[0])/Nbin[0])%Nbin[1];
    i_1d[2]=(i_bin-(i_1d[1]*Nbin[0]+i_1d[0]))/(Nbin[0]*Nbin[1]);

    // Max/min coordinates of the bin
    for (unsigned i=0;i<n_lagrangian;i++)
     {
      zeta_vertex_bin[0][i]=Min_coords[i]+double(i_1d[i])*dzeta[i];
      zeta_vertex_bin[1][i]=Min_coords[i]+double(i_1d[i]+1)*dzeta[i];
     }

    // Build 8 vertex coordinates
    count=0;
    for (unsigned i_min_max=0;i_min_max<2;i_min_max++)
     {
      for (unsigned j_min_max=0;j_min_max<2;j_min_max++)
       {
        for (unsigned k_min_max=0;k_min_max<2;k_min_max++)
         {
          bin_vertex[count].resize(3);
          bin_vertex[count][0]=zeta_vertex_bin[i_min_max][0];
          bin_vertex[count][1]=zeta_vertex_bin[j_min_max][1];
          bin_vertex[count][2]=zeta_vertex_bin[k_min_max][2];
          count++;
         }
       }
     }

    break;

   default:
    
    std::ostringstream error_message;
    error_message 
     << "Can't deal with bins in dimension " << n_lagrangian << "\n";
    throw OomphLibError(
     error_message.str(),
     OOMPH_CURRENT_FUNCTION,
     OOMPH_EXCEPTION_LOCATION);
   }

 }



//========================================================================
///Calculate the bin numbers of all the neighbours to "bin" given the level
//========================================================================
 void MeshAsGeomObject::get_neighbouring_bins_helper(
  const unsigned& bin, const unsigned& level,
  Vector<unsigned>& neighbour_bin)
  {
   const unsigned n_lagrangian = this->nlagrangian();
   // This will be different depending on the number of Lagrangian
   // coordinates
   if (n_lagrangian==1)
    {
     // Single "loop" in one direction - always a vector of max size 2
     unsigned nbr_bin_left=bin-level;
     if ((nbr_bin_left>=0) && (nbr_bin_left<Nbin_x))
      {
       unsigned nbr_bin=nbr_bin_left;
       neighbour_bin.push_back(nbr_bin);
      }
     unsigned nbr_bin_right=bin+level;
     if ((nbr_bin_right>=0) && (nbr_bin_right<Nbin_x) && 
         (nbr_bin_right!=nbr_bin_left))
      {
       unsigned nbr_bin=nbr_bin_right;
       neighbour_bin.push_back(nbr_bin);
      }
    }
   else if (n_lagrangian==2)
    {
     unsigned n_total_bin=Nbin_x*Nbin_y;

     // Which row of the bin structure is the current bin on?
     // This is just given by the integer answer of dividing bin
     // by Nbin_x (the number of bins in a single row)
     // e.g. in a 6x6 grid, bins 6 through 11 would all have bin_row=1
     unsigned bin_row=bin/Nbin_x;

     // The neighbour_bin vector contains all bin numbers at the 
     // specified "distance" (level) away from the current bin

     // Row/column length
     unsigned n_length=(level*2)+1;

     // Loop over the rows
     for (unsigned j=0;j<n_length;j++)
      {
       // Loop over the columns
       for (unsigned i=0;i<n_length;i++)
        {
         // Only do this for all the first & last row, and the
         // end points of every other row
         if ((j==0) || (j==n_length-1) || (i==0) || (i==n_length-1))
          {
           unsigned nbr_bin=bin-level+i-((level-j)*Nbin_x);
           // This number might fall on the wrong
           // row of the bin structure; this needs to be tested

           // Which row is this number on? (see above)
           unsigned nbr_bin_row=nbr_bin/Nbin_x;

           // Which row should it be on?
           unsigned row=bin_row-level+j;

           // These numbers for the rows must match; 
           // if it is then add nbr_bin to the neighbour scheme
           // (The bin number must also be greater than zero
           //  and less than the total number of bins)
           if ((row==nbr_bin_row) && (nbr_bin>=0) && (nbr_bin<n_total_bin))
            {
             neighbour_bin.push_back(nbr_bin);
            }  
          }
        }

      }
    }
   else if (n_lagrangian==3)
    {
     unsigned n_total_bin=Nbin_x*Nbin_y*Nbin_z;

     // Which layer of the bin structure is the current bin on?
     // This is just given by the integer answer of dividing bin
     // by Nbin_x*Nbin_y (the number of bins in a single layer
     // e.g. in a 6x6x6 grid, bins 72 through 107 would all have bin_layer=2
     unsigned bin_layer=bin/(Nbin_x*Nbin_y);

     // Which row in this layer is the bin number on?
     unsigned bin_row=(bin/Nbin_x)-(bin_layer*Nbin_y);

     // The neighbour_bin vector contains all bin numbers at the 
     // specified "distance" (level) away from the current bin

     // Row/column/layer length
     unsigned n_length=(level*2)+1;

     // Loop over the layers
     for (unsigned k=0;k<n_length;k++)
      {
       // Loop over the rows
       for (unsigned j=0;j<n_length;j++)
        {
         // Loop over the columns
         for (unsigned i=0;i<n_length;i++)
          {
           // Only do this for the end points of every row/layer/column
           if ((k==0) || (k==n_length-1) || (j==0) || 
               (j==n_length-1) || (i==0) || (i==n_length-1))
            {
             unsigned nbr_bin=bin-level+i-((level-j)*Nbin_x)-
              ((level-k)*Nbin_x*Nbin_y);
             // This number might fall on the wrong
             // row or layer of the bin structure; this needs to be tested

             // Which layer is this number on?
             unsigned nbr_bin_layer=nbr_bin/(Nbin_x*Nbin_y);

             // Which row is this number on? (see above)
             unsigned nbr_bin_row=(nbr_bin/Nbin_x)-(nbr_bin_layer*Nbin_y);

             // Which layer and row should it be on, given level?
             unsigned layer=bin_layer-level+k;
             unsigned row=bin_row-level+j;

             // These layers and rows must match up:
             // if so then add nbr_bin to the neighbour schemes
             // (The bin number must also be greater than zero
             //  and less than the total number of bins)
             if ((row==nbr_bin_row) && (layer==nbr_bin_layer)
                 && (nbr_bin>=0) && (nbr_bin<n_total_bin))
              {
               neighbour_bin.push_back(nbr_bin);
              }  
            }

          }
        }
      }

    }
  }
 

}
