//LIC// ====================================================================
//LIC// This file forms part of oomph-lib, the object-oriented, 
//LIC// multi-physics finite-element library, available 
//LIC// at http://www.oomph-lib.org.
//LIC// 
//LIC//    Version 1.0; svn revision $LastChangedRevision$
//LIC//
//LIC// $LastChangedDate$
//LIC// 
//LIC// Copyright (C) 2006-2016 Matthias Heil and Andrew Hazel
//LIC// 
//LIC// This library is free software; you can redistribute it and/or
//LIC// modify it under the terms of the GNU Lesser General Public
//LIC// License as published by the Free Software Foundation; either
//LIC// version 2.1 of the License, or (at your option) any later version.
//LIC// 
//LIC// This library is distributed in the hope that it will be useful,
//LIC// but WITHOUT ANY WARRANTY; without even the implied warranty of
//LIC// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//LIC// Lesser General Public License for more details.
//LIC// 
//LIC// You should have received a copy of the GNU Lesser General Public
//LIC// License along with this library; if not, write to the Free Software
//LIC// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
//LIC// 02110-1301  USA.
//LIC// 
//LIC// The authors may be contacted at oomph-lib@maths.man.ac.uk.
//LIC// 
//LIC//====================================================================
// Common base class for all Triangle Meshes
#ifndef OOMPH_TRIMESH_HEADER
#define OOMPH_TRIMESH_HEADER

// Config header generated by autoconfig
#ifdef HAVE_CONFIG_H
  #include <oomph-lib-config.h>
#endif

//oomph-lib includes
#include "Vector.h"
#include "nodes.h"
#include "matrices.h"
#include "mesh.h"

namespace oomph
{

#ifdef OOMPH_HAS_TRIANGLE_LIB

//=====================================================================
/// The Triangle data structure, modified from the triangle.h header
/// supplied with triangle 1.6. by J. R. Schewchuk. We need to define
/// this here separately because we can't include a c header directly
/// into C++ code!
//=====================================================================
struct TriangulateIO 
{
 ///Pointer to list of points x coordinate followed by y coordinate
 double *pointlist;

 ///Pointer to list of point attributes
 double *pointattributelist;

 ///Pointer to list of point markers
 int *pointmarkerlist;
 int numberofpoints;
 int numberofpointattributes;
 
 int *trianglelist;
 double *triangleattributelist;
 double *trianglearealist;
 int *neighborlist;
 int numberoftriangles;
 int numberofcorners;
 int numberoftriangleattributes;
 
 int *segmentlist;
 int *segmentmarkerlist;
 int numberofsegments;
 
 double *holelist;
 int numberofholes;
 
 double *regionlist;
 int numberofregions;
 
 int *edgelist;
 int *edgemarkerlist;  // <---- contains boundary ID (offset by one)
 double *normlist;
 int numberofedges;

};


#endif





///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////


//==================================================================
/// Helper namespace for triangle meshes
//==================================================================
namespace TriangleHelper
{

#ifdef OOMPH_HAS_TRIANGLE_LIB

 /// Clear TriangulateIO structure
 extern void clear_triangulateio(TriangulateIO& triangulate_io,
                                 const bool& clear_hole_data=true);

 /// Initialise TriangulateIO structure
 extern void initialise_triangulateio(TriangulateIO& triangle_io);

 /// \short Make (partial) deep copy of TriangulateIO object. We only copy
 /// those items we need within oomph-lib's adaptation procedures.
 /// Warnings are issued if triangulate_io contains data that is not
 /// not copied, unless quiet=true;
 extern TriangulateIO deep_copy_of_triangulateio_representation(
  TriangulateIO& triangle_io, const bool& quiet=false);

 /// \short Write the triangulateio data to disk as a poly file,
 /// mainly used for debugging
 extern void write_triangulateio_to_polyfile(TriangulateIO &triangle_io,
                                             std::ostream &poly_file);


 /// \short Create a triangulateio data file from ele node and poly
 /// files.
 extern void create_triangulateio_from_polyfiles(
  const std::string& node_file_name,
  const std::string& element_file_name,
  const std::string& poly_file_name,
  TriangulateIO &triangle_io,
  bool &use_attributes);
  

 /// \short Dump the triangulatio data into a dump file
 extern void dump_triangulateio(TriangulateIO &triangle_io,
                                std::ostream &dump_file);

 /// \short Read the triangulateio data from a dump file
 extern void read_triangulateio(std::istream &dump_fil,
                                TriangulateIO &triangulate_io);

#endif

}


/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////

class TriangleMeshPolyLine;
class TriangleMeshCurviLine;

//=====================================================================
/// Base class for defining a triangle mesh boundary, this class has the
/// methods that allow to connect the initial and final ends to other
/// triangle mesh boundaries
//=====================================================================
class TriangleMeshCurveSection
{

  public:

 /// Empty constructor. Initialises the curve section as non connected
 TriangleMeshCurveSection() :
  Initial_vertex_connected(false),
  Final_vertex_connected(false),
  Initial_vertex_connected_suspended(false),
  Final_vertex_connected_suspended(false),
  Initial_vertex_connected_to_curviline(false),
  Final_vertex_connected_to_curviline(false),
  Refinement_tolerance(0.08),
  Unrefinement_tolerance(0.04),
  Maximum_length(-1.0)
 { }

 /// Empty destructor
 virtual ~TriangleMeshCurveSection() { }

 /// \short Number of segments that this part of the
 /// boundary is to be represented by. This corresponds
 /// to the number of straight-line segments in triangle
 /// representation.
 virtual unsigned nsegment() const = 0;
 
 /// Boundary id
 virtual unsigned boundary_id()const = 0;
 
 /// Boundary chunk (Used when a boundary is represented by more
 /// than one polyline
 virtual unsigned boundary_chunk()const = 0;
 
 /// Number of vertices
 virtual unsigned nvertex() const = 0;

 /// Output the curve_section
 virtual void output(std::ostream &outfile, const unsigned& n_sample=50) = 0;

 /// \short Enable refinement of curve section to create a better
 /// representation of curvilinear boundaries (e.g. in free-surface
 /// problems). See tutorial for
 /// interpretation of the optional argument which specifies the
 /// refinement tolerance. It defaults to 0.08 and the smaller the
 /// number the finer the surface representation.
 void enable_refinement_tolerance(const double& tolerance=0.08)
  {
   Refinement_tolerance=tolerance;
  }

 /// \short Set tolerance for refinement of curve sections to create a better
 /// representation of curvilinear boundaries (e.g. in free-surface
 /// problems). See tutorial for
 /// interpretation of the refinement tolerance. (The smaller the
 /// number the finer the surface representation). If set to
 /// a negative value, we're switching off refinement --
 /// equivalent to calling disable_polyline_refinement()
 void set_refinement_tolerance(const double& tolerance)
  {
   Refinement_tolerance=tolerance;
  }

 /// \short Get tolerance for refinement of curve sections to create a better
 /// representation of curvilinear boundaries (e.g. in free-surface
 /// problems). See tutorial for
 /// interpretation. If it's negative refinement is disabled.
 double refinement_tolerance()
  {
   return Refinement_tolerance;
  }

 /// \short Disable refinement of curve section
 void disable_refinement_tolerance()
  {
   Refinement_tolerance=-1.0;
  }

 /// \short Enable unrefinement of curve sections to avoid unnecessarily large
 /// numbers of elements on of curvilinear boundaries (e.g. in free-surface
 /// problems). See tutorial for
 /// interpretation of the optional argument which specifies the
 /// unrefinement tolerance. It defaults to 0.04 and the larger the number
 /// the more agressive we are when removing unnecessary vertices on
 /// gently curved polylines.
 void enable_unrefinement_tolerance(const double& tolerance=0.04)
  {
   Unrefinement_tolerance=tolerance;
  }

 /// \short Set tolerance for unrefinement of curve sections
 /// to avoid unnecessarily large
 /// numbers of elements on of curvilinear boundaries (e.g. in free-surface
 /// problems). See tutorial for
 /// interpretation of the optional argument which specifies the
 /// unrefinement tolerance. It defaults to 0.04 and the larger the number
 /// the more agressive we are when removing unnecessary vertices on
 /// gently curved polylines. If set to
 /// a negative value, we're switching off unrefinement --
 /// equivalent to calling disable_curve_section_unrefinement()
 void set_unrefinement_tolerance(const double& tolerance)
  {
   Unrefinement_tolerance=tolerance;
  }

 /// \short Get tolerance for unrefinement of curve section to create a better
 /// representation of curvilinear boundaries (e.g. in free-surface
 /// problems). See tutorial for
 /// interpretation. If it's negative unrefinement is disabled.
 double unrefinement_tolerance()
  {
   return Unrefinement_tolerance;
  }

 /// \short Disable unrefinement of curve sections
 void disable_unrefinement_tolerance()
  {
   Unrefinement_tolerance=-1.0;
  }

 // \short Allows to specify the maximum distance between two vertices
 // that define the associated polyline of the curve section, it only
 // takes effect on the unrefinement and refinement steps
 void set_maximum_length(const double &maximum_length)
  {Maximum_length = maximum_length;}

 // \short Disables the use of the maximum length criteria on the unrefinement
 // or refinement steps
 void disable_use_maximum_length()
  {Maximum_length=-1.0;}

 // \short Gets access to the maximum length variable
 double maximum_length()
  {return Maximum_length;}
 
 /// Get first vertex coordinates
 virtual void initial_vertex_coordinate(Vector<double> &vertex) = 0;

 /// Get last vertex coordinates
 virtual void final_vertex_coordinate(Vector<double> &vertex) = 0;

 // \short Connects the initial vertex of the curve section to a desired
 /// target polyline by specifying the vertex number. There is a checking
 /// which verifies that the initial vertex is close enough to the
 /// destination vertex on the target polyline by no more than the specified
 /// tolerance
 void connect_initial_vertex_to_polyline(
   TriangleMeshPolyLine *polyline_pt,
   const unsigned &vertex_number,
   const double &tolerance_for_connection = 1.0e-14);

 // \short Connects the final vertex of the curve section to a desired
 /// target polyline by specifying the vertex number. There is a checking
 /// which verifies that the final vertex is close enough to the
 /// destination vertex on the target polyline by no more than the specified
 /// tolerance
 void connect_final_vertex_to_polyline(
   TriangleMeshPolyLine *polyline_pt,
   const unsigned &vertex_number,
   const double &tolerance_for_connection = 1.0e-14);

 // \short Connects the initial vertex of the curve section to a desired
 /// target curviline by specifying the s value (intrinsic value on the
 /// geometric object of the curviline) where to connect on the target
 /// curviline. There is a checking which verifies that the initial vertex
 /// and the coordinates on the given s value are close enough by no more
 /// than the given tolerance
 void connect_initial_vertex_to_curviline(
   TriangleMeshCurviLine *curviline_pt,
   const double &s_value,
   const double &tolerance_for_connection = 1.0e-14);

 // \short Connects the final vertex of the curve section to a desired
 /// target curviline by specifying the s value (intrinsic value on the
 /// geometric object of the curviline) where to connect on the target
 /// curviline. There is a checking which verifies that the final vertex
 /// and the coordinates on the given s value are close enough by no more
 /// than the given tolerance
 void connect_final_vertex_to_curviline(
   TriangleMeshCurviLine *curviline_pt,
   const double &s_value,
   const double &tolerance_for_connection = 1.0e-14);

 /// Test whether initial vertex is connected or not
 bool is_initial_vertex_connected() const
 {return Initial_vertex_connected;}

 /// Sets the initial vertex as connected
 void set_initial_vertex_connected()
 {Initial_vertex_connected = true;}

 /// Sets the initial vertex as non connected
 void unset_initial_vertex_connected()
  {Initial_vertex_connected = false;}
 
 /// Set the initial vertex connection as suspended, it will be
 /// resumed when the method to resume the connections is called
 /// This method is only used in a distributed context, when the
 /// boundary to connect is no longer part of the domain in the
 /// processor
 void suspend_initial_vertex_connected()
 {
  if (Initial_vertex_connected)
   {
    Initial_vertex_connected = false;
    Initial_vertex_connected_suspended = true;
   }
 }
 
 /// Resumes the initial vertex connection, it may be that after load
 /// balancing the boundary to which the connection was suspended be part
 /// of the domain
 void resume_initial_vertex_connected()
 {
  if (Initial_vertex_connected_suspended)
   {
    Initial_vertex_connected = true;
    Initial_vertex_connected_suspended = false;
   }
 }
 
 /// Test whether final vertex is connected or not
 bool is_final_vertex_connected() const
 {return Final_vertex_connected;}

 /// Sets the final vertex as connected
 void set_final_vertex_connected()
 {Final_vertex_connected = true;}

 /// Sets the final vertex as non connected
 void unset_final_vertex_connected()
  {Final_vertex_connected = false;}
 
 /// Set the final vertex connection as suspended, it will be
 /// resumed when the method to resume the connections is called
 /// This method is only used in a distributed context, when the
 /// boundary to connect is no longer part of the domain in the
 /// processor
 void suspend_final_vertex_connected()
 {
  if (Final_vertex_connected)
   {
    Final_vertex_connected = false;
    Final_vertex_connected_suspended = true;
   }
 }
 
 /// Resumes the final vertex connection, it may be that after load
 /// balancing the boundary to which the connection was suspended be part
 /// of the domain
 void resume_final_vertex_connected()
 {
  if (Final_vertex_connected_suspended)
   {
    Final_vertex_connected = true;
    Final_vertex_connected_suspended = false;
   }
 }
 
 /// Gets the id to which the initial end is connected
 unsigned initial_vertex_connected_bnd_id() const
 {return Initial_vertex_connected_bnd_id;}

 /// Sets the id to which the initial end is connected
 unsigned &initial_vertex_connected_bnd_id()
 {return Initial_vertex_connected_bnd_id;}

 /// Gets the vertex number to which the initial end is connected
 unsigned initial_vertex_connected_n_vertex() const
 {return Initial_vertex_connected_n_vertex;}

 /// Sets the vertex number to which the initial end is connected
 unsigned &initial_vertex_connected_n_vertex()
 {return Initial_vertex_connected_n_vertex;}
 
 /// Gets the boundary chunk to which the initial end is connected
 unsigned initial_vertex_connected_n_chunk() const
 {return Initial_vertex_connected_n_chunk;}
 
 /// Sets the boundary chunk to which the initial end is connected
 unsigned &initial_vertex_connected_n_chunk()
 {return Initial_vertex_connected_n_chunk;}
 
 /// Gets the id to which the final end is connected
 unsigned final_vertex_connected_bnd_id() const
 {return Final_vertex_connected_bnd_id;}

 /// Sets the id to which the final end is connected
 unsigned &final_vertex_connected_bnd_id()
 {return Final_vertex_connected_bnd_id;}

 /// Sets the vertex number to which the final end is connected
 unsigned final_vertex_connected_n_vertex() const
 {return Final_vertex_connected_n_vertex;}

 /// Gets the vertex number to which the final end is connected
 unsigned &final_vertex_connected_n_vertex()
 {return Final_vertex_connected_n_vertex;}

 /// Gets the boundary chunk to which the final end is connected
 unsigned final_vertex_connected_n_chunk() const
 {return Final_vertex_connected_n_chunk;}
 
 /// Sets the boundary chunk to which the final end is connected
 unsigned &final_vertex_connected_n_chunk()
 {return Final_vertex_connected_n_chunk;}
 
 /// Test whether the initial vertex is connected to a curviline
 bool is_initial_vertex_connected_to_curviline() const
 {return Initial_vertex_connected_to_curviline;}

 /// Sets the initial vertex as connected to a curviline
 void set_initial_vertex_connected_to_curviline()
 {Initial_vertex_connected_to_curviline = true;}

 /// Sets the initial vertex as non connected to a curviline
 void unset_initial_vertex_connected_to_curviline()
 {Initial_vertex_connected_to_curviline = false;}

 /// Test whether the final vertex is connected to a curviline
 bool is_final_vertex_connected_to_curviline() const
 {return Final_vertex_connected_to_curviline;}

 /// Sets the final vertex as connected to a curviline
 void set_final_vertex_connected_to_curviline()
 {Final_vertex_connected_to_curviline = true;}

 /// Sets the final vertex as non connected to a curviline
 void unset_final_vertex_connected_to_curviline()
 {Final_vertex_connected_to_curviline = false;}

 /// \short Gets the s value to which the initial end is connected
 double initial_s_connection_value() const
 {return Initial_s_connection_value;}

 /// \short Sets the s value to which the initial end is connected
 double &initial_s_connection_value()
 {return Initial_s_connection_value;}

 /// \short Gets the s value to which the final end is connected
 double final_s_connection_value() const
 {return Final_s_connection_value;}
 
 /// \short Sets the s value to which the final end is connected
 double &final_s_connection_value()
 {return Final_s_connection_value;}
 
 /// \short Gets the tolerance value for connections among
 /// curvilines
 double tolerance_for_s_connection() const
 {return Tolerance_for_s_connection;}
 
 /// \short Sets the tolerance value for connections among
 /// curvilines
 double &tolerance_for_s_connection()
 {return Tolerance_for_s_connection;}
 
protected:

 /// \short Used for stating if the initial end is connected
 /// to another boundary
 bool Initial_vertex_connected;

 /// \short Used for stating if the final end is connected
 /// to another boundary
 bool Final_vertex_connected;
 
 /// \short Indicates if the connection is suspended because the
 /// boundary to connect is no longer part of the domain (only used in
 /// a distributed context)
 bool Initial_vertex_connected_suspended;
 
 /// \short Indicates if the connection is suspended because the
 /// boundary to connect is no longer part of the domain (only used in
 /// a distributed context)
 bool Final_vertex_connected_suspended;
 
 /// Stores the id to which the initial end is connected
 unsigned Initial_vertex_connected_bnd_id;

 /// \short Stores the vertex number used for connection with
 /// the initial end
 unsigned Initial_vertex_connected_n_vertex;
 
 /// \short Stores the chunk number of the boundary to which is
 /// connected th initial end
 unsigned Initial_vertex_connected_n_chunk;
 
 /// Stores the id to which the initial end is connected
 unsigned Final_vertex_connected_bnd_id;

 /// \short Stores the vertex number used for connection with
 /// the final end
 unsigned Final_vertex_connected_n_vertex;
 
 /// \short Stores the chunk number of the boundary to which is
 /// connected th initial end
 unsigned Final_vertex_connected_n_chunk;
 
 /// States if the initial vertex is connected to a curviline
 bool Initial_vertex_connected_to_curviline;

 /// States if the final vertex is connected to a curviline
 bool Final_vertex_connected_to_curviline;

 /// \short Stores the s value used for connecting the
 /// initial end with a curviline
 double Initial_s_connection_value;

 /// \short Stores the s value used for connecting the
 /// final end with a curviline
 double Final_s_connection_value;

 /// Tolerance used for connecting the ends to a curviline
 double Tolerance_for_s_connection;

  private:
 
 /// Tolerance for refinement of curve sections (neg if refinement is
 /// disabled)
 double Refinement_tolerance;
 
 /// Tolerance for unrefinement of curve sections (neg if refinement
 /// is disabled)
 double Unrefinement_tolerance;

 /// Maximum allowed distance between two vertices on the polyline
 /// representation of the curve section
 double Maximum_length;

};

 
//=====================================================================
/// Class definining a curvilinear triangle mesh boundary in terms 
/// of a GeomObject. Curvlinear equivalent of PolyLine.
//=====================================================================
class TriangleMeshCurviLine : public virtual TriangleMeshCurveSection
{
 
public:
 
 /// \short Constructor: Specify GeomObject, the start and end coordinates
 /// of the relevant boundary in terms of the GeomObject's intrinsic
 /// coordinate, the number of (initially straight-line) segments that 
 /// this GeomObject is to be split up into, and the boundary ID.
 /// The final optional boolean argument specifies if vertices in 
 /// polygonhal represenation are spaced 
 /// (approximately) evenly in arclength along the GeomObject [true,
 /// default] or in equal increments in zeta.
 /// This is the curvlinear equivalent of PolyLine.
 TriangleMeshCurviLine(GeomObject* geom_object_pt,
                       const double& zeta_start,
                       const double& zeta_end,
                       const unsigned& nsegment,
                       const unsigned& boundary_id,
                       const bool&
                       space_vertices_evenly_in_arclength=true,
                       const unsigned &boundary_chunk = 0)
                     :  TriangleMeshCurveSection(),
                        Geom_object_pt(geom_object_pt),
                        Zeta_start(zeta_start),
                        Zeta_end(zeta_end),
                        Nsegment(nsegment),
                        Boundary_id(boundary_id),
                        Space_vertices_evenly_in_arclength(
                         space_vertices_evenly_in_arclength),
                        Boundary_chunk(boundary_chunk)
  { }


 /// \short Empty Destuctor
 virtual ~TriangleMeshCurviLine() { }
 
 /// Pointer to GeomObject that represents this part of the boundary
 GeomObject* geom_object_pt(){return Geom_object_pt;}
 
 /// Start coordinate in terms of the GeomObject's intrinsic coordinate
 double zeta_start(){return Zeta_start;}

 /// End coordinate in terms of the GeomObject's intrinsic coordinate
 double zeta_end(){return Zeta_end;}

 /// \short Number of (initially straight-line) segments that this part of the
 /// boundary is to be represented by
 unsigned nsegment() const {return Nsegment;}

 /// \short Number of (initially straight-line) segments that this part of the
 /// boundary is to be represented by. This version allows the change of the
 /// number of segments
 unsigned &nsegment() {return Nsegment;}

 /// Boundary ID
 unsigned boundary_id() const {return Boundary_id;}
 
 /// Boundary chunk (Used when a boundary is represented by more
 /// than one polyline
 unsigned boundary_chunk() const {return Boundary_chunk;}
 
 /// Output curvilinear boundary at n_sample (default: 50) points
 void output(std::ostream &outfile, const unsigned& n_sample=50)
  {
   outfile << "ZONE T=\"Boundary " << Boundary_id << "\"\n";
   Vector<double> zeta(1);
   Vector<double> r(2);
   for (unsigned i=0;i<n_sample;i++)
    {
     zeta[0]=Zeta_start+(Zeta_end-Zeta_start)*double(i)/double(n_sample-1);
     Geom_object_pt->position(zeta,r);
     outfile << r[0] << " " << r[1] << std::endl;
    }
  }

 /// \short Boolean to indicate if vertices in polygonal representation
 /// of the Curvline are spaced (approximately) evenly in arclength 
 /// along the GeomObject [true] or in equal increments in zeta [false]
 bool space_vertices_evenly_in_arclength() const
  {
	 return Space_vertices_evenly_in_arclength;
  }

 /// Number of vertices
 unsigned nvertex() const {return 2;}

 /// Get first vertex coordinates
 void initial_vertex_coordinate(Vector<double> &vertex)
  {
   Vector<double> z(1);
   z[0] = Zeta_start;
   Geom_object_pt->position(z, vertex);
  }

 /// Get last vertex coordinates
 void final_vertex_coordinate(Vector<double> &vertex)
  {
   Vector<double> z(1);
   z[0] = Zeta_end;
   Geom_object_pt->position(z, vertex);
  }

 /// \short Does the vector for storing connections has elements?
 bool are_there_connection_points()
 {return !Connection_points_pt.empty();}

 /// \short Returns the connection points vector
 Vector<double> *connection_points_pt()
 {return &Connection_points_pt;}

 /// Add the connection point (z_value) to the connection
 /// points that receive the curviline
 void add_connection_point(
   const double &z_value,
   const double &tol = 1.0e-12)
 {

  // If we are trying to connect to the initial or final
  // point then it is not necessary to add this point
  // to the list since it will explicitly be created when
  // transforming the curviline to polyline
  if (std::fabs(z_value - Zeta_start) < tol ||
    std::fabs(z_value - Zeta_end) < tol)
   {return;}

  // We need to deal with repeated connection points,
  // if the connection point is already in the list then
  // we will not add it!!!
  // Search for repeated elements
  unsigned n_size = Connection_points_pt.size();
  for (unsigned i = 0; i < n_size; i++)
   {
    if (fabs(z_value - Connection_points_pt[i]) < tol)
     {return;}
   }

  // Only add the connection point if it is not the
  // initial or final zeta value and it is not already on the
  // list
  Connection_points_pt.push_back(z_value);

 }

private:

 /// Pointer to GeomObject that represents this part of the boundary
 GeomObject* Geom_object_pt;
 
 /// Start coordinate in terms of the GeomObject's intrinsic coordinate
 double Zeta_start;
 
 /// End coordinate in terms of the GeomObject's intrinsic coordinate
 double Zeta_end;

 /// Number of (initially straight-line) segments that this part of the
 /// boundary is to be represented by
 unsigned Nsegment;

 /// Boundary ID
 unsigned Boundary_id;
 
 /// \short Boolean to indicate if vertices in polygonal representation
 /// of the Curviline are spaced (approximately) evenly in arclength
 /// along the GeomObject [true] or in equal increments in zeta [false]
 bool Space_vertices_evenly_in_arclength;
 
 /// Boundary chunk (Used when a boundary is represented by more
 /// than one polyline
 unsigned Boundary_chunk;
 
 // \short Stores the information for connections received on the
 /// curviline. Used when converting to polyline
 Vector<double> Connection_points_pt;

};



//=====================================================================
/// Class defining a polyline for use in Triangle Mesh generation
//=====================================================================
class TriangleMeshPolyLine : public virtual TriangleMeshCurveSection
{
 
public:
 
 /// \short Constructor: Takes vectors of vertex coordinates in order
 /// Also allows the optional specification of a boundary ID -- useful
 /// in a mesh generation context. If not specified it defaults to zero.
 TriangleMeshPolyLine(const Vector<Vector<double> >& vertex_coordinate,
                      const unsigned &boundary_id,
                      const unsigned &boundary_chunk = 0) :
                       TriangleMeshCurveSection(),
                       Vertex_coordinate(vertex_coordinate),
                        Boundary_id(boundary_id),
                        Boundary_chunk(boundary_chunk)
 {
#ifdef PARANOID
  unsigned nvert=Vertex_coordinate.size();
  for (unsigned i=0;i<nvert;i++)
   {
    if (Vertex_coordinate[i].size()!=2)
     {
      std::ostringstream error_stream;
      error_stream
      << "TriangleMeshPolyLine should only be used in 2D!\n"
      << "Your Vector of coordinates, contains data for "
      << Vertex_coordinate[i].size()
      << "-dimensional coordinates." << std::endl;
      throw OomphLibError(error_stream.str(),
                          OOMPH_CURRENT_FUNCTION,
        OOMPH_EXCEPTION_LOCATION);
     }
   }
#endif
 }
 
 /// Empty destructor
 virtual ~TriangleMeshPolyLine() { }

 /// Number of vertices
 unsigned nvertex() const {return Vertex_coordinate.size();}
   
 /// Number of segments
 unsigned nsegment() const {return Vertex_coordinate.size()-1;}
  
 /// Boundary id
 unsigned boundary_id() const {return Boundary_id;}
 
 /// Boundary chunk (Used when a boundary is represented by more
 /// than one polyline
 unsigned boundary_chunk() const{return Boundary_chunk;}
 
 /// Coordinate vector of i-th vertex (const version)
 Vector<double> vertex_coordinate(const unsigned& i) const
 {return Vertex_coordinate[i];}

 /// Coordinate vector of i-th vertex
 Vector<double>& vertex_coordinate(const unsigned& i)
 {return Vertex_coordinate[i];}

 /// Get first vertex coordinates
 void initial_vertex_coordinate(Vector<double> &vertex)
 {vertex = Vertex_coordinate[0];}

 /// Get last vertex coordinates
 void final_vertex_coordinate(Vector<double> &vertex)
 {vertex = Vertex_coordinate[nvertex()-1];}

 /// Output the polyline -- n_sample is ignored
 void output(std::ostream &outfile, const unsigned& n_sample=50)
  {
   outfile <<"ZONE T=\"TriangleMeshPolyLine with boundary ID" 
           << Boundary_id<<"\""<<std::endl;
   unsigned nvert=Vertex_coordinate.size();
   for(unsigned i=0;i<nvert;i++)
    {
     outfile << Vertex_coordinate[i][0] << " " 
             << Vertex_coordinate[i][1] << std::endl;
    }
  }

 /// Reverse the polyline, this includes the connection information
 /// and the vertices order
 void reverse()
 {
  // Do the reversing of the connection information
  
  // Is there a connection to the initial vertex
  const bool initial_connection = is_initial_vertex_connected();
  
  // Is there a connection to the initial vertex
  const bool final_connection = is_final_vertex_connected();
  
  // If there are any connection at the ends that info. needs to be
  // reversed
  if (initial_connection || final_connection)
   {
    // Backup the connection information
    
    // -------------------------------------------------------------------
    // Backup the initial vertex connection information
    // The boundary id
    const unsigned backup_initial_vertex_connected_bnd_id = 
     initial_vertex_connected_bnd_id();
    // The chunk number
    const unsigned backup_initial_vertex_connected_chunk = 
     initial_vertex_connected_n_chunk();
    // The vertex number
    const unsigned backup_initial_vertex_connected_n_vertex = 
     initial_vertex_connected_n_vertex();
    // Is it connected to a curviline
    const bool backup_initial_vertex_connected_to_curviline =
     is_initial_vertex_connected_to_curviline();
    // The s value for the curviline connection
    const double backup_initial_s_connection = initial_s_connection_value();
    // The tolerance
    const double backup_initial_s_tolerance = tolerance_for_s_connection();
    
    // -------------------------------------------------------------------
    // Backup the final vertex connection information
    // The boundary id
    const unsigned backup_final_vertex_connected_bnd_id = 
     final_vertex_connected_bnd_id();
    // The chunk number
    const unsigned backup_final_vertex_connected_chunk = 
     final_vertex_connected_n_chunk();
    // The vertex number
    const unsigned backup_final_vertex_connected_n_vertex = 
     final_vertex_connected_n_vertex();
    // Is it connected to a curviline
    const bool backup_final_vertex_connected_to_curviline =
     is_final_vertex_connected_to_curviline();
    // The s value for the curviline connection
    const double backup_final_s_connection = final_s_connection_value();
    // The tolerance
    const double backup_final_s_tolerance = tolerance_for_s_connection();
    // -------------------------------------------------------------------
    
    // Disconnect the polyline
    
    // Disconnect the initial vertex
    unset_initial_vertex_connected();
    unset_initial_vertex_connected_to_curviline();
    
    // Disconnect the final vertex
    unset_final_vertex_connected();
    unset_final_vertex_connected_to_curviline();
    
    // Now reconnected but in inverted order
    if (initial_connection)
     {
      // Set the final vertex as connected
      set_final_vertex_connected();
      // Copy the boundary id
      final_vertex_connected_bnd_id() = 
       backup_initial_vertex_connected_bnd_id;
      // Copy the chunk number
      final_vertex_connected_n_chunk() = 
       backup_initial_vertex_connected_chunk;
      // Copy the vertex number
      final_vertex_connected_n_vertex() =
       backup_initial_vertex_connected_n_vertex;
      // Is it connected to a curviline
      if (backup_initial_vertex_connected_to_curviline)
       {
        // Set the final vertex as connected to curviline
        set_final_vertex_connected_to_curviline();
        // Copy the s value to connected
        final_s_connection_value() = backup_initial_s_connection;
        // Copy the tolerance
        tolerance_for_s_connection() = backup_initial_s_tolerance;
       } // if (backup_initial_vertex_connected_to_curviline)
      
     } // if (initial_connection)
    
    if (final_connection)
     {
      // Set the initial vertex as connected
      set_initial_vertex_connected();
      // Copy the boundary id
      initial_vertex_connected_bnd_id() = 
       backup_final_vertex_connected_bnd_id;
      // Copy the chunk number
      initial_vertex_connected_n_chunk() = 
       backup_final_vertex_connected_chunk;
      // Copy the vertex number
      initial_vertex_connected_n_vertex() =
       backup_final_vertex_connected_n_vertex;
      // Is it connected to a curviline
      if (backup_final_vertex_connected_to_curviline)
       {
        // Set the initial vertex as connected to curviline
        set_initial_vertex_connected_to_curviline();
        // Copy the s value to connected
        initial_s_connection_value() = backup_final_s_connection;
        // Copy the tolerance
        tolerance_for_s_connection() = backup_final_s_tolerance;
       } // if (backup_final_vertex_connected_to_curviline)
      
     } // if (final_connection)
    
   } // if (initial_connection || final_connection)
  
  // Do the reversing of the vertices
  std::reverse(Vertex_coordinate.begin(), Vertex_coordinate.end());
  
 }

private:

 /// Vector of Vector of vertex coordinates
 Vector<Vector<double> > Vertex_coordinate;

 /// Boundary ID
 unsigned Boundary_id;
 
 /// Boundary chunk (Used when a boundary is represented by more
 /// than one polyline
 unsigned Boundary_chunk;
 
};



///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////


//===================================================================
/// \short Namespace that allows the specification of a tolerance 
/// between vertices at the ends of polylines that are supposed
/// to be at the same position.
//===================================================================
namespace ToleranceForVertexMismatchInPolygons
{
 
 /// \short Acceptable discrepancy for mismatch in vertex coordinates.
 /// In paranoid mode, the code will die if the beginning/end of
 /// two adjacent polylines differ by more than that. If the
 /// discrepancy is smaller (but nonzero) one of the vertex coordinates
 /// get adjusted to match perfectly; without paranoia the vertex
 /// coordinates are taken as they come...
 extern double Tolerable_error;
}

///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////

//=====================================================================
// \short Class defining triangle mesh curves. Abstract class for
/// closed curves and open curves. All TriangleMeshCurves are composed
/// of a Vector of TriangleMeshCurveSections
//=====================================================================
class TriangleMeshCurve
{

public:

  /// Empty constructor
  TriangleMeshCurve(const Vector<TriangleMeshCurveSection*> &curve_section_pt)
   : Curve_section_pt(curve_section_pt),
     Polyline_refinement_tolerance(0.08),
     Polyline_unrefinement_tolerance(0.04)
  {
   
  }

  /// Empty destructor
  virtual ~TriangleMeshCurve() { }

  /// Number of vertices
  virtual unsigned nvertices() const = 0;

  /// Total number of segments
  virtual unsigned nsegments() const = 0;

  /// Return max boundary id of associated curves
  unsigned max_boundary_id()
  {
   unsigned max=0;
   unsigned n_curve_section = ncurve_section();
   for(unsigned i=0; i<n_curve_section; i++)
    {
     unsigned boundary_id=Curve_section_pt[i]->boundary_id();
     if (boundary_id>max) {max=boundary_id;}
    }
   return max;
  }

  /// Number of constituent curves
  virtual unsigned ncurve_section() const
   {return Curve_section_pt.size();}

  /// \short Enable refinement of polylines to create a better
  /// representation of curvilinear boundaries (e.g. in free-surface
  /// problems). See tutorial for
  /// interpretation of the optional argument which specifies the
  /// refinement tolerance. It defaults to 0.08 and the smaller the
  /// number the finer the surface representation.
  void enable_polyline_refinement(const double& tolerance=0.08)
  {
   Polyline_refinement_tolerance=tolerance;
   // Establish the refinement tolerance for all the
   // curve sections on the TriangleMeshCurve
   unsigned n_curve_sections = Curve_section_pt.size();
   for (unsigned i = 0; i < n_curve_sections; i++)
    {
     Curve_section_pt[i]->set_refinement_tolerance(
      Polyline_refinement_tolerance);
    }
  }

  /// \short Set tolerance for refinement of polylines to create a better
  /// representation of curvilinear boundaries (e.g. in free-surface
  /// problems). See tutorial for
  /// interpretation of the refinement tolerance. (The smaller the
  /// number the finer the surface representation). If set to
  /// a negative value, we're switching off refinement --
  /// equivalent to calling disable_polyline_refinement()
  void set_polyline_refinement_tolerance(const double& tolerance)
  {
   Polyline_refinement_tolerance=tolerance;
   // Establish the refinement tolerance for all the
   // curve sections on the TriangleMeshCurve
   unsigned n_curve_sections = Curve_section_pt.size();
   for (unsigned i = 0; i < n_curve_sections; i++)
    {
     Curve_section_pt[i]->set_refinement_tolerance(
      Polyline_refinement_tolerance);
    }
  }

  /// \short Get tolerance for refinement of polylines to create a better
  /// representation of curvilinear boundaries (e.g. in free-surface
  /// problems). See tutorial for
  /// interpretation. If it's negative refinement is disabled.
  double polyline_refinement_tolerance()
  {
   return Polyline_refinement_tolerance;
  }

  /// \short Disable refinement of polylines
  void disable_polyline_refinement()
  {
   Polyline_refinement_tolerance=-1.0;
   // Disable the refinement tolerance for all the
   // curve sections on the TriangleMeshCurve
   unsigned n_curve_sections = Curve_section_pt.size();
   for (unsigned i = 0; i < n_curve_sections; i++)
    {Curve_section_pt[i]->disable_refinement_tolerance();}
  }

  /// \short Enable unrefinement of polylines to avoid unnecessarily large
  /// numbers of elements on of curvilinear boundaries (e.g. in free-surface
  /// problems). See tutorial for
  /// interpretation of the optional argument which specifies the
  /// unrefinement tolerance. It defaults to 0.04 and the larger the number
  /// the more agressive we are when removing unnecessary vertices on
  /// gently curved polylines.
  void enable_polyline_unrefinement(const double& tolerance=0.04)
  {
   Polyline_unrefinement_tolerance=tolerance;
   // Establish the unrefinement tolerance for all the
   // curve sections on the TriangleMeshCurve
   unsigned n_curve_sections = Curve_section_pt.size();
   for (unsigned i = 0; i < n_curve_sections; i++)
    {
     Curve_section_pt[i]->set_unrefinement_tolerance(
      Polyline_unrefinement_tolerance);
    }
  }

  /// \short Set tolerance for unrefinement of polylines
  /// to avoid unnecessarily large
  /// numbers of elements on of curvilinear boundaries (e.g. in free-surface
  /// problems). See tutorial for
  /// interpretation of the optional argument which specifies the
  /// unrefinement tolerance. It defaults to 0.04 and the larger the number
  /// the more agressive we are when removing unnecessary vertices on
  /// gently curved polylines. If set to
  /// a negative value, we're switching off unrefinement --
  /// equivalent to calling disable_polyline_unrefinement()
  void set_polyline_unrefinement_tolerance(const double& tolerance)
  {
   Polyline_unrefinement_tolerance=tolerance;
   // Establish the unrefinement tolerance for all the
   // curve sections on the TriangleMeshCurve
   unsigned n_curve_sections = Curve_section_pt.size();
   for (unsigned i = 0; i < n_curve_sections; i++)
    {
     Curve_section_pt[i]->set_unrefinement_tolerance(
      Polyline_unrefinement_tolerance);
    }
  }

  /// \short Get tolerance for unrefinement of polylines to create a better
  /// representation of curvilinear boundaries (e.g. in free-surface
  /// problems). See tutorial for
  /// interpretation. If it's negative unrefinement is disabled.
  double polyline_unrefinement_tolerance()
  {
   return Polyline_unrefinement_tolerance;
  }

  /// \short Disable unrefinement of polylines
  void disable_polyline_unrefinement()
  {
   Polyline_unrefinement_tolerance=-1.0;
   // Disable the unrefinement tolerance for all the
   // curve sections on the TriangleMeshCurve
   unsigned n_curve_sections = Curve_section_pt.size();
   for (unsigned i = 0; i < n_curve_sections; i++)
    {Curve_section_pt[i]->disable_unrefinement_tolerance();}
  }

  /// Output each sub-boundary at n_sample (default: 50) points
  virtual void output(std::ostream &outfile, const unsigned& n_sample=50) = 0;

  /// Pointer to i-th constituent curve section
  virtual TriangleMeshCurveSection* curve_section_pt(const unsigned& i) const
  {return Curve_section_pt[i];}

  /// Pointer to i-th constituent curve section
  virtual TriangleMeshCurveSection* &curve_section_pt(const unsigned& i)
  {return Curve_section_pt[i];}

protected:

  /// Vector of curve sections
  Vector<TriangleMeshCurveSection*> Curve_section_pt;

private:

  /// Tolerance for refinement of polylines (neg if refinement is disabled)
  double Polyline_refinement_tolerance;

  /// Tolerance for unrefinement of polylines (neg if refinement is disabled)
  double Polyline_unrefinement_tolerance;

};

///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////

//=====================================================================
/// Base class defining a closed curve for the Triangle mesh generation
//=====================================================================
class TriangleMeshClosedCurve : public virtual TriangleMeshCurve
{

public:

 /// Empty constructor
 TriangleMeshClosedCurve(
   const Vector<TriangleMeshCurveSection*> &curve_section_pt,
   const Vector<double>& internal_point_pt = Vector<double>(0));

 /// Empty destructor
 virtual ~TriangleMeshClosedCurve() { }

 /// Number of vertices
 unsigned nvertices() const
 {
  unsigned n_curve_section=ncurve_section();
  unsigned n_vertices=0;
  for(unsigned j=0;j<n_curve_section;j++)
   {
    // Storing the number of the vertices
    n_vertices+=Curve_section_pt[j]->nvertex()-1;
   }
  // If there's just one boundary. All the vertices should be counted
  if(n_curve_section==1) {n_vertices+=1;}
  return n_vertices;
 }

 /// Total number of segments
 unsigned nsegments() const
 {
  unsigned n_curve_section=ncurve_section();
  unsigned nseg=0;
  for(unsigned j=0;j<n_curve_section;j++)
   {nseg+=Curve_section_pt[j]->nsegment();}
  // If there's just one boundary poly line we have another segment
  // connecting the last vertex to the first one
  if(n_curve_section==1) {nseg+=1;}
  return nseg;
 }

 /// Output each sub-boundary at n_sample (default: 50) points
 void output(std::ostream &outfile, const unsigned& n_sample=50)
 {
  unsigned nb=Curve_section_pt.size();
  for (unsigned i=0;i<nb;i++)
   {
    Curve_section_pt[i]->output(outfile,n_sample);
   }

  if (!Internal_point_pt.empty())
   {
    outfile << "ZONE T=\"Internal point\"\n";
    outfile << Internal_point_pt[0] << " "
            << Internal_point_pt[1] << "\n";
   }

 }

 /// Coordinates of the internal point
 Vector<double> internal_point() const {return Internal_point_pt;}

 /// Coordinates of the internal point
 Vector<double> &internal_point() {return Internal_point_pt;}

protected:

 /// Vector of vertex coordinates
 Vector<double> Internal_point_pt;

};

///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////


//=====================================================================
/// Class defining a closed polygon for the Triangle mesh generation
//=====================================================================
class TriangleMeshPolygon : public virtual TriangleMeshClosedCurve
{
  
public:
  
 /// \short Constructor: Specify vector of pointers to TriangleMeshCurveSection
 /// that define the boundary of the segments of the polygon.
 /// Each TriangleMeshCurveSection has its own boundary ID and can contain
 /// multiple (straight-line) segments. For consistency across the
 /// various uses of this class, we insist that the closed boundary
 /// is represented by at least two separate TriangleMeshCurveSection
 /// whose joint vertices must be specified in both.
 /// (This is to allow the setup of unique boundary coordinate(s)
 /// around the polygon.) This may seem slightly annoying
 /// in cases where a polygon really only represents a single
 /// boundary, but...
 /// Note: The specified vector of pointers must consist of only
 /// TriangleMeshPolyLine elements. There is a checking on the PARANOID
 /// mode for this constraint
 TriangleMeshPolygon(const Vector<TriangleMeshCurveSection*>&
   boundary_polyline_pt, const Vector<double>& internal_point_pt =
     Vector<double>(0));

 /// Empty virtual destructor
 virtual ~TriangleMeshPolygon() { }
 
 /// Number of constituent curves
 unsigned ncurve_section() const
  {return npolyline();}

 /// Number of constituent polylines
 unsigned npolyline() const {return Curve_section_pt.size();}

 /// Pointer to i-th constituent polyline
 TriangleMeshPolyLine* polyline_pt(const unsigned& i) const
 {
  TriangleMeshPolyLine *tmp_polyline =
    dynamic_cast<TriangleMeshPolyLine*>(Curve_section_pt[i]);
#ifdef PARANOID
  if (tmp_polyline == NULL)
   {
    std::ostringstream error_stream;
    error_stream
    << "The (" << i << ") TriangleMeshCurveSection is not a "
    << "TriangleMeshPolyLine\nThe TriangleMeshPolygon object"
    << "is constituent of only TriangleMeshPolyLine objects.\n"
    << "The problem could be generated when changing the constituent "
    << "objects of the TriangleMeshPolygon.\nCheck where you got "
    << "access to this objects and review that you are not introducing "
    << "any other objects than TriangleMeshPolyLines" << std::endl;
    throw OomphLibError(error_stream.str(),
                        OOMPH_CURRENT_FUNCTION,
      OOMPH_EXCEPTION_LOCATION);
   }
#endif
  return tmp_polyline;
 }

 /// Pointer to i-th constituent polyline
 TriangleMeshPolyLine* polyline_pt(const unsigned& i)
 {
  TriangleMeshPolyLine *tmp_polyline =
    dynamic_cast<TriangleMeshPolyLine*>(Curve_section_pt[i]);
#ifdef PARANOID
  if (tmp_polyline == NULL)
   {
    std::ostringstream error_stream;
    error_stream
    << "The (" << i << ") TriangleMeshCurveSection is not a "
    << "TriangleMeshPolyLine\nThe TriangleMeshPolygon object"
    << "is constituent of only TriangleMeshPolyLine objects.\n"
    << "The problem could be generated when changing the constituent "
    << "objects of the TriangleMeshPolygon.\nCheck where you got "
    << "access to this objects and review that you are not introducing "
    << "any other objects than TriangleMeshPolyLines" << std::endl;
    throw OomphLibError(error_stream.str(),
                        OOMPH_CURRENT_FUNCTION,
      OOMPH_EXCEPTION_LOCATION);
   }
#endif
  return tmp_polyline;
 }

 /// Return vector of boundary ids of associated polylines
 Vector<unsigned> polygon_boundary_id()
  {
   // Get the number of polylines
   unsigned nline=npolyline();
   Vector<unsigned> boundary_id(nline);
    
   // Loop over the polyline to get the id
   for(unsigned iline=0;iline<nline;iline++)
    {
     boundary_id[iline]=Curve_section_pt[iline]->boundary_id();
    }
   return boundary_id;
  }

 /// \short Is re-distribution of polyline segments in the curve
 /// between different boundaries during adaptation enabled?
 bool is_redistribution_of_segments_between_polylines_enabled()
  {return Enable_redistribution_of_segments_between_polylines;}

 /// \short Enable re-distribution of polyline segments in the curve
 /// between different boundaries during adaptation
 void enable_redistribution_of_segments_between_polylines()
  {Enable_redistribution_of_segments_between_polylines=true;}

 /// \short Disable re-distribution of polyline segments in the curve
 /// between different boundaries during adaptation
 void disable_redistribution_of_segments_between_polylines()
  {Enable_redistribution_of_segments_between_polylines=false;}

 /// \short Test whether curve can update reference
 bool can_update_reference_configuration() const
 {return Can_update_configuration;}

 /// \short Virtual function that should be overloaded to update the polygons
 /// reference configuration
 virtual void reset_reference_configuration()
 {
   std::ostringstream error_stream;
   error_stream
   << "Broken Default Called\n"
   << "This function should be overloaded if Can_update_configuration = true,\n"
   << "which indicates that the curve in it polylines parts can update its "
   << "own position (i.e. it\n"
   << "may be a rigid body. Otherwise the update will be via a FaceMesh \n"
   << "representation of the boundary which is appropriate for \n"
   << "general deforming surfaces\n";

   throw OomphLibError(
       error_stream.str(),
       OOMPH_CURRENT_FUNCTION,
       OOMPH_EXCEPTION_LOCATION);
 }

 /// \short Test whether the polygon is fixed or not
 bool is_fixed() const {return Polygon_fixed;}

 /// \short Set the polygon to be fixed
 void set_fixed() {Polygon_fixed = true;}

 /// \short Set the polygon to be allowed to move (default)
 void set_unfixed() {Polygon_fixed = false;}

protected:

 /// \short Is re-distribution of polyline segments between different
 /// boundaries during adaptation enabled? (Default: false)
 bool Enable_redistribution_of_segments_between_polylines;

 ///\short Boolean flag to indicate whether the polygon can update its
 ///own reference configuration after it has moved i.e. if it is
 ///upgraded to a rigid body rather than being a free surface (default false)
 bool Can_update_configuration;

private:

 ///\short Boolean flag to indicate whether the polygon can move
 /// (default false because if it doesn't move this will just lead to
 ///  wasted work)
 bool Polygon_fixed;

};

/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////

//=====================================================================
/// Base class defining an open curve for the Triangle mesh generation
/// Basically used to define internal boundaries on the mesh
//=====================================================================
class TriangleMeshOpenCurve : public virtual TriangleMeshCurve
{

 public:

 /// Constructor
 TriangleMeshOpenCurve(const Vector<TriangleMeshCurveSection*> &curve_section_pt);

 /// Empty destructor
 virtual ~TriangleMeshOpenCurve() { }

 /// Number of vertices
 unsigned nvertices() const
 {
  unsigned n_vertices = 0;
  unsigned n_curve_section=ncurve_section();
  for (unsigned i = 0; i < n_curve_section; i++)
   n_vertices+=Curve_section_pt[i]->nvertex();
  // If there's just one boundary. All the vertices should be counted
  if (n_curve_section==1) {n_vertices+=1;}
  return n_vertices;
 }

 /// Total number of segments
 unsigned nsegments() const
 {
  unsigned n_curve_section=ncurve_section();
  unsigned nseg=0;
  for(unsigned j=0;j<n_curve_section;j++)
   {nseg+=Curve_section_pt[j]->nsegment();}
  return nseg;
 }

 /// Output each sub-boundary at n_sample (default: 50) points
 void output(std::ostream &outfile, const unsigned& n_sample=50)
 {
  unsigned nb=Curve_section_pt.size();
  for (unsigned i=0;i<nb;i++)
   {
    Curve_section_pt[i]->output(outfile,n_sample);
   }

 }

 /// Pointer to i-th constituent polyline
 TriangleMeshPolyLine* polyline_pt(const unsigned& i) const
 {
  TriangleMeshPolyLine *tmp_polyline =
    dynamic_cast<TriangleMeshPolyLine*>(Curve_section_pt[i]);
#ifdef PARANOID
  if (tmp_polyline == NULL)
   {
    std::ostringstream error_stream;
    error_stream
    << "The (" << i << ")-th TriangleMeshCurveSection is not a "
    << "TriangleMeshPolyLine.\nPlease make sure that when you"
    << "first created this object the (" <<  i << ")-th\n"
    << "TriangleCurveSection is a TriangleMeshPolyLine."
    << std::endl;
    throw OomphLibError(error_stream.str(),
                        OOMPH_CURRENT_FUNCTION,
      OOMPH_EXCEPTION_LOCATION);
   }
#endif
  return tmp_polyline;
 }

 /// Pointer to i-th constituent polyline
 TriangleMeshPolyLine* polyline_pt(const unsigned& i)
 {
  TriangleMeshPolyLine *tmp_polyline =
    dynamic_cast<TriangleMeshPolyLine*>(Curve_section_pt[i]);
#ifdef PARANOID
  if (tmp_polyline == NULL)
   {
    std::ostringstream error_stream;
    error_stream
    << "The (" << i << ")-th TriangleMeshCurveSection is not a "
    << "TriangleMeshPolyLine.\nPlease make sure that when you"
    << "first created this object the (" <<  i << ")-th\n"
    << "TriangleCurveSection is a TriangleMeshPolyLine."
    << std::endl;
    throw OomphLibError(error_stream.str(),
                        OOMPH_CURRENT_FUNCTION,
      OOMPH_EXCEPTION_LOCATION);
   }
#endif
  return tmp_polyline;
 }

};



///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////



//================================================================
/// Base class for triangle meshes (meshes made of 2D triangle elements).
//================================================================
class TriangleMeshBase : public virtual Mesh
{

public:

 /// Constructor 
 TriangleMeshBase() 
  {
#ifdef OOMPH_HAS_TRIANGLE_LIB

   //Initialise the TriangulateIO Data structure
   TriangleHelper::initialise_triangulateio(Triangulateio);


   // Enable triangulateio specific parts for dump/restart by default.
   Use_triangulateio_restart = true;
#endif
  }

 /// Broken copy constructor
 TriangleMeshBase(const TriangleMeshBase& node) 
  { 
   BrokenCopy::broken_copy("TriangleMeshBase");
  } 
 
 /// Broken assignment operator
 void operator=(const TriangleMeshBase&) 
  {
   BrokenCopy::broken_assign("TriangleMeshBase");
  }
 
 /// Destructor (empty)
 virtual ~TriangleMeshBase()
  {
#ifdef OOMPH_HAS_TRIANGLE_LIB  
   //Clear the triangulate data structure 
   TriangleHelper::clear_triangulateio(Triangulateio);
#endif
  }
 
 /// Setup lookup schemes which establish whic elements are located
 /// next to mesh's boundaries (wrapper to suppress doc).
 void setup_boundary_element_info()
  {
   std::ofstream outfile;
   setup_boundary_element_info(outfile);
  }

 /// \short Setup lookup schemes which establish which elements are located
 /// next to mesh's boundaries. Doc in outfile (if it's open).
 void setup_boundary_element_info(std::ostream &outfile);
 
#ifdef OOMPH_HAS_TRIANGLE_LIB
 /// \short const access for Use_triangulateio_restart.
 bool use_triangulateio_restart() const {return Use_triangulateio_restart;}

 /// \short write access for Use_triangulateio_restart.
 void enable_triangulateio_restart() {Use_triangulateio_restart = true;}

 /// \short write access for Use_triangulateio_restart.
 void disable_triangulateio_restart() {Use_triangulateio_restart = false;}


 
 /// Access to the triangulateio representation of the mesh
 TriangulateIO& triangulateio_representation() {return Triangulateio;}
 
 /// \short Helper function. Write a TriangulateIO object file with all the 
 /// triangulateio fields. String s is add to assign a different value for
 /// the input and/or output structure
 void write_triangulateio(TriangulateIO& triangulate_io, std::string& s);
 
 /// \short Helper function. Clean up the memory associated with the
 /// TriangulateIO object. This should really only be used to save
 /// memory in extremely tight situations.
 void clear_triangulateio()
  {TriangleHelper::clear_triangulateio(Triangulateio);}
 
 /// \short Dump the triangulateio structure to a dump file and
 /// record boundary coordinates of boundary nodes
 void dump_triangulateio(std::ostream &dump_file);
 
#ifdef OOMPH_HAS_MPI
 /// Virtual function that is used to dump info. related with
 /// distributed triangle meshes
 virtual void dump_distributed_info_for_restart(std::ostream &dump_file)
  {
   std::ostringstream error_stream;
   error_stream << "Empty default dump disributed info. method called.\n";
   error_stream << "This should be overloaded in a specific TriangleMesh\n";
   throw OomphLibError(error_stream.str(),
                       "TriangleMeshBase::dump_distributed_info_for_restart()",
                       OOMPH_EXCEPTION_LOCATION);
  }
 
 /// Virtual function that is used to dump info. related with
 /// distributed triangle meshes
 virtual void dump_info_to_reset_halo_haloed_scheme(std::ostream &dump_file)
  {
   std::ostringstream error_stream;
   error_stream << "Empty default dump info. to reset halo haloed scheme.\n";
   error_stream << "This should be overloaded in a specific TriangleMesh\n";
   throw OomphLibError(error_stream.str(),
                       "TriangleMeshBase::dump_info_to_reset_halo_haloed_scheme()",
                       OOMPH_EXCEPTION_LOCATION);
  }
 
 /// Virtual function that is used to read info. related with
 /// distributed triangle meshes
 virtual void read_distributed_info_for_restart(std::istream &restart_file)
  {
   std::ostringstream error_stream;
   error_stream << "Empty default read disributed info. method called.\n";
   error_stream << "This should be overloaded in a specific TriangleMesh\n";
   throw OomphLibError(error_stream.str(),
                       "TriangleMeshBase::read_distributed_info_for_restart()",
                       OOMPH_EXCEPTION_LOCATION);
  }

 /// Virtual function used to re-establish any additional info. related with
 /// the distribution after a re-starting for triangle meshes
 virtual void reestablish_distribution_info_for_restart(
  OomphCommunicator* comm_pt, std::istream &restart_file)
  {
   std::ostringstream error_stream;
   error_stream << "Empty default reestablish disributed info method "
                << "called.\n";
   error_stream << "This should be overloaded in a specific "
                << "RefineableTriangleMesh\n";
   throw OomphLibError(error_stream.str(),
                       "TriangleMeshBase::reestablish_distribution_info_for_restart()",
                       OOMPH_EXCEPTION_LOCATION);
  }
#endif

 /// Virtual function used to update the polylines representation after 
 /// restart
 virtual void update_polyline_representation_from_restart()
  {
   std::ostringstream error_stream;
   error_stream << "Empty default update polylines representation from "
                << "restart method called.\n";
   error_stream << "This should be overloaded in a specific "
                << "RefineableTriangleMesh\n";
   throw OomphLibError(error_stream.str(),
                       "TriangleMeshBase::update_polyline_representation_from_restart()",
                       OOMPH_EXCEPTION_LOCATION);
  }
 
 /// \short Regenerate the mesh from a dumped triangulateio file
 /// and dumped boundary coordinates of boundary nodes
 void remesh_from_triangulateio(std::istream &restart_file);

 ///Virtual function that is used for specific remeshing from the triangulateio
 virtual void remesh_from_internal_triangulateio() 
  {
   std::ostringstream error_stream;
   error_stream << "Empty default remesh function called.\n";
   error_stream << "This should be overloaded in a specific TriangleMesh\n";
   throw OomphLibError(error_stream.str(),
                       OOMPH_CURRENT_FUNCTION,
                       OOMPH_EXCEPTION_LOCATION);
  }

#endif // #ifdef OOMPH_HAS_TRIANGLE_LIB

 /// Virtual function to perform the load balance rutines
 virtual void load_balance(const Vector<unsigned>& 
                           target_domain_for_local_non_halo_element)
 {
  std::ostringstream error_stream;
  error_stream << "Empty default load balancing function called.\n";
  error_stream << "This should be overloaded in a specific TriangleMesh\n";
  throw OomphLibError(error_stream.str(),
                      "TriangleMeshBase::load_balance()",
                      OOMPH_EXCEPTION_LOCATION);
 }
 
 /// Virtual function to perform the reset boundary elements info rutines
 virtual void reset_boundary_element_info(
  Vector<unsigned> &ntmp_boundary_elements,
  Vector<Vector<unsigned> > &ntmp_boundary_elements_in_region,
  Vector<FiniteElement*> &deleted_elements)
 {
  std::ostringstream error_stream;
  error_stream << "Empty default reset boundary element info function"
               << "called.\n";
  error_stream << "This should be overloaded in a specific "
               << "TriangleMesh\n";
  throw OomphLibError(error_stream.str(),
                      "TriangleMeshBase::reset_boundary_element_info()",
                      OOMPH_EXCEPTION_LOCATION);
 }
 
 /// Virtual function to get the number of regions in the mesh
 virtual unsigned nregion()
 {
  std::ostringstream error_stream;
  error_stream << "Empty default nregion() function called.\n";
  error_stream << "This should be overloaded in a specific "
               << "TriangleMesh\n";
  throw OomphLibError(error_stream.str(),
                      "TriangleMeshBase::nregion()",
                      OOMPH_EXCEPTION_LOCATION);
 }
 
 /// Virtual function to get the region attribute
 virtual double region_attribute(const unsigned &i)
 {
  std::ostringstream error_stream;
  error_stream << "Empty default region_attribute() function called.\n";
  error_stream << "This should be overloaded in a specific "
               << "TriangleMesh\n";
  throw OomphLibError(error_stream.str(),
                      "TriangleMeshBase::region_attribute()",
                      OOMPH_EXCEPTION_LOCATION);
 }
 
 /// Virtual function to get the number of boundary elements in a
 /// region
 virtual unsigned nboundary_element_in_region(const unsigned &b,
                                              const unsigned &r) const
 {
  std::ostringstream error_stream;
  error_stream << "Empty default nboundary_element_in_region() function "
               << "called.\n";
  error_stream << "This should be overloaded in a specific "
               << "TriangleMesh\n";
  throw OomphLibError(error_stream.str(),
                      "TriangleMeshBase::nboundary_element_in_region()",
                      OOMPH_EXCEPTION_LOCATION);
 }
 
 /// Output the nodes on the boundary and their respective boundary
 /// coordinates(into separate tecplot zones)
 virtual void output_boundary_coordinates(const unsigned &b,
                                          std::ostream &outfile)
  {
   std::ostringstream error_stream;
   error_stream 
    << "Empty default output_boundary_coordinates() method called.\n"
    << "This should be overloaded on the specific TriangleMesh class\n";
    throw OomphLibError(error_stream.str(),
                        "TriangleMeshBase::output_boundary_coordinates",
                        OOMPH_EXCEPTION_LOCATION);
  }
 
  protected:
 
#ifdef OOMPH_HAS_TRIANGLE_LIB

 ///\short TriangulateIO representation of the mesh
 TriangulateIO Triangulateio;
 
 /// Should we use triangulateio specific parts for dump/restart? (Doesn't
 /// work with some elements and isn't needed if not using adaptivity).
 bool Use_triangulateio_restart;

#endif // OOMPH_HAS_TRIANGLE
 
};

}

#endif

