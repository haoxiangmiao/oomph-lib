This document provides an overview of how to distribute the \href{../../../poisson/two_d_poisson_flux_bc_adapt/html/index.html}{\tt 2D Poisson problem with flux boundary conditions}. It is part of a \href{../../../example_code_list/html/index.html#distributed}{\tt series of tutorials} that discuss how to modify existing serial driver codes so that the {\ttfamily Problem} object can be distributed across multiple processors.

A feature of this problem is that the flux boundary conditions are applied by attaching \char`\"{}flux elements\char`\"{} (derived from the {\ttfamily Face\+Element} base class) to the \char`\"{}bulk elements\char`\"{} adjacent to the appropriate mesh boundary. As discussed in the \href{../../../poisson/two_d_poisson_flux_bc_adapt/html/index.html}{\tt tutorial for the serial driver code}, the {\ttfamily Face\+Elements} are not involved in any adaptation within the bulk mesh. Instead, they are detached before the bulk mesh is adapted and re-\/attached afterwards, which ensures that the {\ttfamily Face\+Elements} are only attached to bulk elements present in the adapted mesh.

The same issue arises when the {\ttfamily Problem} is distributed\+: all {\ttfamily Face\+Elements} must be attached before the problem is distributed to allow {\ttfamily M\+E\+T\+IS} to analyse the interaction between face and bulk elements correctly. However, after the {\ttfamily Problem} has been distributed, some of the bulk elements on each processor will have been deleted, leaving the corresponding {\ttfamily Face\+Element} dangling. To deal with such problems, {\ttfamily oomph-\/lib} provides the empty virtual functions


\begin{DoxyCode}
Problem::actions\_before\_distribute() 
\end{DoxyCode}


and


\begin{DoxyCode}
Problem::actions\_after\_distribute() 
\end{DoxyCode}


which are called automatically by {\ttfamily Problem\+::distribute}(...). Specifically, {\ttfamily Problem\+::actions\+\_\+before\+\_\+distribute()} is called {\bfseries after} the problem distribution has been determined by {\ttfamily M\+E\+T\+IS} but {\bfseries before} the actual distribution (during which elements are deleted) takes place. {\ttfamily Problem\+::actions\+\_\+after\+\_\+distribute()} is called after the problem distribution is complete.

In the present problem we overload the functions {\ttfamily Problem\+::actions\+\_\+before\+\_\+distribute()} and {\ttfamily Problem\+::actions\+\_\+after\+\_\+distribute()} to perform the same functions as {\ttfamily actions\+\_\+before\+\_\+adapt()} (i.\+e. delete the flux elements) and {\ttfamily actions\+\_\+after\+\_\+adapt()} (i.\+e. re-\/attach the flux elements). We note that any {\ttfamily Face\+Element} that is attached to a halo element in the bulk mesh becomes a halo element itself; see the \href{../../general_mpi/html/index.html#face_elements}{\tt general M\+PI tutorial} for further details.

Most of driver code is identical to its serial counterpart and we only discuss the changes required to distribute the problem. Please refer to \href{../../../poisson/two_d_poisson_flux_bc_adapt/html/index.html}{\tt another tutorial} for a more detailed discussion of the problem and its (serial) implementation.



\hypertarget{index_main_body}{}\section{The main function}\label{index_main_body}
The only changes required to the main function are the usual calls to initialise and finalise {\ttfamily oomph-\/lib\textquotesingle{}s} M\+PI routines and a single call to {\ttfamily Problem\+::distribute()} after the problem has been constructed. The source code is actually slightly more complicated because the distribution is read in from a file so that the driver can be used as a self-\/test. Note that the file must specify the partition for {\bfseries all} elements, including the {\ttfamily Face\+Elements}. (We refer to \href{../../adaptive_driven_cavity/html/index.html#no_disk}{\tt another tutorial} for details on how to create the distribution file.)



\hypertarget{index_problem_class}{}\section{The problem class}\label{index_problem_class}
The only additions to the problem class are the functions {\ttfamily actions\+\_\+before\+\_\+distribute()} and {\ttfamily actions\+\_\+after\+\_\+distribute()}. As explained above, these perform exactly the same functions as {\ttfamily actions\+\_\+before\+\_\+adapt()} and {\ttfamily actions\+\_\+after\+\_\+adapt()}, respectively.

 
\begin{DoxyCodeInclude}
 \textcolor{comment}{/// \(\backslash\)short Actions before distribute: Wipe the mesh of prescribed flux elements}
\textcolor{comment}{ /// (simply call actions\_before\_adapt() which does the same thing)}
\textcolor{comment}{} \textcolor{keywordtype}{void} actions\_before\_distribute()
  \{
   actions\_before\_adapt();
  \}

\end{DoxyCodeInclude}



\begin{DoxyCodeInclude}
 \textcolor{comment}{/// \(\backslash\)short Actions after distribute: Rebuild the mesh of prescribed flux }
\textcolor{comment}{ /// elements (simply call actions\_after\_adapt() which does the same thing)}
\textcolor{comment}{} \textcolor{keywordtype}{void} actions\_after\_distribute()
  \{
   actions\_after\_adapt();
  \}

\end{DoxyCodeInclude}




\hypertarget{index_doc_solution}{}\section{The doc\+\_\+solution() function}\label{index_doc_solution}
As with other driver codes, the output files are modified to allow each processor to output its elements into files that include the processor number.


\begin{DoxyCodeInclude}
\textcolor{comment}{//=====================start\_of\_doc=======================================}
\textcolor{comment}{/// Doc the solution: doc\_info contains labels/output directory etc.}
\textcolor{comment}{}\textcolor{comment}{//========================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT>
\textcolor{keywordtype}{void} RefineableTwoMeshFluxPoissonProblem<ELEMENT>::doc\_solution(DocInfo& doc\_info)
\{ 

 \textcolor{comment}{// Doc refinement levels in bulk mesh}
 \textcolor{keywordtype}{unsigned} min\_refinement\_level;
 \textcolor{keywordtype}{unsigned} max\_refinement\_level;
 Bulk\_mesh\_pt->get\_refinement\_levels(min\_refinement\_level,
                                     max\_refinement\_level); 
 cout << \textcolor{stringliteral}{"Ultimate min/max. refinement levels in bulk mesh : "} 
      << min\_refinement\_level << \textcolor{stringliteral}{" "} 
      << max\_refinement\_level << std::endl;


 ofstream some\_file;
 \textcolor{keywordtype}{char} filename[100];

 \textcolor{comment}{// Number of plot points}
 \textcolor{keywordtype}{unsigned} npts;
 npts=5; 


 \textcolor{comment}{// Output solution with halo elements }
 \textcolor{comment}{//-----------------------------------}
 Bulk\_mesh\_pt->enable\_output\_of\_halo\_elements();
 sprintf(filename,\textcolor{stringliteral}{"%s/soln\_with\_halo%i\_on\_proc%i.dat"},
         doc\_info.directory().c\_str(),
         doc\_info.number(),this->communicator\_pt()->my\_rank());
 some\_file.open(filename);
 Bulk\_mesh\_pt->output(some\_file,npts);
 some\_file.close();
 Bulk\_mesh\_pt->disable\_output\_of\_halo\_elements();


 \textcolor{comment}{// Output solution }
 \textcolor{comment}{//-----------------}
 sprintf(filename,\textcolor{stringliteral}{"%s/soln%i\_on\_proc%i.dat"},doc\_info.directory().c\_str(),
         doc\_info.number(),this->communicator\_pt()->my\_rank());
 some\_file.open(filename);
 Bulk\_mesh\_pt->output(some\_file,npts);
 some\_file.close();

 \textcolor{comment}{// Output exact solution }
 \textcolor{comment}{//----------------------}
 sprintf(filename,\textcolor{stringliteral}{"%s/exact\_soln%i\_on\_proc%i.dat"},doc\_info.directory().c\_str(),
         doc\_info.number(),this->communicator\_pt()->my\_rank());
 some\_file.open(filename);
 Bulk\_mesh\_pt->output\_fct(some\_file,npts,TanhSolnForPoisson::get\_exact\_u); 
 some\_file.close();


 \textcolor{comment}{// Doc error and return of the square of the L2 error}
 \textcolor{comment}{//---------------------------------------------------}
 \textcolor{keywordtype}{double} error,norm;
 sprintf(filename,\textcolor{stringliteral}{"%s/error%i\_on\_proc%i.dat"},doc\_info.directory().c\_str(),
         doc\_info.number(),this->communicator\_pt()->my\_rank());
 some\_file.open(filename);
 Bulk\_mesh\_pt->compute\_error(some\_file,TanhSolnForPoisson::get\_exact\_u,
                               error,norm); 
 some\_file.close();

 \textcolor{comment}{// Doc L2 error and norm of solution}
 cout << \textcolor{stringliteral}{"\(\backslash\)nNorm of error   : "} << sqrt(error) << std::endl; 
 cout << \textcolor{stringliteral}{"Norm of solution: "} << sqrt(norm) << std::endl << std::endl;


\} \textcolor{comment}{// end of doc}

\end{DoxyCodeInclude}






The remainder of this driver code is unchanged from the \href{../../../poisson/two_d_poisson_flux_bc_adapt/html/index.html}{\tt serial version}.



 

\hypertarget{index_sources}{}\section{Source files for this tutorial}\label{index_sources}

\begin{DoxyItemize}
\item The source files for this tutorial are located in the directory\+:~\newline
~\newline
\begin{center} \href{../../../../demo_drivers/mpi/distribution/two_d_poisson_flux_bc_adapt/}{\tt demo\+\_\+drivers/mpi/distribution/two\+\_\+d\+\_\+poisson\+\_\+flux\+\_\+bc\+\_\+adapt/ } \end{center} ~\newline

\item The driver code is\+: ~\newline
~\newline
\begin{center} \href{../../../../demo_drivers/mpi/distribution/two_d_poisson_flux_bc_adapt/two_d_poisson_flux_bc_adapt.cc}{\tt demo\+\_\+drivers/mpi/distribution/two\+\_\+d\+\_\+poisson\+\_\+flux\+\_\+bc\+\_\+adapt/two\+\_\+d\+\_\+poisson\+\_\+flux\+\_\+bc\+\_\+adapt.\+cc } \end{center} 
\end{DoxyItemize}



 

 \hypertarget{index_pdf}{}\section{P\+D\+F file}\label{index_pdf}
A \href{../latex/refman.pdf}{\tt pdf version} of this document is available. \end{document}
