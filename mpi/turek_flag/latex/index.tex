This document provides an overview of
\begin{DoxyItemize}
\item how to change the serial driver code for \href{../../../interaction/turek_flag/html/index.html}{\tt Turek \& Hron\textquotesingle{}s F\+SI benchmark problem} so that both the fluid and solid meshes can be adapted,
\end{DoxyItemize}
\begin{DoxyItemize}
\item how to distribute the problem across multiple processors,
\end{DoxyItemize}and
\begin{DoxyItemize}
\item how to enable load balancing of the problem once it is distributed.
\end{DoxyItemize}The document is part of a \href{../../../example_code_list/html/index.html#distributed}{\tt series of tutorials} that discuss how to modify existing serial driver codes so that the {\ttfamily Problem} object can be distributed across multiple processors.



 

\hypertarget{index_double_adapt}{}\section{Enabling spatial adaptivity for the fluid and solid meshes}\label{index_double_adapt}
In the original (serial) driver code for \href{../../../interaction/turek_flag/html/index.html}{\tt Turek \& Hron\textquotesingle{}s F\+SI benchmark problem} we only adapted the fluid mesh. Before discussing how to modify the code to refine the fluid and solid meshes simultaneously, we provide a brief reminder of the procedure used to discretise fluid-\/structure interaction problems that involve fluid and solid domains of equal spatial dimension (e.\+g. a 2D fluid domain interacting with a 2D solid domain) when using algebraic node update methods to adjust the position of the nodes in the fluid mesh. We refer to \href{../../fsi_channel_with_leaflet/html/index.html}{\tt another tutorial} for a discussion of F\+SI problems involving the interaction of fluids with (lower-\/dimensional) shell and beam structures.\hypertarget{index_orig}{}\subsection{General methodology}\label{index_orig}
The figure below shows a sketch of a simple(r) fluid-\/structure interaction problem involving fluid and solid domains that meet along a single mesh boundary. We assume that the fluid mesh uses an algebraic node update function to adjust the position of its nodes in response to changes in the domain boundary, represented by the {\ttfamily Geom\+Object} shown in magenta. (You may wish to consult \href{../../../interaction/fsi_collapsible_channel_algebraic/html/index.html}{\tt another tutorial} for a reminder of how {\ttfamily oomph-\/lib\textquotesingle{}s} algebraic node update methods work).

 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{fsi_with_adaptive_wall_basic}
\doxyfigcaption{Basic setup for F\+SI problems involving algebraic node updates for the fluid mesh. }
\end{DoxyImage}


In an F\+SI problem, the fluid mesh\textquotesingle{}s free boundary is a boundary of the solid mesh, {\itshape  i.\+e. } the boundary along which the fluid exerts a traction onto the solid. Within {\ttfamily oomph-\/lib}, the fluid traction is applied to the solid domain by attaching {\ttfamily F\+S\+I\+Solid\+Traction\+Elements} to the faces of the \char`\"{}bulk\char`\"{} solid elements adjacent to the F\+SI boundary. (In the above sketch the {\ttfamily F\+S\+I\+Solid\+Traction\+Elements} are shown in blue.) The deformation of the fluid and solid meshes is coupled by using the {\ttfamily Mesh\+As\+Geom\+Object} formed from the {\ttfamily F\+S\+I\+Solid\+Traction\+Elements} as the {\ttfamily Geom\+Object} that defines the moving boundary of the fluid mesh. (In sketch above, this is indicated by the magenta arrow.)\hypertarget{index_modification1}{}\subsection{Modifications to allow adaptivity of the fluid and solid meshes}\label{index_modification1}
If the solid mesh is not adapted, the adaptation for the fluid mesh is straightforward and proceeds fully automatically as described \href{../../../interaction/fsi_collapsible_channel_algebraic/html/index.html}{\tt elsewhere}. In particular, the node update data for newly-\/created fluid nodes is created automatically by a call to the {\ttfamily Algebraic\+Mesh\+::update\+\_\+node\+\_\+update}(...) function during the adaptation. This function obtains the required information about the boundary by using the {\ttfamily Mesh\+As\+Geom\+Object} built from the {\ttfamily F\+S\+I\+Solid\+Traction\+Elements}.

If the solid mesh is also adapted, then the existing {\ttfamily F\+S\+I\+Solid\+Traction\+Elements} must (at some point) be deleted and new ones must be attached to the adapted \char`\"{}bulk\char`\"{} solid mesh. In all other problems, this is done by deleting the {\ttfamily F\+S\+I\+Solid\+Traction\+Elements} in {\ttfamily Problem\+::actions\+\_\+before\+\_\+adapt()} and attaching new ones in {\ttfamily Problem\+::actions\+\_\+after\+\_\+adapt()}; see, e.\+g. the \href{../../../poisson/two_d_poisson_flux_bc/html/index.html}{\tt tutorial on the solution of a Poisson problem with flux boundary conditions.} However, in the present problem this is not possible because, once the {\ttfamily F\+S\+I\+Solid\+Traction\+Elements} have been deleted, the {\ttfamily Mesh\+As\+Geom\+Object} can no longer be used to represent the shape and position of the F\+SI boundary, which would cause the adaptation of the fluid mesh to fail.

To avoid this problem, we adopt the following strategy\+:
\begin{DoxyEnumerate}
\item When adding the various meshes to the {\ttfamily Problem\textquotesingle{}s} collection of sub-\/meshes, we add the fluid mesh {\bfseries before} the solid mesh. (This happens to be what was done already in the original driver code.) Usually, the order in which sub-\/meshes are added to the {\ttfamily Problem} is irrelevant. Here the order {\bfseries does} matter because we will exploit the fact that the sub-\/meshes are adapted individually, in the order in which they were added to the {\ttfamily Problem}. ~\newline
~\newline

\item The {\ttfamily F\+S\+I\+Solid\+Traction\+Elements} are not deleted in {\ttfamily Problem\+::actions\+\_\+before\+\_\+adapt()} and remain attached to the \char`\"{}bulk\char`\"{} solid elements throughout the \char`\"{}bulk\char`\"{} mesh adaptation procedure. When the fluid mesh is adapted, the appropriate {\ttfamily Mesh\+As\+Geom\+Object} is, therefore, still fully-\/functional (and refers to the boundary as represented by the solid domain {\bfseries before} the \char`\"{}bulk\char`\"{} solid mesh is adapted). ~\newline
~\newline
 Here is a sketch of problem after adaptation of the fluid mesh\+: ~\newline
~\newline
 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{fsi_with_adaptive_wall_adapted_fluid}
\doxyfigcaption{Sketch of the problem following the adaptation of the fluid mesh. The solid mesh has not yet been refined. }
\end{DoxyImage}
 ~\newline
~\newline

\item The subsequent adaptation of the \char`\"{}bulk\char`\"{} solid mesh is likely to turn some of the {\ttfamily F\+S\+I\+Solid\+Traction\+Elements} into \char`\"{}dangling\char`\"{} elements. (This occurs whenever a {\ttfamily F\+S\+I\+Solid\+Traction\+Elements} is attached to a \char`\"{}bulk\char`\"{} solid elements that disappears during the adaptation, {\itshape  e.\+g. } by being refined.) ~\newline
~\newline
 Here is a plot of the problem following the adaptation of the solid mesh \+: ~\newline
~\newline
 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{fsi_with_adaptive_wall_adapted_solid}
\doxyfigcaption{Sketch of the problem following the adaptation of the solid mesh -\/-\/ the `dangling\textquotesingle{} F\+S\+I\+Solid\+Traction\+Elements are represented by dotted lines. }
\end{DoxyImage}
 ~\newline
~\newline

\item Hence, in {\ttfamily Problem\+::actions\+\_\+after\+\_\+adapt()} we delete the existing {\ttfamily F\+S\+I\+Solid\+Traction\+Elements} and immediately (re-\/)attach new ones. Now, the {\ttfamily Mesh\+As\+Geom\+Object} that represents the F\+SI boundary is broken because it still refers to the just deleted {\ttfamily F\+S\+I\+Solid\+Traction\+Elements}. ~\newline
~\newline
 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{fsi_with_adaptive_wall_new_face_elements}
\doxyfigcaption{Sketch of the problem following the creation of new F\+S\+I\+Solid\+Traction\+Elements. The fact that the Mesh\+As\+Geom\+Object is broken is indicated by the dashed lines. }
\end{DoxyImage}
 ~\newline
~\newline

\item Thus, we rebuild the {\ttfamily Mesh\+As\+Geom\+Object} from the newly-\/created {\ttfamily F\+S\+I\+Solid\+Traction\+Elements}, and update the fluid mesh\textquotesingle{}s pointer to this new {\ttfamily Geom\+Object} that describes the boundary shape. ~\newline
~\newline
 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{fsi_with_adaptive_wall_done}
\doxyfigcaption{Sketch of the problem with re-\/built Mesh\+As\+Geom\+Object. }
\end{DoxyImage}
 ~\newline
~\newline

\item Finally, we execute the {\ttfamily Algebraic\+Mesh\+::update\+\_\+node\+\_\+update}(...) function for all nodes in the fluid mesh to ensure that their node update data refers to the new {\ttfamily F\+S\+I\+Solid\+Traction\+Elements}. ~\newline
~\newline

\item The remaining tasks (such as the renewed setup of the fluid load on the {\ttfamily F\+S\+I\+Solid\+Traction\+Elements} via a call to {\ttfamily F\+S\+I\+\_\+functions\+::setup\+\_\+fluid\+\_\+load\+\_\+info\+\_\+for\+\_\+solid\+\_\+elements}(...), etc.) remain the same as in the previous version of the code.
\end{DoxyEnumerate}

 

\hypertarget{index_distr}{}\section{Distributing the Problem}\label{index_distr}
In the present example, there are two \char`\"{}bulk\char`\"{} meshes corresponding to the fluid and solid domains and three \char`\"{}surface\char`\"{} meshes of traction elements. The traction elements are {\ttfamily Face\+Elements} created from the \char`\"{}bulk\char`\"{} fluid elements and should be deleted before the problem is distributed, see the tutorial on applying \href{../../two_d_poisson_flux_bc_adapt/html/index.html}{\tt flux boundary conditions in a Poisson problem } for more details. In the \href{../../fsi_channel_with_leaflet/html/index.html}{\tt previous example} involving the interaction of a 2D fluid domain with a 1D beam structure there were only two meshes\+: a \char`\"{}bulk\char`\"{} fluid mesh and a \char`\"{}surface\char`\"{} solid mesh. In that problem {\bfseries all} elements in the 1D mesh of {\ttfamily F\+S\+I\+Hermite\+Beam\+Elements} were retained on all processors as halo elements by using the function {\ttfamily Mesh\+::keep\+\_\+all\+\_\+elements\+\_\+as\+\_\+halos()}. The same methodology could be used here, but it would be extremely wasteful to retain all the solid elements in the \char`\"{}bulk\char`\"{} solid mesh because only the elements next to the F\+SI boundary are required. Instead, we use a more fine-\/grained method of retaining elements via the function {\ttfamily Generalised\+Element\+::must\+\_\+be\+\_\+kept\+\_\+as\+\_\+halo()}.



 

\hypertarget{index_impl}{}\section{Implementation}\label{index_impl}
Most of the driver code is identical to the original serial version discussed in \href{../../fsi_channel_with_leaflet/html/index.html}{\tt another tutorial}. We therefore only discuss those parts of the code that have to be changed to allow (i) the simultaneous adaptation of the fluid and solid meshes, and (ii) the problem distribution.



\hypertarget{index_main_body}{}\subsection{The main function}\label{index_main_body}
As usual in a parallel driver code, the only addition to the {\ttfamily main()} function is the inclusion of calls to {\ttfamily M\+P\+I\+\_\+\+Helpers\+::init()}, {\ttfamily M\+P\+I\+\_\+\+Helpers\+::finalize()}, and the {\ttfamily Problem\+::distribute()} functions.



\hypertarget{index_problem_class}{}\subsection{The problem class}\label{index_problem_class}
The only additions to the serial version of the problem class are the functions {\ttfamily actions\+\_\+before\+\_\+distribute()} and {\ttfamily actions\+\_\+after\+\_\+distribute()}, and the helper function {\ttfamily delete\+\_\+fsi\+\_\+traction\+\_\+elements()}, discussed below.



\hypertarget{index_delete_fsi}{}\subsection{Deleting the F\+S\+I\+Solid\+Traction\+Elements}\label{index_delete_fsi}
To facilitate the deletion and re-\/creation of the {\ttfamily F\+S\+I\+Solid\+Traction\+Elements} before and after the adaptation (and distribution) we provide a new helper function {\ttfamily delete\+\_\+fsi\+\_\+traction\+\_\+elements()} which complements the already-\/existing {\ttfamily create\+\_\+fsi\+\_\+traction\+\_\+elements()} function\+:

 
\begin{DoxyCodeInclude}
\textcolor{comment}{//============start\_of\_delete\_traction\_elements==========================}
\textcolor{comment}{/// Delete FSI traction elements }
\textcolor{comment}{}\textcolor{comment}{//=======================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} FLUID\_ELEMENT,\textcolor{keyword}{class} SOLID\_ELEMENT >
\textcolor{keywordtype}{void} TurekProblem<FLUID\_ELEMENT,SOLID\_ELEMENT>::delete\_fsi\_traction\_elements()
\{
 \textcolor{comment}{// There are 3 traction meshes}
 \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} b=0;b<3;b++)
  \{
   \textcolor{keywordtype}{unsigned} n\_element=Traction\_mesh\_pt[b]->nelement();
   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} e=0;e<n\_element;e++)
    \{
     \textcolor{comment}{// Kill the element}
     \textcolor{keyword}{delete} Traction\_mesh\_pt[b]->element\_pt(e);
    \}

   \textcolor{comment}{// Wipe the mesh}
   Traction\_mesh\_pt[b]->flush\_element\_and\_node\_storage();
  \}
\} \textcolor{comment}{// end of delete traction elements}

\end{DoxyCodeInclude}




\hypertarget{index_actions_before_distribute}{}\subsection{Actions before distribute}\label{index_actions_before_distribute}
As discussed above, we must ensure that the \char`\"{}bulk\char`\"{} solid elements adjacent to the F\+SI boundary are retained on all processors. Hence, the {\ttfamily actions\+\_\+before\+\_\+distribute()} function starts with a loop over the {\ttfamily F\+S\+I\+Solid\+Traction\+Elements} within which we use the function {\ttfamily Generalised\+Element\+::must\+\_\+be\+\_\+kept\+\_\+as\+\_\+halo()} to indicate that the associated bulk elements must be retained.

 
\begin{DoxyCodeInclude}
\textcolor{comment}{//==================start\_of\_actions\_before\_distribute====================}
\textcolor{comment}{/// Actions before distribute: Make sure that the bulk solid elements }
\textcolor{comment}{}\textcolor{comment}{/// attached to the FSISolidTractionElements are kept as halo elements.}
\textcolor{comment}{}\textcolor{comment}{/// Unlike in most other parallel codes we DON'T delete the }
\textcolor{comment}{}\textcolor{comment}{/// FSISolidTractionElements here, though, because they need to }
\textcolor{comment}{}\textcolor{comment}{/// be around while the fluid mesh is adapted.}
\textcolor{comment}{}\textcolor{comment}{//========================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} FLUID\_ELEMENT,\textcolor{keyword}{class} SOLID\_ELEMENT >
\textcolor{keywordtype}{void} TurekProblem<FLUID\_ELEMENT,SOLID\_ELEMENT>::actions\_before\_distribute()
\{
 \textcolor{comment}{// The bulk elements attached to the traction elements need to be kept}
 \textcolor{comment}{// as halo elements}

 \textcolor{comment}{// There are 3 traction meshes}
 \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} b=0;b<3;b++)
  \{
   \textcolor{comment}{// Loop over elements in traction meshes}
   \textcolor{keywordtype}{unsigned} n\_element=Traction\_mesh\_pt[b]->nelement();
   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} e=0;e<n\_element;e++)
    \{
     FSISolidTractionElement<SOLID\_ELEMENT,2>* traction\_elem\_pt=
      \textcolor{keyword}{dynamic\_cast<}FSISolidTractionElement<SOLID\_ELEMENT,2>* \textcolor{keyword}{>}
      (Traction\_mesh\_pt[b]->element\_pt(e));

     \textcolor{comment}{// Get the bulk element (which is a SOLID\_ELEMENT)}
     SOLID\_ELEMENT* solid\_elem\_pt = \textcolor{keyword}{dynamic\_cast<}SOLID\_ELEMENT*\textcolor{keyword}{>}
      (traction\_elem\_pt->bulk\_element\_pt());

     \textcolor{comment}{// Require bulk to be kept as a (possible) halo element}
     \textcolor{comment}{// Note: The traction element itself will "become" a halo element }
     \textcolor{comment}{// when it is recreated after the distribution has taken place}
     solid\_elem\_pt->set\_must\_be\_kept\_as\_halo();
    \}
  \} \textcolor{comment}{// end of loop over meshes of fsi traction elements}

\end{DoxyCodeInclude}


Next, we flush all the meshes from the problem\textquotesingle{}s collection of sub-\/meshes and add only the \char`\"{}bulk\char`\"{} fluid and solid meshes (in that order!). The {\ttfamily Face\+Elements} do not need to be distributed, because they will be re-\/created in {\ttfamily actions\+\_\+after\+\_\+distribute()}.


\begin{DoxyCodeInclude}
 

 \textcolor{comment}{// Flush all the submeshes out but keep the meshes of FSISolidTractionElements}
 \textcolor{comment}{// alive (i.e. don't delete them)}
 flush\_sub\_meshes();

 \textcolor{comment}{// Add the fluid mesh and the solid mesh back again}
 \textcolor{comment}{// Remember that it's important that the fluid mesh is}
 \textcolor{comment}{// added before the solid mesh!}
 add\_sub\_mesh(fluid\_mesh\_pt());
 add\_sub\_mesh(solid\_mesh\_pt());

 \textcolor{comment}{// Rebuild global mesh}
 rebuild\_global\_mesh();

\} \textcolor{comment}{// end of actions before distribute}

\end{DoxyCodeInclude}




\hypertarget{index_actions_after_distribute}{}\subsection{Actions after distribute}\label{index_actions_after_distribute}
Following the problem distribution, we delete the old {\ttfamily F\+S\+I\+Solid\+Traction\+Elements} and then (re-\/)attach new ones, which will be created as halo elements where necessary.

 
\begin{DoxyCodeInclude}
\textcolor{comment}{//==================start\_of\_actions\_after\_distribute=====================}
\textcolor{comment}{///  Actions after distribute: Re-setup FSI}
\textcolor{comment}{}\textcolor{comment}{//========================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} FLUID\_ELEMENT,\textcolor{keyword}{class} SOLID\_ELEMENT >
\textcolor{keywordtype}{void} TurekProblem<FLUID\_ELEMENT,SOLID\_ELEMENT>::actions\_after\_distribute()
\{
 \textcolor{comment}{// The solid mesh has now been distributed, so it now has halo elements}
 \textcolor{comment}{// on certain processors. The traction elements attached to these new}
 \textcolor{comment}{// halo elements need to be halo themselves, so we need to delete the}
 \textcolor{comment}{// old ones and re-attach new ones. Recall that FaceElements attached}
 \textcolor{comment}{// to bulk halo elements become halos themselves.}
 delete\_fsi\_traction\_elements();

 \textcolor{comment}{// (Re-)Build the FSI traction elements}
 create\_fsi\_traction\_elements();

\end{DoxyCodeInclude}


We complete the build of the {\ttfamily F\+S\+I\+Solid\+Traction\+Elements} by passing the F\+SI parameter and the boundary number in the bulk mesh. The relevant code is identical to the serial version and we omit its listing here.

Next, we create new {\ttfamily Mesh\+As\+Geom\+Objects} from the newly-\/created {\ttfamily F\+S\+I\+Solid\+Traction\+Elements} and pass them to the (algebraic) fluid mesh\+:


\begin{DoxyCodeInclude}
 \textcolor{comment}{// Turn the three meshes of FSI traction elements into compound}
 \textcolor{comment}{// geometric objects (one Lagrangian, two Eulerian coordinates)}
 \textcolor{comment}{// that determine particular boundaries of the fluid mesh}
 MeshAsGeomObject*
  bottom\_flag\_pt=
  \textcolor{keyword}{new} MeshAsGeomObject
  (Traction\_mesh\_pt[0]);
 
 MeshAsGeomObject* tip\_flag\_pt=
  \textcolor{keyword}{new} MeshAsGeomObject
  (Traction\_mesh\_pt[1]);
 
 MeshAsGeomObject* top\_flag\_pt=
  \textcolor{keyword}{new} MeshAsGeomObject
  (Traction\_mesh\_pt[2]);


 \textcolor{comment}{// Delete the old MeshAsGeomObjects and tell the fluid mesh }
 \textcolor{comment}{// about the new ones.}
 \textcolor{keyword}{delete} fluid\_mesh\_pt()->bottom\_flag\_pt();
 fluid\_mesh\_pt()->set\_bottom\_flag\_pt(bottom\_flag\_pt);
 \textcolor{keyword}{delete} fluid\_mesh\_pt()->top\_flag\_pt();
 fluid\_mesh\_pt()->set\_top\_flag\_pt(top\_flag\_pt);
 \textcolor{keyword}{delete} fluid\_mesh\_pt()->tip\_flag\_pt();
 fluid\_mesh\_pt()->set\_tip\_flag\_pt(tip\_flag\_pt);

\end{DoxyCodeInclude}


The {\ttfamily Mesh\+As\+Geom\+Objects} have changed, so we must call the {\ttfamily update\+\_\+node\+\_\+update()} function again for each node in the fluid mesh\+:


\begin{DoxyCodeInclude}

 \textcolor{comment}{// Call update\_node\_update for all the fluid mesh nodes, as the}
 \textcolor{comment}{// geometric objects representing the fluid mesh boundaries have changed}
 \textcolor{keywordtype}{unsigned} n\_fluid\_node=fluid\_mesh\_pt()->nnode();
 \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} n=0;n<n\_fluid\_node;n++)
  \{
   \textcolor{comment}{// Get the (algebraic) node}
   AlgebraicNode* alg\_nod\_pt=\textcolor{keyword}{dynamic\_cast<}AlgebraicNode*\textcolor{keyword}{>}
    (fluid\_mesh\_pt()->node\_pt(n));

   \textcolor{comment}{// Call update\_node\_update for this node}
   fluid\_mesh\_pt()->update\_node\_update(alg\_nod\_pt);
  \}

\end{DoxyCodeInclude}


Now we add the F\+SI traction meshes back to the problem and rebuild the global mesh.


\begin{DoxyCodeInclude}

 \textcolor{comment}{// Add the traction meshes back to the problem}
 \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} i=0;i<3;i++)
  \{
   add\_sub\_mesh(traction\_mesh\_pt(i));
  \}

 \textcolor{comment}{// Rebuild global mesh}
 rebuild\_global\_mesh();

\end{DoxyCodeInclude}


Finally, we re-\/set the fluid load on the solid elements by calling {\ttfamily F\+S\+I\+\_\+functions\+::setup\+\_\+fluid\+\_\+load\+\_\+info\+\_\+for\+\_\+solid\+\_\+elements}(...) before re-\/assigning the auxiliary node update function that imposes the no-\/slip condition for all fluid nodes on the F\+SI boundaries. \mbox{[}\href{../../fsi_channel_with_leaflet/html/index.html#action_after_adapt}{\tt Recall} that the (re-\/)assignment of the auxiliary node-\/update function must be performed {\bfseries after} the call to {\ttfamily F\+S\+I\+\_\+functions\+::setup\+\_\+fluid\+\_\+load\+\_\+info\+\_\+for\+\_\+solid\+\_\+elements}(...).\mbox{]}


\begin{DoxyCodeInclude}

 \textcolor{comment}{// If the solid is to be loaded by the fluid, then set up the interaction}
 \textcolor{comment}{// and specify the velocity of the fluid nodes based on the wall motion}
 \textcolor{keywordflow}{if} (!Global\_Parameters::Ignore\_fluid\_loading)
  \{

\textcolor{preprocessor}{#ifdef OLD\_FSI}

   \textcolor{comment}{// Re-setup the fluid load information for fsi solid traction elements}
   FSI\_functions::setup\_fluid\_load\_info\_for\_solid\_elements<FLUID\_ELEMENT,2>
    (\textcolor{keyword}{this},5,Fluid\_mesh\_pt,Traction\_mesh\_pt[0]); 

   FSI\_functions::setup\_fluid\_load\_info\_for\_solid\_elements<FLUID\_ELEMENT,2>
    (\textcolor{keyword}{this},6,Fluid\_mesh\_pt,Traction\_mesh\_pt[2]); 

   FSI\_functions::setup\_fluid\_load\_info\_for\_solid\_elements<FLUID\_ELEMENT,2>
    (\textcolor{keyword}{this},7,Fluid\_mesh\_pt,Traction\_mesh\_pt[1]); 

\textcolor{preprocessor}{#else}

   \textcolor{comment}{// Package fsi solid traction meshes and boundary IDs in }
   \textcolor{comment}{// fluid mesh}
   Vector<unsigned> fluid\_fsi\_boundary\_id(3);
   Vector<Mesh*> traction\_mesh\_pt(3);
   fluid\_fsi\_boundary\_id[0]=5;
   traction\_mesh\_pt[0]=Traction\_mesh\_pt[0];
   fluid\_fsi\_boundary\_id[1]=6;
   traction\_mesh\_pt[1]=Traction\_mesh\_pt[2];
   fluid\_fsi\_boundary\_id[2]=7;
   traction\_mesh\_pt[2]=Traction\_mesh\_pt[1];
   
   \textcolor{comment}{// Vector based FSI setup}
   FSI\_functions::setup\_fluid\_load\_info\_for\_solid\_elements<FLUID\_ELEMENT,2>
    (\textcolor{keyword}{this},fluid\_fsi\_boundary\_id,Fluid\_mesh\_pt,
     traction\_mesh\_pt);

\textcolor{preprocessor}{#endif}

   \textcolor{comment}{// The velocity of the fluid nodes on the wall (fluid mesh boundary 5,6,7)}
   \textcolor{comment}{// is set by the wall motion -- hence the no-slip condition must be}
   \textcolor{comment}{// re-applied whenever a node update is performed for these nodes. }
   \textcolor{comment}{// Such tasks may be performed automatically by the auxiliary node update }
   \textcolor{comment}{// function specified by a function pointer:}
   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} ibound=5;ibound<8;ibound++ )
    \{ 
     \textcolor{keywordtype}{unsigned} num\_nod= Fluid\_mesh\_pt->nboundary\_node(ibound);
     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} inod=0;inod<num\_nod;inod++)
      \{   
       Fluid\_mesh\_pt->boundary\_node\_pt(ibound, inod)->
        set\_auxiliary\_node\_update\_fct\_pt(
         FSI\_functions::apply\_no\_slip\_on\_moving\_wall);
      \}
    \}

  \} \textcolor{comment}{// end of (re-)assignment of the auxiliary node update fct}

\end{DoxyCodeInclude}


The remainder of the function identifies which processors contain the fluid control node whose velocities we document in the trace file.



\hypertarget{index_actions_after_adapt}{}\subsection{Actions after adapt}\label{index_actions_after_adapt}
The {\ttfamily actions\+\_\+after\+\_\+adapt()} function is very similar to {\ttfamily actions\+\_\+after\+\_\+distribute()} function, so we omit is listing here. The only significant differences are that (i) the redundant fluid and solid pressures are (re)-\/pinned; (ii) the identification of the fluid control node does not need to be setup; and (iii) the traction meshes were never removed from the problem, so do not need to be added back in.



\hypertarget{index_doc_solution}{}\subsection{The doc\+\_\+solution() function}\label{index_doc_solution}
As with the other parallel driver codes, the main modification to the post-\/processing function is the addition of the processor number to all output files. Furthermore, we only write the trace file on the processors that contain the fluid control node. In the interest of brevity we omit the listing of the modified function.



 

\hypertarget{index_result}{}\section{Results}\label{index_result}
The figure below illustrates the distribution of the problem across four processors, represented by the four colours, with the fluid elements outlined in black and the solid elements outlined in white.

 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{turek_partition}
\doxyfigcaption{Distribution of the Turek \& Hron benchmark problem over four processors. }
\end{DoxyImage}


Zooming in near the \char`\"{}flag\char`\"{} shows how both fluid and solid meshes are refined and distributed independently\+:

 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{turek_partition_zoom}
\doxyfigcaption{Distribution of the Turek \& Hron benchmark problem over four processors; zoomed in view near the `flag\textquotesingle{}. }
\end{DoxyImage}




 

\hypertarget{index_load_balance}{}\section{Load balancing}\label{index_load_balance}
When employing load balancing in this problem, we modify the time-\/stepping loop to perform the procedure after each timestep\+:

 
\begin{DoxyCodeInclude}
 \textcolor{comment}{// Start of timestepping loop}
 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} i=0;i<nstep;i++)
  \{ 
   \textcolor{comment}{// Solve the problem}
   problem.unsteady\_newton\_solve(dt,max\_adapt,first); 
   
   \textcolor{comment}{// Output the solution}
   problem.doc\_solution(doc\_info,trace\_file);
   
   \textcolor{comment}{// Step number}
   doc\_info.number()++;
   
   \textcolor{comment}{// Load balance the problem}
   DocInfo load\_doc\_info;
   problem.load\_balance(load\_doc\_info,report\_stats);

  \} \textcolor{comment}{// end of timestepping loop}

\end{DoxyCodeInclude}
\hypertarget{index_build_mesh}{}\subsection{The build\+\_\+mesh() function}\label{index_build_mesh}
The function {\ttfamily Problem\+::build\+\_\+mesh()} must be supplied by the user if they wish to use the load balancing capability. Thus, in this driver code, we move all the required code to build the entire global mesh into this function, and call it from within the problem constructor\+:

 
\begin{DoxyCodeInclude}
\textcolor{comment}{//=====start\_of\_constructor============================================= }
\textcolor{comment}{/// Constructor: Pass length and height of domain}
\textcolor{comment}{}\textcolor{comment}{//====================================================================== }
\textcolor{keyword}{template}< \textcolor{keyword}{class} FLUID\_ELEMENT,\textcolor{keyword}{class} SOLID\_ELEMENT >
TurekProblem<FLUID\_ELEMENT,SOLID\_ELEMENT>::
TurekProblem(\textcolor{keyword}{const} \textcolor{keywordtype}{double} &length,
             \textcolor{keyword}{const} \textcolor{keywordtype}{double} &height) :  Domain\_height(height),
                                      Domain\_length(length)
 
\{

 \textcolor{comment}{// Tell us how well the load balancing is doing...}
 enable\_doc\_imbalance\_in\_parallel\_assembly();

 \textcolor{comment}{// Increase max. number of iterations in Newton solver to}
 \textcolor{comment}{// accomodate possible poor initial guesses}
 Max\_newton\_iterations=20;
 Max\_residuals=1.0e4;

 \textcolor{comment}{// Create the flag timestepper (consistent with BDF<2> for fluid)}
 Flag\_time\_stepper\_pt=\textcolor{keyword}{new} Newmark<2>;
 add\_time\_stepper\_pt(Flag\_time\_stepper\_pt); 

 \textcolor{comment}{// Create error estimator for the solid mesh}
 Solid\_error\_estimator\_pt=\textcolor{keyword}{new} Z2ErrorEstimator;

 \textcolor{comment}{//Create a new Circle object as the central cylinder}
 Cylinder\_pt = \textcolor{keyword}{new} Circle(Global\_Parameters::Centre\_x,
                          Global\_Parameters::Centre\_y,
                          Global\_Parameters::Radius);
 
 \textcolor{comment}{// Allocate the fluid timestepper}
 Fluid\_time\_stepper\_pt=\textcolor{keyword}{new} BDF<2>;
 add\_time\_stepper\_pt(Fluid\_time\_stepper\_pt);

 \textcolor{comment}{// Create error estimator for the fluid mesh}
 Fluid\_error\_estimator\_pt=\textcolor{keyword}{new} Z2ErrorEstimator;

 \textcolor{comment}{// Build the meshes for this problem}
 build\_mesh();

 \textcolor{comment}{// Setup FSI}
 \textcolor{comment}{//----------}
 
 \textcolor{comment}{// Pass Strouhal number to the helper function that automatically applies}
 \textcolor{comment}{// the no-slip condition}
 FSI\_functions::Strouhal\_for\_no\_slip=Global\_Parameters::St;

 \textcolor{comment}{// If the solid is to be loaded by the fluid, then set up the interaction}
 \textcolor{comment}{// and specify the velocity of the fluid nodes based on the wall motion}
 \textcolor{keywordflow}{if} (!Global\_Parameters::Ignore\_fluid\_loading)
  \{
   \textcolor{comment}{// Work out which fluid dofs affect the residuals of the wall elements:}
   \textcolor{comment}{// We pass the boundary between the fluid and solid meshes and }
   \textcolor{comment}{// pointers to the meshes. The interaction boundary are boundaries 5,6,7}
   \textcolor{comment}{// of the 2D fluid mesh.}
   FSI\_functions::setup\_fluid\_load\_info\_for\_solid\_elements<FLUID\_ELEMENT,2>
    (\textcolor{keyword}{this},5,Fluid\_mesh\_pt,Traction\_mesh\_pt[0]);
   
   FSI\_functions::setup\_fluid\_load\_info\_for\_solid\_elements<FLUID\_ELEMENT,2>
    (\textcolor{keyword}{this},6,Fluid\_mesh\_pt,Traction\_mesh\_pt[2]);

   FSI\_functions::setup\_fluid\_load\_info\_for\_solid\_elements<FLUID\_ELEMENT,2>
    (\textcolor{keyword}{this},7,Fluid\_mesh\_pt,Traction\_mesh\_pt[1]); 

   \textcolor{comment}{// The velocity of the fluid nodes on the wall (fluid mesh boundary 5,6,7)}
   \textcolor{comment}{// is set by the wall motion -- hence the no-slip condition must be}
   \textcolor{comment}{// re-applied whenever a node update is performed for these nodes. }
   \textcolor{comment}{// Such tasks may be performed automatically by the auxiliary node update }
   \textcolor{comment}{// function specified by a function pointer:}
   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} ibound=5;ibound<8;ibound++ )
    \{ 
     \textcolor{keywordtype}{unsigned} num\_nod= Fluid\_mesh\_pt->nboundary\_node(ibound);
     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} inod=0;inod<num\_nod;inod++)
      \{   
       Fluid\_mesh\_pt->boundary\_node\_pt(ibound, inod)->
        set\_auxiliary\_node\_update\_fct\_pt(
         FSI\_functions::apply\_no\_slip\_on\_moving\_wall);
      \}
    \} \textcolor{comment}{// done automatic application of no-slip}
  \} \textcolor{comment}{// end of FSI setup}

 \textcolor{comment}{// Use SuperLU\_dist as the solver}
 linear\_solver\_pt() = \textcolor{keyword}{new} SuperLUSolver;
 \textcolor{keyword}{static\_cast<}SuperLUSolver*\textcolor{keyword}{>}(linear\_solver\_pt())
  ->set\_solver\_type(SuperLUSolver::Distributed);
 \textcolor{keyword}{static\_cast<}SuperLUSolver*\textcolor{keyword}{>}(linear\_solver\_pt())
  ->use\_distributed\_solve\_in\_superlu\_dist();

 \textcolor{comment}{// Assign equation numbers}
 cout << assign\_eqn\_numbers() << std::endl; 

\}\textcolor{comment}{//end\_of\_constructor}

\end{DoxyCodeInclude}


The {\ttfamily build\+\_\+mesh()} function itself contains all the relevant code from within the previous parallel driver code\textquotesingle{}s problem constructor.\hypertarget{index_actions_functions}{}\subsection{Actions before and after load balancing}\label{index_actions_functions}
In this example, all that is required for the {\ttfamily actions\+\_\+after\+\_\+load\+\_\+balance()} function is the addition of the unpin-\/repin procedure from the {\ttfamily actions\+\_\+after\+\_\+adapt()} function to the appropriate part of the {\ttfamily actions\+\_\+after\+\_\+distribute()} function, since all the other functionality is already identical. The {\ttfamily actions\+\_\+before\+\_\+load\+\_\+balance()} function is identical to the {\ttfamily actions\+\_\+before\+\_\+distribute()} function.



 

\hypertarget{index_sources}{}\section{Source files for this tutorial}\label{index_sources}

\begin{DoxyItemize}
\item The source files for this tutorial are located in the directory\+:~\newline
~\newline
\begin{center} \href{../../../../demo_drivers/mpi/multi_domain/turek_flag/}{\tt demo\+\_\+drivers/mpi/multi\+\_\+domain/turek\+\_\+flag/ } \end{center} ~\newline

\item The main driver code is\+: ~\newline
~\newline
\begin{center} \href{../../../../demo_drivers/mpi/multi_domain/turek_flag/turek_flag.cc}{\tt demo\+\_\+drivers/mpi/multi\+\_\+domain/turek\+\_\+flag/turek\+\_\+flag.\+cc } \end{center} 
\item The driver code for the load balancing example is\+: ~\newline
~\newline
\begin{center} \href{../../../../demo_drivers/mpi/multi_domain/turek_flag/turek_flag_load_balance.cc}{\tt demo\+\_\+drivers/mpi/multi\+\_\+domain/turek\+\_\+flag/turek\+\_\+flag\+\_\+load\+\_\+balance.\+cc } \end{center} 
\end{DoxyItemize}



 

 \hypertarget{index_pdf}{}\section{P\+D\+F file}\label{index_pdf}
A \href{../latex/refman.pdf}{\tt pdf version} of this document is available. \end{document}
