{\ttfamily oomph-\/lib\textquotesingle{}s} block preconditioning framework provides an environment for the development of block preconditioners for the iterative solution of linear systems by Krylov subspace methods. The framework is based on the classification of the problem\textquotesingle{}s unknowns (degrees of freedom; here abbreviated as dofs) into different \char`\"{}dof types\char`\"{} which, in a multi-\/physics context, typically represent different physical quantities. A key feature of the framework is that it allows existing block preconditioners (which were developed for a particular single-\/physics application, say) to be re-\/used, in a hierarchical fashion, in block preconditioners for related multi-\/physics problems. This means that existing Navier-\/\+Stokes and solid mechanics preconditioners can be used to create preconditioners for fluid-\/structure interaction problems, say.

Following a brief overview of the underlying ideas and their implementation in {\ttfamily oomph-\/lib} this tutorial discusses a sequence of increasingly complex block preconditioners that illustrate the framework\textquotesingle{}s capabilities in the context of a (rather artificial) model problem. The final example illustrates a simple implementation of a block preconditioner for an F\+SI problem. We conclude with a few comments on the use of block preconditioners in parallel. Other tutorials discuss how the methodology is used in \char`\"{}real\char`\"{} preconditioners. See, for instance, the tutorials discussing


\begin{DoxyItemize}
\item {\ttfamily oomph-\/lib\textquotesingle{}s} \href{../../distributed_general_purpose_block_preconditioners/html/index.html}{\tt \char`\"{}general purpose\char`\"{} block preconditioners.} ~\newline
~\newline

\item The \href{../../../preconditioners/lsc_navier_stokes/html/index.html}{\tt Navier\+Stokes\+Schur\+Complement\+Preconditioner for Navier-\/\+Stokes problems } ~\newline
~\newline

\item The \href{../../../preconditioners/fsi/html/index.html}{\tt F\+S\+I\+Preconditioner for monolithically-\/discretised fluid-\/structure interaction problems.} ~\newline
~\newline

\item The \href{../../../preconditioners/prescribed_displ_lagr_mult/html/index.html}{\tt preconditioner for large-\/displacement solid mechanics problems in which boundary displacements are prescribed.}~\newline
~\newline

\item The previous preconditioner is mainly used as a subsidiary block preconditioner for the \href{../../../preconditioners/pseudo_solid_fsi/html/index.html}{\tt solution of fluid-\/structure interaction problems with (pseudo-\/)solid fluid mesh updates.} ~\newline
~\newline

\end{DoxyItemize}\hypertarget{index_theory}{}\section{Theoretical background}\label{index_theory}
In {\ttfamily oomph-\/lib}, all problems are solved by Newton\textquotesingle{}s method, which requires the repeated solution of linear systems of the form

\[ {\bf J}\;{\bf \delta x}=-{\bf r} \]

for the Newton correction $\bf \delta x$ where ${\bf J}$ is the Jacobian matrix and $\bf r$ is the vector of residuals. (Left) preconditioning represents a transformation of the original linear system to

\[ {\bf P}^{-1}{\bf J}\;{\bf \delta x}=-{\bf P}^{-1}{\bf r}, \]

introduced with the aim of accelerating the convergence of Krylov subspace solvers such as G\+M\+R\+ES or CG. The application of the preconditioner requires the solution of

\[ {\bf P}{\bf z}={\bf y} \]

for $\bf z$ at each Krylov iteration.

Block preconditioners are based (at least formally) on a reordering of the linear system such that related unknowns (e.\+g. dofs representing the same physical quantity) are grouped together and enumerated consecutively.

For instance, in linear elasticity problems (discussed in \href{../../../linear_elasticity/periodic_load/html/index.html}{\tt another tutorial}) where we compute the displacement field of an elastic body in response to an applied traction, the (discrete) unknowns can be sub-\/divided according to which component of the displacement vector they represent. Using this classification of the dofs, the re-\/ordered linear system for a two-\/dimensional problem then has the form

\[ \left[ \begin{array}{cc} {\bf J}_{xx}&{\bf J}_{xy}\\ {\bf J}_{xy}&{\bf J}_{yy} \end{array} \right] \left[ \begin{array}{c} \bf \delta x_x\\ \bf \delta x_y\\ \end{array} \right] = - \left[ \begin{array}{c} \bf r_x\\ \bf r_y\\ \end{array} \right]. \]

A simple (and, in fact, quite effective) block preconditioner for this linear system can be formed by retaining only the diagonal blocks of the system matrix, leading to the block diagonal preconditioner

\[ {\bf P}_{diag}= \left[ \begin{array}{cc} {\bf J}_{xx}& \\ &{\bf J}_{yy} \end{array} \right]. \]

The application of this preconditioner requires the solution of the linear system

\[ \left[ \begin{array}{cc} {\bf J}_{xx}& \\ &{\bf J}_{yy} \end{array} \right] \left[ \begin{array}{c} {\bf z_x}\\ \bf z_y\\ \end{array} \right] = \left[ \begin{array}{c} \bf y_x\\ \bf y_y \end{array} \right], \]

which requires the (exact or approximate) solution of the two smaller linear systems $ {\bf J}_{xx} \ {\bf z_x} = {\bf y_x}$ and $ {\bf J}_{yy} \ {\bf z_y} = {\bf y_y}$.\hypertarget{index_generic_implementation}{}\section{Overview}\label{index_generic_implementation}
The above example shows that the application of block preconditioners typically require several generic steps\+:


\begin{DoxyEnumerate}
\item The classification of the dofs.
\item The application of subsidiary preconditioning operations such as the solution of (smaller) linear systems or the evaluation of matrix-\/vector products with some of the blocks that are extracted from the original linear system.
\end{DoxyEnumerate}

The following subsections describe how these tasks are performed within {\ttfamily oomph-\/lib\textquotesingle{}s} block preconditioning framework.\hypertarget{index_block_preconditionable_elements}{}\subsection{The classification of dof types via block preconditionable elements}\label{index_block_preconditionable_elements}
The classification of dofs is specified by the elements since they are the only objects within {\ttfamily oomph-\/lib\textquotesingle{}s} data structure that \char`\"{}know\char`\"{} what role a specific dof plays in \char`\"{}their\char`\"{} equations. During the setup phase, the block preconditioner loops over \char`\"{}all
elements\char`\"{} (specified via one or more {\ttfamily Meshes} -- here simply used as containers for elements; see below for further details) to establish the \char`\"{}dof type\char`\"{} for each global unknown.

To achieve this, the class {\ttfamily Generalised\+Element} contains two broken virtual methods that must be re-\/implemented/overloaded to label each of the element\textquotesingle{}s dofs with its type. These methods are\+:


\begin{DoxyItemize}
\item {\ttfamily Generalised\+Element\+::ndof\+\_\+types()} must return the number of dof types associated with an element.
\item {\ttfamily Generalised\+Element\+::get\+\_\+dof\+\_\+numbers\+\_\+for\+\_\+unknowns}(...) must return a list of pairs comprising a map from global equation number to dof type for all unknowns in the element.
\end{DoxyItemize}

These are already implemented for many elements. If not, the functions are easy to write. For instance, {\ttfamily oomph-\/lib\textquotesingle{}s} {\ttfamily D\+IM}-\/dimensional linear elasticity elements from the {\ttfamily Q\+Linear\+Elasticity\+Element} family can be made block-\/preconditionable by using the following wrapper class\+:

 
\begin{DoxyCodeInclude}
\textcolor{comment}{//==start\_of\_mylinearelasticityelement===============================}
\textcolor{comment}{/// Wrapper to make quadratic linear elasticity element block}
\textcolor{comment}{}\textcolor{comment}{/// preconditionable }
\textcolor{comment}{}\textcolor{comment}{//===================================================================}
\textcolor{keyword}{template}<\textcolor{keywordtype}{unsigned} DIM>
\textcolor{keyword}{class }MyLinearElasticityElement : \textcolor{keyword}{public} \textcolor{keyword}{virtual} QLinearElasticityElement<DIM,3>
\{
 
\textcolor{keyword}{public}: 
\textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short The number of "DOF types" that degrees of freedom in this element}
\textcolor{comment}{ /// are sub-divided into: The displacement components}
\textcolor{comment}{} \textcolor{keywordtype}{unsigned} ndof\_types()\textcolor{keyword}{ const}
\textcolor{keyword}{  }\{
   \textcolor{keywordflow}{return} DIM;
  \}
 \textcolor{comment}{}
\textcolor{comment}{/// Create a list of pairs for all unknowns in this element,}
\textcolor{comment}{/// so the first entry in each pair contains the global equation}
\textcolor{comment}{/// number of the unknown, while the second one contains the number}
\textcolor{comment}{/// of the "DOF type" that this unknown is associated with.}
\textcolor{comment}{/// (Function can obviously only be called if the equation numbering}
\textcolor{comment}{/// scheme has been set up.)}
\textcolor{comment}{/// }
\textcolor{comment}{/// The dof type enumeration (in 3D) is as follows:}
\textcolor{comment}{/// S\_x = 0}
\textcolor{comment}{/// S\_y = 1}
\textcolor{comment}{/// S\_z = 2}
\textcolor{comment}{/// }
\textcolor{comment}{} \textcolor{keywordtype}{void} get\_dof\_numbers\_for\_unknowns(
  std::list<std::pair<unsigned long,unsigned> >& dof\_lookup\_list)\textcolor{keyword}{ const}
\textcolor{keyword}{  }\{
   \textcolor{comment}{// number of nodes}
   \textcolor{keywordtype}{unsigned} n\_node = this->nnode();
   
   \textcolor{comment}{// temporary pair (used to store dof lookup prior to being added to list)}
   std::pair<unsigned,unsigned> dof\_lookup;
   
   \textcolor{comment}{// loop over the nodes}
   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} j=0;j<n\_node;j++)
    \{
     \textcolor{comment}{//loop over displacement components}
     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} i=0;i<DIM;i++)
      \{
       \textcolor{comment}{// determine local eqn number}
       \textcolor{keywordtype}{int} local\_eqn\_number = this->nodal\_local\_eqn(j,i);
       
       \textcolor{comment}{// ignore pinned values - far away degrees of freedom resulting }
       \textcolor{comment}{// from hanging nodes can be ignored since these are be dealt}
       \textcolor{comment}{// with by the element containing their master nodes}
       \textcolor{keywordflow}{if} (local\_eqn\_number >= 0)
        \{
         \textcolor{comment}{// store dof lookup in temporary pair: Global equation number}
         \textcolor{comment}{// is the first entry in pair}
         dof\_lookup.first = this->eqn\_number(local\_eqn\_number);
         
         \textcolor{comment}{// set dof numbers: Dof number is the second entry in pair}
         dof\_lookup.second = i;
         
         \textcolor{comment}{// add to list}
         dof\_lookup\_list.push\_front(dof\_lookup);
        \}
      \}
    \}
  \}

\};

\end{DoxyCodeInclude}


Thus, in the two-\/dimensional {\ttfamily My\+Linear\+Elasticity\+Element$<$2$>$} we have two types of dofs, corresponding to the displacements in the $x$ and $ y $ directions, respectively. They are enumerated as dof types 0 and 1, respectively.\hypertarget{index_dof_types_and_block_types}{}\subsection{dof types, blocks, compound blocks and meshes}\label{index_dof_types_and_block_types}
In the block diagonal preconditioner for the two-\/dimensional linear elasticity problem, discussed above, we have dof types that correspond directly to the blocks in the (re-\/ordered) Jacobian matrix. However, as we will demonstrate \href{#compound}{\tt below}, it is also possible to combine the blocks associated with multiple dofs into a single (compound) block in which case the number of blocks is smaller than the number of dof types. The relationship between dof types, block types, the elemental dof type classification and meshes are as follows


\begin{DoxyItemize}
\item {\bfseries Elemental} {\bfseries dof} {\bfseries type} {\bfseries classification\+:} Each element classifies its own dof types in the function {\ttfamily get\+\_\+dof\+\_\+numbers\+\_\+for\+\_\+unknowns}(...). In the case of the two-\/dimensional {\ttfamily My\+Linear\+Elasticity\+Element$<$2$>$} elements, the dof types are classified as {\ttfamily 0} and {\ttfamily 1}; for two-\/dimensional {\ttfamily Q\+Taylor\+Hood\+Element$<$2$>$} Navier-\/\+Stokes elements, the dof types are classified as {\ttfamily 0} and {\ttfamily 1} for the $ x $ and $y $-\/velocities, and {\ttfamily 2} for the pressure $ p $; etc. ~\newline
~\newline

\item {\bfseries Role} {\bfseries of} {\bfseries meshes\+:} When classifying the degrees of freedom into dof types, the block preconditioning framework visits all elements that make contributions to the Jacobian matrix and associates the global equation number of each dof with the dof type specified by the element. The block preconditioning framework is given access to the elements via (possibly multiple) meshes (here simply interpreted as containers for elements), each of which is assumed to contain elements of a single type. The total number of dof types in the block preconditioner is the sum of the dof types of the elements in the meshes. For instance, in a 2D fluid-\/structure interaction problem we have two different element types, the solid elements (which contain the $ x $ and $ y$ solid displacements, $ u_x $ and $ u_y $, respectively, assumed to be enumerated as dof types 0 and 1 by these elements) and the fluid elements (which contain the $ x $-\/ and $ y $ -\/ fluid velocities, $ v_x $ and $ v_y $ , and the pressure, $ p $, assumed to be enumerated as dof types 0, 1 and 2 by these elements). Assuming the mesh of solid elements is specified as mesh 0 and the mesh of fluid elements is mesh 1, the block preconditioner has a total of five dof types which represent, in order, $ u_x, u_y, v_x, v_y, p$. Note that if certain degrees of freedom are classified by multiple elements, the most recent assignment of the dof type over-\/writes previous assignments. The order in which meshes are specified therefore matters. ~\newline
 A corollary to this is that a block preconditioner does not need to \char`\"{}know\char`\"{} about elements that do not introduce any new unknowns. For instance, {\ttfamily Face\+Elements} that apply Neumann/flux boundary conditions operate on dofs that are already contained in (and therefore classified by) the elements in the \char`\"{}bulk\char`\"{} mesh. Conversely, if a {\ttfamily Face\+Element} imposes a boundary condition via Lagrange-\/multipliers, the dofs that represent these Lagrange multipliers must be classified by the {\ttfamily Face\+Elements} since the \char`\"{}bulk elements\char`\"{} are not aware of them. ~\newline
 If {\ttfamily oomph-\/lib} is compiled with the {\ttfamily P\+A\+R\+A\+N\+O\+ID} flag, an error is thrown if any of the global unknowns are not associated with a dof type.~\newline
~\newline

\item {\bfseries Blocks\+:} The blocks are the sub-\/blocks of the system matrix (usually the Jacobian matrix from the Newton method) that the block preconditioner works with. By default, each block is associated with exactly one dof type. However, it is possible create \char`\"{}compound blocks\char`\"{} that are associated with more than one dof type. For example, in the Navier-\/\+Stokes L\+SC preconditioner (in 2D) we have three dof types (the $x$ and $y$-\/velocities and the pressure), but the preconditioner works with just two block types (forming the velocity and pressure blocks). The setup of the block types is handled by the function {\ttfamily block\+\_\+setup}(...) discussed below.
\end{DoxyItemize}\hypertarget{index_multi_poisson}{}\section{Simple preconditioner examples}\label{index_multi_poisson}
We will now illustrate the capabilities of the block preconditioning framework by considering the system of $ N $ coupled P\+D\+Es \[ \left( \frac{\partial^2 u_i}{\partial x_j^2} + \beta \sum_{k=1}^{N} u_k \right) = f_i(x_j) \ \ \ \ i=1,...,N \ \ \ \ \ \ \ \ \ \ \ \ (1) \] for the $ N $ fields $ u_i(x_j) $. If $ \beta=0 $, the system represents $ N $ (uncoupled) Poisson equations, each with their own source function $ f_i(x_j). $ If $ \beta \ne 0 $ the P\+DE for $ u_i(x_j) $ is affected by all other fields via the Helmholtz-\/like second term on the left-\/hand-\/side.

The {\ttfamily Multi\+Poisson\+Elements} discretise the equations with standard Galerkin-\/type finite elements in which each field is treated as its own dof type. If $ N = 5, $ the linear system to be solved in the course of the Newton method, \[ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ {\bf J} \ \delta {\bf x} = -{\bf r}, \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (2) \] has a $5 \times 5$ block structure implying that, following a formal re-\/numbering of the unknowns, the matrix and the vectors can be written as \[ \hspace{3cm} {\bf J} = \left( \begin{array}{ccccc} J_{11} & J_{12} & J_{13} & J_{14} & J_{15} \\ J_{21} & J_{22} & J_{23} & J_{24} & J_{25} \\ J_{31} & J_{32} & J_{33} & J_{34} & J_{35} \\ J_{41} & J_{42} & J_{43} & J_{44} & J_{45} \\ J_{51} & J_{52} & J_{53} & J_{54} & J_{55} \\ \end{array} \right), \ \ \delta {\bf x} = \left( \begin{array}{c} \delta x_{1} \\ \delta x_{2} \\ \delta x_{3} \\ \delta x_{4} \\ \delta x_{5} \\ \end{array} \right) \ \mbox{ and } \ {\bf r} = \left( \begin{array}{c} r_{1} \\ r_{2} \\ r_{3} \\ r_{4} \\ r_{5} \\ \end{array} \right). \hspace{3cm} (3) \] We wish to solve this linear system by preconditioned Krylov subspace methods, using a block preconditioner ${\bf P}$ formed (formally) from the blocks of the system matrix ${\bf }J$. As discussed above, the application of the preconditioner (typically once per iteration of the Krylov solver) then requires the solution of linear systems of the form $ {\bf P} {\bf y} = {\bf z}, $ for ${\bf y}$. The preconditioning operation can also be written as $ {\bf y} = {\bf P}^{-1} {\bf z} $ where the operator ${\bf P}^{-1}$ represents the application of the preconditioner to a vector ${\bf z}$. Formally, the operator ${\bf P}^{-1}$ represents the inverse of the matrix ${\bf P}$ but its application may, of course, be performed approximately by another ``subsidiary\textquotesingle{}\textquotesingle{} preconditioner/inexact solver e.\+g. by performing a small number of multigrid cycles, say. (Note that we say ``formally\textquotesingle{}\textquotesingle{} because the preconditioner does not actually have to be associated with a specific matrix -- it simply has to act as a linear operator that ``turns ${\bf z}$ into ${\bf y}$\textquotesingle{}\textquotesingle{}).

A specific block preconditioner must be derived from the {\ttfamily Block\+Preconditioner} base class and must implement two pure virtual member functions of the underlying {\ttfamily Preconditioner} class\+:
\begin{DoxyItemize}
\item {\ttfamily void} {\ttfamily Preconditioner\+::setup()}\+: This function is called once during the solution of a given linear system by any of {\ttfamily oomph-\/lib} \textquotesingle{}s Krylov subspace solvers. It typically extracts a certain number of blocks from the matrix ${\bf J}$, possibly manipulates its local copies of these blocks, and performs any preliminary computations required to allow the rapid subsequent application of ${\bf P}^{-1}$.
\item {\ttfamily void} {\ttfamily Preconditioner\+::preconditioner\+\_\+solve}( $\bf{z}$, $\bf{y}$)\+: This function applies ${\bf P}^{-1}$ to the input argument ${\bf z}$ and computes ${\bf y}$, typically using some data that has been pre-\/computed in the {\ttfamily setup()} function.
\end{DoxyItemize}

To allow a block preconditioner to classify all dofs, the preconditioner must be given access to all elements that contribute to the linear system to be solved. This is done by specifying pointers to these elements via one or more {\ttfamily Mesh} objects (which simply act as containers for the element pointers), using the functions {\ttfamily set\+\_\+nmesh}(...) (which specifies how many meshes the preconditioner works with) and {\ttfamily set\+\_\+mesh}(...).

We will discuss the implementation of the required functions (and associated capabilities of the block preconditioning framework) in a number of increasingly complex block preconditioners for the solution of the $5 \times 5$ linear system defined by equations (2) and (3). We stress that the purpose of this exercise is not the development of particularly clever preconditioners but simply an excuse to demonstrate the use of the available ``machinery\textquotesingle{}\textquotesingle{}. Specifically we will demonstrate how to\+:


\begin{DoxyItemize}
\item extract selected blocks from the system matrix (usually the Jacobian matrix assembled by the Newton solver).
\item perform matrix vector products with selected off-\/diagonal blocks.
\item solve linear systems associated with selected blocks, using either a direct solver and/or subsidiary preconditioners (inexact solvers), including cases where the subsidiary preconditioners are block preconditioners themselves.
\item replace and modify selected blocks and how to make such modified blocks available to subsidiary block preconditioners.
\item concatenate and coarsen blocks.
\end{DoxyItemize}



 

\hypertarget{index_diagonal}{}\subsection{A block diagonal preconditioner}\label{index_diagonal}
N\+EW F\+E\+A\+T\+U\+R\+ES\+: How to extract matrix blocks and corresponding block vectors from their full-\/size counterparts\hypertarget{index_diag_theory}{}\subsubsection{Theory}\label{index_diag_theory}
The simplest possible block preconditioner is a block-\/diagonal preconditioner, formed by retaining only the diagonal blocks of ${\bf J}$, so that \[ \hspace{3cm} {\bf P} = \left( \begin{array}{ccccc} J_{11} & & & & \\ & J_{22} & & & \\ & & J_{33} & & \\ & & & J_{44} & \\ & & & & J_{55} \\ \end{array} \right). \hspace{3cm} (4) \] The application of this preconditioner (i.\+e. the solution of the linear system ${\bf P} {\bf y} ={\bf z}$ for ${\bf y}$) requires the solution of the five much smaller linear systems \[ \hspace{3cm} \begin{array}{c} {\bf J}_{11} \ {\bf y}_1 = {\bf z}_1, \\ {\bf J}_{22} \ {\bf y}_2 = {\bf z}_2, \\ {\bf J}_{33} \ {\bf y}_3 = {\bf z}_3, \\ {\bf J}_{44} \ {\bf y}_4 = {\bf z}_4, \\ {\bf J}_{55} \ {\bf y}_5 = {\bf z}_5, \\ \end{array} \hspace{3cm} (5) \] where we have assumed that the two vectors ${\bf y}$ and ${\bf z}$ are re-\/ordered into ``block vectors\textquotesingle{}\textquotesingle{} in the same way as the vectors $\delta {\bf x}$ and ${\bf r}$ in \char`\"{}the original linear system\char`\"{} (2) are re-\/ordered into the ``block vectors\textquotesingle{}\textquotesingle{} in (3).

The implementation of the preconditioning operations in (5) can naturally be subdivided into two distinct {\ttfamily setup()} and {\ttfamily preconditioner\+\_\+solve}(...) phases. Assuming that the linear systems in (5) are solved exactly by a direct solver (an ``exact preconditioner\textquotesingle{}\textquotesingle{}) that can pre-\/compute and store the LU decomposition of the diagonal matrix blocks, the {\ttfamily setup()} phase involves the following operations \mbox{[}text in square brackets refers to their {\ttfamily oomph-\/lib} -\/specific implementation\mbox{]}\+:
\begin{DoxyItemize}
\item Set up any data structures/lookup tables that are required to extract matrix blocks from the original matrix ${\bf J}$ \mbox{[}by calling the {\ttfamily Block\+Preconditioner\+::block\+\_\+setup()} function\mbox{]}.
\item Extract the five diagonal blocks ${\bf J}_{ii}$ (for $i=1,...,5$) \mbox{[}using the {\ttfamily Block\+Preconditioner\+::get\+\_\+block}(...) function\mbox{]}.
\item Compute and store the LU decomposition of the diagonal blocks to allow the rapid solution of the systems ${\bf J}_{ii} \ {\bf y}_i = {\bf z}_i$ (for $i=1,...,5$) during the {\ttfamily preconditioner\+\_\+solve}(...) phase by back-\/substitution. \mbox{[}This is done by calling the {\ttfamily setup}(...) function of the subsidiary preconditioner/inexact solver. Following this, the diagonal matrix blocks are longer required and can be deleted.\mbox{]}
\end{DoxyItemize}

Once the {\ttfamily setup()} phase has been completed, the solution of the linear system ${\bf P} {\bf y} = {\bf z}$ by the {\ttfamily preconditioner\+\_\+solve}(...) function involves the following steps\+:
\begin{DoxyItemize}
\item Extract the five ``block vectors\textquotesingle{}\textquotesingle{} ${\bf z}_i$ (for $i=1,...,5$) from the vector ${\bf z}$ \mbox{[}using the {\ttfamily Block\+Preconditioner\+::get\+\_\+block\+\_\+vectors}(...) function\mbox{]}.
\item Solve the linear systems ${\bf J}_{ii} \ {\bf y}_i = {\bf z}_i$ for the vectors ${\bf y}_i$ (for $i=1,...,5$) using the precomputed LU decomposition of the diagonal blocks ${\bf J}_{ii}$ (for $i=1,...,5$) created during the {\ttfamily setup()} phase.
\item Combine the five ``block vectors\textquotesingle{}\textquotesingle{} ${\bf y}_i$ (for $i=1,...,5$) to the full-\/length vector ${\bf y}$ \mbox{[}using the {\ttfamily Block\+Preconditioner\+::return\+\_\+block\+\_\+vectors}(...) function\mbox{]}.
\end{DoxyItemize}\hypertarget{index_diag_implementation}{}\subsubsection{Implementation as a Block\+Preconditioner}\label{index_diag_implementation}
Here is a sample implementation of the diagonal block preconditioner as a class {\ttfamily Diagonal}, derived from the {\ttfamily Block\+Preconditioner} base class. The class provides storage for the subsidiary preconditioners that solve the linear systems associated with the diagonal blocks, implements the {\ttfamily setup()} and {\ttfamily preconditioner\+\_\+solve}(...) functions, and provides a helper function {\ttfamily clean\+\_\+up\+\_\+my\+\_\+memory()} which does what it says. We also provide an access function which allows the user to specify the pointer to the {\ttfamily Mesh} that contains the {\ttfamily Multi\+Poisson\+Elements} which classify the dofs.

 
\begin{DoxyCodeInclude}
\textcolor{comment}{//=========================start\_of\_diagonal\_class=============================}
\textcolor{comment}{/// \(\backslash\)short Simple proof-of-concept block diagonal preconditioner for}
\textcolor{comment}{}\textcolor{comment}{/// demo purposes. There's a much better version in src/generic!}
\textcolor{comment}{}\textcolor{comment}{//=============================================================================}
 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MATRIX> 
 \textcolor{keyword}{class }Diagonal : \textcolor{keyword}{public} BlockPreconditioner<MATRIX>
 \{
  
 public :
  \textcolor{comment}{}
\textcolor{comment}{  /// Constructor for Diagonal preconditioner}
\textcolor{comment}{}  Diagonal() : BlockPreconditioner<MATRIX>()
   \{
    Multi\_poisson\_mesh\_pt=0;
   \} \textcolor{comment}{// end\_of\_constructor}

 \textcolor{comment}{}
\textcolor{comment}{  /// \(\backslash\)short Destructor - delete the subsidiary preconditioners (solvers for}
\textcolor{comment}{  /// linear systems involving diagonal block)}
\textcolor{comment}{}  ~Diagonal()
   \{
    this->clean\_up\_my\_memory();
   \}
  \textcolor{comment}{}
\textcolor{comment}{  /// clean up the memory}
\textcolor{comment}{}  \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} clean\_up\_my\_memory();
     \textcolor{comment}{}
\textcolor{comment}{  /// Broken copy constructor}
\textcolor{comment}{}  Diagonal(\textcolor{keyword}{const} Diagonal&) 
   \{ 
    BrokenCopy::broken\_copy(\textcolor{stringliteral}{"Diagonal"});
   \} 
 \textcolor{comment}{}
\textcolor{comment}{  /// Broken assignment operator}
\textcolor{comment}{}  \textcolor{keywordtype}{void} operator=(\textcolor{keyword}{const} Diagonal&) 
   \{
    BrokenCopy::broken\_assign(\textcolor{stringliteral}{"Diagonal"});
   \}

\textcolor{comment}{}
\textcolor{comment}{  /// \(\backslash\)short Setup the preconditioner }
\textcolor{comment}{}  \textcolor{keywordtype}{void} setup();
  
  \textcolor{comment}{// Use the version in the Preconditioner base class for the alternative}
  \textcolor{comment}{// setup function that takes a matrix pointer as an argument.}
  \textcolor{keyword}{using} Preconditioner::setup;
\textcolor{comment}{}
\textcolor{comment}{  /// Apply preconditioner to r, i.e. return solution of P z = r}
\textcolor{comment}{}  \textcolor{keywordtype}{void} preconditioner\_solve(\textcolor{keyword}{const} DoubleVector &r, DoubleVector &z);

\textcolor{comment}{}
\textcolor{comment}{  /// Specify the mesh that contains multi-poisson elements}
\textcolor{comment}{}  \textcolor{keywordtype}{void} set\_multi\_poisson\_mesh(Mesh* multi\_poisson\_mesh\_pt)
  \{
   Multi\_poisson\_mesh\_pt=multi\_poisson\_mesh\_pt;
  \}

 private :
  \textcolor{comment}{}
\textcolor{comment}{  /// \(\backslash\)short Vector of pointers to preconditioners/inexact solvers }
\textcolor{comment}{  /// for each diagonal block}
\textcolor{comment}{}  Vector<Preconditioner*> Diagonal\_block\_preconditioner\_pt;
  \textcolor{comment}{}
\textcolor{comment}{  /// \(\backslash\)short Mesh pointers with preconditionable elements used}
\textcolor{comment}{  /// for classification of dof types.}
\textcolor{comment}{}  Mesh* Multi\_poisson\_mesh\_pt;

 \};

\end{DoxyCodeInclude}
\hypertarget{index_diag_setup}{}\subsubsection{The setup() function}\label{index_diag_setup}
As mentioned above, a {\ttfamily Preconditioner\textquotesingle{}s} {\ttfamily setup()} function is called at the beginning of the {\ttfamily Iterative\+Linear\+Solver\textquotesingle{}s} {\ttfamily solve}(...) function. In time-\/dependent and/or nonlinear problems many (different) linear systems have to be solved by the same linear solver (and the associated preconditioner) throughout the code execution. To avoid memory leaks it is therefore important to free up any memory that may have been allocated in any previous use of the preconditioner. The {\ttfamily setup()} function of all block preconditioner should therefore always start by freeing up such memory. This is best done by using a helper function that can also be called from the destructor.


\begin{DoxyCodeInclude}
 \textcolor{comment}{//=========================start\_of\_setup\_for\_simple========================}\textcolor{comment}{}
\textcolor{comment}{ /// The setup function.}
\textcolor{comment}{} \textcolor{comment}{//============================================================================}
 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MATRIX> 
 \textcolor{keywordtype}{void} Diagonal<MATRIX>::setup()
 \{
  \textcolor{comment}{// clean the memory}
  this->clean\_up\_my\_memory();

\end{DoxyCodeInclude}


Next we set the pointer to the preconditioner\textquotesingle{}s one-\/and-\/only mesh, and call the {\ttfamily block\+\_\+setup()} function to set up the internal data structures and lookup tables required to extract blocks from the system matrix.


\begin{DoxyCodeInclude}


\textcolor{preprocessor}{#ifdef PARANOID}
  \textcolor{keywordflow}{if} (Multi\_poisson\_mesh\_pt == 0)
   \{
    std::stringstream err;
    err << \textcolor{stringliteral}{"Please set pointer to mesh using set\_multi\_poisson\_mesh(...).\(\backslash\)n"};
    \textcolor{keywordflow}{throw} OomphLibError(err.str(),
                        OOMPH\_CURRENT\_FUNCTION,
                        OOMPH\_EXCEPTION\_LOCATION);
   \}
\textcolor{preprocessor}{#endif }
  
  \textcolor{comment}{// The preconditioner works with one mesh; set it!}
  this->set\_nmesh(1);
  this->set\_mesh(0,Multi\_poisson\_mesh\_pt);
  
  \textcolor{comment}{// Set up the generic block lookup scheme}
  this->block\_setup();

\end{DoxyCodeInclude}


We create five subsidiary preconditioners (all exact solvers -- Super\+LU in its incarnation as an \char`\"{}exact\char`\"{} preconditioner) for the solution of the linear systems involving the diagonal blocks\+:


\begin{DoxyCodeInclude}
  \textcolor{comment}{// Extract the number of blocks}
  \textcolor{keywordtype}{unsigned} nblock\_types = this->nblock\_types();

  \textcolor{comment}{// Create the subsidiary preconditioners}
  Diagonal\_block\_preconditioner\_pt.resize(nblock\_types);
  \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} i=0;i<nblock\_types;i++)
   \{
    Diagonal\_block\_preconditioner\_pt[i] = \textcolor{keyword}{new} SuperLUPreconditioner;
   \}

\end{DoxyCodeInclude}


Next we set up the subsidiary preconditioner by extracting the diagonal blocks from the system matrix and passing them to the subsidiary preconditioners.

Note that each preconditioner is expected to retain a copy of whatever data it needs to subsequently perform its {\ttfamily preconditioner\+\_\+solve}(...) function. The deep copy of the block that is returned by the {\ttfamily get\+\_\+block}(...) function can therefore be deleted (here simply go out of scope) once the subsidiary preconditioner has been set up. (In the specific case of the {\ttfamily Super\+L\+U\+Preconditioner}, the {\ttfamily setup}(...) function computes and stores the LU decomposition of the matrix; the matrix itself is then no longer required).


\begin{DoxyCodeInclude}
  \textcolor{comment}{// Setup preconditioners}
  \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} i=0;i<nblock\_types;i++)
   \{
    \textcolor{comment}{// Get block -- this makes a deep copy of the relevant entries in the}
    \textcolor{comment}{// full Jacobian (i.e. the matrix of the linear system we're}
    \textcolor{comment}{// actually trying to solve); we can do with this copy whatever}
    \textcolor{comment}{// we want...}
    CRDoubleMatrix block;
    this->get\_block(i,i,block);
    
    \textcolor{comment}{// Set up preconditioner (i.e. lu-decompose the block)}
    Diagonal\_block\_preconditioner\_pt[i]->setup(&block);
    
    \textcolor{comment}{// Done with this block now, so the diagonal block that we extracted}
    \textcolor{comment}{// above can go out of scope. Its LU decomposition (which is the only }
    \textcolor{comment}{// thing we need to apply the preconditioner in the preconditioner\_solve(...)}
    \textcolor{comment}{// function) is retained in the associated sub-preconditioner/(in)exact }
    \textcolor{comment}{// solver(SuperLU).}
   \}

\end{DoxyCodeInclude}
\hypertarget{index_diag_solve}{}\subsubsection{The preconditioner\+\_\+solve() function}\label{index_diag_solve}
To apply the preconditioner to a given vector, r, we first extract the five block-\/vectors whose sizes (and permutations) match that of the diagonal matrix blocks, using the {\ttfamily get\+\_\+block\+\_\+vectors}(...) function.


\begin{DoxyCodeInclude}
 \textcolor{comment}{//============================================================================}\textcolor{comment}{}
\textcolor{comment}{ /// Preconditioner solve for the diagonal preconditioner: }
\textcolor{comment}{ /// Apply preconditioner to r and return z, so that P z = r, where}
\textcolor{comment}{ /// P is the block diagonal matrix constructed from the original }
\textcolor{comment}{ /// linear system.}
\textcolor{comment}{} \textcolor{comment}{//============================================================================}
 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MATRIX> 
 \textcolor{keywordtype}{void} Diagonal<MATRIX>::
 preconditioner\_solve(\textcolor{keyword}{const} DoubleVector& r, DoubleVector& z)
 \{   
  \textcolor{comment}{// Get number of blocks}
  \textcolor{keywordtype}{unsigned} nblock\_types = this->nblock\_types();

  \textcolor{comment}{// Split up rhs vector into sub-vectors, re-arranged to match}
  \textcolor{comment}{// the matrix blocks}
  Vector<DoubleVector> block\_r;
  this->get\_block\_vectors(r,block\_r);

\end{DoxyCodeInclude}


We then provide storage for the five solution vectors and compute them by applying the subsidiary preconditioners\textquotesingle{} {\ttfamily preconditioner\+\_\+solve}(...) function\+:


\begin{DoxyCodeInclude}
  \textcolor{comment}{// Solution of block solves}
  Vector<DoubleVector> block\_z(nblock\_types);
  \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} i = 0; i < nblock\_types; i++)
   \{
    Diagonal\_block\_preconditioner\_pt[i]->preconditioner\_solve(block\_r[i],
                                                              block\_z[i]);
   \}

\end{DoxyCodeInclude}


Finally the solutions in {\ttfamily block\+\_\+z} are returned into the full-\/length solution vector {\ttfamily z} via a call to {\ttfamily return\+\_\+block\+\_\+vectors}(...).


\begin{DoxyCodeInclude}
  \textcolor{comment}{// Copy solution in block vectors block\_z back to z}
  this->return\_block\_vectors(block\_z,z);
 \}

\end{DoxyCodeInclude}
\hypertarget{index_diag_clean}{}\subsubsection{The clean\+\_\+up\+\_\+my\+\_\+memory() function}\label{index_diag_clean}
This function (which is called by the {\ttfamily setup()} function and the destructor) frees the memory that is allocated when a new linear system is solved -- here the subsidiary preconditioners and their associated data (the LU decompositions of the diagonal blocks).


\begin{DoxyCodeInclude}
 \textcolor{comment}{//=========================start\_of\_clean\_up\_for\_simple=======================}\textcolor{comment}{}
\textcolor{comment}{ /// The clean up function.}
\textcolor{comment}{} \textcolor{comment}{//============================================================================}
 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MATRIX> 
 \textcolor{keywordtype}{void} Diagonal<MATRIX>::clean\_up\_my\_memory()
 \{ 
  \textcolor{comment}{// Delete diagonal preconditioners (approximate solvers)}
  \textcolor{keywordtype}{unsigned} n\_block = Diagonal\_block\_preconditioner\_pt.size();
  \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} i=0;i<n\_block;i++)
   \{
    \textcolor{keywordflow}{if}(Diagonal\_block\_preconditioner\_pt[i]!=0)
     \{
      \textcolor{keyword}{delete} Diagonal\_block\_preconditioner\_pt[i];
      Diagonal\_block\_preconditioner\_pt[i]=0;
     \}
   \}
 \} \textcolor{comment}{// End of clean\_up\_my\_memory function.}

\end{DoxyCodeInclude}
\hypertarget{index_diag_comments}{}\subsubsection{Comments and Exercises}\label{index_diag_comments}

\begin{DoxyItemize}
\item {\ttfamily The} function {\ttfamily get\+\_\+block\+\_\+vectors(r,block\+\_\+r)} extracts the five (or, in general, {\ttfamily nblock\+\_\+type()} ) block vectors {\ttfamily block\+\_\+r} from the full-\/length vector {\ttfamily r}. The sizes of the block vectors (and the permutation of their entries relative to their order in the full length vector {\ttfamily r}) match that of the matrix blocks. There is an alternative function {\ttfamily get\+\_\+block\+\_\+vector}(...) (note the missing s) which extracts a single block vector. An equivalent version exists for the {\ttfamily return\+\_\+block\+\_\+vector}\mbox{[}s\mbox{]} functions.
\item In the example above we used an \char`\"{}exact preconditioner\char`\"{} (direct solver) to solve the five linear systems associated with the diagonal blocks. However, the (approximate) solution of these linear systems can be performed by any other matrix-\/based preconditioner, such as {\ttfamily oomph-\/lib\textquotesingle{}s} diagonal preconditioner, {\ttfamily Matrix\+Based\+Diag\+Preconditioner}, discussed in \href{../../../linear_solvers/html/index.html}{\tt another tutorial}. The setup and application of this preconditioner is obviously much faster than for the {\ttfamily Super\+L\+U\+Preconditioner}. Its setup merely requires the extraction of the diagonal entries and storage of their inverses (rather than the computation of the LU decomposition), while the application simply requires the multiplication of the input vector by the pre-\/computed inverses of the diagonal entries (rather than a back-\/substitution). However, the preconditioner is clearly not \char`\"{}as good\char`\"{} and therefore results in a larger number of iterations in the iterative linear solver. In fact, using the diagonal preconditioner for the approximate solution of the five linear systems involving the diagonal blocks is mathematically equivalent to using the diagonal preconditioner on the entire matrix. Try it out!
\end{DoxyItemize}



 

\hypertarget{index_upper_triangular}{}\subsection{A block upper triangular preconditioner}\label{index_upper_triangular}
N\+EW F\+E\+A\+T\+U\+R\+ES\+: How to set up matrix vector products with off-\/diagonal blocks\hypertarget{index_upper_triangular_theory}{}\subsubsection{Theory}\label{index_upper_triangular_theory}
Next we consider the implementation of an upper triangular preconditioner, formed by retaining only the blocks in the upper right hand part of ${\bf J}$, including the diagonals. \[ \hspace{3cm} {\bf P} = \left( \begin{array}{ccccc} J_{11} & J_{12} & J_{13} & J_{14} & J_{15} \\ & J_{22} & J_{23} & J_{24} & J_{25} \\ & & J_{33} & J_{34} & J_{35} \\ & & & J_{44} & J_{45} \\ & & & & J_{55} \\ \end{array} \right). \hspace{3cm} (6) \] The application of this preconditioner (i.\+e. the solution of the linear system ${\bf P} {\bf y} ={\bf z}$ for ${\bf y}$) again requires the solution of five much smaller linear systems \[ \hspace{3cm} \begin{array}{l} {\bf J}_{11} \ {\bf y}_1 = \widetilde{\bf z}_1 = {\bf z}_1 - {\bf J}_{15} \ {\bf y}_5 - {\bf J}_{14} \ {\bf y}_4 - {\bf J}_{13} \ {\bf y}_3 - {\bf J}_{12} \ {\bf y}_2, \\ {\bf J}_{22} \ {\bf y}_2 = \widetilde{\bf z}_2 = {\bf z}_2 - {\bf J}_{25} \ {\bf y}_5 - {\bf J}_{24} \ {\bf y}_4 - {\bf J}_{23} \ {\bf y}_3, \\ {\bf J}_{33} \ {\bf y}_3 = \widetilde{\bf z}_3 ={\bf z}_3 - {\bf J}_{35} \ {\bf y}_5 - {\bf J}_{34} \ {\bf y}_4, \\ {\bf J}_{44} \ {\bf y}_4 = \widetilde{\bf z}_4 ={\bf z}_4 - {\bf J}_{45} \ {\bf y}_5, \\ {\bf J}_{55} \ {\bf y}_5 = \widetilde{\bf z}_5 = {\bf z}_5, \\ \end{array} \hspace{3cm} (7) \] where we have again assumed that the two vectors ${\bf y}$ and ${\bf z}$ are re-\/ordered into ``block vectors\textquotesingle{}\textquotesingle{} in the same way as the vectors $\delta {\bf x}$ and ${\bf r}$ in \char`\"{}the original linear system\char`\"{} (2) are re-\/ordered into the ``block vectors\textquotesingle{}\textquotesingle{} in (3).

The main difference to the block diagonal preconditioner considered before is that the right hand sides of the linear systems have to be modified. We start by solving the final equation for $ {\bf y}_5 $. We then multiply this vector by the off-\/diagonal block $ {\bf J}_{45} $, subtract the result from $ {\bf z}_4 $ and use the result of this operation as the right-\/hand-\/side for the linear system that determines $ {\bf y}_4$, etc.

The implementation of the preconditioning operations in (7) can again be subdivided into two distinct {\ttfamily setup()} and {\ttfamily preconditioner\+\_\+solve}(...) phases. Assuming that the linear systems in (7) are solved exactly by a direct solver (an ``exact preconditioner\textquotesingle{}\textquotesingle{}) that can pre-\/compute and store the LU decomposition of the diagonal matrix blocks, the {\ttfamily setup()} phase involves the following operations \mbox{[}text in square brackets refers to their {\ttfamily oomph-\/lib} specific implementation\mbox{]}\+:
\begin{DoxyItemize}
\item Set up any data structures/lookup tables that are required to extract matrix blocks from the original matrix ${\bf J}$ \mbox{[}by calling the {\ttfamily Block\+Preconditioner\+::block\+\_\+setup()} function\mbox{]}.
\item Extract the five diagonal blocks ${\bf J}_{ii}$ (for $i=1,...,5$) \mbox{[}using the {\ttfamily Block\+Preconditioner\+::get\+\_\+block}(...) function\mbox{]}.
\item Compute and store the LU decomposition of the diagonal blocks to allow the rapid solution of the systems ${\bf J}_{ii} \ {\bf y}_i = \widetilde{\bf z}_i$ (for $i=1,...,5$) during the {\ttfamily preconditioner\+\_\+solve}(...) phase by back-\/substitution. \mbox{[}This is done by calling the {\ttfamily setup}(...) function of the subsidiary preconditioner/inexact solver. Following this, the diagonal matrix blocks are longer required and can be deleted.\mbox{]}
\item Extract the relevant off-\/diagonal blocks from ${\bf J}$ and create {\ttfamily Matrix\+Vector\+Product} operators. \mbox{[}The matrix vector products are set up using the {\ttfamily setup\+\_\+matrix\+\_\+vector\+\_\+product}(...) function. As with the subsidiary preconditioners, the {\ttfamily Matrix\+Vector\+Product} operators retain their own copy of any required data, so the off-\/diagonal matrix blocks can be deleted (or be allowed to go out of scope) following the setup.\mbox{]}
\end{DoxyItemize}\hypertarget{index_upper_triangular_implementation}{}\subsubsection{Implementation as a Block\+Preconditioner}\label{index_upper_triangular_implementation}
Here is a sample implementation of the upper triangular block preconditioner as a class {\ttfamily Upper\+Triangular}, derived from the {\ttfamily Block\+Preconditioner} base class. The class provides storage for the subsidiary preconditioners that solve the linear systems associated with the diagonal blocks, and the {\ttfamily Matrix\+Vector\+Product} operators. We also implement the {\ttfamily setup()} and {\ttfamily preconditioner\+\_\+solve}(...) functions, and provide a helper function {\ttfamily clean\+\_\+up\+\_\+my\+\_\+memory()} which does what it says. As before we also provide an access function which allows the user to specify the pointer to the {\ttfamily Mesh} that contains the {\ttfamily Multi\+Poisson\+Elements} which classify the dofs.

 
\begin{DoxyCodeInclude}
\textcolor{comment}{//=========================start\_of\_upper\_triangular\_class=====================}
\textcolor{comment}{/// \(\backslash\)short Upper triangular preconditioner for a system }
\textcolor{comment}{}\textcolor{comment}{/// with any number of dof types.}
\textcolor{comment}{}\textcolor{comment}{//=============================================================================}
 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MATRIX> 
 \textcolor{keyword}{class }UpperTriangular : \textcolor{keyword}{public} BlockPreconditioner<MATRIX>
 \{
 
 public :
 \textcolor{comment}{}
\textcolor{comment}{  /// Constructor.}
\textcolor{comment}{}  UpperTriangular() : BlockPreconditioner<MATRIX>()
   \{
    Multi\_poisson\_mesh\_pt=0;
   \}
 \textcolor{comment}{}
\textcolor{comment}{  /// Destructor - delete the preconditioner matrices}
\textcolor{comment}{}  \textcolor{keyword}{virtual} ~UpperTriangular()
   \{
    this->clean\_up\_my\_memory();
   \}
\textcolor{comment}{}
\textcolor{comment}{  /// clean up the memory}
\textcolor{comment}{}  \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} clean\_up\_my\_memory();
 \textcolor{comment}{}
\textcolor{comment}{  /// Broken copy constructor}
\textcolor{comment}{}  UpperTriangular(\textcolor{keyword}{const} UpperTriangular&) 
   \{ 
    BrokenCopy::broken\_copy(\textcolor{stringliteral}{"UpperTriangular"});
   \} 
  \textcolor{comment}{}
\textcolor{comment}{  /// Broken assignment operator}
\textcolor{comment}{}  \textcolor{keywordtype}{void} operator=(\textcolor{keyword}{const} UpperTriangular&) 
   \{
    BrokenCopy::broken\_assign(\textcolor{stringliteral}{"UpperTriangular"});
   \}
  \textcolor{comment}{}
\textcolor{comment}{  /// Apply preconditioner to r}
\textcolor{comment}{}  \textcolor{keywordtype}{void} preconditioner\_solve(\textcolor{keyword}{const} DoubleVector &r, DoubleVector &z);
 \textcolor{comment}{}
\textcolor{comment}{  /// \(\backslash\)short Setup the preconditioner }
\textcolor{comment}{}  \textcolor{keywordtype}{void} setup();
  
  \textcolor{comment}{// Use the version in the Preconditioner base class for the alternative}
  \textcolor{comment}{// setup function that takes a matrix pointer as an argument.}
  \textcolor{keyword}{using} Preconditioner::setup;
\textcolor{comment}{}
\textcolor{comment}{  /// Specify the mesh that contains multi-poisson elements}
\textcolor{comment}{}  \textcolor{keywordtype}{void} set\_multi\_poisson\_mesh(Mesh* multi\_poisson\_mesh\_pt)
  \{
   Multi\_poisson\_mesh\_pt=multi\_poisson\_mesh\_pt;
  \}

 \textcolor{keyword}{private}:  
\textcolor{comment}{}
\textcolor{comment}{  /// Pointers to matrix vector product operators for the off diagonals}
\textcolor{comment}{}  DenseMatrix<MatrixVectorProduct*> Off\_diagonal\_matrix\_vector\_product\_pt;
\textcolor{comment}{}
\textcolor{comment}{  /// \(\backslash\)short Vector of pointers to preconditioners/inexact solvers }
\textcolor{comment}{  /// for each diagonal block}
\textcolor{comment}{}  Vector<Preconditioner*> Block\_preconditioner\_pt;
\textcolor{comment}{}
\textcolor{comment}{  /// \(\backslash\)short Pointer to mesh with preconditionable elements used}
\textcolor{comment}{  /// for classification of dof types.}
\textcolor{comment}{}  Mesh* Multi\_poisson\_mesh\_pt;

 \};

\end{DoxyCodeInclude}
\hypertarget{index_upper_triangular_setup}{}\subsubsection{The setup() function}\label{index_upper_triangular_setup}
As before, we start by cleaning up the memory, set the pointer to the mesh, and set up the generic block preconditioner functionality by calling {\ttfamily block\+\_\+setup()}.


\begin{DoxyCodeInclude}
 \textcolor{comment}{//========================start\_of\_setup\_for\_upper\_triangular\_class===========}\textcolor{comment}{}
\textcolor{comment}{ /// The setup function.}
\textcolor{comment}{} \textcolor{comment}{//============================================================================}
 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MATRIX> 
 \textcolor{keywordtype}{void} UpperTriangular<MATRIX>::setup()
 \{
  \textcolor{comment}{// clean the memory}
  this->clean\_up\_my\_memory();

\textcolor{preprocessor}{#ifdef PARANOID}
  \textcolor{keywordflow}{if} (Multi\_poisson\_mesh\_pt == 0)
   \{
    std::stringstream err;
    err << \textcolor{stringliteral}{"Please set pointer to mesh using set\_multi\_poisson\_mesh(...).\(\backslash\)n"};
    \textcolor{keywordflow}{throw} OomphLibError(err.str(),
                        OOMPH\_CURRENT\_FUNCTION,
                        OOMPH\_EXCEPTION\_LOCATION);
   \}
\textcolor{preprocessor}{#endif }
  
  \textcolor{comment}{// The preconditioner works with one mesh; set it!}
  this->set\_nmesh(1);
  this->set\_mesh(0,Multi\_poisson\_mesh\_pt);

  \textcolor{comment}{// Set up the block look up schemes}
  this->block\_setup();

\end{DoxyCodeInclude}


We provide storage for the (pointers to the) matrix vector products and the subsidiary preconditioners.


\begin{DoxyCodeInclude}
  \textcolor{comment}{// Number of block types  }
  \textcolor{keywordtype}{unsigned} nblock\_types = this->nblock\_types();

  \textcolor{comment}{// Storage for the pointers to the off diagonal matrix vector products}
  \textcolor{comment}{// and the the subsidiary preconditioners (inexact solvers) for the diagonal }
  \textcolor{comment}{// blocks}
  Off\_diagonal\_matrix\_vector\_product\_pt.resize(nblock\_types,nblock\_types,0);
  Block\_preconditioner\_pt.resize(nblock\_types);

\end{DoxyCodeInclude}


Next we create the subsidiary preconditioners which we will use to solve the linear systems involving the diagonal blocks.


\begin{DoxyCodeInclude}

  \textcolor{comment}{// Build the preconditioners and matrix vector products}
  \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} i = 0; i < nblock\_types; i++)
   \{
    \textcolor{comment}{// Create the subsidiary preconditioners}
    Block\_preconditioner\_pt[i] = \textcolor{keyword}{new} SuperLUPreconditioner;
    
    \textcolor{comment}{// Put in braces so block matrix goes out of scope when done...}
    \{
     \textcolor{comment}{// Get block -- this makes a deep copy of the relevant entries in the}
     \textcolor{comment}{// full Jacobian (i.e. the matrix of the linear system we're}
     \textcolor{comment}{// actually trying to solve); we can do with this copy whatever}
     \textcolor{comment}{// we want...}
     CRDoubleMatrix block;
     this->get\_block(i,i,block);
     
     \textcolor{comment}{// Set up preconditioner (i.e. lu-decompose the block)}
     Block\_preconditioner\_pt[i]->setup(&block);
     
     \textcolor{comment}{// Done with this block now, so the diagonal block that we extracted}
     \textcolor{comment}{// above can go out of scope. Its LU decomposition (which is the only }
     \textcolor{comment}{// thing we need to apply the preconditioner in the }
     \textcolor{comment}{// preconditioner\_solve(...) function) is retained in the associated }
     \textcolor{comment}{// sub-preconditioner/(in)exact solver(SuperLU).}

    \} \textcolor{comment}{// end of brace to make block go out of scope}

\end{DoxyCodeInclude}


We then extract the relevant off-\/diagonal blocks (those above the diagonal) from the full matrix, create a {\ttfamily Matrix\+Vector\+Product} operator for each and use the {\ttfamily Block\+Preconditioner\+::setup\+\_\+matrix\+\_\+vector\+\_\+product}(...) function to make them fully functional. Note that the final argument to this function (the column index of the off-\/diagonal block in its block enumeration within the current preconditioner) is required to set up additional lookup tables that are required to ensure the correct operation of this object in cases when the preconditioner operates in parallel. The details are messy and not worth explaining here -- just do it!


\begin{DoxyCodeInclude}
    \textcolor{comment}{// Next set up the off diagonal mat vec operators}
    \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} j=i+1;j<nblock\_types;j++)
     \{
      \textcolor{comment}{// Get the off diagonal block}
      CRDoubleMatrix block\_matrix = this->get\_block(i,j);

      \textcolor{comment}{// Create a matrix vector product operator}
      Off\_diagonal\_matrix\_vector\_product\_pt(i,j) = \textcolor{keyword}{new} MatrixVectorProduct;

      \textcolor{comment}{// Setup the matrix vector product for the currrent block matrix}
      \textcolor{comment}{// and specify the column in the "big matrix" as final argument.}
      \textcolor{comment}{// This is needed for things to work properly in parallel -- don't ask!}
      this->setup\_matrix\_vector\_product(
       Off\_diagonal\_matrix\_vector\_product\_pt(i,j),&block\_matrix,j);

      \textcolor{comment}{// Done with this block now, so the diagonal block that we extracted}
      \textcolor{comment}{// above can go out of scope. The MatrixVectorProduct operator retains}
      \textcolor{comment}{// its own copy of whatever data it needs.}

     \} \textcolor{comment}{// End for loop over j}
   \} \textcolor{comment}{// End for loop over i}
 \} \textcolor{comment}{// End setup(...)}

\end{DoxyCodeInclude}
\hypertarget{index_upper_triangular_solve}{}\subsubsection{The preconditioner\+\_\+solve() function}\label{index_upper_triangular_solve}
As in the block diagonal preconditioner, we start by extracting the block vectors from the full-\/length vector, {\ttfamily r}.


\begin{DoxyCodeInclude}
 \textcolor{comment}{//=============================================================================}\textcolor{comment}{}
\textcolor{comment}{ /// Preconditioner solve for the upper triangular preconditioner: }
\textcolor{comment}{ /// Apply preconditioner to r and return z, so that P z = r, where}
\textcolor{comment}{ /// P is the block diagonal matrix constructed from the original }
\textcolor{comment}{ /// linear system.}
\textcolor{comment}{} \textcolor{comment}{//=============================================================================}
 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MATRIX> \textcolor{keywordtype}{void} UpperTriangular<MATRIX>::
 preconditioner\_solve(\textcolor{keyword}{const} DoubleVector& r, DoubleVector& z)
 \{
  \textcolor{comment}{// Get number of blocks}
  \textcolor{keywordtype}{unsigned} n\_block = this->nblock\_types();

  \textcolor{comment}{// vector of vectors for each section of rhs vector}
  Vector<DoubleVector> block\_r;
  
  \textcolor{comment}{// rearrange the vector r into the vector of block vectors block\_r}
  this->get\_block\_vectors(r,block\_r);

\end{DoxyCodeInclude}


Next we provide storage for the solution vectors and work backwards through the (block)-\/rows of the (block-\/)linear system (7). Following each linear solve we update the right-\/hand-\/side of the next linear system, as discussed above.


\begin{DoxyCodeInclude}
  \textcolor{comment}{// Vector of vectors for the solution block vectors}
  Vector<DoubleVector> block\_z(n\_block);

  \textcolor{comment}{// Required to be an int due to an unsigned being unable to be compared to a}
  \textcolor{comment}{// negative number (because it would roll over).}
  \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i=n\_block-1;i>-1;i--)
   \{
    \textcolor{comment}{// Back substitute}
    \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} j=i+1;j<n\_block;j++)
     \{
      DoubleVector temp;
      Off\_diagonal\_matrix\_vector\_product\_pt(i,j)->multiply(block\_z[j],temp);
      block\_r[i] -= temp;
     \} \textcolor{comment}{// End for over j}

    \textcolor{comment}{// Solve on the block}
    this->Block\_preconditioner\_pt[i]->
     preconditioner\_solve(block\_r[i], block\_z[i]);
   \} \textcolor{comment}{// End for over i}

\end{DoxyCodeInclude}


Finally, the solutions in {\ttfamily block\+\_\+z} are combined via {\ttfamily return\+\_\+block\+\_\+vectors}(...) which places the results back into the full-\/length vector {\ttfamily z} that is returned by this function.


\begin{DoxyCodeInclude}
  \textcolor{comment}{// Copy solution in block vectors block\_r back to z}
  this->return\_block\_vectors(block\_z,z);
 \}

\end{DoxyCodeInclude}
\hypertarget{index_upper_triangular_clean}{}\subsubsection{The clean\+\_\+up\+\_\+my\+\_\+memory() function}\label{index_upper_triangular_clean}
This function again deletes any data that was allocated in the setup function -- here the subsidiary preconditioners (and their LU decompositions) and the matrix-\/vector product operators.


\begin{DoxyCodeInclude}
 \textcolor{comment}{//========================start\_of\_clean\_up\_for\_upper\_triangular\_class========}\textcolor{comment}{}
\textcolor{comment}{ /// The clean up function.}
\textcolor{comment}{} \textcolor{comment}{//============================================================================}
 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MATRIX> 
 \textcolor{keywordtype}{void} UpperTriangular<MATRIX>::clean\_up\_my\_memory()
 \{     
  \textcolor{comment}{// Delete anything in Off\_diagonal\_matrix\_vector\_products}
  \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} i=0,ni=Off\_diagonal\_matrix\_vector\_product\_pt.nrow();i<ni;i++)
   \{
    \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} j=0,nj=Off\_diagonal\_matrix\_vector\_product\_pt.ncol();j<nj;j++)
     \{
      \textcolor{keywordflow}{if}(Off\_diagonal\_matrix\_vector\_product\_pt(i,j) != 0)
       \{    
        \textcolor{keyword}{delete} Off\_diagonal\_matrix\_vector\_product\_pt(i,j);
        Off\_diagonal\_matrix\_vector\_product\_pt(i,j) = 0;
       \}
     \}
   \}

  \textcolor{comment}{// Delete preconditioners (approximate solvers)}
  \textcolor{keywordtype}{unsigned} n\_block = Block\_preconditioner\_pt.size();
  \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} i=0;i<n\_block;i++)
   \{
    \textcolor{keywordflow}{if}(Block\_preconditioner\_pt[i]!=0)
     \{
      \textcolor{keyword}{delete} Block\_preconditioner\_pt[i];
      Block\_preconditioner\_pt[i]=0;
     \}
   \}
 \} \textcolor{comment}{// End of clean\_up\_my\_memory function.}

\end{DoxyCodeInclude}




 



\label{_compound}%
 \hypertarget{index_two_plus_three}{}\subsection{Combining multiple dof types into compound blocks. Part 1}\label{index_two_plus_three}
N\+EW F\+E\+A\+T\+U\+R\+ES\+: How to combine multiple dof types into compound blocks\hypertarget{index_two_plus_three_theory}{}\subsubsection{Theory}\label{index_two_plus_three_theory}
So far we have illustrated how to implement block preconditioners for cases where the dof types (as identified by the elements) correspond directly to the block types. This is appropriate for our model P\+DE system (1) in which the five fields (and the governing equations) are all of the same type. In many applications, particularly in multi-\/physics problems, it may be desirable to combine similar/related dof types into single blocks. For instance, in a 2D fluid-\/structure interaction problem, we may wish to distinguish between the two solid (x and y solid displacements) and three fluid (x and y fluid velocities and the pressure) dofs and employ subsidiary preconditioners that act directly on the two distinct solid and fluid blocks. A basic block diagonal preconditioner for such a problem that ignores the coupling between fluid and solid dofs has the following structure \[ \hspace{3cm} {\bf P} = \left( \begin{array}{cc|ccc} J_{11} & J_{12} & & & \\ J_{21} & J_{22} & & & \\ \hline & & J_{33} & J_{34} & J_{35} \\ & & J_{43} & J_{44} & J_{45} \\ & & J_{53} & J_{54} & J_{55} \\ \end{array} \right) = \left( \begin{array}{c|c} B_{11} & \\ \hline & B_{22} \\ \end{array} \right) \hspace{3cm} \] where $ B_{11} $ and $ B_{22} $ are the blocks formed from the corresponding \char`\"{}dof blocks\char`\"{} (the $ J_{ij} $ matrices). The application of this preconditioner (i.\+e. the solution of the linear system ${\bf P} {\bf y} ={\bf z}$ for ${\bf y}$) requires the solution of the two smaller linear systems \[ \hspace{3cm} \left( \begin{array}{cc} J_{11} & J_{12} \\ J_{21} & J_{22} \\ \end{array} \right) \left( \begin{array}{c} y_1 \\ y_2 \\ \end{array} \right) = \left( \begin{array}{c} z_1 \\ z_2 \\ \end{array} \right) \mbox{\ \ \ \ \ \ \ or \ \ \ \ \ \ } B_{11} \ Y_1 = Z_1 \hspace{3cm} (8) \] and \[ \hspace{3cm} \left( \begin{array}{ccc} J_{33} & J_{34} & J_{35} \\ J_{43} & J_{44} & J_{45} \\ J_{53} & J_{54} & J_{55} \\ \end{array} \right) \left( \begin{array}{c} y_3 \\ y_4 \\ y_5 \\ \end{array} \right) = \left( \begin{array}{c} z_3 \\ z_4 \\ z_5 \\ \end{array} \right) \mbox{\ \ \ \ \ \ \ or \ \ \ \ \ \ } B_{22} \ Y_2 = Z_2. \hspace{3cm} (9) \]

A key feature of the block preconditioning framework is the ability to combine dof types in this manner so that the preconditioner can operate directly with blocks $ B_{11} $ and $ B_{22} $ and the corresponding block vectors $ Y_1, Y_2, Z_1 $ and $ Z_2 $.

Assuming again that the linear systems in (8) and (9) are solved exactly by a direct solver (an ``exact preconditioner\textquotesingle{}\textquotesingle{}) that can pre-\/compute and store the LU decomposition of the diagonal matrix blocks, $ B_{11} $ and $ B_{22} $, the {\ttfamily setup()} phase involves the following operations \mbox{[}text in square brackets refers to their {\ttfamily oomph-\/lib} specific implementation\mbox{]}\+:
\begin{DoxyItemize}
\item Set up any data structures/lookup tables that are required to extract the matrix blocks $ B_{11} $ and $ B_{22} $ and the associated block vectors \mbox{[}by calling the {\ttfamily Block\+Preconditioner\+::block\+\_\+setup}(...) function -- this time with arguments that specify the mapping between \char`\"{}dof types\char`\"{} and \char`\"{}block types\char`\"{}\mbox{]}.
\item Extract the two diagonal blocks, $ B_{11} $ and $ B_{22}$ \mbox{[}using the {\ttfamily Block\+Preconditioner\+::get\+\_\+block}(...) function\mbox{]}.
\item Compute and store the LU decomposition of the diagonal blocks to allow the rapid solution of the systems during the {\ttfamily preconditioner\+\_\+solve}(...) phase by back-\/substitution. \mbox{[}This is done by calling the {\ttfamily setup}(...) function of the subsidiary preconditioner/inexact solver. Following this, the diagonal matrix blocks are longer required and can be deleted.\mbox{]}
\end{DoxyItemize}

Once the {\ttfamily setup()} phase has been completed, the solution of the linear system ${\bf P} {\bf y} = {\bf z}$ by the {\ttfamily preconditioner\+\_\+solve}(...) function involves the following steps\+:
\begin{DoxyItemize}
\item Extract the two ``block vectors\textquotesingle{}\textquotesingle{} ${\bf Z}_i$ (for $i=1,2$) from the vector ${\bf z}$ \mbox{[}using the {\ttfamily Block\+Preconditioner\+::get\+\_\+block\+\_\+vectors}(...) function\mbox{]}.
\item Solve the linear systems ${\bf B}_{ii} \ {\bf Y}_i = {\bf Z}_i$ for the vectors ${\bf Y}_i$ (for $i=1,2$) using the precomputed LU decomposition of the diagonal blocks ${\bf B}_{ii}$ (for $i=1,2$) created during the {\ttfamily setup()} phase.
\item Combine the two ``block vectors\textquotesingle{}\textquotesingle{} ${\bf Y}_i$ (for $i=1,...,2$) to the full-\/length vector ${\bf y}$ \mbox{[}using the {\ttfamily Block\+Preconditioner\+::return\+\_\+block\+\_\+vectors}(...) function\mbox{]}.
\end{DoxyItemize}\hypertarget{index_two_plus_three_implementation}{}\subsubsection{Implementation as a Block\+Preconditioner}\label{index_two_plus_three_implementation}
The implementation of the preconditioner closely follows that of the block diagonal preconditioner discussed above, the main difference being that the current preconditioner only ever operates with exactly two blocks. Therefore we store pointers to the two subsidiary preconditioners (rather than a vector of pointers that can store an arbitrary number of these).


\begin{DoxyCodeInclude}
\textcolor{comment}{//=======================start\_of\_two\_plus\_three\_class=========================}\textcolor{comment}{}
\textcolor{comment}{/// \(\backslash\)short Block diagonal preconditioner for system with 5 dof types}
\textcolor{comment}{/// assembled into a 2x2 block system, with (0,0) block containing the }
\textcolor{comment}{/// first two dof types and the (1,1) block the remaining three dof types.}
\textcolor{comment}{}\textcolor{comment}{//=============================================================================}
 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MATRIX> 
 \textcolor{keyword}{class }TwoPlusThree : \textcolor{keyword}{public} BlockPreconditioner<MATRIX>
  \{
    public :
   \textcolor{comment}{}
\textcolor{comment}{  /// Constructor for TwoPlusThree}
\textcolor{comment}{}  TwoPlusThree() : BlockPreconditioner<MATRIX>(),
   First\_subsidiary\_preconditioner\_pt(0),
   Second\_subsidiary\_preconditioner\_pt(0)
    \{
     Multi\_poisson\_mesh\_pt=0;
    \} \textcolor{comment}{// end\_of\_constructor}
    \textcolor{comment}{}
\textcolor{comment}{  /// Destructor - delete the diagonal solvers (subsidiary preconditioners)}
\textcolor{comment}{}  ~TwoPlusThree()
   \{
    this->clean\_up\_my\_memory();
   \}\textcolor{comment}{}
\textcolor{comment}{  /// clean up the memory}
\textcolor{comment}{}  \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} clean\_up\_my\_memory();
\textcolor{comment}{}
\textcolor{comment}{  /// Broken copy constructor}
\textcolor{comment}{}  TwoPlusThree
  (\textcolor{keyword}{const} TwoPlusThree&) 
   \{ 
    BrokenCopy::broken\_copy(\textcolor{stringliteral}{"TwoPlusThree"});
   \} 
  \textcolor{comment}{}
\textcolor{comment}{  /// Broken assignment operator}
\textcolor{comment}{}  \textcolor{keywordtype}{void} operator=(\textcolor{keyword}{const} TwoPlusThree&) 
   \{
    BrokenCopy::broken\_assign(\textcolor{stringliteral}{"TwoPlusThree"});
   \}
  \textcolor{comment}{}
\textcolor{comment}{  /// Apply preconditioner to r, i.e. return z such that P z = r}
\textcolor{comment}{}  \textcolor{keywordtype}{void} preconditioner\_solve(\textcolor{keyword}{const} DoubleVector &r, DoubleVector &z);
  \textcolor{comment}{}
\textcolor{comment}{  /// \(\backslash\)short Setup the preconditioner }
\textcolor{comment}{}  \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} setup();
 \textcolor{comment}{}
\textcolor{comment}{  /// Specify the mesh that contains multi-poisson elements}
\textcolor{comment}{}  \textcolor{keywordtype}{void} set\_multi\_poisson\_mesh(Mesh* multi\_poisson\_mesh\_pt)
  \{
   Multi\_poisson\_mesh\_pt=multi\_poisson\_mesh\_pt;
  \}

 private :
  \textcolor{comment}{}
\textcolor{comment}{  /// \(\backslash\)short Pointer to preconditioners/inexact solver}
\textcolor{comment}{  /// for (0,0) block}
\textcolor{comment}{}  Preconditioner* First\_subsidiary\_preconditioner\_pt;
  \textcolor{comment}{}
\textcolor{comment}{  /// \(\backslash\)short Pointer to preconditioners/inexact solver}
\textcolor{comment}{  /// for (1,1) block}
\textcolor{comment}{}  Preconditioner* Second\_subsidiary\_preconditioner\_pt;
\textcolor{comment}{}
\textcolor{comment}{  /// \(\backslash\)short Pointer to mesh with preconditionable elements used}
\textcolor{comment}{  /// for classification of dof types.  }
\textcolor{comment}{}  Mesh* Multi\_poisson\_mesh\_pt; 
 \};

\end{DoxyCodeInclude}
\hypertarget{index_two_plus_three_setup}{}\subsubsection{The setup() function}\label{index_two_plus_three_setup}
As usual, we start by freeing up any previously allocated memory, and set the pointer to the mesh\+:


\begin{DoxyCodeInclude}
 \textcolor{comment}{//====================start\_of\_setup\_for\_two\_plus\_three=======================}\textcolor{comment}{}
\textcolor{comment}{ /// The setup function.}
\textcolor{comment}{} \textcolor{comment}{//============================================================================}
 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MATRIX> 
 \textcolor{keywordtype}{void} TwoPlusThree<MATRIX>::setup()
 \{
  \textcolor{comment}{// Clean up memory.}
  this->clean\_up\_my\_memory();

\textcolor{preprocessor}{#ifdef PARANOID}
  \textcolor{keywordflow}{if} (Multi\_poisson\_mesh\_pt == 0)
   \{
    std::stringstream err;
    err << \textcolor{stringliteral}{"Please set pointer to mesh using set\_multi\_poisson\_mesh(...).\(\backslash\)n"};
    \textcolor{keywordflow}{throw} OomphLibError(err.str(),
                        OOMPH\_CURRENT\_FUNCTION,
                        OOMPH\_EXCEPTION\_LOCATION);
   \}
\textcolor{preprocessor}{#endif }
  
  \textcolor{comment}{// The preconditioner works with one mesh; set it!}
  this->set\_nmesh(1);
  this->set\_mesh(0,Multi\_poisson\_mesh\_pt);

\end{DoxyCodeInclude}


Since this preconditioner assumes explicitly that the problem involves five dof types we check that this is actually the case.


\begin{DoxyCodeInclude}

  \textcolor{comment}{// How many dof types do we have?}
  \textcolor{keywordtype}{unsigned} n\_dof\_types = this->ndof\_types();


\textcolor{preprocessor}{#ifdef PARANOID}
  \textcolor{comment}{// This preconditioner only works for 5 dof types}
  \textcolor{keywordflow}{if} (n\_dof\_types!=5)
   \{
    std::stringstream tmp;
    tmp << \textcolor{stringliteral}{"This preconditioner only works for problems with 5 dof types\(\backslash\)n"}
        << \textcolor{stringliteral}{"Yours has "} << n\_dof\_types;
    \textcolor{keywordflow}{throw} OomphLibError(tmp.str(),
                        OOMPH\_CURRENT\_FUNCTION,
                        OOMPH\_EXCEPTION\_LOCATION);
   \}
\textcolor{preprocessor}{#endif}

\end{DoxyCodeInclude}


To indicate that several dof types are to be combined into single blocks, we specify the mapping between dof types and block types as an argument to the {\ttfamily block\+\_\+setup}(...) function This is done by creating vector of length {\ttfamily ndof\+\_\+type()} in which each entry indicates the block that the corresponding dof is supposed to end up in\+:


\begin{DoxyCodeInclude}
  \textcolor{comment}{// Combine into two blocks, one containing dof types 0 and 1, the}
  \textcolor{comment}{// final one dof types 2-4. In general we want:}
  \textcolor{comment}{// dof\_to\_block\_map[dof\_type] = block type}
  Vector<unsigned> dof\_to\_block\_map(n\_dof\_types);
  dof\_to\_block\_map[0]=0;
  dof\_to\_block\_map[1]=0;
  dof\_to\_block\_map[2]=1;
  dof\_to\_block\_map[3]=1;
  dof\_to\_block\_map[4]=1;
  this->block\_setup(dof\_to\_block\_map);

\end{DoxyCodeInclude}


To show that this actually worked, we output the number of blocks (which should be -- and indeed is -- equal to two).


\begin{DoxyCodeInclude}
  \textcolor{comment}{// Show that it worked ok:}
  oomph\_info << \textcolor{stringliteral}{"Preconditioner has "} 
             << this->nblock\_types() << \textcolor{stringliteral}{" block types\(\backslash\)n"};

\end{DoxyCodeInclude}


Next we create the two subsidiary preconditioners and call their {\ttfamily setup}(...) functions, passing the two diagonal blocks ${\bf B}_{11} $ and ${\bf B}_{22} $ to them.


\begin{DoxyCodeInclude}
  \textcolor{comment}{// Create the subsidiary preconditioners}
  First\_subsidiary\_preconditioner\_pt= \textcolor{keyword}{new} SuperLUPreconditioner;
  Second\_subsidiary\_preconditioner\_pt= \textcolor{keyword}{new} SuperLUPreconditioner;
  
  \textcolor{comment}{// Set diagonal solvers/preconditioners; put in own scope}
  \textcolor{comment}{// so variable block goes out of scope}
  \{
   CRDoubleMatrix block;
   this->get\_block(0,0,block);

   \textcolor{comment}{// Set up preconditioner (i.e. lu-decompose the block)}
   First\_subsidiary\_preconditioner\_pt->setup(&block);
  \}
  \{
   CRDoubleMatrix block;
   this->get\_block(1,1,block);
   
   \textcolor{comment}{// Set up preconditioner (i.e. lu-decompose the block)}
   Second\_subsidiary\_preconditioner\_pt->setup(&block);
  \}

 \} \textcolor{comment}{// End of setup}

\end{DoxyCodeInclude}
\hypertarget{index_two_plus_three_solve}{}\subsubsection{The preconditioner\+\_\+solve() function}\label{index_two_plus_three_solve}
The {\ttfamily preconditioner\+\_\+solve}(...) function is equivalent to that in the {\ttfamily Diagonal} preconditioner discussed above, though here it simply acts on a 2x2 block system.


\begin{DoxyCodeInclude}
 \textcolor{comment}{//=============================================================================}\textcolor{comment}{}
\textcolor{comment}{ /// Preconditioner solve for the two plus three diagonal preconditioner: }
\textcolor{comment}{ /// Apply preconditioner to r and return z, so that P r = z, where}
\textcolor{comment}{ /// P is the block diagonal matrix constructed from the original }
\textcolor{comment}{ /// linear system.}
\textcolor{comment}{} \textcolor{comment}{//=============================================================================}
 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MATRIX> 
 \textcolor{keywordtype}{void} TwoPlusThree<MATRIX>::
 preconditioner\_solve(\textcolor{keyword}{const} DoubleVector& r, DoubleVector& z)
 \{   
  \textcolor{comment}{// Get number of blocks}
  \textcolor{keywordtype}{unsigned} n\_block = this->nblock\_types();

  \textcolor{comment}{// Split up rhs vector into sub-vectors, arranged to match the matrix blocks.}
  Vector<DoubleVector> block\_r;
  this->get\_block\_vectors(r,block\_r);

  \textcolor{comment}{// Create storage for solution of block solves}
  Vector<DoubleVector> block\_z(n\_block);

  \textcolor{comment}{// Solve (0,0) diagonal block system}
  First\_subsidiary\_preconditioner\_pt->preconditioner\_solve(block\_r[0],
                                                           block\_z[0]);
  
  \textcolor{comment}{// Solve (1,1) diagonal block system}
  Second\_subsidiary\_preconditioner\_pt->preconditioner\_solve(block\_r[1],
                                                            block\_z[1]);
  
  \textcolor{comment}{// Copy solution in block vectors block\_z back to z}
  this->return\_block\_vectors(block\_z,z);
 \}

\end{DoxyCodeInclude}
\hypertarget{index_two_plus_three_clean}{}\subsubsection{The clean\+\_\+up\+\_\+my\+\_\+memory() function}\label{index_two_plus_three_clean}
This function again deletes the allocated storage -- here the subsidiary preconditioners.


\begin{DoxyCodeInclude}
 \textcolor{comment}{//====================start\_of\_clean\_up\_for\_two\_plus\_three====================}\textcolor{comment}{}
\textcolor{comment}{ /// The clean up function.}
\textcolor{comment}{} \textcolor{comment}{//============================================================================}
 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MATRIX> 
 \textcolor{keywordtype}{void} TwoPlusThree<MATRIX>::clean\_up\_my\_memory()
 \{     
  \textcolor{comment}{//Clean up subsidiary preconditioners.}
  \textcolor{keywordflow}{if}(First\_subsidiary\_preconditioner\_pt!=0)
   \{
    \textcolor{keyword}{delete} First\_subsidiary\_preconditioner\_pt;
    First\_subsidiary\_preconditioner\_pt = 0;
   \}
  \textcolor{keywordflow}{if}(Second\_subsidiary\_preconditioner\_pt!=0)
   \{
    \textcolor{keyword}{delete} Second\_subsidiary\_preconditioner\_pt;
    Second\_subsidiary\_preconditioner\_pt = 0;
   \}
 \} \textcolor{comment}{// End of clean\_up\_my\_memory function.}

\end{DoxyCodeInclude}




 

\hypertarget{index_two_plus_three_upper_triangular}{}\subsection{Combining multiple dof types into compound blocks. Part 2\+: How to deal with off-\/diagonal blocks}\label{index_two_plus_three_upper_triangular}
N\+EW F\+E\+A\+T\+U\+R\+ES\+: How to set up matrix vector products when multiple dof types have been combined into compound blocks\hypertarget{index_two_plus_three_upper_triangular_theory}{}\subsubsection{Theory}\label{index_two_plus_three_upper_triangular_theory}
The extension of the preconditioner introduced in the previous section to block-\/triangular form is straightforward\+: We use the same dof-\/to-\/block mapping as before but now retain the off-\/diagonal block $ B_{12} $ so that the preconditioner has the structure\+: \[ \hspace{3cm} {\bf P} = \left( \begin{array}{cc|ccc} J_{11} & J_{12} & J_{13} & J_{14} & J_{15} \\ J_{21} & J_{22} & J_{13} & J_{14} & J_{15} \\ \hline & & J_{33} & J_{34} & J_{35} \\ & & J_{43} & J_{44} & J_{45} \\ & & J_{53} & J_{54} & J_{55} \\ \end{array} \right) = \left( \begin{array}{c|c} B_{11} & B_{12}\\ \hline & B_{22} \\ \end{array} \right). \hspace{3cm} (10) \]

In the F\+SI context where $ B_{11} $ and $ B_{22} $ represent the solid and fluid sub-\/blocks, respectively, the inclusion of the off-\/diagonal block $ B_{12} $ incorporates the effect of fluid dofs (via pressure and shear stress) onto the solid equations. Since this captures \char`\"{}more of the physics\char`\"{} the preconditioner can be expected to be better than its block diagonal counterpart.

The application of the preconditioner (i.\+e. the solution of the linear system ${\bf P} {\bf y} ={\bf z}$ for ${\bf y}$) requires the solution of the two smaller linear systems \[ \ \ \ \ \ \left( \begin{array}{cc} J_{11} & J_{12} \\ J_{21} & J_{22} \\ \end{array} \right) \left( \begin{array}{c} y_1 \\ y_2 \\ \end{array} \right) = \left( \begin{array}{c} z_1 \\ z_2 \\ \end{array} \right) - \left( \begin{array}{ccc} J_{13} & J_{14} & J_{15} \\ J_{23} & J_{24} & J_{25} \\ \end{array} \right) \left( \begin{array}{c} y_3 \\ y_4 \\ y_5 \\ \end{array} \right) \mbox{\ \ \ \ \ \ \ \ \ or \ \ \ \ \ \ \ \ } B_{11} Y_1 = Z_1 - B_{12} Y_2 \hspace{3cm} (11) \] and \[ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \left( \begin{array}{ccc} J_{33} & J_{34} & J_{35} \\ J_{43} & J_{44} & J_{45} \\ J_{53} & J_{54} & J_{55} \\ \end{array} \right) \left( \begin{array}{c} y_3 \\ y_4 \\ y_5 \\ \end{array} \right) = \left( \begin{array}{c} z_3 \\ z_4 \\ z_5 \\ \end{array} \right) \mbox{\ \ \ \ \ \ \ \ \ or \ \ \ \ \ \ \ \ } B_{22} Y_2 = Z_2. \hspace{3cm} (12) \]\hypertarget{index_two_plus_three_upper_triangular_implementation}{}\subsubsection{Implementation as a Block\+Preconditioner}\label{index_two_plus_three_upper_triangular_implementation}
The implementation is very similar to that in the previous example -- we simply provide additional storage for the (single) matrix vector product operator required for the multiplication with $ B_{12} $ when updating the right-\/hand-\/side in equation (11).


\begin{DoxyCodeInclude}
\textcolor{comment}{//=================start\_of\_two\_plus\_three\_upper\_triangular\_class==============}\textcolor{comment}{}
\textcolor{comment}{/// \(\backslash\)short Upper triangular two plus three triangular preconditioner for a }
\textcolor{comment}{/// system with  5 dof types.}
\textcolor{comment}{}\textcolor{comment}{//=============================================================================}
 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MATRIX> 
 \textcolor{keyword}{class }TwoPlusThreeUpperTriangular 
  : \textcolor{keyword}{public} BlockPreconditioner<MATRIX>
 \{
 
 public :
 \textcolor{comment}{}
\textcolor{comment}{  /// Constructor.}
\textcolor{comment}{}  TwoPlusThreeUpperTriangular()  :
   BlockPreconditioner<MATRIX>(),
    Off\_diagonal\_matrix\_vector\_product\_pt(0),
    First\_subsidiary\_preconditioner\_pt(0),
    Second\_subsidiary\_preconditioner\_pt(0)
   \{ 
    Multi\_poisson\_mesh\_pt=0;
   \}
 \textcolor{comment}{}
\textcolor{comment}{  /// Destructor - delete the preconditioner matrices}
\textcolor{comment}{}  \textcolor{keyword}{virtual} ~TwoPlusThreeUpperTriangular()
   \{
    this->clean\_up\_my\_memory();
   \}
\textcolor{comment}{}
\textcolor{comment}{  /// clean up the memory}
\textcolor{comment}{}  \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} clean\_up\_my\_memory();
 \textcolor{comment}{}
\textcolor{comment}{  /// Broken copy constructor}
\textcolor{comment}{}  TwoPlusThreeUpperTriangular(\textcolor{keyword}{const} TwoPlusThreeUpperTriangular&) 
   \{ 
    BrokenCopy::broken\_copy(\textcolor{stringliteral}{"TwoPlusThreeUpperTriangular"});
   \} 
 \textcolor{comment}{}
\textcolor{comment}{  /// Broken assignment operator}
\textcolor{comment}{}  \textcolor{keywordtype}{void} operator=(\textcolor{keyword}{const} TwoPlusThreeUpperTriangular&) 
   \{
    BrokenCopy::broken\_assign(\textcolor{stringliteral}{"TwoPlusThreeUpperTriangular"});
   \}
 \textcolor{comment}{}
\textcolor{comment}{  /// Apply preconditioner to r}
\textcolor{comment}{}  \textcolor{keywordtype}{void} preconditioner\_solve(\textcolor{keyword}{const} DoubleVector &r, DoubleVector &z);
 \textcolor{comment}{}
\textcolor{comment}{  /// \(\backslash\)short Setup the preconditioner }
\textcolor{comment}{}  \textcolor{keywordtype}{void} setup();
  
  \textcolor{comment}{// Use the version in the Preconditioner base class for the alternative}
  \textcolor{comment}{// setup function that takes a matrix pointer as an argument.}
  \textcolor{keyword}{using} Preconditioner::setup;
\textcolor{comment}{}
\textcolor{comment}{  /// Specify the mesh that contains multi-poisson elements}
\textcolor{comment}{}  \textcolor{keywordtype}{void} set\_multi\_poisson\_mesh(Mesh* multi\_poisson\_mesh\_pt)
  \{
   Multi\_poisson\_mesh\_pt=multi\_poisson\_mesh\_pt;
  \}

 \textcolor{keyword}{private}:  
\textcolor{comment}{}
\textcolor{comment}{  /// Pointer to matrix vector product operator for the single off diagonals}
\textcolor{comment}{}  MatrixVectorProduct* Off\_diagonal\_matrix\_vector\_product\_pt;
\textcolor{comment}{}
\textcolor{comment}{  /// \(\backslash\)short Pointer to preconditioners/inexact solver}
\textcolor{comment}{  /// for (0,0) block}
\textcolor{comment}{}  Preconditioner* First\_subsidiary\_preconditioner\_pt;
  \textcolor{comment}{}
\textcolor{comment}{  /// \(\backslash\)short Pointer to preconditioners/inexact solver}
\textcolor{comment}{  /// for (1,1) block}
\textcolor{comment}{}  Preconditioner* Second\_subsidiary\_preconditioner\_pt;
\textcolor{comment}{}
\textcolor{comment}{  /// \(\backslash\)short Pointer to mesh with preconditionable elements used}
\textcolor{comment}{  /// for classification of dof types.}
\textcolor{comment}{}  Mesh* Multi\_poisson\_mesh\_pt;

 \};

\end{DoxyCodeInclude}
\hypertarget{index_two_plus_three_upper_triangular_setup}{}\subsubsection{The setup() function}\label{index_two_plus_three_upper_triangular_setup}
As before, we start by freeing up any previously allocated memory and set the pointer to the mesh,


\begin{DoxyCodeInclude}
 \textcolor{comment}{//==============start\_of\_setup\_for\_two\_plus\_three\_upper\_triangular\_class=======}\textcolor{comment}{}
\textcolor{comment}{ /// The setup function.}
\textcolor{comment}{} \textcolor{comment}{//============================================================================}
 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MATRIX> 
 \textcolor{keywordtype}{void} TwoPlusThreeUpperTriangular<MATRIX>::setup()
 \{
  \textcolor{comment}{// clean the memory}
  this->clean\_up\_my\_memory();

\textcolor{preprocessor}{#ifdef PARANOID}
  \textcolor{keywordflow}{if} (Multi\_poisson\_mesh\_pt == 0)
   \{
    std::stringstream err;
    err << \textcolor{stringliteral}{"Please set pointer to mesh using set\_multi\_poisson\_mesh(...).\(\backslash\)n"};
    \textcolor{keywordflow}{throw} OomphLibError(err.str(),
                        OOMPH\_CURRENT\_FUNCTION,
                        OOMPH\_EXCEPTION\_LOCATION);
   \}
\textcolor{preprocessor}{#endif }
  
  \textcolor{comment}{// The preconditioner works with one mesh; set it!}
  this->set\_nmesh(1);
  this->set\_mesh(0,Multi\_poisson\_mesh\_pt);

\end{DoxyCodeInclude}


and check that the number of dof types is correct. 
\begin{DoxyCodeInclude}

  \textcolor{comment}{// Get number of degrees of freedom.}
  \textcolor{keywordtype}{unsigned} n\_dof\_types = this->ndof\_types();

\textcolor{preprocessor}{#ifdef PARANOID}
  \textcolor{comment}{// This preconditioner only works for 5 dof types}
  \textcolor{keywordflow}{if} (n\_dof\_types!=5)
   \{
    std::stringstream tmp;
    tmp << \textcolor{stringliteral}{"This preconditioner only works for problems with 5 dof types\(\backslash\)n"}
        << \textcolor{stringliteral}{"Yours has "} << n\_dof\_types;
    \textcolor{keywordflow}{throw} OomphLibError(tmp.str(),
                        OOMPH\_CURRENT\_FUNCTION,
                        OOMPH\_EXCEPTION\_LOCATION);
   \}
\textcolor{preprocessor}{#endif}

\end{DoxyCodeInclude}


The block setup is again performed with a dof-\/to-\/block mapping that results in a block preconditioner with 2x2 blocks.


\begin{DoxyCodeInclude}
  \textcolor{comment}{// Combine into two major blocks, one containing dof types 0 and 1, the}
  \textcolor{comment}{// final one dof types 2-4. In general we want}
  \textcolor{comment}{// dof\_to\_block\_map[dof\_type] = block\_type}
  Vector<unsigned> dof\_to\_block\_map(n\_dof\_types);
  dof\_to\_block\_map[0]=0;
  dof\_to\_block\_map[1]=0;
  dof\_to\_block\_map[2]=1;
  dof\_to\_block\_map[3]=1;
  dof\_to\_block\_map[4]=1;
  this->block\_setup(dof\_to\_block\_map);

\end{DoxyCodeInclude}


We create the two subsidiary preconditioners and pass the two diagonal blocks $ B_{11} $ and $ B_{22} $ to their {\ttfamily setup()} functions. As before, the deep copies of these matrices are then allowed to go out of scope, freeing up the memory, since the subsidiary preconditioners retain whatever information they require.


\begin{DoxyCodeInclude}
  \textcolor{comment}{// Create the subsidiary preconditioners}
  First\_subsidiary\_preconditioner\_pt= \textcolor{keyword}{new} SuperLUPreconditioner;
  Second\_subsidiary\_preconditioner\_pt= \textcolor{keyword}{new} SuperLUPreconditioner;

  \textcolor{comment}{// Set diagonal solvers/preconditioners; put in own scope}
  \textcolor{comment}{// so block goes out of scope}
  \{

   CRDoubleMatrix block;
   this->get\_block(0,0,block);
   
   \textcolor{comment}{// Set up preconditioner (i.e. lu-decompose the block)}
   First\_subsidiary\_preconditioner\_pt->setup(&block);

  \}
  \{

   CRDoubleMatrix block;
   this->get\_block(1,1,block);
   
   \textcolor{comment}{// Set up preconditioner (i.e. lu-decompose the block)}
   Second\_subsidiary\_preconditioner\_pt->setup(&block);

  \} \textcolor{comment}{// end setup of last subsidiary preconditioner}

\end{DoxyCodeInclude}


Finally we create and set up the off-\/diagonal vector product. Note that the block column index refers to the block enumeration, so the block column index of $ B_{12} $ is 1 (in a C++ zero-\/based enumeration!).


\begin{DoxyCodeInclude}
  \textcolor{comment}{// next setup the off diagonal mat vec operators}
  \{
   \textcolor{comment}{// Get the block}
   CRDoubleMatrix block\_matrix = this->get\_block(0,1);

   \textcolor{comment}{// Create matrix vector product}
   Off\_diagonal\_matrix\_vector\_product\_pt = \textcolor{keyword}{new} MatrixVectorProduct;

   \textcolor{comment}{// Set it up -- note that the block column index refers to the}
   \textcolor{comment}{// block enumeration (not the dof enumeration)}
   \textcolor{keywordtype}{unsigned} block\_column\_index=1;
   this->setup\_matrix\_vector\_product(
    Off\_diagonal\_matrix\_vector\_product\_pt,&block\_matrix,block\_column\_index);
  \}

\end{DoxyCodeInclude}
\hypertarget{index_two_plus_three_upper_triangular_solve}{}\subsubsection{The preconditioner\+\_\+solve() function}\label{index_two_plus_three_upper_triangular_solve}
The application of the preconditioner is the exact equivalent of that of the general-\/purpose block triangular preconditioner discussed above, restricted to a 2x2 system\+:


\begin{DoxyCodeInclude}
 \textcolor{comment}{//=============================================================================}\textcolor{comment}{}
\textcolor{comment}{ /// Preconditioner solve for the two plus three upper block triangular }
\textcolor{comment}{ /// preconditioner: }
\textcolor{comment}{ /// Apply preconditioner to r and return z, so that P z = r, where}
\textcolor{comment}{ /// P is the block diagonal matrix constructed from the original }
\textcolor{comment}{ /// linear system.}
\textcolor{comment}{} \textcolor{comment}{//=============================================================================}
 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MATRIX> 
 \textcolor{keywordtype}{void} TwoPlusThreeUpperTriangular<MATRIX>::
 preconditioner\_solve(\textcolor{keyword}{const} DoubleVector& r, DoubleVector& z)
 \{
  \textcolor{comment}{// Get number of blocks}
  \textcolor{keywordtype}{unsigned} n\_block = this->nblock\_types();

  \textcolor{comment}{// Split up rhs vector into sub-vectors, rarranged to match the matrix blocks.}
  Vector<DoubleVector> block\_r;
  this->get\_block\_vectors(r,block\_r);

  \textcolor{comment}{// Create storage for solution of block solves}
  Vector<DoubleVector> block\_z(n\_block);

  \textcolor{comment}{// Solve (1,1) diagonal block system}
  Second\_subsidiary\_preconditioner\_pt->preconditioner\_solve(block\_r[1],
                                                            block\_z[1]);

  \textcolor{comment}{// Solve (0,1) off diagonal.}
  \textcolor{comment}{// Substitute}
  DoubleVector temp;
  Off\_diagonal\_matrix\_vector\_product\_pt->multiply(block\_z[1],temp);
  block\_r[0] -= temp;   

  \textcolor{comment}{// Solve (0,0) diagonal block system}
  First\_subsidiary\_preconditioner\_pt->preconditioner\_solve(block\_r[0],
                                                           block\_z[0]); 

  \textcolor{comment}{// Copy solution in block vectors block\_z back to z}
  this->return\_block\_vectors(block\_z,z);
 \}

\end{DoxyCodeInclude}
\hypertarget{index_two_plus_three_upper_triangular_clean}{}\subsubsection{The clean\+\_\+up\+\_\+my\+\_\+memory() function}\label{index_two_plus_three_upper_triangular_clean}
As before, this function frees up any memory that has been allocated in the {\ttfamily setup()} function.


\begin{DoxyCodeInclude}
 \textcolor{comment}{//===========start\_of\_clean\_up\_for\_two\_plus\_three\_upper\_triangular\_class======}\textcolor{comment}{}
\textcolor{comment}{ /// The clean up function.}
\textcolor{comment}{} \textcolor{comment}{//============================================================================}
 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MATRIX> 
 \textcolor{keywordtype}{void} TwoPlusThreeUpperTriangular<MATRIX>::clean\_up\_my\_memory()
 \{     
  \textcolor{comment}{// Delete of diagonal matrix vector product}
  \textcolor{keywordflow}{if} (Off\_diagonal\_matrix\_vector\_product\_pt != 0)
   \{
    \textcolor{keyword}{delete} Off\_diagonal\_matrix\_vector\_product\_pt;
    Off\_diagonal\_matrix\_vector\_product\_pt = 0;
   \}

  \textcolor{comment}{//Clean up subsidiary preconditioners.}
  \textcolor{keywordflow}{if}(First\_subsidiary\_preconditioner\_pt!=0)
   \{
    \textcolor{keyword}{delete} First\_subsidiary\_preconditioner\_pt;
    First\_subsidiary\_preconditioner\_pt = 0;
   \}
  \textcolor{keywordflow}{if}(Second\_subsidiary\_preconditioner\_pt!=0)
   \{
    \textcolor{keyword}{delete} Second\_subsidiary\_preconditioner\_pt;
    Second\_subsidiary\_preconditioner\_pt = 0;
   \}
 \} \textcolor{comment}{// End of clean\_up\_my\_memory function.}

\end{DoxyCodeInclude}




 

\hypertarget{index_two_plus_three_upper_triangular_with_sub}{}\subsection{Using subsidiary block preconditioners}\label{index_two_plus_three_upper_triangular_with_sub}
N\+EW F\+E\+A\+T\+U\+R\+ES\+: How to use subsidiary block preconditioners to (approximately) solve linear systems constructed from subsets of dof-\/blocks.\hypertarget{index_two_plus_three_upper_triangular_with_sub_theory}{}\subsubsection{Theory}\label{index_two_plus_three_upper_triangular_with_sub_theory}
The two previous examples were motivated by the observation that in multi-\/physics problems (such as fluid-\/structure interaction) it is natural to combine \char`\"{}related\char`\"{} dof blocks into compound block matrices. We showed that the block preconditioning framework makes it easy to extract such matrices from the original system matrix and demonstrated how to solve linear systems involving these matrices with separate subsidiary preconditioners. One problem with this approach is that, once a compound matrix has been created (by the {\ttfamily get\+\_\+block}(...) function), all information about its dof types is lost, making it impossible to employ block preconditioners as subsidiary preconditioners.

We will now revisit the 2x2 block triangular preconditioner described in the previous example and demonstrate how to employ subsidiary block preconditioners to (approximately) solve linear systems involving matrices formed (formally) by compound matrices that are constructed from multiple dof-\/level blocks. From a mathematical point of view, the structure of the preconditioner therefore remains unchanged and is given by \[ \hspace{3cm} {\bf P} = \left( \begin{array}{cc|ccc} J_{11} & J_{12} & J_{13} & J_{14} & J_{15} \\ J_{21} & J_{22} & J_{13} & J_{14} & J_{15} \\ \hline & & J_{33} & J_{34} & J_{35} \\ & & J_{43} & J_{44} & J_{45} \\ & & J_{53} & J_{54} & J_{55} \\ \end{array} \right)= \left( \begin{array}{c|c} B_{11} & B_{12}\\ \hline & B_{22} \\ \end{array} \right). \hspace{3cm} (13) \] We will continue to use a dof-\/to-\/block mapping to view this as the 2x2 block matrix shown on the right. This makes it easy to extract the compound off-\/diagonal block $ B_{12} $ from the system matrix when setting up the matrix-\/vector product (as before). The setup of the subsidiary block preconditioners used to (approximately) solve the linear systems involving $ B_{11} $ and $ B_{22}$ is handled differently\+:
\begin{DoxyItemize}
\item When calling the subsidiary block preconditioner\textquotesingle{}s {\ttfamily setup}(...) function we pass a pointer to the entire system matrix, i.\+e. the matrix containing, formally, all the dof-\/level blocks in equation (3).
\end{DoxyItemize}
\begin{DoxyItemize}
\item We then turn the preconditioner into a subsidiary block preconditioner, using its member function {\ttfamily turn\+\_\+into\+\_\+subsidiary\+\_\+block\+\_\+preconditioner}(...) whose arguments specify which of the dof-\/level blocks in the current (master) preconditioner are to be used by the subsidiary block preconditioner.
\end{DoxyItemize}The subsidiary block preconditioner is thus given access to all the information required to extract the relevant data directly from the original system matrix (and any associated full-\/length vectors). It is in fact a key design principle of the block preconditioning framework that {\bfseries subsidiary block preconditioners are given access to the \char`\"{}full size\char`\"{} matrices and vectors, but only operate on the subset of data that they are \char`\"{}in charge of\char`\"{}.}

When employing subsidiary block preconditioners for the approximate solution of the two smaller linear systems \[ \begin{array}{c} \underbrace{ \left( \begin{array}{cc} J_{11} & J_{12} \\ J_{21} & J_{22} \\ \end{array} \right) }_{B_{11}} \underbrace{ \left( \begin{array}{c} y_1 \\ y_2 \\ \end{array} \right) }_{Y_{1}} = \underbrace{ \left( \begin{array}{c} z_1 \\ z_2 \\ \end{array} \right) }_{{\bf Z}_1} - \underbrace{ \left( \begin{array}{ccc} J_{13} & J_{14} & J_{15} \\ J_{23} & J_{24} & J_{25} \\ \end{array} \right) }_{B_{12}} \underbrace{ \left( \begin{array}{c} y_3 \\ y_4 \\ y_5 \\ \end{array} \right) }_{{\bf Y}_2} \\ \hspace{3cm} (14) \\ \underbrace{ \left( \begin{array}{ccc} J_{33} & J_{34} & J_{35} \\ J_{43} & J_{44} & J_{45} \\ J_{53} & J_{54} & J_{55} \\ \end{array} \right) }_{B_{22}} \underbrace{ \left( \begin{array}{c} y_3 \\ y_4 \\ y_5 \\ \end{array} \right) }_{{\bf Y}_2} = \underbrace{ \left( \begin{array}{c} z_3 \\ z_4 \\ z_5 \\ \end{array} \right) }_{{\bf Z}_2}, \end{array} \] the subsidiary preconditioners that operate on the linear systems involving $ B_{11} $ and $ B_{22} $ therefore retain access to the relevant dof-\/level blocks. Hence, if we employ the block triangular preconditioner discussed above to (approximately) solve the two linear systems in equation (14), the complete preconditioning operation is described by the following equations\+: \[ \begin{array}{c} \left( \begin{array}{cc} J_{11} & J_{12} \\ & J_{22} \\ \end{array} \right) \left( \begin{array}{c} y_1 \\ y_2 \\ \end{array} \right) = \underbrace{ \underbrace{ \left( \begin{array}{c} z_1 \\ z_2 \\ \end{array} \right) }_{{\bf Z}_1} - \underbrace{ \left( \begin{array}{ccc} J_{13} & J_{14} & J_{15} \\ J_{23} & J_{24} & J_{25} \\ \end{array} \right) }_{B_{12}} \underbrace{ \left( \begin{array}{c} y_3 \\ y_4 \\ y_5 \\ \end{array} \right) }_{{\bf Y}_2} }_{\widehat{\bf Z}_1} \\ \left( \begin{array}{ccc} J_{33} & J_{34} & J_{35} \\ & J_{44} & J_{45} \\ & & J_{55} \\ \end{array} \right) \left( \begin{array}{c} y_3 \\ y_4 \\ y_5 \\ \end{array} \right) = \left( \begin{array}{c} z_3 \\ z_4 \\ z_5 \\ \end{array} \right). \end{array} \] Note that when we wrote the block triangular preconditioner we did not have to be aware of the fact that it may subsequently be used as a subsidiary block preconditioner. The internal data structures implemented in the {\ttfamily Block\+Preconditioner} base class ensure that when we call {\ttfamily get\+\_\+block(0,0,block\+\_\+matrix)} in the subsidiary block preconditioner acting on $ B_{22} $, {\ttfamily block\+\_\+matrix} will receive a deep copy of $ J_{33} $, extracted from the full system matrix. Similarly, a call to {\ttfamily get\+\_\+block\+\_\+vectors(r,block\+\_\+r)} will extract the three block vectors $ {\bf r}_3, {\bf r}_4 $ and ${\bf r}_5 $ from the full-\/length vector $ {\bf r} $, while {\ttfamily return\+\_\+block\+\_\+vectors(block\+\_\+z,z)} will return the three solution vectors $ {\bf z_3}, {\bf z_4} $ and $ {\bf z_5} $ to the appropriate entries in the full-\/length vector $ {\bf z}. $

The implementation of the preconditioning operations can again be subdivided into two distinct {\ttfamily setup()} and {\ttfamily preconditioner\+\_\+solve}(...) phases.
\begin{DoxyItemize}
\item Set up the data structures/lookup tables that map dof types 0 and 1 to block 0 and dof types 2, 3 and 4 to block 1 \mbox{[}by calling the {\ttfamily Block\+Preconditioner\+::block\+\_\+setup}(...) function with arguments that specify the mapping between \char`\"{}dof types\char`\"{} and \char`\"{}block types\char`\"{} as before\mbox{]}.
\item Create two instances of the block triangular preconditioner (or any other block preconditioner) and turn them into the subsidiary preconditioners for the current (master) preconditioner, specifying which dof types in the master preconditioner the subsidiary block preconditioners are to work with.
\item Extract the compound off-\/diagonal block $ B_{12}$ and create a {\ttfamily Matrix\+Vector\+Product} operator.
\end{DoxyItemize}

Once the {\ttfamily setup()} phase has been completed, the solution of the linear system ${\bf P} {\bf y} = {\bf z}$ by the {\ttfamily preconditioner\+\_\+solve}(...) function involves the following steps\+:
\begin{DoxyItemize}
\item Solve the linear systems $ {\bf B}_{22} \ {\bf Y}_2 = {\bf Z}_2$ using the subsidiary block preconditioner that works with $ {\bf B}_{22} $. \mbox{[}The subsidiary block preconditioner\textquotesingle{}s {\ttfamily preconditioner\+\_\+solve}(...) function is given access to the full-\/size vectors $ {\bf z} $ and $ {\bf y} $ and extracts/returns $ {\bf Z}_2 $ and $ {\bf Y}_2$ directly from/into these.\mbox{]}
\item Extract the solution vector $ {\bf Y}_2 $ from the just undated full-\/length vector $ {\bf y} $, perform the matrix vector product with $ B_{12} $ and store the result in a temporary vector $ {\bf t} $.
\item Extract the block vector $ {\bf Z}_1$ from the full-\/length vector $ {\bf z} $, subtract $ {\bf t} $ from it, and return the result, $ \widehat{\bf Z}_1 = {\bf Z}_1 - B_{12} {\bf Z}_2 $ into the appropriate entries into the full-\/length vector $ {\bf z} $.
\item Solve the linear systems $ {\bf B}_{11} \ {\bf Y}_1 = \widehat{\bf Z}_1 = {\bf Z}_1 - B_{12} {\bf Z}_2 $ using the subsidiary block preconditioner that works with $ {\bf B}_{11} $. \mbox{[}The subsidiary block preconditioner\textquotesingle{}s {\ttfamily preconditioner\+\_\+solve}(...) function is given access to the full-\/size vectors $ {\bf z} $ and $ {\bf y} $ and extracts/returns $ \widehat{\bf Z}_1 $ and $ {\bf Y}_1$ directly from/into these; recall that the relevant entries in $ {\bf z}$ have been over-\/written in the previous step so that $ \widehat{\bf Z}_1 $ contains the updated right hand side.\mbox{]}
\end{DoxyItemize}\hypertarget{index_two_plus_three_upper_triangular_with_sub_implementation}{}\subsubsection{Implementation as a Block\+Preconditioner}\label{index_two_plus_three_upper_triangular_with_sub_implementation}
The implementation of the preconditioner is completely equivalent to the corresponding block triangular preconditioner considered in the previous example\+:


\begin{DoxyCodeInclude}
\textcolor{comment}{//=========start\_of\_two\_plus\_three\_upper\_triangular\_with\_sub\_class=============}\textcolor{comment}{}
\textcolor{comment}{/// \(\backslash\)short Upper block triangular with subsidiary block preconditioners }
\textcolor{comment}{/// for a system with 5 dof types.}
\textcolor{comment}{}\textcolor{comment}{//=============================================================================}
 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MATRIX> 
 \textcolor{keyword}{class }TwoPlusThreeUpperTriangularWithOneLevelSubsidiary 
  : \textcolor{keyword}{public} BlockPreconditioner<MATRIX>
 \{
 
 public :
 \textcolor{comment}{}
\textcolor{comment}{  /// Constructor.}
\textcolor{comment}{}  TwoPlusThreeUpperTriangularWithOneLevelSubsidiary() :
   BlockPreconditioner<MATRIX>(),
    Off\_diagonal\_matrix\_vector\_product\_pt(0),
    First\_subsidiary\_preconditioner\_pt(0),
    Second\_subsidiary\_preconditioner\_pt(0)
   \{
    Multi\_poisson\_mesh\_pt=0;
   \}
 \textcolor{comment}{}
\textcolor{comment}{  /// Destructor - delete the preconditioner matrices}
\textcolor{comment}{}  \textcolor{keyword}{virtual} ~TwoPlusThreeUpperTriangularWithOneLevelSubsidiary()
   \{
    this->clean\_up\_my\_memory();
   \}
\textcolor{comment}{}
\textcolor{comment}{  /// Clean up the memory}
\textcolor{comment}{}  \textcolor{keywordtype}{void} clean\_up\_my\_memory();
 \textcolor{comment}{}
\textcolor{comment}{  /// Broken copy constructor}
\textcolor{comment}{}  TwoPlusThreeUpperTriangularWithOneLevelSubsidiary
  (\textcolor{keyword}{const} TwoPlusThreeUpperTriangularWithOneLevelSubsidiary&) 
   \{ 
    BrokenCopy::broken\_copy
     (\textcolor{stringliteral}{"TwoPlusThreeUpperTriangularWithOneLevelSubsidiary"});
   \} 
 \textcolor{comment}{}
\textcolor{comment}{  /// Broken assignment operator}
\textcolor{comment}{}  \textcolor{keywordtype}{void} operator=(\textcolor{keyword}{const} 
                 TwoPlusThreeUpperTriangularWithOneLevelSubsidiary&) 
   \{
    BrokenCopy::broken\_assign(
     \textcolor{stringliteral}{"TwoPlusThreeUpperTriangularWithOneLevelSubsidiary"});
   \}
 \textcolor{comment}{}
\textcolor{comment}{  /// Apply preconditioner to r}
\textcolor{comment}{}  \textcolor{keywordtype}{void} preconditioner\_solve(\textcolor{keyword}{const} DoubleVector &r, DoubleVector &z);
 \textcolor{comment}{}
\textcolor{comment}{  /// \(\backslash\)short Setup the preconditioner }
\textcolor{comment}{}  \textcolor{keywordtype}{void} setup();

  \textcolor{comment}{// Use the version in the Preconditioner base class for the alternative}
  \textcolor{comment}{// setup function that takes a matrix pointer as an argument.}
  \textcolor{keyword}{using} Preconditioner::setup;
\textcolor{comment}{}
\textcolor{comment}{  /// Specify the mesh that contains multi-poisson elements}
\textcolor{comment}{}  \textcolor{keywordtype}{void} set\_multi\_poisson\_mesh(Mesh* multi\_poisson\_mesh\_pt)
  \{
   Multi\_poisson\_mesh\_pt=multi\_poisson\_mesh\_pt;
  \}

 \textcolor{keyword}{private}:  
\textcolor{comment}{}
\textcolor{comment}{  /// Pointer to matrix vector product operators for the off diagonal block}
\textcolor{comment}{}  MatrixVectorProduct* Off\_diagonal\_matrix\_vector\_product\_pt;
\textcolor{comment}{}
\textcolor{comment}{  /// \(\backslash\)short Pointer to preconditioners/inexact solver}
\textcolor{comment}{  /// for (0,0) block}
\textcolor{comment}{}  Preconditioner* First\_subsidiary\_preconditioner\_pt;
  \textcolor{comment}{}
\textcolor{comment}{  /// \(\backslash\)short Pointer to preconditioners/inexact solver}
\textcolor{comment}{  /// for (1,1) block}
\textcolor{comment}{}  Preconditioner* Second\_subsidiary\_preconditioner\_pt;
\textcolor{comment}{}
\textcolor{comment}{  /// \(\backslash\)short Pointer to mesh with preconditionable elements used}
\textcolor{comment}{  /// for classification of dof types.}
\textcolor{comment}{}  Mesh* Multi\_poisson\_mesh\_pt;

 \};

\end{DoxyCodeInclude}
\hypertarget{index_two_plus_three_upper_triangular_with_sub_setup}{}\subsubsection{The setup() function}\label{index_two_plus_three_upper_triangular_with_sub_setup}
As usual we free up any memory and set the pointer to the mesh\+:


\begin{DoxyCodeInclude}
 \textcolor{comment}{//=======start\_of\_setup\_for\_two\_plus\_three\_upper\_triangular\_with\_sub\_class====}\textcolor{comment}{}
\textcolor{comment}{ /// The setup function.}
\textcolor{comment}{} \textcolor{comment}{//============================================================================}
 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MATRIX> 
 \textcolor{keywordtype}{void} TwoPlusThreeUpperTriangularWithOneLevelSubsidiary<MATRIX>::setup()
 \{
  \textcolor{comment}{// clean the memory}
  this->clean\_up\_my\_memory();

\textcolor{preprocessor}{#ifdef PARANOID}
  \textcolor{keywordflow}{if} (Multi\_poisson\_mesh\_pt == 0)
   \{
    std::stringstream err;
    err << \textcolor{stringliteral}{"Please set pointer to mesh using set\_multi\_poisson\_mesh(...).\(\backslash\)n"};
    \textcolor{keywordflow}{throw} OomphLibError(err.str(),
                        OOMPH\_CURRENT\_FUNCTION,
                        OOMPH\_EXCEPTION\_LOCATION);
   \}
\textcolor{preprocessor}{#endif }
  
  \textcolor{comment}{// The preconditioner works with one mesh; set it!}
  this->set\_nmesh(1);
  this->set\_mesh(0,Multi\_poisson\_mesh\_pt);

\end{DoxyCodeInclude}


We check that the number of dof types is appropriate for this preconditioner\+: 
\begin{DoxyCodeInclude}

  \textcolor{comment}{// number of dof types  }
  \textcolor{keywordtype}{unsigned} n\_dof\_types = this->ndof\_types();

\textcolor{preprocessor}{#ifdef PARANOID}
  \textcolor{comment}{// This preconditioner only works for 5 dof types}
  \textcolor{keywordflow}{if} (n\_dof\_types!=5)
   \{
    std::stringstream tmp;
    tmp << \textcolor{stringliteral}{"This preconditioner only works for problems with 5 dof types\(\backslash\)n"}
        << \textcolor{stringliteral}{"Yours has "} << n\_dof\_types;
    \textcolor{keywordflow}{throw} OomphLibError(tmp.str(),
                        OOMPH\_CURRENT\_FUNCTION,
                        OOMPH\_EXCEPTION\_LOCATION);
   \}
\textcolor{preprocessor}{#endif}

\end{DoxyCodeInclude}


Next we define the block structure of the preconditioner, using a dof-\/to-\/block mapping to combine dofs 0 and 1 into block 0, and dofs 2, 3 and 4 into block 1\+:


\begin{DoxyCodeInclude}
  \textcolor{comment}{// Combine "dof blocks" into two compound blocks, one containing dof }
  \textcolor{comment}{// types 0 and 1, the final one dof types 2-4. In general we want:}
  \textcolor{comment}{// dof\_to\_block\_map[dof\_type] = block type}
  Vector<unsigned> dof\_to\_block\_map(n\_dof\_types);
  dof\_to\_block\_map[0]=0;
  dof\_to\_block\_map[1]=0;
  dof\_to\_block\_map[2]=1;
  dof\_to\_block\_map[3]=1;
  dof\_to\_block\_map[4]=1;
  this->block\_setup(dof\_to\_block\_map);

\end{DoxyCodeInclude}


Next we create the block triangular preconditioner used to (approximately) solve linear systems involving the compound \char`\"{}top left\char`\"{} 2x2 block\+: 
\begin{DoxyCodeInclude}
  \textcolor{comment}{// Create the subsidiary block preconditioners.  }
  \{
   \textcolor{comment}{// Block upper triangular block preconditioner for compound }
   \textcolor{comment}{// 2x2 top left block in "big" 5x5 matrix}
   UpperTriangular<CRDoubleMatrix>* block\_prec\_pt=
    \textcolor{keyword}{new} UpperTriangular<CRDoubleMatrix>;
   First\_subsidiary\_preconditioner\_pt=block\_prec\_pt;

\end{DoxyCodeInclude}


Next we specify the pointer to the mesh that contains the elements that classify the degrees of freedom. We note, that, strictly speaking this is not necessary since the preconditioner will only be used as a subsidiary preconditioner -- the enumeration of the dof types is always handled by the top-\/most master preconditioner. One (or more) mesh pointers must be set for the master preconditioner, and, if compiled in {\ttfamily P\+A\+R\+A\+N\+O\+ID} mode, {\ttfamily oomph-\/lib} will throw an error if this is not done. Some (but not all!) {\ttfamily oomph-\/lib} developers regard it as \char`\"{}good practice\char`\"{} to set the mesh pointer anyway, so one is less likely to forget...


\begin{DoxyCodeInclude}
   \textcolor{comment}{// Set mesh}
   block\_prec\_pt->set\_multi\_poisson\_mesh(Multi\_poisson\_mesh\_pt);

\end{DoxyCodeInclude}


We turn this preconditioner into a subsidiary block preconditioner, specifying the pointer to the current (master) preconditioner and the mapping between dof types in the present and the subsidiary block preconditioners (here the identity)\+: 
\begin{DoxyCodeInclude}
   
   \textcolor{comment}{// Turn into a subsidiary preconditioner, declaring which}
   \textcolor{comment}{// of the five dof types in the present (master) preconditioner}
   \textcolor{comment}{// correspond to the dof types in the subsidiary block preconditioner:}
   \textcolor{comment}{// dof\_map[dof\_block\_ID\_in\_subsdiary] = dof\_block\_ID\_in\_master. Also }
   \textcolor{comment}{// pass pointer to present (master) preconditioner.}
   \textcolor{keywordtype}{unsigned} n\_sub\_dof\_types=2;
   Vector<unsigned> dof\_map(n\_sub\_dof\_types);
   dof\_map[0]=0;
   dof\_map[1]=1;
   block\_prec\_pt->turn\_into\_subsidiary\_block\_preconditioner(\textcolor{keyword}{this},dof\_map);

\end{DoxyCodeInclude}


When calling the subsidiary block preconditioners {\ttfamily setup}(...) function we pass a pointer to the full matrix\+: 
\begin{DoxyCodeInclude}
    
   \textcolor{comment}{// Setup: Pass pointer to full-size matrix!}
   block\_prec\_pt->setup(this->matrix\_pt());
  \}

\end{DoxyCodeInclude}


The second subsidiary block preconditioner (for the 3x3 \char`\"{}bottom right\char`\"{} compound matrix) is created similarly, though the mapping between dof-\/types is now no longer the identity but maps dof types 2, 3 and 4 in the current (master) preconditioner to dof types 0, 1 and 2 in the subsidiary block preconditioner\+: 
\begin{DoxyCodeInclude}

  \{
   \textcolor{comment}{// Block upper triangular for 3x3 bottom right block in "big" 5x5 matrix}
   UpperTriangular<CRDoubleMatrix>* block\_prec\_pt=
    \textcolor{keyword}{new} UpperTriangular<CRDoubleMatrix>;
   Second\_subsidiary\_preconditioner\_pt=block\_prec\_pt;
   
   \textcolor{comment}{// Set mesh}
   block\_prec\_pt->set\_multi\_poisson\_mesh(Multi\_poisson\_mesh\_pt);
   
   \textcolor{comment}{// Turn second\_sub into a subsidiary preconditioner, declaring which}
   \textcolor{comment}{// of the five dof types in the present (master) preconditioner}
   \textcolor{comment}{// correspond to the dof types in the subsidiary block preconditioner:}
   \textcolor{comment}{// dof\_map[dof\_block\_ID\_in\_subsdiary] = dof\_block\_ID\_in\_master. Also }
   \textcolor{comment}{// pass pointer to present (master) preconditioner.}
   \textcolor{keywordtype}{unsigned} n\_sub\_dof\_types=3;
   Vector<unsigned> dof\_map(n\_sub\_dof\_types);
   dof\_map[0]=2;
   dof\_map[1]=3;
   dof\_map[2]=4;
   block\_prec\_pt->turn\_into\_subsidiary\_block\_preconditioner(\textcolor{keyword}{this},dof\_map);    

   \textcolor{comment}{// Setup: Pass pointer to full-size matrix!}
   block\_prec\_pt->setup(this->matrix\_pt());
  \}

\end{DoxyCodeInclude}


The setup of the matrix-\/vector product with the off-\/diagonal matrix is unchanged from the previous example\+:


\begin{DoxyCodeInclude}
  \textcolor{comment}{// Setup the off-diagonal mat vec operator}
  \{
   \textcolor{comment}{// Get the off-diagonal block: the top-right block in the present}
   \textcolor{comment}{// block preconditioner (which views the system matrix as comprising}
   \textcolor{comment}{// 2x2 blocks).}
   CRDoubleMatrix block\_matrix = this->get\_block(0,1);
   
   \textcolor{comment}{// Create matrix vector product}
   Off\_diagonal\_matrix\_vector\_product\_pt = \textcolor{keyword}{new} MatrixVectorProduct;
   
   \textcolor{comment}{// Setup: Final argument indicates block column in the present}
   \textcolor{comment}{// block preconditioner (which views the system matrix as comprising}
   \textcolor{comment}{// 2x2 blocks).}
   \textcolor{keywordtype}{unsigned} block\_column\_index=1;
   this->setup\_matrix\_vector\_product(
    Off\_diagonal\_matrix\_vector\_product\_pt,&block\_matrix,block\_column\_index);
  \}
 
 \}

\end{DoxyCodeInclude}
\hypertarget{index_two_plus_three_upper_triangular_with_sub_solve}{}\subsubsection{The preconditioner\+\_\+solve() function}\label{index_two_plus_three_upper_triangular_with_sub_solve}
As discussed in the theory section, we start by (approximately) solving the system $ B_{22} Y_2 = Z_2 $, using the second subsidiary block preconditioner which automatically extracts $ Z_2 $ from the full length vector {\ttfamily z} and returns the result $ Y_2 $ into the appropriate entries of the full length vector {\ttfamily y}.


\begin{DoxyCodeInclude}
 \textcolor{comment}{//=============================================================================}\textcolor{comment}{}
\textcolor{comment}{ /// Preconditioner solve }
\textcolor{comment}{} \textcolor{comment}{//=============================================================================}
 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MATRIX> 
 \textcolor{keywordtype}{void} TwoPlusThreeUpperTriangularWithOneLevelSubsidiary<MATRIX>::
 preconditioner\_solve(\textcolor{keyword}{const} DoubleVector& z, DoubleVector& y)
 \{
  \textcolor{comment}{// Solve "bottom right" (1,1) diagonal block system, using the }
  \textcolor{comment}{// subsidiary block preconditioner that acts on the}
  \textcolor{comment}{// "bottom right" 3x3 sub-system (only!). The subsidiary preconditioner }
  \textcolor{comment}{// will extract the relevant (3x1) "sub-vectors" from the "big" (5x1)}
  \textcolor{comment}{// vector z and treat it as the rhs, r, of P y = z}
  \textcolor{comment}{// where P is 3x3 a block matrix. Once the system is solved,}
  \textcolor{comment}{// the result is automatically put back into the appropriate places }
  \textcolor{comment}{// of the "big" (5x1) vector y:}
  Second\_subsidiary\_preconditioner\_pt->preconditioner\_solve(z,y);

\end{DoxyCodeInclude}


We now extract the block vector $ Y_2 $ from the full-\/length vector {\ttfamily y}, 
\begin{DoxyCodeInclude}
    
  \textcolor{comment}{// Now extract the "bottom" (3x1) block vector from the full-size (5x1)}
  \textcolor{comment}{// solution vector that we've just computed -- note that index 1}
  \textcolor{comment}{// refers to the block enumeration in the current preconditioner}
  \textcolor{comment}{// (which has two blocks!)}
  DoubleVector block\_y;
  this->get\_block\_vector(1,y,block\_y);

\end{DoxyCodeInclude}


multiply it by $ B_{12} $, using the {\ttfamily Matrix\+Vector\+Product} operator, 
\begin{DoxyCodeInclude}

  \textcolor{comment}{// Evaluate matrix vector product of just-extracted (3x1) solution }
  \textcolor{comment}{// vector with off-diagonal block and store in temporary vector}
  DoubleVector temp;
  Off\_diagonal\_matrix\_vector\_product\_pt->multiply(block\_y,temp);

\end{DoxyCodeInclude}


and subtract the result from $ Z_1 $ (which we extract from the full length vector {\ttfamily z} )\+:


\begin{DoxyCodeInclude}
  \textcolor{comment}{// Extract "upper" (2x1) block vector from full-size (5x1) rhs }
  \textcolor{comment}{// vector (as passed into this function)...}
  DoubleVector block\_z;
  this->get\_block\_vector(0,z,block\_z);

  \textcolor{comment}{// ...and subtract matrix vector product computed above}
  block\_z -= temp;   

\end{DoxyCodeInclude}


{\ttfamily block\+\_\+z} now contains the updated right hand side, $ \widehat{{\bf Z}_1}$, for the linear system to be (approximately) solved by the first subsidiary block preconditioner. We therefore return $ \widehat{{\bf Z}_1}$ to the appropriate entries into a full length vector of the same size as right hand side vector {\ttfamily z\+:} 


\begin{DoxyCodeInclude}

  \textcolor{comment}{// Block solve for first diagonal block. Since the associated subsidiary }
  \textcolor{comment}{// preconditioner is a block preconditioner itself, it will extract }
  \textcolor{comment}{// the required (2x1) block from a "big" (5x1) rhs vector.}
  \textcolor{comment}{// Therefore we first put the actual (2x1) rhs vector block\_z into a}
  \textcolor{comment}{// "big" (5x1) vector big\_z whose row distribution matches that of the}
  \textcolor{comment}{// "big" right hand side vector, z, that was passed into this function.}
  DoubleVector big\_z(z.distribution\_pt());
  this->return\_block\_vector(0,block\_z,big\_z);

\end{DoxyCodeInclude}


We then pass this vector to first subsidiary preconditioner which updates the appropriate entries in the full-\/length solution vector {\ttfamily y} which can therefore be returned directly by this function\+:


\begin{DoxyCodeInclude}
  \textcolor{comment}{// Now apply the subsidiary block preconditioner that acts on the}
  \textcolor{comment}{// "upper left" (2x2) sub-system (only!). The subsidiary preconditioner }
  \textcolor{comment}{// will extract the relevant (2x1) block vector from the "big" (5x1)}
  \textcolor{comment}{// vector big\_r and treat it as the rhs, z, of its P y = z}
  \textcolor{comment}{// where P is upper left 2x2 block diagonal of the big system. }
  \textcolor{comment}{// Once the system is solved, the result is automatically put back }
  \textcolor{comment}{// into the appropriate places of the "big" (5x1) vector y which is }
  \textcolor{comment}{// returned by the current function, so no further action is required.}
  First\_subsidiary\_preconditioner\_pt->preconditioner\_solve(big\_z,y);
 \}

\end{DoxyCodeInclude}
\hypertarget{index_two_plus_three_upper_triangular_with_sub_clean}{}\subsubsection{The clean\+\_\+up\+\_\+my\+\_\+memory() function}\label{index_two_plus_three_upper_triangular_with_sub_clean}
As usual, we use this helper function to free up any memory allocated in the {\ttfamily setup()} function to avoid memory leaks.


\begin{DoxyCodeInclude}
 \textcolor{comment}{//====start\_of\_clean\_up\_for\_two\_plus\_three\_upper\_triangular\_with\_sub\_class=====}\textcolor{comment}{}
\textcolor{comment}{ /// The clean up function.}
\textcolor{comment}{} \textcolor{comment}{//============================================================================}
 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MATRIX> 
 \textcolor{keywordtype}{void} TwoPlusThreeUpperTriangularWithOneLevelSubsidiary<MATRIX>::
 clean\_up\_my\_memory()
 \{     
  \textcolor{comment}{// Delete off-diagonal matrix vector product}
  \textcolor{keywordflow}{if}(Off\_diagonal\_matrix\_vector\_product\_pt!= 0)
   \{
    \textcolor{keyword}{delete} Off\_diagonal\_matrix\_vector\_product\_pt;
    Off\_diagonal\_matrix\_vector\_product\_pt = 0;
   \}

  \textcolor{comment}{//Clean up subsidiary preconditioners.}
  \textcolor{keywordflow}{if}(First\_subsidiary\_preconditioner\_pt!=0)
   \{
    \textcolor{keyword}{delete} First\_subsidiary\_preconditioner\_pt;
    First\_subsidiary\_preconditioner\_pt = 0;
   \}
  \textcolor{keywordflow}{if}(Second\_subsidiary\_preconditioner\_pt!=0)
   \{
    \textcolor{keyword}{delete} Second\_subsidiary\_preconditioner\_pt;
    Second\_subsidiary\_preconditioner\_pt = 0;
   \}
 \} \textcolor{comment}{// End of clean\_up\_my\_memory function.}

\end{DoxyCodeInclude}




 

\hypertarget{index_two_plus_three_upper_triangular_with_replace}{}\subsection{Replacing/modifying blocks}\label{index_two_plus_three_upper_triangular_with_replace}
N\+EW F\+E\+A\+T\+U\+R\+ES\+: How to replace/modify matrix blocks\hypertarget{index_two_plus_three_upper_triangular_with_replace_theory}{}\subsubsection{Theory}\label{index_two_plus_three_upper_triangular_with_replace_theory}
So far, we have demonstrated how to extract matrix blocks from the full-\/sized system matrix (typically the Jacobian matrix used in Newton\textquotesingle{}s method) and how to apply a preconditioner via operations involving these blocks. Many preconditioners do not operate directly with the matrix blocks themselves, but on matrices that are derived from them. For instance, {\ttfamily oomph-\/lib}\textquotesingle{}s \href{../../../preconditioners/lsc_navier_stokes/html/index.html}{\tt Schur complement Navier-\/\+Stokes preconditioner} operates on an (approximate) Schur complement; augmentation preconditioners involve operations on matrices that are obtained by the addition of a diagonal matrix to some of the matrix blocks; etc. Within a given preconditioner such derived matrices are typically pre-\/computed by the preconditioner\textquotesingle{}s {\ttfamily setup()} function and then stored as private member data which makes them available to the {\ttfamily preconditioner\+\_\+solve()} function. Unfortunately, this approach does not work if the modified block is to be used in a subsidiary block preconditioner because, as discussed in the previous example, by default the subsidiary block preconditioner will extract its block matrices directly from the full-\/size system matrix and will therefore ignore any (local) modifications made by its master preconditioner(s). What is therefore required is a method that indicates to the block preconditioning framework that a given sub-\/block is not to be extracted from the full system matrix but to be represented by suitable replacement matrix.

We demonstrate this methodology by re-\/visiting the preconditioner considered in the previous example, namely \[ \hspace{3cm} {\bf P}_{\rm previous} = \left( \begin{array}{cc|ccc} J_{11} & J_{12} & J_{13} & J_{14} & J_{15} \\ J_{21} & J_{22} & J_{13} & J_{14} & J_{15} \\ \hline & & J_{33} & J_{34} & J_{35} \\ & & J_{43} & J_{44} & J_{45} \\ & & J_{53} & J_{54} & J_{55} \\ \end{array} \right). \hspace{3cm} (15) \] However, here we want to modify the off-\/diagonal blocks by \char`\"{}replacing\char`\"{} each block $J_{ij}$ (for $ i \ne j $) by a \char`\"{}replacement matrix\char`\"{} $R_{ij}$ so that the preconditioner becomes \[ {\bf P} = \left( \begin{array}{cc|ccc} J_{11} & R_{12} & R_{13} & R_{14} & R_{15} \\ R_{21} & J_{22} & R_{23} & R_{24} & R_{25} \\ \hline & & J_{33} & R_{34} & R_{35} \\ & & R_{43} & J_{44} & R_{45} \\ & & R_{53} & R_{54} & J_{55} \\ \end{array} \right) = \left( \begin{array}{c|c} B_{11} & B_{12}\\ \hline & B_{22} \\ \end{array} \right). \hspace{3cm} (16) \] The application of this preconditioner (i.\+e. the solution of the linear system ${\bf P} {\bf y} ={\bf z}$ for ${\bf y}$) still requires the solution of the two smaller linear systems \[ \begin{array}{c} \underbrace{ \left( \begin{array}{cc} J_{11} & R_{12} \\ R_{21} & J_{22} \\ \end{array} \right) }_{B_{11}} \left( \begin{array}{c} y_1 \\ y_2 \\ \end{array} \right) = \left( \begin{array}{c} z_1 \\ z_2 \\ \end{array} \right) - \underbrace{ \left( \begin{array}{ccc} R_{13} & R_{14} & R_{15} \\ R_{23} & R_{24} & R_{25} \\ \end{array} \right) }_{B_{12}} \left( \begin{array}{c} z_3 \\ z_4 \\ z_5 \\ \end{array} \right) \\ \hspace{3cm} (17) \\ \underbrace{ \left( \begin{array}{ccc} J_{33} & R_{34} & R_{35} \\ R_{43} & J_{44} & R_{45} \\ R_{53} & R_{54} & J_{55} \\ \end{array} \right) }_{B_{22}} \left( \begin{array}{c} y_3 \\ y_4 \\ y_5 \\ \end{array} \right) = \left( \begin{array}{c} z_3 \\ z_4 \\ z_5 \\ \end{array} \right) \end{array} \] where we have again assumed that the two vectors ${\bf y}$ and ${\bf z}$ are re-\/ordered into ``block vectors\textquotesingle{}\textquotesingle{} in the same way as the vectors $\delta {\bf x}$ and ${\bf r}$ in \char`\"{}the original linear system\char`\"{} (3) are re-\/ordered into the ``block vectors\textquotesingle{}\textquotesingle{} in (17). We wish to continue to solve the linear systems involving the compound matrices $ B_{11} $ and $ B_{22} $ (which involve \char`\"{}replaced\char`\"{} blocks) by two subsidiary block preconditioners (which operate on 3x3 and 2x2 dof blocks, respectively).

In the specific example below we replace all of the diagonal matrices by suitably sized zero matrices, so that the actual preconditioning operation is defined by the following linear systems \[ \begin{array}{c} \underbrace{ \left( \begin{array}{cc} J_{11} & \\ & J_{22} \\ \end{array} \right) }_{B_{11}} \left( \begin{array}{c} y_1 \\ y_2 \\ \end{array} \right) = \left( \begin{array}{c} z_1 \\ z_2 \\ \end{array} \right) - \underbrace{ \left( \begin{array}{ccc} & & \\ & & \\ \end{array} \right) }_{B_{12}} \left( \begin{array}{c} z_3 \\ z_4 \\ z_5 \\ \end{array} \right) \\ \underbrace{ \left( \begin{array}{ccc} J_{33} & & \\ & J_{44} & \\ & & J_{55} \\ \end{array} \right) }_{B_{22}} \left( \begin{array}{c} y_3 \\ y_4 \\ y_5 \\ \end{array} \right) = \left( \begin{array}{c} z_3 \\ z_4 \\ z_5 \\ \end{array} \right) \end{array} \] which, in effect, turns the preconditioner into the block-\/diagonal preconditioner considered at the very beginning of this tutorial.\hypertarget{index_two_plus_three_upper_triangular_with_replace_implementation}{}\subsubsection{Implementation as a Block\+Preconditioner}\label{index_two_plus_three_upper_triangular_with_replace_implementation}
The implementation of the preconditioner is completely equivalent to the preconditioner considered in the previous example. The only additional feature is the provision a matrix of pointers to the replacement matrices, {\ttfamily Replacement\+\_\+matrix\+\_\+pt}.


\begin{DoxyCodeInclude}
\textcolor{comment}{//=============start\_of\_two\_plus\_three\_upper\_triangular\_with\_replace\_class=====}\textcolor{comment}{}
\textcolor{comment}{/// \(\backslash\)short Block diagonal preconditioner for system with 5 dof types}
\textcolor{comment}{/// assembled into a 2x2 block system, with (0,0) block containing}
\textcolor{comment}{/// the first two dof types, the (1,1) block the remaining dof types.}
\textcolor{comment}{/// The blocks are solved by upper block triangular preconditioners.}
\textcolor{comment}{/// However, the overall system is modified by replacing all off-diagonal }
\textcolor{comment}{/// blocks by replacement matrices (zero matrices, so the preconditioner }
\textcolor{comment}{/// again behaves like a 5x5 block diagonal preconditioner).}
\textcolor{comment}{}\textcolor{comment}{//=============================================================================}
 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MATRIX> 
 \textcolor{keyword}{class }TwoPlusThreeUpperTriangularWithReplace : 
  \textcolor{keyword}{public} BlockPreconditioner<MATRIX>
 \{
  
 public :
  \textcolor{comment}{}
\textcolor{comment}{  /// Constructor for TwoPlusThreeUpperTriangularWithReplace}
\textcolor{comment}{}  TwoPlusThreeUpperTriangularWithReplace() : 
   BlockPreconditioner<MATRIX>(),
   First\_subsidiary\_preconditioner\_pt(0),
   Second\_subsidiary\_preconditioner\_pt(0),
   Off\_diagonal\_matrix\_vector\_product\_pt(0)
   \{    
    Multi\_poisson\_mesh\_pt=0;
   \} \textcolor{comment}{// end\_of\_constructor}
  
  \textcolor{comment}{}
\textcolor{comment}{  /// Destructor clean up memory}
\textcolor{comment}{}  ~TwoPlusThreeUpperTriangularWithReplace()
   \{
    this->clean\_up\_my\_memory();
   \}
\textcolor{comment}{}
\textcolor{comment}{  /// Clean up the memory}
\textcolor{comment}{}  \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} clean\_up\_my\_memory();
\textcolor{comment}{}
\textcolor{comment}{  /// Broken copy constructor}
\textcolor{comment}{}  TwoPlusThreeUpperTriangularWithReplace
  (\textcolor{keyword}{const} TwoPlusThreeUpperTriangularWithReplace&) 
   \{ 
    BrokenCopy::
     broken\_copy(\textcolor{stringliteral}{"TwoPlusThreeUpperTriangularWithReplace"});
   \} 
  \textcolor{comment}{}
\textcolor{comment}{  /// Broken assignment operator}
\textcolor{comment}{}  \textcolor{keywordtype}{void} operator=(\textcolor{keyword}{const} TwoPlusThreeUpperTriangularWithReplace&) 
   \{
    BrokenCopy::
     broken\_assign(\textcolor{stringliteral}{"TwoPlusThreeUpperTriangularWithReplace"});
   \}
  \textcolor{comment}{}
\textcolor{comment}{  /// Apply preconditioner to r, i.e. return z such that P z = r}
\textcolor{comment}{}  \textcolor{keywordtype}{void} preconditioner\_solve(\textcolor{keyword}{const} DoubleVector &r, DoubleVector &z);
  \textcolor{comment}{}
\textcolor{comment}{  /// \(\backslash\)short Setup the preconditioner }
\textcolor{comment}{}  \textcolor{keywordtype}{void} setup();
 \textcolor{comment}{}
\textcolor{comment}{  /// Specify the mesh that contains multi-poisson elements}
\textcolor{comment}{}  \textcolor{keywordtype}{void} set\_multi\_poisson\_mesh(Mesh* multi\_poisson\_mesh\_pt)
  \{
   Multi\_poisson\_mesh\_pt=multi\_poisson\_mesh\_pt;
  \}

   private :
  \textcolor{comment}{}
\textcolor{comment}{  /// \(\backslash\)short Pointer to preconditioners/inexact solver}
\textcolor{comment}{  /// for compound  (0,0) block}
\textcolor{comment}{}  Preconditioner* First\_subsidiary\_preconditioner\_pt;
  \textcolor{comment}{}
\textcolor{comment}{  /// \(\backslash\)short Pointer to preconditioners/inexact solver}
\textcolor{comment}{  /// for compound (1,1) block}
\textcolor{comment}{}  Preconditioner* Second\_subsidiary\_preconditioner\_pt;
\textcolor{comment}{}
\textcolor{comment}{  /// \(\backslash\)short Matrix vector product operator with the compound }
\textcolor{comment}{  /// (0,1) off diagonal block.}
\textcolor{comment}{}  MatrixVectorProduct* Off\_diagonal\_matrix\_vector\_product\_pt;

  \textcolor{comment}{// Matrix of pointers to replacement matrix blocks}
  DenseMatrix<CRDoubleMatrix*> Replacement\_matrix\_pt;
\textcolor{comment}{}
\textcolor{comment}{  /// \(\backslash\)short Pointer to mesh with preconditionable elements used}
\textcolor{comment}{  /// for classification of dof types.}
\textcolor{comment}{}  Mesh* Multi\_poisson\_mesh\_pt;
  
 \};

\end{DoxyCodeInclude}
\hypertarget{index_two_plus_three_upper_triangular_with_replace_setup}{}\subsubsection{The setup() function}\label{index_two_plus_three_upper_triangular_with_replace_setup}
As usual, we start by cleaning up any memory using a call to a {\ttfamily clean\+\_\+up\+\_\+my\+\_\+memory()} function, and set the pointer to the mesh


\begin{DoxyCodeInclude}
 \textcolor{comment}{//==start\_of\_setup\_for\_two\_plus\_three\_upper\_triangular\_with\_replace===========}\textcolor{comment}{}
\textcolor{comment}{ /// The setup function.}
\textcolor{comment}{} \textcolor{comment}{//============================================================================}
 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MATRIX> 
 \textcolor{keywordtype}{void} TwoPlusThreeUpperTriangularWithReplace<MATRIX>::setup()
 \{
  \textcolor{comment}{// Clean up memory.}
  this->clean\_up\_my\_memory();

\textcolor{preprocessor}{#ifdef PARANOID}
  \textcolor{keywordflow}{if} (Multi\_poisson\_mesh\_pt == 0)
   \{
    std::stringstream err;
    err << \textcolor{stringliteral}{"Please set pointer to mesh using set\_multi\_poisson\_mesh(...).\(\backslash\)n"};
    \textcolor{keywordflow}{throw} OomphLibError(err.str(),
                        OOMPH\_CURRENT\_FUNCTION,
                        OOMPH\_EXCEPTION\_LOCATION);
   \}
\textcolor{preprocessor}{#endif }
  
  \textcolor{comment}{// The preconditioner works with one mesh; set it!}
  this->set\_nmesh(1);
  this->set\_mesh(0,Multi\_poisson\_mesh\_pt);

\end{DoxyCodeInclude}


Next we check that the number of dof types is 5, as the preconditioner is designed to only work for that number.


\begin{DoxyCodeInclude}
  \textcolor{comment}{// How many dof types do we have?}
  \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} n\_dof\_types = this->ndof\_types();

\textcolor{preprocessor}{#ifdef PARANOID}
  \textcolor{comment}{// This preconditioner only works for 5 dof types}
  \textcolor{keywordflow}{if} (n\_dof\_types!=5)
   \{
    std::stringstream tmp;
    tmp << \textcolor{stringliteral}{"This preconditioner only works for problems with 5 dof types\(\backslash\)n"}
        << \textcolor{stringliteral}{"Yours has "} << n\_dof\_types;
    \textcolor{keywordflow}{throw} OomphLibError(tmp.str(),
                        OOMPH\_CURRENT\_FUNCTION,
                        OOMPH\_EXCEPTION\_LOCATION);
   \}
\textcolor{preprocessor}{#endif}

\end{DoxyCodeInclude}


The block setup follows exactly the same pattern as in the previous example\+: Dof types 0 and 1 are combined into compound block 0, while dof types 2, 3 and 4 are combined into compound block 1. On return from the block setup function we should therefore have two block types\+: 
\begin{DoxyCodeInclude}
  \textcolor{comment}{// Call block setup with the Vector [0,0,1,1,1] to:}
  \textcolor{comment}{// Merge DOF types 0 and 1 into block type 0}
  \textcolor{comment}{// Merge DOF types 2, 3, and 4 into block type 1.}
  Vector<unsigned> dof\_to\_block\_map(n\_dof\_types,0);
  dof\_to\_block\_map[0] = 0;
  dof\_to\_block\_map[1] = 0;
  dof\_to\_block\_map[2] = 1;
  dof\_to\_block\_map[3] = 1;
  dof\_to\_block\_map[4] = 1;
  this->block\_setup(dof\_to\_block\_map);

\textcolor{preprocessor}{#ifdef PARANOID}

  \textcolor{comment}{// We should now have two block types -- do we?}
  \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} nblocks = this->nblock\_types();
  \textcolor{keywordflow}{if} (nblocks!=2)
   \{
    std::stringstream tmp;
    tmp << \textcolor{stringliteral}{"Expected number of block types is 2.\(\backslash\)n"}
        << \textcolor{stringliteral}{"Yours has "} << nblocks << \textcolor{stringliteral}{".\(\backslash\)n"}
        << \textcolor{stringliteral}{"Perhaps your argument to block\_setup(...) is not correct.\(\backslash\)n"};
    \textcolor{keywordflow}{throw} OomphLibError(tmp.str(),
                        OOMPH\_CURRENT\_FUNCTION,
                        OOMPH\_EXCEPTION\_LOCATION);
   \}

\textcolor{preprocessor}{#endif}

\end{DoxyCodeInclude}


Now we perform the replacement of the off-\/diagonal dof blocks. (Note that there are still five of these. Dof-\/blocks and compound blocks are not the same -- if you get them confused you will get into trouble!). We allocate storage for the pointers to the replacement matrices and loop over the off-\/diagonal blocks\+:


\begin{DoxyCodeInclude}
  \textcolor{comment}{// Now replace all the off-diagonal DOF blocks.}

  \textcolor{comment}{// Storage for the replacement DOF blocks}
  Replacement\_matrix\_pt.resize(n\_dof\_types,n\_dof\_types,0);

  \textcolor{comment}{// Set off-diagonal DOF blocks to zero, loop over the number of DOF blocks.}
  \textcolor{comment}{// NOTE: There are two (compound) blocks, but the replacement functionality}
  \textcolor{comment}{// works with DOF blocks.}
  \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} i=0;i<n\_dof\_types;i++)
   \{
    \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} j=0;j<n\_dof\_types;j++)
     \{
      \textcolor{keywordflow}{if}(i!=j)
       \{

\end{DoxyCodeInclude}


Given that the replacement matrices are zero matrices, we could simply create them without ever looking at the original blocks. Sadly the creation of zero matrices turns out to be slightly more painful than one would wish because they have to be created as a (possibly distributed) {\ttfamily C\+R\+Double\+Matrix}. The relevant code is contained in the source code but we won\textquotesingle{}t discuss it here since the more common situation is one where we actually want to modify the already existing entries of an already existing block matrix. Therefore we simply extract the matrix and set its initially nonzero entries to zero (admittedly a bit silly -- we now have a sparse matrix full of zeroes, but it\textquotesingle{}s just a demonstration!)\+:


\begin{DoxyCodeInclude}
        \textcolor{comment}{// Modify matrix}
        \textcolor{keywordtype}{bool} modify\_existing\_matrix=\textcolor{keyword}{true};
        \textcolor{keywordflow}{if} (modify\_existing\_matrix)
         \{
          \textcolor{comment}{// Get the dof-block and make a deep copy of it}
          Replacement\_matrix\_pt(i,j)=\textcolor{keyword}{new} CRDoubleMatrix;
          this->get\_dof\_level\_block(i,j,(*Replacement\_matrix\_pt(i,j))); 
          
          \textcolor{comment}{// Set all its entries to zero}
          \textcolor{keywordtype}{unsigned} nnz=Replacement\_matrix\_pt(i,j)->nnz();
          \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} k=0;k<nnz;k++)
           \{
            Replacement\_matrix\_pt(i,j)->value()[k]=0.0;
           \}
         \} \textcolor{comment}{// done -- quite wasteful, we're actually storing lots of zeroes, but}
           \textcolor{comment}{// this is just an example!}

\end{DoxyCodeInclude}


We then pass the pointer to the replacement dof block to the block preconditioner


\begin{DoxyCodeInclude}
        \textcolor{comment}{// Replace (i,j)-th dof block}
        this->set\_replacement\_dof\_block(i,j,Replacement\_matrix\_pt(i,j));
       \}
     \}\textcolor{comment}{// end for loop of j}
   \}\textcolor{comment}{// end for loop of i}

\end{DoxyCodeInclude}


The rest of the setup works exactly as in the previous example, only this time, the subsidiary preconditioners and the matrix vector products will work with the replacement dof blocks that we\textquotesingle{}ve just defined.

We create and set up the first subsidiary block preconditioner which operates on our dof types 0 and 1 (and treats them as its own dof types 0 and 1)\+: 
\begin{DoxyCodeInclude}
  \textcolor{comment}{// First subsidiary precond is a block triangular preconditioner}
  \{
   UpperTriangular<CRDoubleMatrix>* block\_prec\_pt=
    \textcolor{keyword}{new} UpperTriangular<CRDoubleMatrix>;
   First\_subsidiary\_preconditioner\_pt=block\_prec\_pt;
  
   \textcolor{comment}{// Set mesh}
   block\_prec\_pt->set\_multi\_poisson\_mesh(Multi\_poisson\_mesh\_pt);
   
   \textcolor{comment}{// Turn it into a subsidiary preconditioner, declaring which}
   \textcolor{comment}{// of the five dof types in the present (master) preconditioner}
   \textcolor{comment}{// correspond to the dof types in the subsidiary block preconditioner}
   \textcolor{keywordtype}{unsigned} n\_sub\_dof\_types=2;
   Vector<unsigned> dof\_map(n\_sub\_dof\_types);
   dof\_map[0]=0;
   dof\_map[1]=1;
   block\_prec\_pt->turn\_into\_subsidiary\_block\_preconditioner(\textcolor{keyword}{this},dof\_map);

    \textcolor{comment}{// Perform setup. Note that because the subsidiary}
   \textcolor{comment}{// preconditioner is a block preconditioner itself it is given}
   \textcolor{comment}{// the pointer to the "full" matrix}
   block\_prec\_pt->setup(this->matrix\_pt());
  \}

\end{DoxyCodeInclude}


The second subsidiary block preconditioner which operates on our dof types 2, 3 and 4 (and treats them as its own dof types 0, 1 and 2)\+:


\begin{DoxyCodeInclude}
  \textcolor{comment}{// Second subsidiary precond is a block triangular preconditioner}
  \{
   UpperTriangular<CRDoubleMatrix>* block\_prec\_pt=
    \textcolor{keyword}{new} UpperTriangular<CRDoubleMatrix>;
   Second\_subsidiary\_preconditioner\_pt=block\_prec\_pt;
   
   \textcolor{comment}{// Set mesh}
   block\_prec\_pt->set\_multi\_poisson\_mesh(Multi\_poisson\_mesh\_pt);
   
   \textcolor{comment}{// Turn it into a subsidiary preconditioner, declaring which}
   \textcolor{comment}{// of the five dof types in the present (master) preconditioner}
   \textcolor{comment}{// correspond to the dof types in the subsidiary block preconditioner}
   \textcolor{keywordtype}{unsigned} n\_sub\_dof\_types=3;
   Vector<unsigned> dof\_map(n\_sub\_dof\_types);
   dof\_map[0]=2;
   dof\_map[1]=3;
   dof\_map[2]=4;
   block\_prec\_pt->turn\_into\_subsidiary\_block\_preconditioner(\textcolor{keyword}{this},dof\_map);
   
   \textcolor{comment}{// Perform setup. Note that because the subsidiary}
   \textcolor{comment}{// preconditioner is a block preconditioner itself it is given}
   \textcolor{comment}{// the pointer to the "full" matrix}
   block\_prec\_pt->setup(this->matrix\_pt());
  \}

\end{DoxyCodeInclude}


Finally, we create the matrix vector product operator\+: 
\begin{DoxyCodeInclude}
  \textcolor{comment}{// Next setup the off diagonal mat vec operators:}
  \{
   \textcolor{comment}{// Get the block}
   CRDoubleMatrix block\_matrix = this->get\_block(0,1);
   
   \textcolor{comment}{// Create matrix vector product operator}
   Off\_diagonal\_matrix\_vector\_product\_pt = \textcolor{keyword}{new} MatrixVectorProduct;
   
   \textcolor{comment}{// Setup: Final argument indicates block column in the present}
   \textcolor{comment}{// block preconditioner (which views the system matrix as comprising}
   \textcolor{comment}{// 2x2 blocks).}
   \textcolor{keywordtype}{unsigned} block\_column\_index=1;
   this->setup\_matrix\_vector\_product(
   Off\_diagonal\_matrix\_vector\_product\_pt,&block\_matrix,block\_column\_index);

   \textcolor{comment}{// Extracted block can now go out of scope since the matrix vector}
   \textcolor{comment}{// product retains whatever information it needs}
  \}

 \}

\end{DoxyCodeInclude}
\hypertarget{index_two_plus_three_upper_triangular_with_replace_solve}{}\subsubsection{The preconditioner\+\_\+solve() function}\label{index_two_plus_three_upper_triangular_with_replace_solve}
The {\ttfamily preconditioner\+\_\+solve()} function is completely identical to the one used in the previous preconditioner, so we omit the code listing -- the subsidiary preconditioners and the matrix vector product operator work in the same way but now simply operate on the replacement dof blocks where they have been set.\hypertarget{index_two_plus_three_upper_triangular_with_replace_clean}{}\subsubsection{The clean\+\_\+up\+\_\+my\+\_\+memory() function}\label{index_two_plus_three_upper_triangular_with_replace_clean}
Memory is cleaned up as before, so we omit the code listing.



 

\hypertarget{index_coarse_two_plus_two_plus_one}{}\subsection{Coarsening/combining dof types}\label{index_coarse_two_plus_two_plus_one}
N\+EW F\+E\+A\+T\+U\+R\+ES\+: How to coarsen/combine dof types for use by subsidiary block preconditioners.\hypertarget{index_coarse_two_plus_two_plus_one_theory}{}\subsubsection{Theory}\label{index_coarse_two_plus_two_plus_one_theory}
In the examples presented so far we have demonstrated how to combine various dof-\/blocks into compound blocks in order to facilitate the application of certain preconditioning operations. For instance, in many of the previous examples we performed a matrix vector product using the compound matrix $ B_{12} $ that was (formally) formed by the concatenation of the 2x3 \char`\"{}top right\char`\"{} off-\/diagonal dof blocks in the full-\/sized system.

We also showed how subsidiary block preconditioners which operate on a specific number of dof blocks can be instructed to operate on selected dof types from the full-\/sized system. Our standard example for this was a 2D Navier-\/\+Stokes preconditioner which operates on three dof types (two fluid velocities and one pressure) and is used as a subsidiary block preconditioner in an F\+SI problem that also involves additional dofs associated with the solid mechanics (e.\+g. the two solid displacement components). This was done by informing the subsidiary preconditioner which of the dof types in the full-\/sized system to regard as \char`\"{}its own\char`\"{} when calling its {\ttfamily turn\+\_\+into\+\_\+subsidiary\+\_\+block\+\_\+preconditioner}(...) function. This implies that the subsidiary block preconditioner remains unaware of any compound blocks that may have been formed in its master preconditioner. The functionality presented so far only allows us to associate dof-\/blocks in the master preconditioner with dof blocks in the subsidiary block preconditioner. It is therefore not possible (without further functionality which we explain in this example) to use a subsidiary block preconditioner if the dof-\/types in the master preconditioner are \char`\"{}too fine-\/grained\char`\"{}. This arises, for instance, in Navier-\/\+Stokes problems where the master preconditioner sub-\/divides the two components of the fluid velocity into degrees of freedom on the domain boundary and those in the interior. It is then necessary to make the subsidiary preconditioner act on the combined dof types, a process that we describe as \char`\"{}coarsening\char`\"{}.

We illustrate the procedure by returning, yet again, to our 5x5 block linear system that we wish to precondition with \[ \hspace{3cm} {\bf P}_{\rm previous} = \left( \begin{array}{cc|ccc} J_{11} & J_{12} & J_{13} & J_{14} & J_{15} \\ J_{21} & J_{22} & J_{13} & J_{14} & J_{15} \\ \hline & & J_{33} & J_{34} & J_{35} \\ & & J_{43} & J_{44} & J_{45} \\ & & J_{53} & J_{54} & J_{55} \\ \end{array} \right) = \left( \begin{array}{c|c} B_{11} & B_{12}\\ \hline & B_{22} \\ \end{array} \right). \hspace{3cm} (18) \] However, now we wish to solve the two linear systems involving the compound matrices $ B_{11} $ and $ B_{22} $ with a 2x2 upper triangular subsidiary block preconditioner. To make this possible, we \char`\"{}coarsen\char`\"{} the dof types such that the subsidiary block preconditioner acting on $ B_{22}$ treats the global dof types 3 and 4 as a single dof type so that the block structure can be viewed as \[ {\bf P} = \left( \begin{array}{c||c} \begin{array}{cc} J_{11} & J_{12} \\ J_{21} & J_{22} \\ \end{array} & \begin{array}{ccc} J_{13} & J_{14} & J_{15} \\ J_{23} & J_{24} & J_{25} \\ \end{array} \\ \hline \hline & \begin{array}{cc|c} J_{33} & J_{34} & J_{35} \\ J_{43} & J_{44} & J_{45} \\ \hline J_{53} & J_{54} & J_{55} \\ \end{array} \end{array} \right) = \left( \begin{array}{c|c} B_{11} & B_{12}\\ \hline & B_{22} \\ \end{array} \right). \hspace{3cm} (19) \]

If we now use a 2x2 upper triangular block preconditioner to (approximately) solve the linear systems involving the diagonal blocks $ B_{11} $ and $ B_{22} $ the preconditioner is given (mathematically) by \[ {\bf P} = \left( \begin{array}{ccccc} J_{11} & J_{12} & J_{13} & J_{14} & J_{15} \\ & J_{22} & J_{23} & J_{24} & J_{25} \\ & & J_{33} & J_{34} & J_{35} \\ & & J_{34} & J_{44} & J_{45} \\ & & & & J_{55} \\ \end{array} \right). \]

\mbox{[}Note that, In the actual implementation discussed below, we also set the off diagonal dof-\/blocks to zero, using the replacement methodology discussed in the previous example. The preconditioner therefore becomes mathematically equivalent to the $ 5x5 $ block diagonal preconditioner discussed at the very beginning of this tutorial.\mbox{]}\hypertarget{index_coarse_two_plus_two_plus_one_implementation}{}\subsubsection{Implementation as a Block\+Preconditioner}\label{index_coarse_two_plus_two_plus_one_implementation}
The implementation of the preconditioner is completely equivalent to the preconditioner considered in the previous examples\+:


\begin{DoxyCodeInclude}
\textcolor{comment}{//==================start\_of\_coarse\_two\_plus\_two\_plus\_one\_class================}\textcolor{comment}{}
\textcolor{comment}{/// \(\backslash\)short Block diagonal preconditioner for system with 5 dof types}
\textcolor{comment}{/// assembled into a 2x2 block system, with the (0,0) block containing}
\textcolor{comment}{/// the first two dof types, the (1,1) block containing the three remaining }
\textcolor{comment}{/// ones.}
\textcolor{comment}{}\textcolor{comment}{//=============================================================================}
 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MATRIX> 
 \textcolor{keyword}{class }CoarseTwoPlusTwoPlusOne : 
  \textcolor{keyword}{public} BlockPreconditioner<MATRIX>
 \{
  
 public :
  \textcolor{comment}{}
\textcolor{comment}{  /// Constructor for CoarseTwoPlusTwoPlusOne}
\textcolor{comment}{}   CoarseTwoPlusTwoPlusOne() : 
  BlockPreconditioner<MATRIX>(),
   First\_subsidiary\_preconditioner\_pt(0),
   Second\_subsidiary\_preconditioner\_pt(0),
   Off\_diagonal\_matrix\_vector\_product\_pt(0)
    \{    
     Multi\_poisson\_mesh\_pt=0;
    \} \textcolor{comment}{// end\_of\_constructor}
  
  \textcolor{comment}{}
\textcolor{comment}{  /// Destructor - delete the diagonal solvers (subsidiary preconditioners)}
\textcolor{comment}{}  ~CoarseTwoPlusTwoPlusOne()
   \{
    this->clean\_up\_my\_memory();
   \}    
  \textcolor{comment}{}
\textcolor{comment}{  /// clean up the memory}
\textcolor{comment}{}  \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} clean\_up\_my\_memory();
\textcolor{comment}{}
\textcolor{comment}{  /// Broken copy constructor}
\textcolor{comment}{}  CoarseTwoPlusTwoPlusOne
  (\textcolor{keyword}{const} CoarseTwoPlusTwoPlusOne&) 
   \{ 
    BrokenCopy::broken\_copy(
     \textcolor{stringliteral}{"CoarseTwoPlusTwoPlusOne"});
   \} 
  \textcolor{comment}{}
\textcolor{comment}{  /// Broken assignment operator}
\textcolor{comment}{}  \textcolor{keywordtype}{void} operator=(\textcolor{keyword}{const} 
                 CoarseTwoPlusTwoPlusOne&) 
   \{
    BrokenCopy::broken\_assign(
     \textcolor{stringliteral}{"CoarseTwoPlusTwoPlusOne"});
   \}
  \textcolor{comment}{}
\textcolor{comment}{  /// Apply preconditioner to r, i.e. return z such that P z = r}
\textcolor{comment}{}  \textcolor{keywordtype}{void} preconditioner\_solve(\textcolor{keyword}{const} DoubleVector &r, DoubleVector &z);
  \textcolor{comment}{}
\textcolor{comment}{  /// \(\backslash\)short Setup the preconditioner }
\textcolor{comment}{}  \textcolor{keyword}{virtual} \textcolor{keywordtype}{void} setup();
 \textcolor{comment}{}
\textcolor{comment}{  /// Specify the mesh that contains multi-poisson elements}
\textcolor{comment}{}  \textcolor{keywordtype}{void} set\_multi\_poisson\_mesh(Mesh* multi\_poisson\_mesh\_pt)
  \{
   Multi\_poisson\_mesh\_pt=multi\_poisson\_mesh\_pt;
  \}

 private :
  \textcolor{comment}{}
\textcolor{comment}{  /// \(\backslash\)short Pointer to preconditioners/inexact solver}
\textcolor{comment}{  /// for (0,0) block}
\textcolor{comment}{}  Preconditioner* First\_subsidiary\_preconditioner\_pt;
  \textcolor{comment}{}
\textcolor{comment}{  /// \(\backslash\)short Pointer to preconditioners/inexact solver}
\textcolor{comment}{  /// for (1,1) block}
\textcolor{comment}{}  Preconditioner* Second\_subsidiary\_preconditioner\_pt;

  \textcolor{comment}{// Matrix of pointers to replacement matrix blocks}
  DenseMatrix<CRDoubleMatrix*> Replacement\_matrix\_pt;
\textcolor{comment}{}
\textcolor{comment}{  /// Matrix vector product operator}
\textcolor{comment}{}  MatrixVectorProduct* Off\_diagonal\_matrix\_vector\_product\_pt;
\textcolor{comment}{}
\textcolor{comment}{  /// \(\backslash\)short Pointer to mesh with preconditionable elements used}
\textcolor{comment}{  /// for classification of dof types.  }
\textcolor{comment}{}  Mesh* Multi\_poisson\_mesh\_pt;
 \};

\end{DoxyCodeInclude}
\hypertarget{index_coarse_two_plus_two_plus_one_setup}{}\subsubsection{The setup() function}\label{index_coarse_two_plus_two_plus_one_setup}
As usual we clean up any previously allocated memory and set the pointer to the mesh\+:


\begin{DoxyCodeInclude}
 \textcolor{comment}{//===============start\_of\_setup\_for\_coarse\_two\_plus\_two\_plus\_one=============}\textcolor{comment}{}
\textcolor{comment}{ /// The setup function.}
\textcolor{comment}{} \textcolor{comment}{//===========================================================================}
 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MATRIX> 
 \textcolor{keywordtype}{void} CoarseTwoPlusTwoPlusOne<MATRIX>::setup()
 \{
  \textcolor{comment}{// Clean up memory}
  this->clean\_up\_my\_memory();

\textcolor{preprocessor}{#ifdef PARANOID}
  \textcolor{keywordflow}{if} (Multi\_poisson\_mesh\_pt == 0)
   \{
    std::stringstream err;
    err << \textcolor{stringliteral}{"Please set pointer to mesh using set\_multi\_poisson\_mesh(...).\(\backslash\)n"};
    \textcolor{keywordflow}{throw} OomphLibError(err.str(),
                        OOMPH\_CURRENT\_FUNCTION,
                        OOMPH\_EXCEPTION\_LOCATION);
   \}
\textcolor{preprocessor}{#endif }
  
  \textcolor{comment}{// The preconditioner works with one mesh; set it!}
  this->set\_nmesh(1);
  this->set\_mesh(0,Multi\_poisson\_mesh\_pt);

\end{DoxyCodeInclude}


Next we check that the number of degrees of freedom is 5, as the preconditioner is designed to only work for that number.


\begin{DoxyCodeInclude}
  \textcolor{comment}{// This preconditioner only works for 5 dof types}
  \textcolor{keywordtype}{unsigned} n\_dof\_types = this->ndof\_types();
\textcolor{preprocessor}{#ifdef PARANOID}
  \textcolor{keywordflow}{if} (n\_dof\_types!=5)
   \{
    std::stringstream tmp;
    tmp << \textcolor{stringliteral}{"This preconditioner only works for problems with 5 dof types\(\backslash\)n"}
        << \textcolor{stringliteral}{"Yours has "} << n\_dof\_types;
    \textcolor{keywordflow}{throw} OomphLibError(tmp.str(),
                        OOMPH\_CURRENT\_FUNCTION,
                        OOMPH\_EXCEPTION\_LOCATION);
   \}
\textcolor{preprocessor}{#endif}

\end{DoxyCodeInclude}


The block setup follows exactly the same pattern as in the previous examples\+: Dof types 0 and 1 are combined into compound block 0, while dof types 2, 3 and 4 are combined into compound block 1.


\begin{DoxyCodeInclude}
  \textcolor{comment}{// Call block setup with the Vector [0,0,1,1,1] to:}
  \textcolor{comment}{// Merge DOF types 0 and 1 into block type 0.}
  \textcolor{comment}{// Merge DOF types 2, 3 and 4 into block type 1.}
  Vector<unsigned> dof\_to\_block\_map(n\_dof\_types,0);
  dof\_to\_block\_map[0] = 0;
  dof\_to\_block\_map[1] = 0;
  dof\_to\_block\_map[2] = 1;
  dof\_to\_block\_map[3] = 1;
  dof\_to\_block\_map[4] = 1;
  this->block\_setup(dof\_to\_block\_map);

\end{DoxyCodeInclude}


\mbox{[}We omit the code listing the replacement of the off-\/diagonal dof blocks with zero matrices since it is identical to what we already discussed in the previous example.\mbox{]}

Next we create the two subsidiary preconditioners that (approximately) solve the linear systems involving the diagonal blocks $ B_{11} $ and $ B_{22} $. The first subsidiary preconditioner is a standard upper triangular block preconditioner which acts on the compound block formed by dof types 0 and 1\+:


\begin{DoxyCodeInclude}
  \textcolor{comment}{// Create the subsidiary preconditioners}
  \textcolor{comment}{//--------------------------------------}
  \{
   \textcolor{comment}{// First subsidiary precond is a block diagonal preconditioner itself.}
   UpperTriangular<CRDoubleMatrix>* block\_prec\_pt=
    \textcolor{keyword}{new} UpperTriangular<CRDoubleMatrix>;
   First\_subsidiary\_preconditioner\_pt=block\_prec\_pt;

   \textcolor{comment}{// Set mesh}
   block\_prec\_pt->set\_multi\_poisson\_mesh(Multi\_poisson\_mesh\_pt);
   
   \textcolor{comment}{// Turn first\_sub into a subsidiary preconditioner, declaring which}
   \textcolor{comment}{// of the five dof types in the present (master) preconditioner}
   \textcolor{comment}{// correspond to the dof types in the subsidiary block preconditioner}
   \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} n\_sub\_dof\_types=2;
   Vector<unsigned> dof\_map(n\_sub\_dof\_types);
   dof\_map[0]=0;
   dof\_map[1]=1;
   block\_prec\_pt->turn\_into\_subsidiary\_block\_preconditioner(\textcolor{keyword}{this},dof\_map);    

   \textcolor{comment}{// Perform setup. Note that because the subsidiary}
   \textcolor{comment}{// preconditioner is a block preconditioner itself it is given}
   \textcolor{comment}{// the pointer to the "full" matrix}
   block\_prec\_pt->setup(this->matrix\_pt());
  \}

\end{DoxyCodeInclude}


The second subsidiary preconditioner is more interesting. It\textquotesingle{}s a block preconditioner that only operates on a 2x2 block system, yet we want to use it to solve the linear system involving the compound block formed the three dof types 2, 3 and 4. To do this we wish to combine the dof blocks associated with dof types 2 and 3 into a single block. We start by setting the mesh pointer and by setting up the usual mapping that identifies the dof types (in the current preconditioner) that we wish the subsidiary preconditioner to act on.


\begin{DoxyCodeInclude}
  \textcolor{comment}{// Second subsidiary preconditioner is also a block preconditioner }
  \{
   SimpleTwoDofOnly<CRDoubleMatrix>* block\_prec\_pt=
    \textcolor{keyword}{new} SimpleTwoDofOnly<CRDoubleMatrix>;
   Second\_subsidiary\_preconditioner\_pt=block\_prec\_pt;
   
   \textcolor{comment}{// Set mesh}
   block\_prec\_pt->set\_multi\_poisson\_mesh(Multi\_poisson\_mesh\_pt);
   
   \textcolor{comment}{// This is the usual mapping between the subsidiary and master dof types.}
   Vector<unsigned> dof\_map(3);
   dof\_map[0]=2;
   dof\_map[1]=3;
   dof\_map[2]=4;

\end{DoxyCodeInclude}


To combine/coarsen dof types 2 and 3 (in the current preconditioner) into a single dof type for the subsidiary preconditioner we create a vector of vectors, {\ttfamily  doftype\+\_\+coarsening } whose entries are to be interpreted as

{\ttfamily  doftype\+\_\+coarsening\mbox{[}coarsened\+\_\+dof\+\_\+type\mbox{]}\mbox{[}i\mbox{]}=dof\+\_\+type}

where {\ttfamily i} ranges from 0 to the number of dof types (minus one, because of the zero-\/based indexing...) in the enumeration of the subsidiary preconditioner that are to be combined/coarsened into dof type {\ttfamily coarsened\+\_\+dof\+\_\+type\+:} 


\begin{DoxyCodeInclude}
   \textcolor{comment}{// The subsidiary block preconditioner SimpleTwoDofOnly accepts only two}
   \textcolor{comment}{// dof types. We therefore have to "coarsen" the 3 dof types into two}
   \textcolor{comment}{// by specifying the vector of vectors doftype\_coarsening whose}
   \textcolor{comment}{// entries are to be interpreted as}
   \textcolor{comment}{// }
   \textcolor{comment}{//    doftype\_coarsening[coarsened\_dof\_type][i]=dof\_type}
   \textcolor{comment}{//}
   \textcolor{comment}{// where i ranges from 0 to the number of dof types (minus one, because}
   \textcolor{comment}{// of the zero-based indexing...) that are to be}
   \textcolor{comment}{// combined/coarsened into dof type dof\_type\_in\_coarsed\_block\_preconditioner}


   \textcolor{comment}{// Number of dof types the subsidiary block preconditioner expects.}
   \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} n\_sub\_dof\_types=2;
   Vector<Vector<unsigned> > doftype\_coarsening(n\_sub\_dof\_types);
   
   \textcolor{comment}{// Subsidiary dof type 0 contains 2 dof types.}
   doftype\_coarsening[0].resize(2);

   \textcolor{comment}{// Coarsen subsidiary dof types 0 and 1 into subsidiary dof type 0.}
   doftype\_coarsening[0][0]=0;
   doftype\_coarsening[0][1]=1;
   
   \textcolor{comment}{// Subsidiary dof type 1 contains 1 dof types. }
   doftype\_coarsening[1].resize(1);
   
   \textcolor{comment}{// Subsidiary Dof type 1 contains subsidiary dof type 2.}
   doftype\_coarsening[1][0]=2;

\end{DoxyCodeInclude}


We pass both lookup schemes to the function that turns the preconditioner into a subsidiary block preconditioner and then call its own setup function, as usual.


\begin{DoxyCodeInclude}
      
   \textcolor{comment}{// Turn into subdiary preconditioner}
   block\_prec\_pt->
    turn\_into\_subsidiary\_block\_preconditioner(\textcolor{keyword}{this},dof\_map,
                                              doftype\_coarsening);

   \textcolor{comment}{// Perform setup. Note that because the subsidiary}
   \textcolor{comment}{// preconditioner is a block preconditioner itself it is given}
   \textcolor{comment}{// the pointer to the "full" matrix}
   block\_prec\_pt->setup(this->matrix\_pt());
  \}

\end{DoxyCodeInclude}


Finally, we set up the of diagonal matrix-\/vector product which acts on the compound (0,1) block (formed from dof types \{0,1\}x\{2,3,4\}) in the current preconditioner.


\begin{DoxyCodeInclude}
   
   
  \textcolor{comment}{// Set up off diagonal matrix vector product}
  \{
   \textcolor{comment}{// Get the off diagonal block.}
   CRDoubleMatrix block\_matrix = this->get\_block(0,1);
   
   \textcolor{comment}{// Create matrix vector product operator}
   Off\_diagonal\_matrix\_vector\_product\_pt = \textcolor{keyword}{new} MatrixVectorProduct;
   
   \textcolor{comment}{// Setup: Final argument indicates block column in the present}
   \textcolor{comment}{// block preconditioner (which views the system matrix as comprising}
   \textcolor{comment}{// 2x2 blocks).}
   \textcolor{keywordtype}{unsigned} block\_column\_index=1;
   this->setup\_matrix\_vector\_product(
    Off\_diagonal\_matrix\_vector\_product\_pt,&block\_matrix,block\_column\_index);

   \textcolor{comment}{// extracted block can now go out of scope; the matrix vector product}
   \textcolor{comment}{// retains its own (deep) copy.}
  \}
 
 \}\textcolor{comment}{// End of setup}

\end{DoxyCodeInclude}
\hypertarget{index_coarse_two_plus_two_plus_one__solve}{}\subsubsection{The preconditioner\+\_\+solve() function}\label{index_coarse_two_plus_two_plus_one__solve}
The {\ttfamily preconditioner\+\_\+solve()} function is completely identical to the one used in the previous example, so we omit the code listing.\hypertarget{index_coarse_two_plus_two_plus_one_clean}{}\subsubsection{The clean\+\_\+up\+\_\+my\+\_\+memory() function}\label{index_coarse_two_plus_two_plus_one_clean}
Memory is cleaned up as before, so we omit the code listing.



 

\hypertarget{index_fsi_multiple_meshes}{}\subsection{Using multiple meshes -\/-\/ explained for a genuine fluid-\/structure interaction problem}\label{index_fsi_multiple_meshes}
N\+EW F\+E\+A\+T\+U\+R\+ES\+: How to use multiple meshes\hypertarget{index_fsi_multiple_meshes_theory}{}\subsubsection{Theory}\label{index_fsi_multiple_meshes_theory}
Finally, we demonstrate the use of multiple meshes by discussing a simple implementation of the F\+SI preconditioner described in the \href{../../../preconditioners/fsi/html/index.html}{\tt F\+SI Preconditioner Tutorial}. We refer to the tutorial discussing the \href{../../../interaction/fsi_channel_with_leaflet/html/index.html}{\tt F\+SI channel with leaflet problem} for the overall problem setup.

F\+SI problems involve fluid (velocities and pressures from the Navier-\/\+Stokes equations) and solid (the nodal positions in the solid domain) degrees of freedom (dofs). We begin by reordering the linear system to group together the two types of dof

\[ \left[ \begin{array}{cc} F&C_{fs}\\ C_{sf}&S \end{array} \right] \left[ \begin{array}{c} \bf \delta f\\ \bf \delta s \end{array} \right] = - \left[ \begin{array}{c} \bf r_f\\ \bf r_s \end{array} \right] , \]

where $\bf f$ and $\bf s$ denote the fluid and solid dofs, $F$ is the Navier-\/\+Stokes Jacobian (representing the derivatives of the discretised fluid equations with respect to the fluid dofs), $S$ is the solid Jacobian, and the blocks $C_{fs}$ and $C_{sf}$ arise from the interaction between fluid and solid equations.

The Navier Stokes Jacobian $F$ has its own block structure. Decomposing the fluid dofs into velocity and pressure dofs so that

\[ {\bf f}= \left[ \begin{array}{c} \bf u\\ \bf p \end{array} \right], \]

we obtain the well known saddle-\/point structure of $F$

\[ F= \left[ \begin{array}{cc} A&B^T\\ B& \end{array} \right], \]

where $A$ is the momentum block, $B^T$ the discrete gradient operator, and $B$ the discrete divergence operator (see \href{../../../preconditioners/lsc_navier_stokes/html/index.html}{\tt Navier Stokes Preconditioner Tutorial}).

This F\+SI preconditioner takes the form of a block triangular preconditioner. Here we only consider the lower block triangular version \[ P_{FSI}= \left[ \begin{array}{cc} F& \\ C_{sf}&S \end{array} \right] \] obtained by omitting the $C_{fs}$ block from the Jacobian.

The application of the preconditioner requires the solution of the linear system

\[ \left[ \begin{array}{cc} F& \\ C_{sf}&S \end{array} \right] \left[ \begin{array}{c} \bf z_f\\ \bf z_s \end{array} \right] = \left[ \begin{array}{c} \bf y_f\\ \bf y_s \end{array} \right]. \]

However, for preconditioning purposes this system does not have to be solved exactly. We therefore replace the solution of the linear systems involving the diagonal blocks (representing the single-\/physics fluid and solid Jacobians $F$ and $S$) by existing preconditioners (interpreted as inexact solvers). Formally, we write this as

\[ \left[ \begin{array}{cc} \tilde F& \\ C_{sf}&\tilde S \end{array} \right] \left[ \begin{array}{c} \bf z_f\\ \bf z_s \end{array} \right] = \left[ \begin{array}{c} \bf y_f\\ \bf y_s \end{array} \right] . \ \ \ \ \ \ \ \ \ \ \ \ (20) \]

where $ \tilde F $ is the fluid preconditioner and $ \tilde{S} $ the solid preconditioner, both used as subsidiary preconditioners.

The application of the preconditioner can be accomplished in four distinct steps\+:


\begin{DoxyEnumerate}
\item Apply the fluid preconditioner $ \tilde F $ to the fluid dofs of the R\+HS vector $ \bf y_f $ and store the result in the fluid solution $ {\bf z_f}=\tilde F^{-1}{\bf y_f} $ .
\item Multiply the fluid-\/solid coupling matrix $ C_{sf} $ with the fluid solution $ \bf z_f $ and store the result in the temporary vector $ {\bf w}=C_{sf}\bf z_f $ .
\item Subtract $ \bf w $ from the solid dofs of the R\+HS vector $ \bf y_s $ and store the result in the temporary $ \bf w $ to complete the action of the $ C_{sf} $ matrix vector product, $ {\bf w}={\bf y_s}-{\bf w} $ .
\item Apply the solid preconditioner $\tilde S$ to the temporary $ \bf w $ to compute the solid solution $ {\bf z_s}=\tilde S^{-1}{\bf w} $ .
\end{DoxyEnumerate}This is, of course, extremely similar to the methodology explained in the section \hyperlink{index_two_plus_three_upper_triangular_with_sub}{Using subsidiary block preconditioners}, the main difference being that the fluid and solid dofs are classified by two different elements. In the two-\/dimensional \href{../../../interaction/fsi_channel_with_leaflet/html/index.html}{\tt F\+SI channel with leaflet problem} these are\+:
\begin{DoxyItemize}
\item The fluid elements are of type {\ttfamily Refineable\+Q\+Taylor\+Hood\+Element$<$2$>$}. These elements have three types of dof; $x$-\/velocity dofs are labelled {\ttfamily 0}, $y$-\/velocity dofs are labelled {\ttfamily 1} and the pressure dofs are labelled {\ttfamily 2}.~\newline
~\newline

\item The solid elements are of type {\ttfamily F\+S\+I\+Hermite\+Beam\+Element}. They have one type of dof (the nodal position) labelled {\ttfamily 0}.
\end{DoxyItemize}When classifying the dofs we specify the elements via two separate meshes, the first one containing the pointers to the fluid elements, the second one the pointers to the solid elements. This means that in the global enumeration of the dof types the fluid dofs appear before the solid dofs.\hypertarget{index_implementing_the_fsi_preconditioner}{}\subsubsection{The Implementation of the F\+S\+I Preconditioner}\label{index_implementing_the_fsi_preconditioner}
We implement the F\+SI preconditioner in the class {\ttfamily Simple\+F\+S\+I\+Preconditioner}. This class inherits from the base class {\ttfamily Block\+Preconditioner} which provides the generic functionality required for common block preconditioning operations.

The overall structure of the class is similar to that of the preconditioners considered before, the main difference being that we now store pointers to two meshes.

 
\begin{DoxyCodeInclude}
\textcolor{comment}{//=start\_of\_simple\_fsi\_preconditioner========================================== }
\textcolor{comment}{/// \(\backslash\)short Simple FSI preconditioner. A block uppper triangular preconditioner}
\textcolor{comment}{}\textcolor{comment}{/// for the 2x2 FSI block system -- DOFs are decomposed into fluid DOFs and }
\textcolor{comment}{}\textcolor{comment}{/// solid DOFs. The fluid subisidiary system is solved with the }
\textcolor{comment}{}\textcolor{comment}{/// Navier Stokes Preconditioner and the solid subsidiary system with the}
\textcolor{comment}{}\textcolor{comment}{//=============================================================================}
 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MATRIX> 
\textcolor{keyword}{class }SimpleFSIPreconditioner 
 : \textcolor{keyword}{public} \textcolor{keyword}{virtual} BlockPreconditioner<MATRIX>
\{
 
public :
 \textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Constructor for SimpleFSIPreconditioner}
\textcolor{comment}{} SimpleFSIPreconditioner(Problem* problem\_pt)
  : BlockPreconditioner<MATRIX>(), Navier\_stokes\_preconditioner\_pt(0),
    Solid\_preconditioner\_pt(0), Fluid\_solid\_coupling\_matvec\_pt(0),
    Navier\_stokes\_mesh\_pt(0), Solid\_mesh\_pt(0)
  \{
   \textcolor{comment}{// Create the Navier Stokes Schur Complement preconditioner}
   Navier\_stokes\_preconditioner\_pt = 
    \textcolor{keyword}{new} NavierStokesSchurComplementPreconditioner(problem\_pt);

   \textcolor{comment}{// Create the Solid preconditioner}
   Solid\_preconditioner\_pt = \textcolor{keyword}{new} SuperLUPreconditioner;

   \textcolor{comment}{// Create the matrix-vector product operator}
   Fluid\_solid\_coupling\_matvec\_pt = \textcolor{keyword}{new} MatrixVectorProduct;

  \}\textcolor{comment}{// end\_of\_constructor}
 
 \textcolor{comment}{}
\textcolor{comment}{ /// Destructor: Clean up.}
\textcolor{comment}{} ~SimpleFSIPreconditioner()
  \{
   \textcolor{comment}{//Delete the Navier-Stokes preconditioner}
   \textcolor{keyword}{delete} Navier\_stokes\_preconditioner\_pt; Navier\_stokes\_preconditioner\_pt = 0;
   
   \textcolor{comment}{//Delete the solid preconditioner}
   \textcolor{keyword}{delete} Solid\_preconditioner\_pt; Solid\_preconditioner\_pt = 0;
   
   \textcolor{comment}{// Delete the matrix vector product operator}
   \textcolor{keyword}{delete} Fluid\_solid\_coupling\_matvec\_pt; Fluid\_solid\_coupling\_matvec\_pt = 0;
  \}
 \textcolor{comment}{}
\textcolor{comment}{ /// Broken copy constructor}
\textcolor{comment}{} SimpleFSIPreconditioner(\textcolor{keyword}{const} SimpleFSIPreconditioner&)
  \{
   BrokenCopy::broken\_copy(\textcolor{stringliteral}{"SimpleFSIPreconditioner"});
  \}
 
  \textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Access function to mesh containing the block-preconditionable}
\textcolor{comment}{ /// Navier-Stokes elements. }
\textcolor{comment}{} \textcolor{keywordtype}{void} set\_navier\_stokes\_mesh(Mesh* mesh\_pt) 
  \{
   Navier\_stokes\_mesh\_pt = mesh\_pt;
  \}
\textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Access function to mesh containing the block-preconditionable}
\textcolor{comment}{ /// FSI solid elements. }
\textcolor{comment}{} \textcolor{keywordtype}{void} set\_solid\_mesh(Mesh* mesh\_pt) 
  \{
   Solid\_mesh\_pt = mesh\_pt;
  \}
\textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Setup the preconditioner}
\textcolor{comment}{} \textcolor{keywordtype}{void} setup();
 \textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Apply preconditioner to r}
\textcolor{comment}{} \textcolor{keywordtype}{void} preconditioner\_solve(\textcolor{keyword}{const} DoubleVector &r,
                           DoubleVector &z);

\textcolor{keyword}{private}:
\textcolor{comment}{}
\textcolor{comment}{ /// Pointer the Navier Stokes preconditioner.}
\textcolor{comment}{} NavierStokesSchurComplementPreconditioner* Navier\_stokes\_preconditioner\_pt;
\textcolor{comment}{}
\textcolor{comment}{ /// Pointer to the solid preconditioner.}
\textcolor{comment}{} Preconditioner* Solid\_preconditioner\_pt;
\textcolor{comment}{}
\textcolor{comment}{ /// Pointer to the fluid onto solid matrix vector product.}
\textcolor{comment}{} MatrixVectorProduct* Fluid\_solid\_coupling\_matvec\_pt;
\textcolor{comment}{}
\textcolor{comment}{ /// Pointer to the navier stokes mesh.}
\textcolor{comment}{} Mesh* Navier\_stokes\_mesh\_pt;
\textcolor{comment}{}
\textcolor{comment}{ /// Pointer to the solid mesh.}
\textcolor{comment}{} Mesh* Solid\_mesh\_pt;

\};

\end{DoxyCodeInclude}
\hypertarget{index_setup}{}\subsubsection{Preconditioner Setup}\label{index_setup}
We start by setting up the meshes, choosing the fluid mesh to be mesh {\ttfamily 0} and the solid mesh to be mesh {\ttfamily 1}. The preconditioner therefore has four dof types enumerated in mesh order\+:


\begin{DoxyItemize}
\item {\ttfamily 0} fluid $x$ velocity (dof type 0 in mesh 0)
\item {\ttfamily 1} fluid $y$ velocity (dof type 1 in mesh 0)
\item {\ttfamily 2} fluid pressure (dof type 2 in mesh 0)
\item {\ttfamily 3} solid (dof type 0 in mesh 1)
\end{DoxyItemize}

 
\begin{DoxyCodeInclude}
\textcolor{comment}{//=start\_of\_setup===============================================================}
\textcolor{comment}{/// Setup the preconditioner.}
\textcolor{comment}{}\textcolor{comment}{//==============================================================================}
 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MATRIX> 
 \textcolor{keywordtype}{void} SimpleFSIPreconditioner<MATRIX>::setup()
\{
 \textcolor{comment}{// setup the meshes for BlockPreconditioner and get the number of types of}
 \textcolor{comment}{// DOF assoicated with each Mesh.}
 \textcolor{comment}{// Mesh 0 is the fluid mesh, and hence DOFs 0 to n\_fluid\_dof\_type-1 }
 \textcolor{comment}{// are the fluid DOFs. Mesh 1 is the solid mesh and therefore DOFs }
 \textcolor{comment}{// n\_fluid\_dof\_type to n\_total\_dof\_type-1 are solid DOFs}
 \textcolor{comment}{// set the mesh pointers}
 this->set\_nmesh(2);
 this->set\_mesh(0,Navier\_stokes\_mesh\_pt);
 this->set\_mesh(1,Solid\_mesh\_pt);
 
 \textcolor{keywordtype}{unsigned} n\_fluid\_dof\_type = this->ndof\_types\_in\_mesh(0);
 \textcolor{keywordtype}{unsigned} n\_total\_dof\_type = n\_fluid\_dof\_type + this->ndof\_types\_in\_mesh(1);

\end{DoxyCodeInclude}


Next we define the mapping from dof number to block number. The preconditioner has two block types -- fluid and solid -- therefore we group the fluid dofs into block type {\ttfamily 0} and the solid dofs into block type {\ttfamily 1}. We define a map from dof type to block type in a vector (the vector indices denote the dof type and the vector elements denote the block type) and pass it to {\ttfamily block\+\_\+setup}(...) to complete the setup of the {\ttfamily Block\+Preconditioner} infrastructure.

 
\begin{DoxyCodeInclude}
 \textcolor{comment}{// This fsi preconditioner has two types of block -- fluid and solid.}
 \textcolor{comment}{// Create a map from DOF number to block type. The fluid block is labelled}
 \textcolor{comment}{// 0 and the solid block 1.}
 Vector<unsigned> dof\_to\_block\_map(n\_total\_dof\_type,0);
 \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} i = n\_fluid\_dof\_type; i < n\_total\_dof\_type; i++)
  \{
   dof\_to\_block\_map[i] = 1;
  \}
 
 \textcolor{comment}{// Call the BlockPreconditioner method block\_setup(...) to assemble the data}
 \textcolor{comment}{// structures required for block preconditioning.}
 this->block\_setup(dof\_to\_block\_map);

\end{DoxyCodeInclude}


Next we set up the subsidiary operators required by the preconditioner. We start with the solid subsidiary preconditioner ( $\tilde S$). We extract the solid matrix block $S$ from the Jacobian using the {\ttfamily Block\+Preconditioner} method {\ttfamily get\+\_\+block}(...) and then set up the solid subsidiary preconditioner\+:

 
\begin{DoxyCodeInclude}
 \textcolor{comment}{// First the solid preconditioner}
 \textcolor{comment}{//===============================}
 
 \textcolor{comment}{// get the solid block matrix (1,1)}
 CRDoubleMatrix* solid\_matrix\_pt = \textcolor{keyword}{new} CRDoubleMatrix;
 this->get\_block(1,1,*solid\_matrix\_pt);
 
 \textcolor{comment}{// setup the solid preconditioner}
 \textcolor{comment}{// (perform the LU decomposition)}
 Solid\_preconditioner\_pt->setup(solid\_matrix\_pt);
 \textcolor{keyword}{delete} solid\_matrix\_pt; solid\_matrix\_pt = 0;

\end{DoxyCodeInclude}


Note that, compared to the previous examples, we have used an alternative, pointer-\/based version of the {\ttfamily get\+\_\+block}(...) function. However, as before, the block matrix can be deleted once the subsidiary preconditioner has been set up since the latter retains whatever data it requires.

The fluid subsidiary preconditioner ( $\tilde F$) a block preconditioner itself. Its setup is therefore performed in two steps\+:


\begin{DoxyEnumerate}
\item First we turn the {\ttfamily Navier\+Stokes\+Schur\+Complement\+Preconditioner} into a subsidiary block preconditioner. We assemble a list a fluid dof types in the current (master) preconditioner, and pass this list to the Navier-\/\+Stokes preconditioner to indicate that dof type {\ttfamily i} in the master F\+SI preconditioner is dof type {\ttfamily i} in the subsidiary fluid preconditioner (for {\ttfamily i} {\ttfamily =} {\ttfamily 0}, {\ttfamily 1}, {\ttfamily 2}) (Note that the fact that this mapping is the identity mapping is a result of choosing the fluid mesh to be mesh {\ttfamily 0}; in general the index of {\ttfamily ns\+\_\+dof\+\_\+list} corresponds to the dof type number in the Navier Stokes subsidiary preconditioner and the value corresponds to the index in this master preconditioner).  
\begin{DoxyCodeInclude}
 \textcolor{comment}{// Next the fluid preconditioner}
 \textcolor{comment}{//==============================}
 
 \textcolor{comment}{// Specify the relationship between the enumeration of DOF types in the }
 \textcolor{comment}{// master preconditioner and the Schur complement subsidiary preconditioner }
 \textcolor{comment}{// so that ns\_dof\_type[i\_nst] contains i\_master}
 Vector<unsigned> ns\_dof\_list(n\_fluid\_dof\_type);
 \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} i = 0; i < n\_fluid\_dof\_type; i++)
  \{
   ns\_dof\_list[i] = i;
  \}
 
 \textcolor{comment}{// Turn the NavierStokesSchurComplement preconditioner into a subsidiary }
 \textcolor{comment}{// preconditioner of this (FSI) preconditioner}
 Navier\_stokes\_preconditioner\_pt->
  turn\_into\_subsidiary\_block\_preconditioner(\textcolor{keyword}{this},ns\_dof\_list);

\end{DoxyCodeInclude}

\item Next we set up the {\ttfamily Navier\+Stokes\+Schur\+Complement\+Preconditioner}. We pass the Navier-\/\+Stokes mesh to the the subsidiary preconditioner and set up the preconditioner. Note that the pointer to the full F\+SI Jacobian is passed to the subsidiary block preconditioner. This allows the subsidiary preconditioner to extract the relevant sub-\/blocks, using the lookup schemes established by the call to {\ttfamily turn\+\_\+into\+\_\+subsidiary\+\_\+block\+\_\+preconditioner}(...).  
\begin{DoxyCodeInclude}
 \textcolor{comment}{// Set up the NavierStokesSchurComplement preconditioner. }
 \textcolor{comment}{// (Pass it a pointer to the Navier Stokes mesh)}
 Navier\_stokes\_preconditioner\_pt->
  set\_navier\_stokes\_mesh(Navier\_stokes\_mesh\_pt);

 \textcolor{comment}{// Navier Stokes preconditioner is a subsidiary block preconditioner.}
 \textcolor{comment}{// It therefore needs a pointer to the full matrix.}
 Navier\_stokes\_preconditioner\_pt->setup(this->matrix\_pt());

\end{DoxyCodeInclude}

\end{DoxyEnumerate}

Finally, we set up is the matrix-\/vector product. This mirrors the set up of the solid subsidiary preconditioner. First the subsidiary matrix is extracted from the Jacobian and then the operator is set up\+:

 
\begin{DoxyCodeInclude}
 \textcolor{comment}{// Finally the fluid onto solid matrix vector product operator}
 \textcolor{comment}{//============================================================}
 
 \textcolor{comment}{// Similar to the solid preconditioner get the matrix}
 CRDoubleMatrix* fluid\_onto\_solid\_matrix\_pt = \textcolor{keyword}{new} CRDoubleMatrix;
 this->get\_block(1,0,*fluid\_onto\_solid\_matrix\_pt);
 
 \textcolor{comment}{// And setup the matrix vector product operator}
 this->setup\_matrix\_vector\_product(Fluid\_solid\_coupling\_matvec\_pt,
                                   fluid\_onto\_solid\_matrix\_pt,
                                   0);
 \textcolor{comment}{// Clean up}
 \textcolor{keyword}{delete} fluid\_onto\_solid\_matrix\_pt; fluid\_onto\_solid\_matrix\_pt = 0;

\end{DoxyCodeInclude}


Again, the extracted block can be deleted since the matrix vector product operator retains the relevant data. The F\+SI preconditioner is now ready to be used.\hypertarget{index_solve}{}\subsection{Preconditioner Solve}\label{index_solve}
The {\ttfamily preconditioner\+\_\+solve}(...) method applies the preconditioner to the input vector $\bf y$ and returns the result in $\bf z$.

We start by applying the Navier-\/\+Stokes preconditioner $\tilde F$ to the fluid elements {\ttfamily y\+\_\+f} of {\ttfamily y}. Since $\tilde F$ is a subsidiary block preconditioner we apply it to the full-\/length {\ttfamily y} and {\ttfamily z} vectors which contain both the fluid and solid unknowns. The block preconditioning infrastructure utilised within the {\ttfamily Navier\+Stokes\+Schur\+Complement\+Preconditioner} will ensure that the preconditioner only operates on fluid dofs.

 
\begin{DoxyCodeInclude}
\textcolor{comment}{//=start\_of\_preconditioner\_solve================================================}
\textcolor{comment}{/// Apply preconditioner.}
\textcolor{comment}{}\textcolor{comment}{//==============================================================================}
 \textcolor{keyword}{template}<\textcolor{keyword}{typename} MATRIX> 
 \textcolor{keywordtype}{void} SimpleFSIPreconditioner<MATRIX>::preconditioner\_solve(
  \textcolor{keyword}{const} DoubleVector &y, DoubleVector &z)
\{
 \textcolor{comment}{// Fluid Subsidiary Preconditioner}
 \textcolor{comment}{//=================================}

 \textcolor{comment}{// Start by applying the Fluid subsidiary preconditioner}
 \textcolor{comment}{// The fluid subsidiary preconditioner is a block preconditioner and}
 \textcolor{comment}{// hence we pass it the global residual and solution vectors (y and z)}
 Navier\_stokes\_preconditioner\_pt->preconditioner\_solve(y,z);

\end{DoxyCodeInclude}


The fluid elements {\ttfamily z\+\_\+f} of the vector {\ttfamily z} will now have been updated to contain the action of the Schur\+Complement preconditioner on the fluid elements {\ttfamily y\+\_\+f} of the vector {\ttfamily y}.

To apply the fluid-\/solid coupling matrix vector product $C_{sf}$, we copy the fluid elements from {\ttfamily z} into another vector {\ttfamily z\+\_\+f}. We then apply the matrix-\/vector product operator to {\ttfamily z\+\_\+f} and store the result in a vector {\ttfamily w}. Finally, we subtract {\ttfamily w} from the solid residuals {\ttfamily y\+\_\+s} and store the result in {\ttfamily w} to complete the application of the matrix-\/vector product.

 
\begin{DoxyCodeInclude}
 \textcolor{comment}{// Fluid Onto Solid Matrix Vector Product Operator}
 \textcolor{comment}{//================================================}

 \textcolor{comment}{// The vector z\_f contains the result of the action of the }
 \textcolor{comment}{// NavierStokesPreconditioner on a subset of  the elements of z.}
 \textcolor{comment}{// Remember the fluid block index is 0 and the solid block index is 1.}
 DoubleVector z\_f;
 this->get\_block\_vector(0,z,z\_f);

 \textcolor{comment}{// Apply the matrix vector product to z\_f and store the results in w}
 DoubleVector w;
 Fluid\_solid\_coupling\_matvec\_pt->multiply(z\_f,w);

 \textcolor{comment}{// The vector y\_s contains the solid residuals}
 DoubleVector y\_s;
 this->get\_block\_vector(1,y,y\_s);

 \textcolor{comment}{// Subtract the action of the fluid onto solid matrix vector product from y\_s}
 y\_s -= w;
 w = y\_s; 

\end{DoxyCodeInclude}


Finally, we apply the solid subsidiary preconditioner $\tilde S$ to {\ttfamily w} and return the result to {\ttfamily z}. We note that because the solid subsidiary preconditioner is not a block preconditioner, the preconditioner solve method must be called with the solid block vectors. The result is then copied to the full-\/length vector {\ttfamily z} which contains the fluid and solid dofs.

 
\begin{DoxyCodeInclude}
 \textcolor{comment}{// Solid Subsidiary Preconditioner}
 \textcolor{comment}{//================================}

 \textcolor{comment}{// Apply the solid preconditioner to s and return the result to the }
 \textcolor{comment}{// global solution vector z}
 DoubleVector z\_s;
 Solid\_preconditioner\_pt->preconditioner\_solve(w,z\_s);
 this->return\_block\_vector(1,z\_s,z);
\}

\end{DoxyCodeInclude}




 

\hypertarget{index_para}{}\section{Parallelisation}\label{index_para}
We note that the above discussion did not address the parallelisation of the preconditioners. This is because all the required parallel features are \char`\"{}hidden\char`\"{} within the block preconditioning framework which relies heavily on the library\textquotesingle{}s \href{../../../mpi/distributed_linear_algebra_infrastructure/html/index.html}{\tt distributed linear algebra infrastructure.} Any of the preconditioners discussed in this tutorial can therefore be used without change when {\ttfamily oomph-\/lib} is compiled with M\+PI support and if the the executable is run on multiple processes.



 

\hypertarget{index_sources}{}\section{Source files for this tutorial}\label{index_sources}

\begin{DoxyItemize}
\item The source file for the simple block diagonal preconditioner for the linear elasticity problem is \begin{center} \href{../../../../demo_drivers/linear_solvers/simple_block_preconditioners.h}{\tt demo\+\_\+drivers/linear\+\_\+solvers/simple\+\_\+block\+\_\+preconditioners.\+h } \end{center}  ~\newline

\item The driver code demonstrating the use of the simple block diagonal preconditioner for the linear elasticity problem is \begin{center} \href{../../../../demo_drivers/linear_solvers/two_d_linear_elasticity_with_simple_block_diagonal_preconditioner.cc}{\tt demo\+\_\+drivers/linear\+\_\+solvers/two\+\_\+d\+\_\+linear\+\_\+elasticity\+\_\+with\+\_\+simple\+\_\+block\+\_\+diagonal\+\_\+preconditioner.\+cc } \end{center}  ~\newline

\item The source files for the \char`\"{}multi-\/poisson\char`\"{} preconditioners and the serial driver codes are located in the directory\+: \begin{center} \href{../../../../demo_drivers/linear_solvers/}{\tt demo\+\_\+drivers/linear\+\_\+solvers/ } \end{center}  ~\newline

\item The serial \char`\"{}multi-\/poisson\char`\"{} driver code (which demonstrates the use of the various \char`\"{}multi-\/poisson\char`\"{} preconditioners discussed above) is\+: \begin{center} \href{../../../../demo_drivers/linear_solvers/two_d_multi_poisson.cc}{\tt demo\+\_\+drivers/poisson/two\+\_\+d\+\_\+multi\+\_\+poisson.\+cc } \end{center}  ~\newline

\item The parallel counterpart is here (note that, as claimed, this code uses exactly the same preconditioners as the serial version)\+: \begin{center} \href{../../../../demo_drivers/mpi/solvers/two_d_multi_poisson.cc}{\tt demo\+\_\+drivers/mpi/solvers/two\+\_\+d\+\_\+multi\+\_\+poisson.\+cc } \end{center}  ~\newline

\item The (parallel) driver code which demonstrates the implementation and use of the simple F\+SI preconditioner (for the \char`\"{}channel with leaflet\char`\"{} problem) is here\+: \begin{center} \href{../../../../demo_drivers/mpi/solvers/fsi_channel_with_leaflet.cc}{\tt demo\+\_\+drivers/mpi/solvers/fsi\+\_\+channel\+\_\+with\+\_\+leaflet.\+cc } \end{center}  ~\newline

\end{DoxyItemize}



 

 \hypertarget{index_pdf}{}\section{P\+D\+F file}\label{index_pdf}
A \href{../latex/refman.pdf}{\tt pdf version} of this document is available. \end{document}
