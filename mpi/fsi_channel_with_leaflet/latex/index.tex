This document provides an overview of how to distribute fluid-\/structure interaction problems in which algebraic node update methods are used to deform the fluid mesh in response to changes in the shape of the domain boundary. It is part of a \href{../../../example_code_list/html/index.html#distributed}{\tt series of tutorials} that discuss how to modify existing serial driver codes so that the {\ttfamily Problem} object can be distributed across multiple processors.

As discussed in the \href{../../general_mpi/html/index.html#alg_node_update}{\tt general M\+PI tutorial}, the parallel implementation of algebraic node update methods for specific meshes is greatly facilitated if the {\ttfamily Geom\+Object} that describes the motion of the moving domain boundary is available on all processors. In F\+SI problems, the moving boundary is typically represented by a {\ttfamily Mesh\+As\+Geom\+Object} -- a compound {\ttfamily Geom\+Object} formed from the lower-\/dimensional mesh of {\ttfamily Solid\+Elements} that define the moving boundary of the fluid domain. To ensure that the {\ttfamily Mesh\+As\+Geom\+Object} remains available on all processors when the underlying mesh is distributed, we use the function {\ttfamily Mesh\+::keep\+\_\+all\+\_\+elements\+\_\+as\+\_\+halos()} to indicate that all elements should be retained on all processors.

\begin{center} \tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*{1}{|X[-1]}|}
\hline
\begin{center} {\bfseries Note} \end{center}  The procedure described here is appropriate {\bfseries only} if the solid mesh used to create the {\ttfamily Mesh\+As\+Geom\+Object} is {\bfseries not} {\bfseries adapted} during the solution of the problem. We refer to \href{../../turek_flag/html/index.html}{\tt another tutorial} for instructions on how to deal with the case when the solid mesh is itself adapted.   \\\cline{1-1}
\end{longtabu}
\end{center} 



\hypertarget{index_fsi_channel_with_leaflet}{}\section{Revisiting the F\+S\+I channel with leaflet problem}\label{index_fsi_channel_with_leaflet}
We demonstrate the methodology for the problem of \href{../../../interaction/fsi_channel_with_leaflet/html/index.html}{\tt flow past an elastic leaflet in a 2D channel}. Most of driver code is identical to its serial counterpart and we only discuss the changes required to distribute the problem. Please refer to \href{../../../interaction/fsi_channel_with_leaflet/html/index.html}{\tt another tutorial} for a more detailed discussion of the problem and its (serial) implementation.



\hypertarget{index_main_body}{}\subsection{The main function}\label{index_main_body}
As with other parallel driver codes, the changes from the \href{../../../interaction/fsi_channel_with_leaflet/html/index.html}{\tt serial driver code } are extremely modest, essentially including the initialisation and shutdown of M\+PI. Once the problem is set up, we call {\ttfamily Problem\+::distribute}(...), using the boolean flag {\ttfamily report\+\_\+stats} to indicate that the statistics of the distribution should be reported on screen.

 
\begin{DoxyCodeInclude}
   \textcolor{comment}{// Distribute problem using METIS to determine the partitioning}
   problem.distribute(report\_stats);

\end{DoxyCodeInclude}




\hypertarget{index_problem_class}{}\subsection{The problem class}\label{index_problem_class}
The only additional function is {\ttfamily actions\+\_\+after\+\_\+distribute()}, described \href{#actions_routines}{\tt later in this tutorial}.



\hypertarget{index_constructor}{}\subsection{The problem constructor}\label{index_constructor}
The only difference from the serial counterpart is that we insist that all beam elements are kept as halos when the mesh is distributed.

 
\begin{DoxyCodeInclude}
 \textcolor{comment}{// Discretise leaflet}
 \textcolor{comment}{//-------------------}

 \textcolor{comment}{// Geometric object that represents the undeformed leaflet}
 UndeformedLeaflet* undeformed\_wall\_pt=\textcolor{keyword}{new} UndeformedLeaflet(x\_0);

 \textcolor{comment}{//Create the "wall" mesh with FSI Hermite beam elements}
 \textcolor{keywordtype}{unsigned} n\_wall\_el=5;
 Wall\_mesh\_pt = \textcolor{keyword}{new} OneDLagrangianMesh<FSIHermiteBeamElement>
  (n\_wall\_el,hleaflet,undeformed\_wall\_pt,wall\_time\_stepper\_pt);

 \textcolor{comment}{// Flag to tell the wall mesh that all its elements should be halo}
 Wall\_mesh\_pt->set\_keep\_all\_elements\_as\_halos();

\end{DoxyCodeInclude}




\hypertarget{index_action_after_adapt}{}\subsection{Actions after adaptation}\label{index_action_after_adapt}
The {\ttfamily actions\+\_\+after\+\_\+adapt()} function requires only a minor change from the serial version --- a simple re-\/ordering of the sequence in which the various steps are performed. In serial it does not matter in which order the (re-\/)assignment of the auxiliary node update functions and (re-\/)setup of the fluid-\/structure interaction are performed. In the parallel version, however, the assignment of the auxiliary node update functions must take place {\bfseries after} the (re-\/)setup of the fluid-\/structure interaction. This is because the function {\ttfamily F\+S\+I\+\_\+functions\+::setup\+\_\+fluid\+\_\+load\+\_\+info\+\_\+for\+\_\+solid\+\_\+elements}(...) creates halo copies of the fluid elements (and their nodes!) if the required fluid element is not present on the current processor. Any newly-\/created halo fluid nodes on the F\+SI boundary are accessible via the usual boundary lookup schemes and must be told about the auxiliary node update function which applies the no-\/slip condition.


\begin{DoxyCodeInclude}
\textcolor{comment}{//==== start\_of\_actions\_after\_adapt=================================}
\textcolor{comment}{/// Actions\_after\_adapt()}
\textcolor{comment}{}\textcolor{comment}{//==================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT>
\textcolor{keywordtype}{void} FSIChannelWithLeafletProblem<ELEMENT>::actions\_after\_adapt()
\{
 \textcolor{comment}{// Unpin all pressure dofs}
 RefineableNavierStokesEquations<2>::
  unpin\_all\_pressure\_dofs(Fluid\_mesh\_pt->element\_pt());

 \textcolor{comment}{// Pin redundant pressure dofs}
 RefineableNavierStokesEquations<2>::
  pin\_redundant\_nodal\_pressures(Fluid\_mesh\_pt->element\_pt());


 \textcolor{comment}{// Re-setup FSI}
 \textcolor{comment}{//-------------}

 \textcolor{comment}{// Work out which fluid dofs affect the residuals of the wall elements:}
 \textcolor{comment}{// We pass the boundary between the fluid and solid meshes and}
 \textcolor{comment}{// pointers to the meshes. The interaction boundary is boundary 4 and 5}
 \textcolor{comment}{// of the 2D fluid mesh.}

 \textcolor{comment}{// Front of leaflet: Set face=0 (which is also the default so this argument}
 \textcolor{comment}{// could be omitted)}
 \textcolor{keywordtype}{unsigned} face=0;
 FSI\_functions::setup\_fluid\_load\_info\_for\_solid\_elements<ELEMENT,2>
  (\textcolor{keyword}{this},4,Fluid\_mesh\_pt,Wall\_mesh\_pt,face);

 \textcolor{comment}{// Back of leaflet: face 1, needs to be specified explicitly}
 face=1;
 FSI\_functions::setup\_fluid\_load\_info\_for\_solid\_elements<ELEMENT,2>
  (\textcolor{keyword}{this},5,Fluid\_mesh\_pt,Wall\_mesh\_pt,face);

 \textcolor{comment}{// (Re-)apply the no slip condition on the moving wall}
 \textcolor{comment}{//-----------------------------------------------------}

 \textcolor{comment}{// The velocity of the fluid nodes on the wall (fluid mesh boundary 4,5)}
 \textcolor{comment}{// is set by the wall motion -- hence the no-slip condition must be}
 \textcolor{comment}{// re-applied whenever a node update is performed for these nodes.}
 \textcolor{comment}{// Such tasks may be performed automatically by the auxiliary node update}
 \textcolor{comment}{// function specified by a function pointer:}
 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} ibound=4;ibound<6;ibound++ )
  \{
   \textcolor{keywordtype}{unsigned} num\_nod= Fluid\_mesh\_pt->nboundary\_node(ibound);
   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} inod=0;inod<num\_nod;inod++)
    \{
     Fluid\_mesh\_pt->boundary\_node\_pt(ibound, inod)->
      set\_auxiliary\_node\_update\_fct\_pt(
       FSI\_functions::apply\_no\_slip\_on\_moving\_wall);
    \}
  \} \textcolor{comment}{// aux node update fct has been (re-)set}

\} \textcolor{comment}{// end\_of\_actions\_after\_adapt}

\end{DoxyCodeInclude}




\hypertarget{index_action_after_distribution}{}\subsection{Actions after distribution}\label{index_action_after_distribution}
The actions required after distribution are extremely similar to those required after adaptation because distribution deletes certain elements (or replaces them by halo copies). The only difference is that the redundant pressure degrees of freedom do not have to be re-\/pinned.


\begin{DoxyCodeInclude}
\textcolor{comment}{//==== start\_of\_actions\_after\_distribute============================}
\textcolor{comment}{/// Actions\_after\_distribute()}
\textcolor{comment}{}\textcolor{comment}{//==================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT>
\textcolor{keywordtype}{void} FSIChannelWithLeafletProblem<ELEMENT>::actions\_after\_distribute()
\{
 \textcolor{comment}{// Re-setup FSI}
 \textcolor{comment}{//-------------}

 \textcolor{comment}{// Work out which fluid dofs affect the residuals of the wall elements:}
 \textcolor{comment}{// We pass the boundary between the fluid and solid meshes and}
 \textcolor{comment}{// pointers to the meshes. The interaction boundary is boundary 4 and 5}
 \textcolor{comment}{// of the 2D fluid mesh.}

 \textcolor{comment}{// Front of leaflet: Set face=0 (which is also the default so this argument}
 \textcolor{comment}{// could be omitted)}
 \textcolor{keywordtype}{unsigned} face=0;
 FSI\_functions::setup\_fluid\_load\_info\_for\_solid\_elements<ELEMENT,2>
  (\textcolor{keyword}{this},4,Fluid\_mesh\_pt,Wall\_mesh\_pt,face);

 \textcolor{comment}{// Back of leaflet: face 1, needs to be specified explicitly}
 face=1;
 FSI\_functions::setup\_fluid\_load\_info\_for\_solid\_elements<ELEMENT,2>
  (\textcolor{keyword}{this},5,Fluid\_mesh\_pt,Wall\_mesh\_pt,face);

 \textcolor{comment}{// (Re-)apply the no slip condition on the moving wall}
 \textcolor{comment}{//-----------------------------------------------------}

 \textcolor{comment}{// The velocity of the fluid nodes on the wall (fluid mesh boundary 4,5)}
 \textcolor{comment}{// is set by the wall motion -- hence the no-slip condition must be}
 \textcolor{comment}{// re-applied whenever a node update is performed for these nodes.}
 \textcolor{comment}{// Such tasks may be performed automatically by the auxiliary node update}
 \textcolor{comment}{// function specified by a function pointer:}
 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} ibound=4;ibound<6;ibound++ )
  \{
   \textcolor{keywordtype}{unsigned} num\_nod= Fluid\_mesh\_pt->nboundary\_node(ibound);
   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} inod=0;inod<num\_nod;inod++)
    \{
     Fluid\_mesh\_pt->boundary\_node\_pt(ibound, inod)->
      set\_auxiliary\_node\_update\_fct\_pt(
       FSI\_functions::apply\_no\_slip\_on\_moving\_wall);
    \}
  \} \textcolor{comment}{// aux node update fct has been (re-)set}


\} \textcolor{comment}{// end\_of\_actions\_after\_distribute}

\end{DoxyCodeInclude}




\hypertarget{index_doc_solution}{}\subsection{The doc\+\_\+solution() function}\label{index_doc_solution}
As usual, we add the processor number to the end of the filename for each output file to make sure that the different processors don\textquotesingle{}t over-\/write each other\textquotesingle{}s output.

The trace file documents the time trace of the imposed influx and the displacement of the node at the tip of the leaflet. It could be written by any processor since all solid elements are retained everywhere. We only write to the trace file from processor 0.


\begin{DoxyCodeInclude}
 \textcolor{comment}{// Write trace file (only on processor 0) -- Tip node exists on}
 \textcolor{comment}{// every processor (because all wall elements are kept as halos)}
 \textcolor{comment}{// but we don't want different processors to overwrite (or replicate)}
 \textcolor{comment}{// the trace file.}
 \textcolor{keywordflow}{if} (this->communicator\_pt()->my\_rank()==0)
  \{
   trace << time << \textcolor{stringliteral}{" "}
         << Global\_Physical\_Variables::flux(time) << \textcolor{stringliteral}{" "}
         << tip\_node\_pt->x(0) << \textcolor{stringliteral}{" "}
         << tip\_node\_pt->x(1) << \textcolor{stringliteral}{" "}
         << tip\_node\_pt->dposition\_dt(0) << \textcolor{stringliteral}{" "}
         << tip\_node\_pt->dposition\_dt(1) << \textcolor{stringliteral}{" "}
         << doc\_info.number() << \textcolor{stringliteral}{" "}
         << std::endl;
  \}

\end{DoxyCodeInclude}




 

\hypertarget{index_sources}{}\section{Source files for this tutorial}\label{index_sources}
The source files for this tutorial can be found in

\begin{center} \href{../../../../demo_drivers/mpi/multi_domain/fsi_channel_with_leaflet}{\tt demo\+\_\+drivers/mpi/multi\+\_\+domain/fsi\+\_\+channel\+\_\+with\+\_\+leaflet } \end{center} 

Similar examples of modified driver codes for F\+SI problems for a channel with a collapsible wall and an oscillating ring can be found in \begin{center} \href{../../../../demo_drivers/mpi/multi_domain/}{\tt demo\+\_\+drivers/mpi/multi\+\_\+domain } \end{center} 



 

 \hypertarget{index_pdf}{}\section{P\+D\+F file}\label{index_pdf}
A \href{../latex/refman.pdf}{\tt pdf version} of this document is available. \end{document}
