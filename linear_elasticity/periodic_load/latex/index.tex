This is our first linear elasticity example problem. We discuss the non-\/dimensionalisation of the governing equations and their implementation in {\ttfamily oomph-\/lib}, and then demonstrate the solution of a 2D problem\+: the deformation of an elastic strip by a periodic traction.

\begin{center} \tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*{1}{|X[-1]}|}
\hline
\begin{center} {\bfseries Acknowledgement\+:} This tutorial and the associated driver code was developed jointly with David Rutter. \end{center}    \\\cline{1-1}
\end{longtabu}
\end{center} 



 

\hypertarget{index_equation}{}\section{The governing equations}\label{index_equation}
The figure below shows a sketch of a general elasticity problem. A linearly elastic solid body occupies the domain $ V $ and is loaded by a body force $ {\bf F}^* $ and by a surface traction $ {\bf t}^* $ which is applied along part of its boundary, $ A_{\rm tract} $. The displacement is prescribed along the remainder of the boundary, $ A_{\rm displ} $, where $ \partial V = A_{\rm tract} \cup A_{\rm displ} $.

 
\begin{DoxyImage}
\includegraphics[width=0.5\textwidth]{Solid_boundary_conds}
\doxyfigcaption{Sketch of a general elasticity problem\+: A linearly elastic body is loaded by a body force and is exposed to a prescribed traction along part of its boundary while the displacement is prescribed along the remainder of the boundary. }
\end{DoxyImage}


We adopt an Eulerian approach and describe the deformation in terms of the displacement field $ {\bf u}^*\left( x_i^*,t^* \right) $ where $ x_i^* $ and $ t^* $ are the spatial coordinates and time, respectively. Throughout this document we will use index notation and the summation convention, and use asterisks to distinguish dimensional quantities from their non-\/dimensional counterparts. Denoting the density of the body by $ \rho $, the deformation is governed by the Cauchy equations, \begin{center} \[ \frac{\partial \tau_{ij}^*}{\partial x_j^*} + \rho F_i^* = \rho \frac{\partial^2 u_i^*}{\partial t^{2*}}, \] \end{center}  where $ \tau_{ij}^* $ is the Cauchy stress tensor which, for a linearly elastic solid, is given by \begin{center} \[ \tau_{ij}^* = E_{ijkl}^* \ e_{kl}, \] \end{center}  where $ e_{kl} $ is the strain tensor, \begin{center} \[ e_{ij} = \frac{1}{2} \left( \frac{\partial u_i^*}{\partial x_j^*}+ \frac{\partial u_j^*}{\partial x_i^*}\right). \] \end{center}  $ E_{ijkl} $ is the 4th order elasticity tensor, which for a homogeneous and isotropic solid is \begin{center} \[ E_{ijkl}^* = \frac{E}{1+\nu} \left(\frac{\nu}{1-2\nu} \delta_{ij} \delta_{kl} + \delta_{ik} \delta_{jl} \right), \] \end{center}  where $ E $ is Young\textquotesingle{}s modulus, $ \nu $ is the Poisson ratio and $ \delta_{ij} $ is the Kronecker delta. Thus the Cauchy stress is given in terms of the displacement derivatives by \begin{center} \[ \tau_{ij}^* = \frac{E}{1+\nu} \left(\frac{\nu}{1-2\nu} \ \delta_{ij} \ \frac{\partial u_k^*}{\partial x_k^*} + \frac{1}{2}\left(\frac{\partial u_i^*}{\partial x_j^*}+ \frac{\partial u_j^*}{\partial x_i^*} \right) \right). \] \end{center} 

We non-\/dimensionalise the equations, using a problem specific reference length, $ {\cal L} $, and a timescale $ {\cal T} $, and use Young\textquotesingle{}s modulus to non-\/dimensionalise the body force and the stress, \begin{center} \[ \tau_{ij}^* = E \, \tau_{ij}, \qquad x_i^* = {\cal L}\, x_i, \qquad u_i^* = {\cal L}\, u_i, \] \[ t^* = {\cal T}\, t, \qquad F_i^* = \frac{E}{\rho \cal L} \, F_i. \qquad \] \end{center} 

The non-\/dimensional form of the Cauchy equations is then given by \begin{center} \[ \frac{\partial \tau_{ij}}{\partial x_j} + F_i = \Lambda^2 \frac{\partial^2 u_i}{\partial t^2}, \ \ \ \ \ \ \ \ \ \ (1) \] \end{center}  where \begin{center} \[ \tau_{ij} = \frac{1}{1+\nu} \left(\frac{\nu}{1-2\nu} \ \delta_{ij} \ \frac{\partial u_k}{\partial x_k} + \frac{1}{2} \left(\frac{\partial u_i}{\partial x_j}+ \frac{\partial u_j}{\partial x_i} \right) \right). \ \ \ \ \ \ \ \ \ \ (2) \] \end{center}  The parameter \begin{center} \[ \Lambda = \frac{{\cal L} \sqrt{\frac{\rho}{E}} }{\cal T}, \] \end{center}  is the ratio of the elastic body\textquotesingle{}s intrinsic timescale, $ {\cal L} \sqrt{\frac{\rho}{E}} $, to the problem-\/specific timescale, $ {\cal T} $, that we used to non-\/dimensionalise time.

The displacement constraints provide a Dirichlet condition for the displacements, \[ u_i = u_i^{[\rm prescribed]} \ \ \ \ \ \ \mbox{on $A_{\mathrm{displ}}$}, \] while the traction boundary conditions require that \[ t_i = \tau_{ij} n_j \ \ \ \ \ \ \mbox{on $A_{\mathrm{tract}},$} \] where the $ n_j $ are the components of the outer unit normal to the boundary.

In this tutorial we only consider steady problems for which the equations reduce to \begin{center} \[ \frac{\partial \tau_{ij}}{\partial x_j} + F_i = 0. \] \end{center} 



 

\hypertarget{index_element_types}{}\section{Implementation}\label{index_element_types}


\hypertarget{index_el}{}\subsection{The elements}\label{index_el}
Within {\ttfamily oomph-\/lib}, the non-\/dimensional version of the {\ttfamily D\+IM}-\/dimensional Cauchy equations (1) with the constitutive equations (2) are implemented in the {\ttfamily Linear\+Elasticity\+Equations$<$\+D\+I\+M$>$} equations class. Following our usual approach, discussed in the \href{../../../quick_guide/html/index.html}{\tt (Not-\/\+So-\/)Quick Guide,} this equation class is then combined with a geometric finite element to form a fully-\/functional finite element. For instance, the combination of the {\ttfamily Linear\+Elasticity\+Equations$<$2$>$} class with the geometric finite element {\ttfamily Q\+Element$<$2,3$>$} yields a nine-\/node quadrilateral linear elasticity element. As usual, the mapping between local and global (Eulerian) coordinates within an element is given by, \begin{center} \[ x_i = \sum_{j=1}^{N^{(E)}} X^{(E)}_{ij} \, \psi_j, \qquad i=1,2\quad [\mbox{and }3], \] \end{center}  where $ N^{(E)} $ is the number of nodes in the element, $ X^{(E)}_{ij} $ is the $ i $-\/th global (Eulerian) coordinate of the $ j $-\/th {\ttfamily Node} in the element, and the $ \psi_j $ are the element\textquotesingle{}s shape functions, defined in the geometric finite element.

The cartesian displacement components $ u_1, $ $ u_2, $ \mbox{[}and $ u_3 $\mbox{]} are stored as nodal values, and the shape functions are used to interpolate the displacements as \begin{center} \[ u_i = \sum_{j=1}^{N^{(E)}} U^{(E)}_{ij} \, \psi_j, \qquad i=1,2\quad [\mbox{and }3], \] \end{center}  where $ U^{(E)}_{ij} $ is the $ i $-\/th displacement component at the $ j $-\/th {\ttfamily Node} in the element. Nodal values of the displacement components are accessible via the access function


\begin{DoxyCode}
LinearElasticityEquations<DIM>::u(i,j)
\end{DoxyCode}


which returns the $ i $-\/th displacement component stored at the element\textquotesingle{}s $ j $-\/th {\ttfamily Node}.



 

\hypertarget{index_example}{}\section{The example problem}\label{index_example}
To illustrate the solution of the steady equations of linear elasticity, we consider the 2D problem shown in the sketch below.

\begin{center} \tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*{1}{|X[-1]}|}
\hline
\begin{center} {\bfseries The problem.} \end{center}   
\begin{DoxyImage}
\includegraphics[width=0.5\textwidth]{attempt3}
\doxyfigcaption{Infinitely long strip loaded by a periodic traction. }
\end{DoxyImage}
 Solve \[ \frac{\partial \tau_{ij}}{\partial x_j} + F_i=0, \ \ \ \ \ \ \ \ \ \ (3) \] in the domain $ D = \{x_1 \in [-\infty,+\infty], x_2 \in [0,L_y]\} $, subject to the Dirichlet boundary conditions \[ \left. \mathbf{u}\right|_{x_2 = 0}=(0,0), \ \ \ \ \ \ \ \ \ \ (4) \] on the bottom boundary, the Neumann (traction) boundary conditions \[ \left. \mathbf{t}\right|_{x_2 = L_y}=\left(-A \cos{\left(\frac{2 \pi x_1}{L_x}\right)}, -A \sin{\left(\frac{2 \pi x_1}{L_x}\right)}\right), \ \ \ \ \ \ \ \ \ \ (5) \] on the top boundary, and symmetry conditions at $ x_1 = 0 $ and $ x_1 = L_x $, \[ \left. {\bf u}\right|_{x_1=0} = \left.{\bf u}\right|_{x_1=L_x}. \]   \\\cline{1-1}
\end{longtabu}
\end{center} 

We note that for $ L_y \to \infty $ the problem converges to the analytical solution. \[ u_1^{[exact]} = -\frac{A(1+\nu)}{2 \pi} \cos{\left(\frac{2 \pi x_1}{L_x}\right)} \exp{\left(2 \pi (x_2-L_y)\right)}, \] \[ u_2^{[exact]} = -\frac{A(1+\nu)}{2 \pi} \sin{\left(\frac{2 \pi x_1}{L_x}\right)} \exp{\left(2 \pi (x_2-L_y)\right)}, \]



 

\hypertarget{index_results}{}\section{Results}\label{index_results}
The figure below shows a vector plot of the displacement field near the upper domain boundary for $ L_x = 1 $ and $ L_y=2 $. Note that we only discretised the infinite strip over one period of the applied, spatially-\/periodic surface traction, and imposed symmetry conditions on the left and right mesh boundaries.

The plot shows that the displacements decay rapidly with distance from the loaded surface -- as suggested by the analytical solution for the infinite depth case. This suggests that the computation could greatly benefit from the use of spatial adaptivity. This is indeed the case and is explored in \href{../../refineable_periodic_load/html/index.html}{\tt another tutorial.}

 
\begin{DoxyImage}
\includegraphics[width=0.75\textwidth]{displ}
\doxyfigcaption{Plot of the displacement field. }
\end{DoxyImage}




 

\hypertarget{index_namespace}{}\section{Global parameters and functions}\label{index_namespace}
As usual, we define all non-\/dimensional parameters in a namespace.

 
\begin{DoxyCodeInclude}
\textcolor{comment}{//===start\_of\_namespace=================================================}
\textcolor{comment}{/// Namespace for global parameters}
\textcolor{comment}{}\textcolor{comment}{//======================================================================}
\textcolor{keyword}{namespace }\hyperlink{namespaceGlobal__Parameters}{Global\_Parameters}
\{\textcolor{comment}{}
\textcolor{comment}{ /// Amplitude of traction applied}
\textcolor{comment}{} \textcolor{keywordtype}{double} Amplitude = 1.0;
\textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Specify problem to be solved (boundary conditons for finite or}
\textcolor{comment}{ /// infinite domain).}
\textcolor{comment}{} \textcolor{keywordtype}{bool} Finite=\textcolor{keyword}{false};
\textcolor{comment}{}
\textcolor{comment}{ /// Define Poisson coefficient Nu}
\textcolor{comment}{} \textcolor{keywordtype}{double} Nu = 0.3;
\textcolor{comment}{}
\textcolor{comment}{ /// Length of domain in x direction}
\textcolor{comment}{} \textcolor{keywordtype}{double} Lx = 1.0;
\textcolor{comment}{}
\textcolor{comment}{ /// Length of domain in y direction}
\textcolor{comment}{} \textcolor{keywordtype}{double} Ly = 2.0;
\textcolor{comment}{}
\textcolor{comment}{ /// The elasticity tensor}
\textcolor{comment}{} IsotropicElasticityTensor \hyperlink{namespaceGlobal__Parameters_a397f48e074d2589259ed5c6e4d89f948}{E}(Nu);
\textcolor{comment}{}
\textcolor{comment}{ /// The exact solution for infinite depth case}
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{namespaceGlobal__Parameters_a6e53a9e4370e8719e9091eff6b6a0c01}{exact\_solution}(\textcolor{keyword}{const} Vector<double> &x,
                     Vector<double> &u)
 \{
  u[0] = -Amplitude*cos(2.0*MathematicalConstants::Pi*x[0]/Lx)*
        exp(2.0*MathematicalConstants::Pi*(x[1]-Ly))/
        (2.0/(1.0+\hyperlink{namespaceGlobal__Parameters_a20fccdcfa2c15ad8b951b9ada3bb1661}{Nu})*MathematicalConstants::Pi);
  u[1] = -Amplitude*sin(2.0*MathematicalConstants::Pi*x[0]/Lx)*
        exp(2.0*MathematicalConstants::Pi*(x[1]-Ly))/
        (2.0/(1.0+\hyperlink{namespaceGlobal__Parameters_a20fccdcfa2c15ad8b951b9ada3bb1661}{Nu})*MathematicalConstants::Pi);
 \}
\textcolor{comment}{}
\textcolor{comment}{ /// The traction function}
\textcolor{comment}{}\textcolor{keywordtype}{void} \hyperlink{namespaceGlobal__Parameters_a003c4c942a4c8b88b417f139fc5c637c}{periodic\_traction}(\textcolor{keyword}{const} \textcolor{keywordtype}{double} &time,
                       \textcolor{keyword}{const} Vector<double> &x,
                       \textcolor{keyword}{const} Vector<double> &n,
                       Vector<double> &result)
 \{
  result[0] = -Amplitude*cos(2.0*MathematicalConstants::Pi*x[0]/Lx);
  result[1] = -Amplitude*sin(2.0*MathematicalConstants::Pi*x[0]/Lx);
 \}
\} \textcolor{comment}{// end\_of\_namespace}

\end{DoxyCodeInclude}




 

\hypertarget{index_main}{}\section{The driver code}\label{index_main}
We start by setting the number of elements in each of the two coordinate directions before creating a {\ttfamily Doc\+Info} object to store the output directory.


\begin{DoxyCodeInclude}
\textcolor{comment}{//===start\_of\_main======================================================}
\textcolor{comment}{/// Driver code for PeriodicLoad linearly elastic problem}
\textcolor{comment}{}\textcolor{comment}{//======================================================================}
\textcolor{keywordtype}{int} \hyperlink{periodic__load_8cc_a0ddf1224851353fc92bfbff6f499fa97}{main}(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char}* argv[]) 
\{
 \textcolor{comment}{// Number of elements in x-direction}
 \textcolor{keywordtype}{unsigned} nx=5;
 
 \textcolor{comment}{// Number of elements in y-direction (for (approximately) square elements)}
 \textcolor{keywordtype}{unsigned} ny=unsigned(\textcolor{keywordtype}{double}(nx)*\hyperlink{namespaceGlobal__Parameters_a25a31b2de3f05ac457b62fc9fa999872}{Global\_Parameters::Ly}/
      \hyperlink{namespaceGlobal__Parameters_a8a81b077f0a29b3468c576f56ecb1348}{Global\_Parameters::Lx});
 
 \textcolor{comment}{// Set up doc info}
 DocInfo doc\_info;
 
 \textcolor{comment}{// Set output directory}
 doc\_info.set\_directory(\textcolor{stringliteral}{"RESLT"});

\end{DoxyCodeInclude}


We build the problem using two-\/dimensional {\ttfamily Q\+Linear\+Elasticity\+Elements}, solve using the {\ttfamily Problem\+::newton\+\_\+solve()} function, and document the results.


\begin{DoxyCodeInclude}
 \textcolor{comment}{// Set up problem}
 \hyperlink{classPeriodicLoadProblem}{PeriodicLoadProblem<QLinearElasticityElement<2,3>} > 
  problem(nx,ny,\hyperlink{namespaceGlobal__Parameters_a8a81b077f0a29b3468c576f56ecb1348}{Global\_Parameters::Lx}, 
      \hyperlink{namespaceGlobal__Parameters_a25a31b2de3f05ac457b62fc9fa999872}{Global\_Parameters::Ly});
 
 \textcolor{comment}{// Solve}
 problem.newton\_solve();
 
 \textcolor{comment}{// Output the solution}
 problem.doc\_solution(doc\_info);
  
\} \textcolor{comment}{// end\_of\_main}

\end{DoxyCodeInclude}




 

\hypertarget{index_problem}{}\section{The problem class}\label{index_problem}
The {\ttfamily Problem} class is very simple. As in other problems with Neumann boundary conditions, we provide separate meshes for the \char`\"{}bulk\char`\"{} elements and the face elements that apply the traction boundary conditions. The latter are attached to the relevant faces of the bulk elements by the function {\ttfamily assign\+\_\+traction\+\_\+elements()}.

 
\begin{DoxyCodeInclude}
\textcolor{comment}{//===start\_of\_problem\_class=============================================}
\textcolor{comment}{/// Periodic loading problem}
\textcolor{comment}{}\textcolor{comment}{//======================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT>
\textcolor{keyword}{class }\hyperlink{classPeriodicLoadProblem}{PeriodicLoadProblem} : \textcolor{keyword}{public} Problem
\{
\textcolor{keyword}{public}:
\textcolor{comment}{}
\textcolor{comment}{ /// \(\backslash\)short Constructor: Pass number of elements in x and y directions }
\textcolor{comment}{ /// and lengths}
\textcolor{comment}{} \hyperlink{classPeriodicLoadProblem_a66bf36608f2068374c09c73d9256edda}{PeriodicLoadProblem}(\textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} &nx, \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} &ny, 
                     \textcolor{keyword}{const} \textcolor{keywordtype}{double} &lx, \textcolor{keyword}{const} \textcolor{keywordtype}{double} &ly);
\textcolor{comment}{}
\textcolor{comment}{ /// Update before solve is empty}
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{classPeriodicLoadProblem_aad83601d810e4cc135f83c1308a0449b}{actions\_before\_newton\_solve}() \{\}
\textcolor{comment}{}
\textcolor{comment}{ /// Update after solve is empty}
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{classPeriodicLoadProblem_aad99d153549e1ec0b5504e486039ef5e}{actions\_after\_newton\_solve}() \{\}
\textcolor{comment}{}
\textcolor{comment}{ /// Doc the solution}
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{classPeriodicLoadProblem_ad414cf9a0b4a61de439e459f10e762c7}{doc\_solution}(DocInfo& doc\_info);

\textcolor{keyword}{private}:
\textcolor{comment}{}
\textcolor{comment}{ /// Allocate traction elements on the top surface}
\textcolor{comment}{} \textcolor{keywordtype}{void} \hyperlink{classPeriodicLoadProblem_ad850863c61c0055e230e6319d67905e2}{assign\_traction\_elements}();
 \textcolor{comment}{}
\textcolor{comment}{ /// Pointer to the bulk mesh}
\textcolor{comment}{} Mesh* \hyperlink{classPeriodicLoadProblem_a120027bff23e2cd1f17f560c852533b6}{Bulk\_mesh\_pt};
\textcolor{comment}{}
\textcolor{comment}{ /// Pointer to the mesh of traction elements}
\textcolor{comment}{} Mesh* \hyperlink{classPeriodicLoadProblem_a39b0b15487ae9aafc3d9e70b0e017325}{Surface\_mesh\_pt};

\}; \textcolor{comment}{// end\_of\_problem\_class}

\end{DoxyCodeInclude}




 

\hypertarget{index_constructor}{}\section{The problem constructor}\label{index_constructor}
Since this is a steady problem, the constructor is quite simple. We begin by building the meshes and pin the displacements on the appropriate boundaries. We then assign the boundary values for the displacements along the bottom boundary. We either set the displacements to zero or assign their values from the exact solution for the infinite depth case.


\begin{DoxyCodeInclude}
\textcolor{comment}{//===start\_of\_constructor=============================================}
\textcolor{comment}{/// Problem constructor: Pass number of elements in coordinate}
\textcolor{comment}{}\textcolor{comment}{/// directions and size of domain.}
\textcolor{comment}{}\textcolor{comment}{//====================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT>
\hyperlink{classPeriodicLoadProblem_a66bf36608f2068374c09c73d9256edda}{PeriodicLoadProblem<ELEMENT>::PeriodicLoadProblem}
(\textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} &nx, \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} &ny,
 \textcolor{keyword}{const} \textcolor{keywordtype}{double} &lx, \textcolor{keyword}{const} \textcolor{keywordtype}{double}& ly)
\{
 \textcolor{comment}{//Now create the mesh with periodic boundary conditions in x direction}
 \textcolor{keywordtype}{bool} periodic\_in\_x=\textcolor{keyword}{true};
 Bulk\_mesh\_pt = 
  \textcolor{keyword}{new} RectangularQuadMesh<ELEMENT>(nx,ny,lx,ly,periodic\_in\_x);

 \textcolor{comment}{//Create the surface mesh of traction elements}
 Surface\_mesh\_pt=\textcolor{keyword}{new} Mesh;
 assign\_traction\_elements();

 \textcolor{comment}{// Set the boundary conditions for this problem: All nodes are}
 \textcolor{comment}{// free by default -- just pin & set the ones that have Dirichlet }
 \textcolor{comment}{// conditions here}
 \textcolor{keywordtype}{unsigned} ibound=0;
 \textcolor{keywordtype}{unsigned} num\_nod=Bulk\_mesh\_pt->nboundary\_node(ibound);
 \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} inod=0;inod<num\_nod;inod++)
  \{
   \textcolor{comment}{// Get pointer to node}
   Node* nod\_pt=Bulk\_mesh\_pt->boundary\_node\_pt(ibound,inod);

   \textcolor{comment}{// Pinned in x & y at the bottom and set value}
   nod\_pt->pin(0);
   nod\_pt->pin(1);

   \textcolor{comment}{// Check which boundary conditions to set and set them}
   \textcolor{keywordflow}{if} (\hyperlink{namespaceGlobal__Parameters_a3a5d4759509036a2650d5efde8e15d56}{Global\_Parameters::Finite})
     \{
      \textcolor{comment}{// Set the displacements to zero}
      nod\_pt->set\_value(0,0);
      nod\_pt->set\_value(1,0);
     \}
   \textcolor{keywordflow}{else}
     \{
      \textcolor{comment}{// Extract nodal coordinates from node:}
      Vector<double> x(2);
      x[0]=nod\_pt->x(0);
      x[1]=nod\_pt->x(1);

      \textcolor{comment}{// Compute the value of the exact solution at the nodal point}
      Vector<double> u(2);
      \hyperlink{namespaceGlobal__Parameters_a6e53a9e4370e8719e9091eff6b6a0c01}{Global\_Parameters::exact\_solution}(x,u);

      \textcolor{comment}{// Assign these values to the nodal values at this node}
      nod\_pt->set\_value(0,u[0]);
      nod\_pt->set\_value(1,u[1]);
     \};
  \} \textcolor{comment}{// end\_loop\_over\_boundary\_nodes}

\end{DoxyCodeInclude}


Next we pass a pointer to the elasticity tensor (stored in {\ttfamily Global\+\_\+\+Physical\+\_\+\+Variables\+::E}) to all elements.


\begin{DoxyCodeInclude}
 \textcolor{comment}{// Complete the problem setup to make the elements fully functional}

 \textcolor{comment}{// Loop over the elements}
 \textcolor{keywordtype}{unsigned} n\_el = Bulk\_mesh\_pt->nelement();
 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} e=0;e<n\_el;e++)
  \{
   \textcolor{comment}{// Cast to a bulk element}
   ELEMENT *el\_pt = \textcolor{keyword}{dynamic\_cast<}ELEMENT*\textcolor{keyword}{>}(Bulk\_mesh\_pt->element\_pt(e));

   \textcolor{comment}{// Set the elasticity tensor}
   el\_pt->elasticity\_tensor\_pt() = &\hyperlink{namespaceGlobal__Parameters_a397f48e074d2589259ed5c6e4d89f948}{Global\_Parameters::E};
  \}\textcolor{comment}{// end loop over elements}

\end{DoxyCodeInclude}


We loop over the traction elements and specify the applied traction.


\begin{DoxyCodeInclude}
 \textcolor{comment}{// Loop over the traction elements}
 \textcolor{keywordtype}{unsigned} n\_traction =  Surface\_mesh\_pt->nelement();
 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} e=0;e<n\_traction;e++)
  \{
   \textcolor{comment}{// Cast to a surface element}
   LinearElasticityTractionElement<ELEMENT> *el\_pt = 
    \textcolor{keyword}{dynamic\_cast<}LinearElasticityTractionElement<ELEMENT>* \textcolor{keyword}{>}
    (Surface\_mesh\_pt->element\_pt(e));
   
   \textcolor{comment}{// Set the applied traction}
   el\_pt->traction\_fct\_pt() = &\hyperlink{namespaceGlobal__Parameters_a003c4c942a4c8b88b417f139fc5c637c}{Global\_Parameters::periodic\_traction};
  \}\textcolor{comment}{// end loop over traction elements}

\end{DoxyCodeInclude}


The two submeshes are now added to the problem and a global mesh is constructed before the equation numbering scheme is set up, using the function {\ttfamily assign\+\_\+eqn\+\_\+numbers()}.


\begin{DoxyCodeInclude}
 \textcolor{comment}{// Add the submeshes to the problem}
 add\_sub\_mesh(Bulk\_mesh\_pt);
 add\_sub\_mesh(Surface\_mesh\_pt);

 \textcolor{comment}{// Now build the global mesh}
 build\_global\_mesh();

 \textcolor{comment}{// Assign equation numbers}
 cout << assign\_eqn\_numbers() << \textcolor{stringliteral}{" equations assigned"} << std::endl; 
\} \textcolor{comment}{// end of constructor}

\end{DoxyCodeInclude}




 

\hypertarget{index_traction_elements}{}\section{The traction elements}\label{index_traction_elements}
In anticipation of the extension of this code to its \href{../../refineable_periodic_load/html/index.html}{\tt adaptive counterpart}, we create the face elements that apply the traction to the upper boundary in a separate function.


\begin{DoxyCodeInclude}
\textcolor{comment}{//===start\_of\_traction===============================================}
\textcolor{comment}{/// Make traction elements along the top boundary of the bulk mesh}
\textcolor{comment}{}\textcolor{comment}{//===================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT>
\textcolor{keywordtype}{void} \hyperlink{classPeriodicLoadProblem_ad850863c61c0055e230e6319d67905e2}{PeriodicLoadProblem<ELEMENT>::assign\_traction\_elements}
      ()
\{

 \textcolor{comment}{// How many bulk elements are next to boundary 2 (the top boundary)?}
 \textcolor{keywordtype}{unsigned} bound=2;
 \textcolor{keywordtype}{unsigned} n\_neigh = Bulk\_mesh\_pt->nboundary\_element(bound); 
 
 \textcolor{comment}{// Now loop over bulk elements and create the face elements}
 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{unsigned} n=0;n<n\_neigh;n++)
  \{
   \textcolor{comment}{// Create the face element}
   FiniteElement *traction\_element\_pt 
    = \textcolor{keyword}{new} LinearElasticityTractionElement<ELEMENT>
    (Bulk\_mesh\_pt->boundary\_element\_pt(bound,n),
     Bulk\_mesh\_pt->face\_index\_at\_boundary(bound,n));
 
   \textcolor{comment}{// Add to mesh}
   Surface\_mesh\_pt->add\_element\_pt(traction\_element\_pt);
  \}
 
\} \textcolor{comment}{// end of assign\_traction\_elements}

\end{DoxyCodeInclude}




 

\hypertarget{index_doc}{}\section{Post-\/processing}\label{index_doc}
As expected, this member function documents the computed solution.


\begin{DoxyCodeInclude}
\textcolor{comment}{//==start\_of\_doc\_solution=================================================}
\textcolor{comment}{/// Doc the solution}
\textcolor{comment}{}\textcolor{comment}{//========================================================================}
\textcolor{keyword}{template}<\textcolor{keyword}{class} ELEMENT>
\textcolor{keywordtype}{void} \hyperlink{classPeriodicLoadProblem_ad414cf9a0b4a61de439e459f10e762c7}{PeriodicLoadProblem<ELEMENT>::doc\_solution}(DocInfo& doc\_info
      )
\{ 
 ofstream some\_file;
 \textcolor{keywordtype}{char} filename[100];

 \textcolor{comment}{// Number of plot points}
 \textcolor{keywordtype}{unsigned} npts=5; 

 \textcolor{comment}{// Output solution }
 sprintf(filename,\textcolor{stringliteral}{"%s/soln.dat"},doc\_info.directory().c\_str());
 some\_file.open(filename);
 Bulk\_mesh\_pt->output(some\_file,npts);
 some\_file.close();

 \textcolor{comment}{// Output exact solution }
 sprintf(filename,\textcolor{stringliteral}{"%s/exact\_soln.dat"},doc\_info.directory().c\_str());
 some\_file.open(filename);
 Bulk\_mesh\_pt->output\_fct(some\_file,npts,
                          \hyperlink{namespaceGlobal__Parameters_a6e53a9e4370e8719e9091eff6b6a0c01}{Global\_Parameters::exact\_solution}); 
 some\_file.close();

 \textcolor{comment}{// Doc error}
 \textcolor{keywordtype}{double} error=0.0;
 \textcolor{keywordtype}{double} norm=0.0;
 sprintf(filename,\textcolor{stringliteral}{"%s/error.dat"},doc\_info.directory().c\_str());
 some\_file.open(filename);
 Bulk\_mesh\_pt->compute\_error(some\_file,
                             \hyperlink{namespaceGlobal__Parameters_a6e53a9e4370e8719e9091eff6b6a0c01}{Global\_Parameters::exact\_solution}, 
                             error,norm);
 some\_file.close();

\textcolor{comment}{// Doc error norm:}
 cout << \textcolor{stringliteral}{"\(\backslash\)nNorm of error    "} << sqrt(error) << std::endl; 
 cout << \textcolor{stringliteral}{"Norm of solution : "} << sqrt(norm) << std::endl << std::endl;
 cout << std::endl;


\} \textcolor{comment}{// end\_of\_doc\_solution   }

\end{DoxyCodeInclude}




 

\hypertarget{index_comments}{}\section{Comments and Exercises}\label{index_comments}
\hypertarget{index_nondim}{}\subsection{Comments}\label{index_nondim}
As discussed in the introduction, the non-\/dimensional version of the steady Cauchy equations only contains a single non-\/dimensional parameter, the Poisson ratio $ \nu $ which is passed to the constructor of the {\ttfamily Isotropic\+Elasticity\+Tensor}. If you inspect the relevant source code \href{../../../../src/linear_elasticity/elasticity_tensor.h}{\tt src/linear\+\_\+elasticity/elasticity\+\_\+tensor.\+h} you will find that this constructor has a second argument which defaults to one. This argument plays the role of Young\textquotesingle{}s modulus and is best interpreted as the ratio of the material\textquotesingle{}s actual Young\textquotesingle{}s modulus to the (nominal) Young\textquotesingle{}s modulus used in the non-\/dimensionalisation of the equations. The ability to provide this ratio is important if different regions of the body contain materials with different material properties.\hypertarget{index_exercises}{}\subsection{Exercises}\label{index_exercises}

\begin{DoxyEnumerate}
\item Fix the size of the domain and set the displacements along the bottom boundary to the exact solution for the infinite depth case, i.\+e. $ {\bf u} = {\bf u}^{[\mathrm{exact}]} $, using the {\ttfamily \hyperlink{namespaceGlobal__Parameters_a3a5d4759509036a2650d5efde8e15d56}{Global\+\_\+\+Parameters\+::\+Finite}} flag. Then investigate how the solution converges to the exact solution for increasing numbers of elements.
\item Try varying the depth of the domain by changing {\ttfamily \hyperlink{namespaceGlobal__Parameters_a25a31b2de3f05ac457b62fc9fa999872}{Global\+\_\+\+Parameters\+::\+Ly}} while maintaining a constant spatial resolution (i.\+e. increasing the number of elements -- this is already done in the driver code where we compute {\ttfamily ny} in terms of {\ttfamily \hyperlink{namespaceGlobal__Parameters_a25a31b2de3f05ac457b62fc9fa999872}{Global\+\_\+\+Parameters\+::\+Ly}} ) and compare how the solution converges to the exact solution of the infinite depth case.
\end{DoxyEnumerate}



 

\hypertarget{index_sources}{}\section{Source files for this tutorial}\label{index_sources}

\begin{DoxyItemize}
\item The source files for this tutorial are located in the directory\+: \begin{center} \href{../../../../demo_drivers/linear_elasticity/periodic_load/}{\tt demo\+\_\+drivers/linear\+\_\+elasticity/periodic\+\_\+load/ } \end{center} 
\item The driver code is\+: \begin{center} \href{../../../../demo_drivers/linear_elasticity/periodic_load/periodic_load.cc}{\tt demo\+\_\+drivers/linear\+\_\+elasticity/periodic\+\_\+load/periodic\+\_\+load.\+cc } \end{center} 
\end{DoxyItemize}



 

 \hypertarget{index_pdf}{}\section{P\+D\+F file}\label{index_pdf}
A \href{../latex/refman.pdf}{\tt pdf version} of this document is available. \end{document}
