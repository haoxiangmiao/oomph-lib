\hypertarget{classoomph_1_1CCDoubleMatrix}{}\section{oomph\+:\+:C\+C\+Double\+Matrix Class Reference}
\label{classoomph_1_1CCDoubleMatrix}\index{oomph\+::\+C\+C\+Double\+Matrix@{oomph\+::\+C\+C\+Double\+Matrix}}


A class for compressed column matrices that store doubles.  




{\ttfamily \#include $<$matrices.\+h$>$}

Inheritance diagram for oomph\+:\+:C\+C\+Double\+Matrix\+:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=3.456790cm]{classoomph_1_1CCDoubleMatrix}
\end{center}
\end{figure}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classoomph_1_1CCDoubleMatrix_abc80ef8ffa3a961daf6759bb2c574239}{C\+C\+Double\+Matrix} ()
\begin{DoxyCompactList}\small\item\em Default constructor. \end{DoxyCompactList}\item 
\hyperlink{classoomph_1_1CCDoubleMatrix_ad98b162e3cc1aac48e9f5e1e06e262a5}{C\+C\+Double\+Matrix} (const \hyperlink{classoomph_1_1Vector}{Vector}$<$ double $>$ \&\hyperlink{classoomph_1_1SparseMatrix_a3e382ff145082821a6b0b3e63b6aed5d}{value}, const \hyperlink{classoomph_1_1Vector}{Vector}$<$ int $>$ \&row\+\_\+index\+\_\+, const \hyperlink{classoomph_1_1Vector}{Vector}$<$ int $>$ \&column\+\_\+start\+\_\+, const unsigned long \&n, const unsigned long \&m)
\begin{DoxyCompactList}\small\item\em Constructor\+: Pass vector of values, vector of row indices, vector of column starts and number of rows (can be suppressed for square matrices). Number of nonzero entries is read off from value, so make sure the vector has been shrunk to its correct length. \end{DoxyCompactList}\item 
\hyperlink{classoomph_1_1CCDoubleMatrix_a98d894f76da33c507c6d7368b13a4fb6}{C\+C\+Double\+Matrix} (const \hyperlink{classoomph_1_1CCDoubleMatrix}{C\+C\+Double\+Matrix} \&matrix)
\begin{DoxyCompactList}\small\item\em Broken copy constructor. \end{DoxyCompactList}\item 
void \hyperlink{classoomph_1_1CCDoubleMatrix_ad21e909c73b8336792afd20de783e7c7}{operator=} (const \hyperlink{classoomph_1_1CCDoubleMatrix}{C\+C\+Double\+Matrix} \&)
\begin{DoxyCompactList}\small\item\em Broken assignment operator. \end{DoxyCompactList}\item 
virtual \hyperlink{classoomph_1_1CCDoubleMatrix_a89019bdd7b9a64a2f32cd4efa07fe45c}{$\sim$\+C\+C\+Double\+Matrix} ()
\begin{DoxyCompactList}\small\item\em Destructor\+: Kill the LU factors if they have been setup. \end{DoxyCompactList}\item 
unsigned long \hyperlink{classoomph_1_1CCDoubleMatrix_ab541153fa5ab2c1bc18e5339bacadfb9}{nrow} () const
\begin{DoxyCompactList}\small\item\em Return the number of rows of the matrix. \end{DoxyCompactList}\item 
unsigned long \hyperlink{classoomph_1_1CCDoubleMatrix_aa38cc544ab30f9318161763e13c20957}{ncol} () const
\begin{DoxyCompactList}\small\item\em Return the number of columns of the matrix. \end{DoxyCompactList}\item 
double \hyperlink{classoomph_1_1CCDoubleMatrix_a2fd1f3dfa66ed45be1ced60d2835634c}{operator()} (const unsigned long \&\hyperlink{cfortran_8h_adb50e893b86b3e55e751a42eab3cba82}{i}, const unsigned long \&j) const
\begin{DoxyCompactList}\small\item\em Overload the round-\/bracket access operator to provide read-\/only (const) access to the data. \end{DoxyCompactList}\item 
virtual void \hyperlink{classoomph_1_1CCDoubleMatrix_acb7c9b4e04b877b3ef40be905829eb41}{ludecompose} ()
\begin{DoxyCompactList}\small\item\em LU decomposition using Super\+LU. \end{DoxyCompactList}\item 
virtual void \hyperlink{classoomph_1_1CCDoubleMatrix_a59fbc30e6a856794cd2678856c8aea6d}{lubksub} (\hyperlink{classoomph_1_1DoubleVector}{Double\+Vector} \&rhs)
\begin{DoxyCompactList}\small\item\em LU back solve for given R\+HS. \end{DoxyCompactList}\item 
void \hyperlink{classoomph_1_1CCDoubleMatrix_add24c25e344b84fb5b732e294af5e8b2}{multiply} (const \hyperlink{classoomph_1_1DoubleVector}{Double\+Vector} \&x, \hyperlink{classoomph_1_1DoubleVector}{Double\+Vector} \&soln) const
\begin{DoxyCompactList}\small\item\em Multiply the matrix by the vector x\+: soln=Ax. \end{DoxyCompactList}\item 
void \hyperlink{classoomph_1_1CCDoubleMatrix_a582352912b0a7e097f9ac31c5054beed}{multiply\+\_\+transpose} (const \hyperlink{classoomph_1_1DoubleVector}{Double\+Vector} \&x, \hyperlink{classoomph_1_1DoubleVector}{Double\+Vector} \&soln) const
\begin{DoxyCompactList}\small\item\em Multiply the transposed matrix by the vector x\+: soln=A$^\wedge$T x. \end{DoxyCompactList}\item 
void \hyperlink{classoomph_1_1CCDoubleMatrix_ae6834fcfc28dca27243ec53ea48d34be}{multiply} (const \hyperlink{classoomph_1_1CCDoubleMatrix}{C\+C\+Double\+Matrix} \&matrix\+\_\+in, \hyperlink{classoomph_1_1CCDoubleMatrix}{C\+C\+Double\+Matrix} \&result)
\begin{DoxyCompactList}\small\item\em Function to multiply this matrix by the \hyperlink{classoomph_1_1CCDoubleMatrix}{C\+C\+Double\+Matrix} matrix\+\_\+in The multiplication method used can be selected using the flag Matrix\+\_\+matrix\+\_\+multiply\+\_\+method. By default Method 2 is used. Method 1\+: First runs through this matrix and matrix\+\_\+in to find the storage requirements for result -\/ arrays of the correct size are then allocated before performing the calculation. Minimises memory requirements but more costly. Method 2\+: Grows storage for values and column indices of result \textquotesingle{}on the fly\textquotesingle{} using an array of maps. Faster but more memory intensive. Method 3\+: Grows storage for values and column indices of result \textquotesingle{}on the fly\textquotesingle{} using a vector of vectors. Not particularly impressive on the platforms we tried... \end{DoxyCompactList}\item 
void \hyperlink{classoomph_1_1CCDoubleMatrix_a600a58c92baf401a534598cedcfd3415}{matrix\+\_\+reduction} (const double \&alpha, \hyperlink{classoomph_1_1CCDoubleMatrix}{C\+C\+Double\+Matrix} \&reduced\+\_\+matrix)
\begin{DoxyCompactList}\small\item\em For every row, find the maximum absolute value of the entries in this row. Set all values that are less than alpha times this maximum to zero and return the resulting matrix in reduced\+\_\+matrix. Note\+: Diagonal entries are retained regardless of their size. \end{DoxyCompactList}\item 
unsigned \& \hyperlink{classoomph_1_1CCDoubleMatrix_ac30e2e7873bf639f36494ab1b03e26d7}{matrix\+\_\+matrix\+\_\+multiply\+\_\+method} ()
\begin{DoxyCompactList}\small\item\em Access function to Matrix\+\_\+matrix\+\_\+multiply\+\_\+method, the flag which determines the matrix matrix multiplication method used. Method 1\+: First runs through this matrix and matrix\+\_\+in to find the storage requirements for result -\/ arrays of the correct size are then allocated before performing the calculation. Minimises memory requirements but more costly. Method 2\+: Grows storage for values and column indices of result \textquotesingle{}on the fly\textquotesingle{} using an array of maps. Faster but more memory intensive. Method 3\+: Grows storage for values and column indices of result \textquotesingle{}on the fly\textquotesingle{} using a vector of vectors. Not particularly impressive on the platforms we tried... \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
unsigned \hyperlink{classoomph_1_1CCDoubleMatrix_afb1660974c8f6218c2a000c2d6c6d267}{Matrix\+\_\+matrix\+\_\+multiply\+\_\+method}
\begin{DoxyCompactList}\small\item\em Flag to determine which matrix-\/matrix multiplication method is used. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Additional Inherited Members}


\subsection{Detailed Description}
A class for compressed column matrices that store doubles. 

Definition at line 2573 of file matrices.\+h.



\subsection{Constructor \& Destructor Documentation}
\mbox{\Hypertarget{classoomph_1_1CCDoubleMatrix_abc80ef8ffa3a961daf6759bb2c574239}\label{classoomph_1_1CCDoubleMatrix_abc80ef8ffa3a961daf6759bb2c574239}} 
\index{oomph\+::\+C\+C\+Double\+Matrix@{oomph\+::\+C\+C\+Double\+Matrix}!C\+C\+Double\+Matrix@{C\+C\+Double\+Matrix}}
\index{C\+C\+Double\+Matrix@{C\+C\+Double\+Matrix}!oomph\+::\+C\+C\+Double\+Matrix@{oomph\+::\+C\+C\+Double\+Matrix}}
\subsubsection{\texorpdfstring{C\+C\+Double\+Matrix()}{CCDoubleMatrix()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily oomph\+::\+C\+C\+Double\+Matrix\+::\+C\+C\+Double\+Matrix (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Default constructor. 

Default constructor, set the default linear solver and matrix-\/matrix multiplication method. 

Definition at line 586 of file matrices.\+cc.



References oomph\+::\+Double\+Matrix\+Base\+::\+Default\+\_\+linear\+\_\+solver\+\_\+pt, oomph\+::\+Double\+Matrix\+Base\+::\+Linear\+\_\+solver\+\_\+pt, and Matrix\+\_\+matrix\+\_\+multiply\+\_\+method.

\mbox{\Hypertarget{classoomph_1_1CCDoubleMatrix_ad98b162e3cc1aac48e9f5e1e06e262a5}\label{classoomph_1_1CCDoubleMatrix_ad98b162e3cc1aac48e9f5e1e06e262a5}} 
\index{oomph\+::\+C\+C\+Double\+Matrix@{oomph\+::\+C\+C\+Double\+Matrix}!C\+C\+Double\+Matrix@{C\+C\+Double\+Matrix}}
\index{C\+C\+Double\+Matrix@{C\+C\+Double\+Matrix}!oomph\+::\+C\+C\+Double\+Matrix@{oomph\+::\+C\+C\+Double\+Matrix}}
\subsubsection{\texorpdfstring{C\+C\+Double\+Matrix()}{CCDoubleMatrix()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily oomph\+::\+C\+C\+Double\+Matrix\+::\+C\+C\+Double\+Matrix (\begin{DoxyParamCaption}\item[{const \hyperlink{classoomph_1_1Vector}{Vector}$<$ double $>$ \&}]{value,  }\item[{const \hyperlink{classoomph_1_1Vector}{Vector}$<$ int $>$ \&}]{row\+\_\+index\+\_\+,  }\item[{const \hyperlink{classoomph_1_1Vector}{Vector}$<$ int $>$ \&}]{column\+\_\+start\+\_\+,  }\item[{const unsigned long \&}]{n,  }\item[{const unsigned long \&}]{m }\end{DoxyParamCaption})}



Constructor\+: Pass vector of values, vector of row indices, vector of column starts and number of rows (can be suppressed for square matrices). Number of nonzero entries is read off from value, so make sure the vector has been shrunk to its correct length. 



Definition at line 599 of file matrices.\+cc.



References oomph\+::\+Double\+Matrix\+Base\+::\+Default\+\_\+linear\+\_\+solver\+\_\+pt, oomph\+::\+Double\+Matrix\+Base\+::\+Linear\+\_\+solver\+\_\+pt, and Matrix\+\_\+matrix\+\_\+multiply\+\_\+method.

\mbox{\Hypertarget{classoomph_1_1CCDoubleMatrix_a98d894f76da33c507c6d7368b13a4fb6}\label{classoomph_1_1CCDoubleMatrix_a98d894f76da33c507c6d7368b13a4fb6}} 
\index{oomph\+::\+C\+C\+Double\+Matrix@{oomph\+::\+C\+C\+Double\+Matrix}!C\+C\+Double\+Matrix@{C\+C\+Double\+Matrix}}
\index{C\+C\+Double\+Matrix@{C\+C\+Double\+Matrix}!oomph\+::\+C\+C\+Double\+Matrix@{oomph\+::\+C\+C\+Double\+Matrix}}
\subsubsection{\texorpdfstring{C\+C\+Double\+Matrix()}{CCDoubleMatrix()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily oomph\+::\+C\+C\+Double\+Matrix\+::\+C\+C\+Double\+Matrix (\begin{DoxyParamCaption}\item[{const \hyperlink{classoomph_1_1CCDoubleMatrix}{C\+C\+Double\+Matrix} \&}]{matrix }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Broken copy constructor. 



Definition at line 2594 of file matrices.\+h.



References oomph\+::\+Broken\+Copy\+::broken\+\_\+copy().

\mbox{\Hypertarget{classoomph_1_1CCDoubleMatrix_a89019bdd7b9a64a2f32cd4efa07fe45c}\label{classoomph_1_1CCDoubleMatrix_a89019bdd7b9a64a2f32cd4efa07fe45c}} 
\index{oomph\+::\+C\+C\+Double\+Matrix@{oomph\+::\+C\+C\+Double\+Matrix}!````~C\+C\+Double\+Matrix@{$\sim$\+C\+C\+Double\+Matrix}}
\index{````~C\+C\+Double\+Matrix@{$\sim$\+C\+C\+Double\+Matrix}!oomph\+::\+C\+C\+Double\+Matrix@{oomph\+::\+C\+C\+Double\+Matrix}}
\subsubsection{\texorpdfstring{$\sim$\+C\+C\+Double\+Matrix()}{~CCDoubleMatrix()}}
{\footnotesize\ttfamily oomph\+::\+C\+C\+Double\+Matrix\+::$\sim$\+C\+C\+Double\+Matrix (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}



Destructor\+: Kill the LU factors if they have been setup. 

Destructor\+: delete the default linear solver. 

Definition at line 611 of file matrices.\+cc.



References oomph\+::\+Double\+Matrix\+Base\+::\+Default\+\_\+linear\+\_\+solver\+\_\+pt.



\subsection{Member Function Documentation}
\mbox{\Hypertarget{classoomph_1_1CCDoubleMatrix_a59fbc30e6a856794cd2678856c8aea6d}\label{classoomph_1_1CCDoubleMatrix_a59fbc30e6a856794cd2678856c8aea6d}} 
\index{oomph\+::\+C\+C\+Double\+Matrix@{oomph\+::\+C\+C\+Double\+Matrix}!lubksub@{lubksub}}
\index{lubksub@{lubksub}!oomph\+::\+C\+C\+Double\+Matrix@{oomph\+::\+C\+C\+Double\+Matrix}}
\subsubsection{\texorpdfstring{lubksub()}{lubksub()}}
{\footnotesize\ttfamily void oomph\+::\+C\+C\+Double\+Matrix\+::lubksub (\begin{DoxyParamCaption}\item[{\hyperlink{classoomph_1_1DoubleVector}{Double\+Vector} \&}]{rhs }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}



LU back solve for given R\+HS. 

Do the backsubstitution. 

Definition at line 625 of file matrices.\+cc.



References oomph\+::\+Double\+Matrix\+Base\+::\+Default\+\_\+linear\+\_\+solver\+\_\+pt.

\mbox{\Hypertarget{classoomph_1_1CCDoubleMatrix_acb7c9b4e04b877b3ef40be905829eb41}\label{classoomph_1_1CCDoubleMatrix_acb7c9b4e04b877b3ef40be905829eb41}} 
\index{oomph\+::\+C\+C\+Double\+Matrix@{oomph\+::\+C\+C\+Double\+Matrix}!ludecompose@{ludecompose}}
\index{ludecompose@{ludecompose}!oomph\+::\+C\+C\+Double\+Matrix@{oomph\+::\+C\+C\+Double\+Matrix}}
\subsubsection{\texorpdfstring{ludecompose()}{ludecompose()}}
{\footnotesize\ttfamily void oomph\+::\+C\+C\+Double\+Matrix\+::ludecompose (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}



LU decomposition using Super\+LU. 

Perform LU decomposition. Return the sign of the determinant. 

Definition at line 617 of file matrices.\+cc.



References oomph\+::\+Double\+Matrix\+Base\+::\+Default\+\_\+linear\+\_\+solver\+\_\+pt.

\mbox{\Hypertarget{classoomph_1_1CCDoubleMatrix_ac30e2e7873bf639f36494ab1b03e26d7}\label{classoomph_1_1CCDoubleMatrix_ac30e2e7873bf639f36494ab1b03e26d7}} 
\index{oomph\+::\+C\+C\+Double\+Matrix@{oomph\+::\+C\+C\+Double\+Matrix}!matrix\+\_\+matrix\+\_\+multiply\+\_\+method@{matrix\+\_\+matrix\+\_\+multiply\+\_\+method}}
\index{matrix\+\_\+matrix\+\_\+multiply\+\_\+method@{matrix\+\_\+matrix\+\_\+multiply\+\_\+method}!oomph\+::\+C\+C\+Double\+Matrix@{oomph\+::\+C\+C\+Double\+Matrix}}
\subsubsection{\texorpdfstring{matrix\+\_\+matrix\+\_\+multiply\+\_\+method()}{matrix\_matrix\_multiply\_method()}}
{\footnotesize\ttfamily unsigned\& oomph\+::\+C\+C\+Double\+Matrix\+::matrix\+\_\+matrix\+\_\+multiply\+\_\+method (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Access function to Matrix\+\_\+matrix\+\_\+multiply\+\_\+method, the flag which determines the matrix matrix multiplication method used. Method 1\+: First runs through this matrix and matrix\+\_\+in to find the storage requirements for result -\/ arrays of the correct size are then allocated before performing the calculation. Minimises memory requirements but more costly. Method 2\+: Grows storage for values and column indices of result \textquotesingle{}on the fly\textquotesingle{} using an array of maps. Faster but more memory intensive. Method 3\+: Grows storage for values and column indices of result \textquotesingle{}on the fly\textquotesingle{} using a vector of vectors. Not particularly impressive on the platforms we tried... 



Definition at line 2671 of file matrices.\+h.

\mbox{\Hypertarget{classoomph_1_1CCDoubleMatrix_a600a58c92baf401a534598cedcfd3415}\label{classoomph_1_1CCDoubleMatrix_a600a58c92baf401a534598cedcfd3415}} 
\index{oomph\+::\+C\+C\+Double\+Matrix@{oomph\+::\+C\+C\+Double\+Matrix}!matrix\+\_\+reduction@{matrix\+\_\+reduction}}
\index{matrix\+\_\+reduction@{matrix\+\_\+reduction}!oomph\+::\+C\+C\+Double\+Matrix@{oomph\+::\+C\+C\+Double\+Matrix}}
\subsubsection{\texorpdfstring{matrix\+\_\+reduction()}{matrix\_reduction()}}
{\footnotesize\ttfamily void oomph\+::\+C\+C\+Double\+Matrix\+::matrix\+\_\+reduction (\begin{DoxyParamCaption}\item[{const double \&}]{alpha,  }\item[{\hyperlink{classoomph_1_1CCDoubleMatrix}{C\+C\+Double\+Matrix} \&}]{reduced\+\_\+matrix }\end{DoxyParamCaption})}



For every row, find the maximum absolute value of the entries in this row. Set all values that are less than alpha times this maximum to zero and return the resulting matrix in reduced\+\_\+matrix. Note\+: Diagonal entries are retained regardless of their size. 

For every row, find the maximum absolute value of the entries in this row. Set all values that are less than alpha times this maximum to zero and return the resulting matrix in reduced\+\_\+matrix. Note\+: Diagonal entries are retained regardless of their size. 

Definition at line 1171 of file matrices.\+cc.



References oomph\+::\+C\+C\+Matrix$<$ double $>$\+::build(), oomph\+::\+C\+C\+Matrix$<$ double $>$\+::\+Column\+\_\+start, i, ncol(), nrow(), oomph\+::\+C\+C\+Matrix$<$ double $>$\+::\+Row\+\_\+index, and oomph\+::\+Sparse\+Matrix$<$ double, C\+C\+Matrix$<$ double $>$ $>$\+::\+Value.

\mbox{\Hypertarget{classoomph_1_1CCDoubleMatrix_add24c25e344b84fb5b732e294af5e8b2}\label{classoomph_1_1CCDoubleMatrix_add24c25e344b84fb5b732e294af5e8b2}} 
\index{oomph\+::\+C\+C\+Double\+Matrix@{oomph\+::\+C\+C\+Double\+Matrix}!multiply@{multiply}}
\index{multiply@{multiply}!oomph\+::\+C\+C\+Double\+Matrix@{oomph\+::\+C\+C\+Double\+Matrix}}
\subsubsection{\texorpdfstring{multiply()}{multiply()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily void oomph\+::\+C\+C\+Double\+Matrix\+::multiply (\begin{DoxyParamCaption}\item[{const \hyperlink{classoomph_1_1DoubleVector}{Double\+Vector} \&}]{x,  }\item[{\hyperlink{classoomph_1_1DoubleVector}{Double\+Vector} \&}]{soln }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [virtual]}}



Multiply the matrix by the vector x\+: soln=Ax. 

Multiply the matrix by the vector x. 

Implements \hyperlink{classoomph_1_1DoubleMatrixBase_a78204eab557e0dc99618e41a28a5c092}{oomph\+::\+Double\+Matrix\+Base}.



Definition at line 633 of file matrices.\+cc.



References oomph\+::\+Double\+Vector\+::build(), oomph\+::\+Double\+Vector\+::built(), oomph\+::\+C\+C\+Matrix$<$ double $>$\+::\+Column\+\_\+start, oomph\+::\+Linear\+Algebra\+Distribution\+::communicator\+\_\+pt(), oomph\+::\+Distributable\+Linear\+Algebra\+Object\+::distributed(), oomph\+::\+Distributable\+Linear\+Algebra\+Object\+::distribution\+\_\+pt(), i, oomph\+::\+Double\+Vector\+::initialise(), oomph\+::\+Sparse\+Matrix$<$ double, C\+C\+Matrix$<$ double $>$ $>$\+::N, ncol(), oomph\+::\+Distributable\+Linear\+Algebra\+Object\+::nrow(), nrow(), oomph\+::\+C\+C\+Matrix$<$ double $>$\+::\+Row\+\_\+index, oomph\+::\+Sparse\+Matrix$<$ double, C\+C\+Matrix$<$ double $>$ $>$\+::\+Value, and oomph\+::\+Double\+Vector\+::values\+\_\+pt().

\mbox{\Hypertarget{classoomph_1_1CCDoubleMatrix_ae6834fcfc28dca27243ec53ea48d34be}\label{classoomph_1_1CCDoubleMatrix_ae6834fcfc28dca27243ec53ea48d34be}} 
\index{oomph\+::\+C\+C\+Double\+Matrix@{oomph\+::\+C\+C\+Double\+Matrix}!multiply@{multiply}}
\index{multiply@{multiply}!oomph\+::\+C\+C\+Double\+Matrix@{oomph\+::\+C\+C\+Double\+Matrix}}
\subsubsection{\texorpdfstring{multiply()}{multiply()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily void oomph\+::\+C\+C\+Double\+Matrix\+::multiply (\begin{DoxyParamCaption}\item[{const \hyperlink{classoomph_1_1CCDoubleMatrix}{C\+C\+Double\+Matrix} \&}]{matrix\+\_\+in,  }\item[{\hyperlink{classoomph_1_1CCDoubleMatrix}{C\+C\+Double\+Matrix} \&}]{result }\end{DoxyParamCaption})}



Function to multiply this matrix by the \hyperlink{classoomph_1_1CCDoubleMatrix}{C\+C\+Double\+Matrix} matrix\+\_\+in The multiplication method used can be selected using the flag Matrix\+\_\+matrix\+\_\+multiply\+\_\+method. By default Method 2 is used. Method 1\+: First runs through this matrix and matrix\+\_\+in to find the storage requirements for result -\/ arrays of the correct size are then allocated before performing the calculation. Minimises memory requirements but more costly. Method 2\+: Grows storage for values and column indices of result \textquotesingle{}on the fly\textquotesingle{} using an array of maps. Faster but more memory intensive. Method 3\+: Grows storage for values and column indices of result \textquotesingle{}on the fly\textquotesingle{} using a vector of vectors. Not particularly impressive on the platforms we tried... 

Function to multiply this matrix by the \hyperlink{classoomph_1_1CCDoubleMatrix}{C\+C\+Double\+Matrix} matrix\+\_\+in The multiplication method used can be selected using the flag Matrix\+\_\+matrix\+\_\+multiply\+\_\+method. By default Method 2 is used. Method 1\+: First runs through this matrix and matrix\+\_\+in to find the storage requirements for result -\/ arrays of the correct size are then allocated before performing the calculation. Minimises memory requirements but more costly. Method 2\+: Grows storage for values and column indices of result \textquotesingle{}on the fly\textquotesingle{} using an array of maps. Faster but more memory intensive. Method 3\+: Grows storage for values and column indices of result \textquotesingle{}on the fly\textquotesingle{} using a vector of vectors. Not particularly impressive on the platforms we tried... 

Definition at line 839 of file matrices.\+cc.



References oomph\+::\+C\+C\+Matrix$<$ T $>$\+::build\+\_\+without\+\_\+copy(), oomph\+::\+C\+C\+Matrix$<$ T $>$\+::column\+\_\+start(), oomph\+::\+C\+C\+Matrix$<$ double $>$\+::column\+\_\+start(), oomph\+::\+C\+C\+Matrix$<$ double $>$\+::\+Column\+\_\+start, i, oomph\+::\+Sparse\+Matrix$<$ double, C\+C\+Matrix$<$ double $>$ $>$\+::M, Matrix\+\_\+matrix\+\_\+multiply\+\_\+method, oomph\+::\+Sparse\+Matrix$<$ double, C\+C\+Matrix$<$ double $>$ $>$\+::N, ncol(), oomph\+::\+Sparse\+Matrix$<$ double, C\+C\+Matrix$<$ double $>$ $>$\+::\+Nnz, nrow(), oomph\+::\+C\+C\+Matrix$<$ double $>$\+::row\+\_\+index(), oomph\+::\+C\+C\+Matrix$<$ T $>$\+::row\+\_\+index(), oomph\+::\+C\+C\+Matrix$<$ double $>$\+::\+Row\+\_\+index, oomph\+::\+Sparse\+Matrix$<$ double, C\+C\+Matrix$<$ double $>$ $>$\+::\+Value, oomph\+::\+Sparse\+Matrix$<$ T, M\+A\+T\+R\+I\+X\+\_\+\+T\+Y\+P\+E $>$\+::value(), and oomph\+::\+Sparse\+Matrix$<$ double, C\+C\+Matrix$<$ double $>$ $>$\+::value().

\mbox{\Hypertarget{classoomph_1_1CCDoubleMatrix_a582352912b0a7e097f9ac31c5054beed}\label{classoomph_1_1CCDoubleMatrix_a582352912b0a7e097f9ac31c5054beed}} 
\index{oomph\+::\+C\+C\+Double\+Matrix@{oomph\+::\+C\+C\+Double\+Matrix}!multiply\+\_\+transpose@{multiply\+\_\+transpose}}
\index{multiply\+\_\+transpose@{multiply\+\_\+transpose}!oomph\+::\+C\+C\+Double\+Matrix@{oomph\+::\+C\+C\+Double\+Matrix}}
\subsubsection{\texorpdfstring{multiply\+\_\+transpose()}{multiply\_transpose()}}
{\footnotesize\ttfamily void oomph\+::\+C\+C\+Double\+Matrix\+::multiply\+\_\+transpose (\begin{DoxyParamCaption}\item[{const \hyperlink{classoomph_1_1DoubleVector}{Double\+Vector} \&}]{x,  }\item[{\hyperlink{classoomph_1_1DoubleVector}{Double\+Vector} \&}]{soln }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [virtual]}}



Multiply the transposed matrix by the vector x\+: soln=A$^\wedge$T x. 



Implements \hyperlink{classoomph_1_1DoubleMatrixBase_a843d44405b70da1d96b43218a21e6ffc}{oomph\+::\+Double\+Matrix\+Base}.



Definition at line 729 of file matrices.\+cc.



References oomph\+::\+Double\+Vector\+::build(), oomph\+::\+Double\+Vector\+::built(), oomph\+::\+C\+C\+Matrix$<$ double $>$\+::\+Column\+\_\+start, oomph\+::\+Linear\+Algebra\+Distribution\+::communicator\+\_\+pt(), oomph\+::\+Distributable\+Linear\+Algebra\+Object\+::distributed(), oomph\+::\+Distributable\+Linear\+Algebra\+Object\+::distribution\+\_\+pt(), i, oomph\+::\+Double\+Vector\+::initialise(), oomph\+::\+Sparse\+Matrix$<$ double, C\+C\+Matrix$<$ double $>$ $>$\+::N, ncol(), oomph\+::\+Distributable\+Linear\+Algebra\+Object\+::nrow(), nrow(), oomph\+::\+C\+C\+Matrix$<$ double $>$\+::\+Row\+\_\+index, oomph\+::\+Sparse\+Matrix$<$ double, C\+C\+Matrix$<$ double $>$ $>$\+::\+Value, and oomph\+::\+Double\+Vector\+::values\+\_\+pt().



Referenced by oomph\+::\+Super\+L\+U\+Solver\+::solve().

\mbox{\Hypertarget{classoomph_1_1CCDoubleMatrix_aa38cc544ab30f9318161763e13c20957}\label{classoomph_1_1CCDoubleMatrix_aa38cc544ab30f9318161763e13c20957}} 
\index{oomph\+::\+C\+C\+Double\+Matrix@{oomph\+::\+C\+C\+Double\+Matrix}!ncol@{ncol}}
\index{ncol@{ncol}!oomph\+::\+C\+C\+Double\+Matrix@{oomph\+::\+C\+C\+Double\+Matrix}}
\subsubsection{\texorpdfstring{ncol()}{ncol()}}
{\footnotesize\ttfamily unsigned long oomph\+::\+C\+C\+Double\+Matrix\+::ncol (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}



Return the number of columns of the matrix. 



Implements \hyperlink{classoomph_1_1DoubleMatrixBase_a253feffbf1db1976cdd86c6134c50abe}{oomph\+::\+Double\+Matrix\+Base}.



Definition at line 2613 of file matrices.\+h.



References oomph\+::\+Sparse\+Matrix$<$ T, C\+C\+Matrix$<$ T $>$ $>$\+::ncol().



Referenced by oomph\+::\+C\+R\+Double\+Matrix\+::add(), oomph\+::\+C\+R\+Double\+Matrix\+::\+C\+R\+Double\+Matrix(), oomph\+::\+C\+R\+Double\+Matrix\+::diagonal\+\_\+entries(), oomph\+::\+C\+R\+Double\+Matrix\+::get\+\_\+matrix\+\_\+transpose(), oomph\+::\+C\+R\+Double\+Matrix\+::global\+\_\+matrix(), oomph\+::\+C\+R\+Double\+Matrix\+::matrix\+\_\+reduction(), matrix\+\_\+reduction(), oomph\+::\+C\+R\+Double\+Matrix\+::multiply(), multiply(), oomph\+::\+C\+R\+Double\+Matrix\+::multiply\+\_\+transpose(), multiply\+\_\+transpose(), and oomph\+::\+C\+R\+Double\+Matrix\+::redistribute().

\mbox{\Hypertarget{classoomph_1_1CCDoubleMatrix_ab541153fa5ab2c1bc18e5339bacadfb9}\label{classoomph_1_1CCDoubleMatrix_ab541153fa5ab2c1bc18e5339bacadfb9}} 
\index{oomph\+::\+C\+C\+Double\+Matrix@{oomph\+::\+C\+C\+Double\+Matrix}!nrow@{nrow}}
\index{nrow@{nrow}!oomph\+::\+C\+C\+Double\+Matrix@{oomph\+::\+C\+C\+Double\+Matrix}}
\subsubsection{\texorpdfstring{nrow()}{nrow()}}
{\footnotesize\ttfamily unsigned long oomph\+::\+C\+C\+Double\+Matrix\+::nrow (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}



Return the number of rows of the matrix. 



Implements \hyperlink{classoomph_1_1DoubleMatrixBase_acdcd6e1ea2bf2380f1a2fa32c7829cb5}{oomph\+::\+Double\+Matrix\+Base}.



Definition at line 2610 of file matrices.\+h.



References oomph\+::\+Sparse\+Matrix$<$ T, C\+C\+Matrix$<$ T $>$ $>$\+::nrow().



Referenced by oomph\+::\+C\+R\+Double\+Matrix\+::add(), oomph\+::\+C\+R\+Double\+Matrix\+::diagonal\+\_\+entries(), oomph\+::\+C\+R\+Double\+Matrix\+::entries\+\_\+are\+\_\+sorted(), oomph\+::\+Super\+L\+U\+Solver\+::factorise\+\_\+distributed(), oomph\+::\+C\+R\+Double\+Matrix\+::get\+\_\+matrix\+\_\+transpose(), oomph\+::\+C\+R\+Double\+Matrix\+::global\+\_\+matrix(), matrix\+\_\+reduction(), oomph\+::\+C\+R\+Double\+Matrix\+::multiply(), multiply(), oomph\+::\+C\+R\+Double\+Matrix\+::multiply\+\_\+transpose(), multiply\+\_\+transpose(), oomph\+::\+C\+R\+Double\+Matrix\+::redistribute(), oomph\+::\+I\+L\+U\+Zero\+Preconditioner$<$ C\+C\+Double\+Matrix $>$\+::setup(), and oomph\+::\+C\+R\+Double\+Matrix\+::sort\+\_\+entries().

\mbox{\Hypertarget{classoomph_1_1CCDoubleMatrix_a2fd1f3dfa66ed45be1ced60d2835634c}\label{classoomph_1_1CCDoubleMatrix_a2fd1f3dfa66ed45be1ced60d2835634c}} 
\index{oomph\+::\+C\+C\+Double\+Matrix@{oomph\+::\+C\+C\+Double\+Matrix}!operator()@{operator()}}
\index{operator()@{operator()}!oomph\+::\+C\+C\+Double\+Matrix@{oomph\+::\+C\+C\+Double\+Matrix}}
\subsubsection{\texorpdfstring{operator()()}{operator()()}}
{\footnotesize\ttfamily double oomph\+::\+C\+C\+Double\+Matrix\+::operator() (\begin{DoxyParamCaption}\item[{const unsigned long \&}]{i,  }\item[{const unsigned long \&}]{j }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}



Overload the round-\/bracket access operator to provide read-\/only (const) access to the data. 



Implements \hyperlink{classoomph_1_1DoubleMatrixBase_a20b85f0286f80464f42f0846fede2d77}{oomph\+::\+Double\+Matrix\+Base}.



Definition at line 2617 of file matrices.\+h.



References oomph\+::\+C\+C\+Matrix$<$ T $>$\+::get\+\_\+entry(), and oomph\+::\+Trilinos\+Epetra\+Helpers\+::multiply().

\mbox{\Hypertarget{classoomph_1_1CCDoubleMatrix_ad21e909c73b8336792afd20de783e7c7}\label{classoomph_1_1CCDoubleMatrix_ad21e909c73b8336792afd20de783e7c7}} 
\index{oomph\+::\+C\+C\+Double\+Matrix@{oomph\+::\+C\+C\+Double\+Matrix}!operator=@{operator=}}
\index{operator=@{operator=}!oomph\+::\+C\+C\+Double\+Matrix@{oomph\+::\+C\+C\+Double\+Matrix}}
\subsubsection{\texorpdfstring{operator=()}{operator=()}}
{\footnotesize\ttfamily void oomph\+::\+C\+C\+Double\+Matrix\+::operator= (\begin{DoxyParamCaption}\item[{const \hyperlink{classoomph_1_1CCDoubleMatrix}{C\+C\+Double\+Matrix} \&}]{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Broken assignment operator. 



Definition at line 2601 of file matrices.\+h.



References oomph\+::\+Broken\+Copy\+::broken\+\_\+assign().



\subsection{Member Data Documentation}
\mbox{\Hypertarget{classoomph_1_1CCDoubleMatrix_afb1660974c8f6218c2a000c2d6c6d267}\label{classoomph_1_1CCDoubleMatrix_afb1660974c8f6218c2a000c2d6c6d267}} 
\index{oomph\+::\+C\+C\+Double\+Matrix@{oomph\+::\+C\+C\+Double\+Matrix}!Matrix\+\_\+matrix\+\_\+multiply\+\_\+method@{Matrix\+\_\+matrix\+\_\+multiply\+\_\+method}}
\index{Matrix\+\_\+matrix\+\_\+multiply\+\_\+method@{Matrix\+\_\+matrix\+\_\+multiply\+\_\+method}!oomph\+::\+C\+C\+Double\+Matrix@{oomph\+::\+C\+C\+Double\+Matrix}}
\subsubsection{\texorpdfstring{Matrix\+\_\+matrix\+\_\+multiply\+\_\+method}{Matrix\_matrix\_multiply\_method}}
{\footnotesize\ttfamily unsigned oomph\+::\+C\+C\+Double\+Matrix\+::\+Matrix\+\_\+matrix\+\_\+multiply\+\_\+method\hspace{0.3cm}{\ttfamily [private]}}



Flag to determine which matrix-\/matrix multiplication method is used. 



Definition at line 2679 of file matrices.\+h.



Referenced by C\+C\+Double\+Matrix(), and multiply().



The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
\hyperlink{matrices_8h}{matrices.\+h}\item 
\hyperlink{matrices_8cc}{matrices.\+cc}\end{DoxyCompactItemize}
