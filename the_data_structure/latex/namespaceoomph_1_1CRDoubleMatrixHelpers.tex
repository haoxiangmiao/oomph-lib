\hypertarget{namespaceoomph_1_1CRDoubleMatrixHelpers}{}\section{oomph\+:\+:C\+R\+Double\+Matrix\+Helpers Namespace Reference}
\label{namespaceoomph_1_1CRDoubleMatrixHelpers}\index{oomph\+::\+C\+R\+Double\+Matrix\+Helpers@{oomph\+::\+C\+R\+Double\+Matrix\+Helpers}}


Namespace for helper functions for C\+R\+Double\+Matrices.  


\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{namespaceoomph_1_1CRDoubleMatrixHelpers_ae3c10e59d5857457c7e34be8e9262035}{create\+\_\+uniformly\+\_\+distributed\+\_\+matrix} (const unsigned \&nrow, const unsigned \&ncol, const \hyperlink{classoomph_1_1OomphCommunicator}{Oomph\+Communicator} $\ast$const comm\+\_\+pt, const \hyperlink{classoomph_1_1Vector}{Vector}$<$ double $>$ \&values, const \hyperlink{classoomph_1_1Vector}{Vector}$<$ int $>$ \&column\+\_\+indices, const \hyperlink{classoomph_1_1Vector}{Vector}$<$ int $>$ \&row\+\_\+start, \hyperlink{classoomph_1_1CRDoubleMatrix}{C\+R\+Double\+Matrix} \&matrix\+\_\+out)
\begin{DoxyCompactList}\small\item\em Builds a uniformly distributed matrix. A locally replicated matrix is constructed then redistributed using O\+O\+M\+P\+H-\/\+L\+IB\textquotesingle{}s default uniform row distribution. This is memory intensive thus should be used for testing or small problems only. \end{DoxyCompactList}\item 
double \hyperlink{namespaceoomph_1_1CRDoubleMatrixHelpers_ad81583a57fba80fee50d14afdf1c86e2}{inf\+\_\+norm} (const \hyperlink{classoomph_1_1DenseMatrix}{Dense\+Matrix}$<$ \hyperlink{classoomph_1_1CRDoubleMatrix}{C\+R\+Double\+Matrix} $\ast$$>$ \&matrix\+\_\+pt)
\begin{DoxyCompactList}\small\item\em Compute infinity (maximum) norm of sub blocks as if it was one matrix. \end{DoxyCompactList}\item 
double \hyperlink{namespaceoomph_1_1CRDoubleMatrixHelpers_ac7abb3c0163ba84dbf12eb5a0240a59c}{gershgorin\+\_\+eigenvalue\+\_\+estimate} (const \hyperlink{classoomph_1_1DenseMatrix}{Dense\+Matrix}$<$ \hyperlink{classoomph_1_1CRDoubleMatrix}{C\+R\+Double\+Matrix} $\ast$$>$ \&matrix\+\_\+pt)
\begin{DoxyCompactList}\small\item\em Calculates the largest Gershgorin disc whilst preserving the sign. Let A be an n by n matrix, with entries aij. For $ i \in \{ 1,...,n \} $ let $ R_i = \sum_{i\neq j} |a_{ij}| $ be the sum of the absolute values of the non-\/diagonal entries in the i-\/th row. Let $ D(a_{ii},R_i) $ be the closed disc centered at $ a_{ii} $ with radius $ R_i $, such a disc is called a Gershgorin disc. \end{DoxyCompactList}\item 
void \hyperlink{namespaceoomph_1_1CRDoubleMatrixHelpers_aba5724bb1f89625f601045ba6ad139bf}{concatenate} (const \hyperlink{classoomph_1_1DenseMatrix}{Dense\+Matrix}$<$ \hyperlink{classoomph_1_1CRDoubleMatrix}{C\+R\+Double\+Matrix} $\ast$$>$ \&matrix\+\_\+pt, \hyperlink{classoomph_1_1CRDoubleMatrix}{C\+R\+Double\+Matrix} \&result\+\_\+matrix)
\begin{DoxyCompactList}\small\item\em Concatenate \hyperlink{classoomph_1_1CRDoubleMatrix}{C\+R\+Double\+Matrix} matrices. The in matrices are concatenated such that the block structure of the in matrices are preserved in the result matrix. Communication between processors is required. If the block structure of the sub matrices does not need to be preserved, consider using \hyperlink{namespaceoomph_1_1CRDoubleMatrixHelpers_ab335593fd53dbb5162fd63f14db95377}{C\+R\+Double\+Matrix\+Helpers\+::concatenate\+\_\+without\+\_\+communication}(...). \end{DoxyCompactList}\item 
void \hyperlink{namespaceoomph_1_1CRDoubleMatrixHelpers_ab335593fd53dbb5162fd63f14db95377}{concatenate\+\_\+without\+\_\+communication} (const \hyperlink{classoomph_1_1Vector}{Vector}$<$ \hyperlink{classoomph_1_1LinearAlgebraDistribution}{Linear\+Algebra\+Distribution} $\ast$$>$ \&row\+\_\+distribution\+\_\+pt, const \hyperlink{classoomph_1_1Vector}{Vector}$<$ \hyperlink{classoomph_1_1LinearAlgebraDistribution}{Linear\+Algebra\+Distribution} $\ast$$>$ \&col\+\_\+distribution\+\_\+pt, const \hyperlink{classoomph_1_1DenseMatrix}{Dense\+Matrix}$<$ \hyperlink{classoomph_1_1CRDoubleMatrix}{C\+R\+Double\+Matrix} $\ast$$>$ \&matrix\+\_\+pt, \hyperlink{classoomph_1_1CRDoubleMatrix}{C\+R\+Double\+Matrix} \&result\+\_\+matrix)
\begin{DoxyCompactList}\small\item\em Concatenate \hyperlink{classoomph_1_1CRDoubleMatrix}{C\+R\+Double\+Matrix} matrices. \end{DoxyCompactList}\item 
void \hyperlink{namespaceoomph_1_1CRDoubleMatrixHelpers_a53d5c536ca841d3d4fae5feb78448b0a}{concatenate\+\_\+without\+\_\+communication} (const \hyperlink{classoomph_1_1Vector}{Vector}$<$ \hyperlink{classoomph_1_1LinearAlgebraDistribution}{Linear\+Algebra\+Distribution} $\ast$$>$ \&block\+\_\+distribution\+\_\+pt, const \hyperlink{classoomph_1_1DenseMatrix}{Dense\+Matrix}$<$ \hyperlink{classoomph_1_1CRDoubleMatrix}{C\+R\+Double\+Matrix} $\ast$$>$ \&matrix\+\_\+pt, \hyperlink{classoomph_1_1CRDoubleMatrix}{C\+R\+Double\+Matrix} \&result\+\_\+matrix)
\begin{DoxyCompactList}\small\item\em Concatenate \hyperlink{classoomph_1_1CRDoubleMatrix}{C\+R\+Double\+Matrix} matrices. This calls the other concatenate\+\_\+without\+\_\+communication(...) function, passing block\+\_\+distribution\+\_\+pt as both the row\+\_\+distribution\+\_\+pt and col\+\_\+distribution\+\_\+pt. This should only be called for block square matrices. \end{DoxyCompactList}\item 
void \hyperlink{namespaceoomph_1_1CRDoubleMatrixHelpers_a157511f700993ab8bc014f9d0d44f4c7}{deep\+\_\+copy} (const \hyperlink{classoomph_1_1CRDoubleMatrix}{C\+R\+Double\+Matrix} $\ast$const in\+\_\+matrix\+\_\+pt, \hyperlink{classoomph_1_1CRDoubleMatrix}{C\+R\+Double\+Matrix} \&out\+\_\+matrix)
\begin{DoxyCompactList}\small\item\em Create a deep copy of the matrix pointed to by in\+\_\+matrix\+\_\+pt. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
Namespace for helper functions for C\+R\+Double\+Matrices. 

\subsection{Function Documentation}
\mbox{\Hypertarget{namespaceoomph_1_1CRDoubleMatrixHelpers_aba5724bb1f89625f601045ba6ad139bf}\label{namespaceoomph_1_1CRDoubleMatrixHelpers_aba5724bb1f89625f601045ba6ad139bf}} 
\index{oomph\+::\+C\+R\+Double\+Matrix\+Helpers@{oomph\+::\+C\+R\+Double\+Matrix\+Helpers}!concatenate@{concatenate}}
\index{concatenate@{concatenate}!oomph\+::\+C\+R\+Double\+Matrix\+Helpers@{oomph\+::\+C\+R\+Double\+Matrix\+Helpers}}
\subsubsection{\texorpdfstring{concatenate()}{concatenate()}}
{\footnotesize\ttfamily void oomph\+::\+C\+R\+Double\+Matrix\+Helpers\+::concatenate (\begin{DoxyParamCaption}\item[{const \hyperlink{classoomph_1_1DenseMatrix}{Dense\+Matrix}$<$ \hyperlink{classoomph_1_1CRDoubleMatrix}{C\+R\+Double\+Matrix} $\ast$$>$ \&}]{matrix\+\_\+pt,  }\item[{\hyperlink{classoomph_1_1CRDoubleMatrix}{C\+R\+Double\+Matrix} \&}]{result\+\_\+matrix }\end{DoxyParamCaption})}



Concatenate \hyperlink{classoomph_1_1CRDoubleMatrix}{C\+R\+Double\+Matrix} matrices. The in matrices are concatenated such that the block structure of the in matrices are preserved in the result matrix. Communication between processors is required. If the block structure of the sub matrices does not need to be preserved, consider using \hyperlink{namespaceoomph_1_1CRDoubleMatrixHelpers_ab335593fd53dbb5162fd63f14db95377}{C\+R\+Double\+Matrix\+Helpers\+::concatenate\+\_\+without\+\_\+communication}(...). 

The matrix manipulation functions \hyperlink{namespaceoomph_1_1CRDoubleMatrixHelpers_aba5724bb1f89625f601045ba6ad139bf}{C\+R\+Double\+Matrix\+Helpers\+::concatenate}(...) and \hyperlink{namespaceoomph_1_1CRDoubleMatrixHelpers_ab335593fd53dbb5162fd63f14db95377}{C\+R\+Double\+Matrix\+Helpers\+::concatenate\+\_\+without\+\_\+communication}(...) are analogous to the \hyperlink{classoomph_1_1Vector}{Vector} manipulation functions \hyperlink{namespaceoomph_1_1DoubleVectorHelpers_ae5259ed3ae48ad417c743de0166884f8}{Double\+Vector\+Helpers\+::concatenate}(...) and \hyperlink{namespaceoomph_1_1DoubleVectorHelpers_ac69d6979ffbf4987684c0e025d107947}{Double\+Vector\+Helpers\+::concatenate\+\_\+without\+\_\+communication}(...). Please look at the \hyperlink{classoomph_1_1DoubleVector}{Double\+Vector} functions for an illustration of the differences between concatenate(...) and concatenate\+\_\+without\+\_\+communication(...).

Distribution of the result matrix\+: If the result matrix does not have a distribution built, then it will be given a uniform row distribution. Otherwise we use the existing distribution. This gives the user the ability to define their own distribution, or save computing power if a distribution has been pre-\/built.

N\+O\+TE\+: A\+LL the matrices pointed to by matrix\+\_\+pt has to be built. This is not the case with concatenate\+\_\+without\+\_\+communication(...) 

Definition at line 4309 of file matrices.\+cc.



References oomph\+::\+C\+R\+Double\+Matrix\+::build(), oomph\+::\+Linear\+Algebra\+Distribution\+::built(), oomph\+::\+C\+R\+Double\+Matrix\+::column\+\_\+index(), oomph\+::\+Linear\+Algebra\+Distribution\+::communicator\+\_\+pt(), oomph\+::\+Distributable\+Linear\+Algebra\+Object\+::distributed(), oomph\+::\+Distributable\+Linear\+Algebra\+Object\+::distribution\+\_\+pt(), oomph\+::\+Linear\+Algebra\+Distribution\+::first\+\_\+row(), oomph\+::\+Dense\+Matrix$<$ T $>$\+::ncol(), oomph\+::\+Dense\+Matrix$<$ T $>$\+::nrow(), oomph\+::\+C\+R\+Double\+Matrix\+::nrow(), oomph\+::\+Linear\+Algebra\+Distribution\+::nrow\+\_\+local(), oomph\+::oomph\+\_\+info, oomph\+::\+Linear\+Algebra\+Distribution\+::rank\+\_\+of\+\_\+global\+\_\+row(), oomph\+::\+C\+R\+Double\+Matrix\+::row\+\_\+start(), oomph\+::\+Timing\+Helpers\+::timer(), and oomph\+::\+C\+R\+Double\+Matrix\+::value().

\mbox{\Hypertarget{namespaceoomph_1_1CRDoubleMatrixHelpers_ab335593fd53dbb5162fd63f14db95377}\label{namespaceoomph_1_1CRDoubleMatrixHelpers_ab335593fd53dbb5162fd63f14db95377}} 
\index{oomph\+::\+C\+R\+Double\+Matrix\+Helpers@{oomph\+::\+C\+R\+Double\+Matrix\+Helpers}!concatenate\+\_\+without\+\_\+communication@{concatenate\+\_\+without\+\_\+communication}}
\index{concatenate\+\_\+without\+\_\+communication@{concatenate\+\_\+without\+\_\+communication}!oomph\+::\+C\+R\+Double\+Matrix\+Helpers@{oomph\+::\+C\+R\+Double\+Matrix\+Helpers}}
\subsubsection{\texorpdfstring{concatenate\+\_\+without\+\_\+communication()}{concatenate\_without\_communication()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily void oomph\+::\+C\+R\+Double\+Matrix\+Helpers\+::concatenate\+\_\+without\+\_\+communication (\begin{DoxyParamCaption}\item[{const \hyperlink{classoomph_1_1Vector}{Vector}$<$ \hyperlink{classoomph_1_1LinearAlgebraDistribution}{Linear\+Algebra\+Distribution} $\ast$$>$ \&}]{row\+\_\+distribution\+\_\+pt,  }\item[{const \hyperlink{classoomph_1_1Vector}{Vector}$<$ \hyperlink{classoomph_1_1LinearAlgebraDistribution}{Linear\+Algebra\+Distribution} $\ast$$>$ \&}]{col\+\_\+distribution\+\_\+pt,  }\item[{const \hyperlink{classoomph_1_1DenseMatrix}{Dense\+Matrix}$<$ \hyperlink{classoomph_1_1CRDoubleMatrix}{C\+R\+Double\+Matrix} $\ast$$>$ \&}]{matrix\+\_\+pt,  }\item[{\hyperlink{classoomph_1_1CRDoubleMatrix}{C\+R\+Double\+Matrix} \&}]{result\+\_\+matrix }\end{DoxyParamCaption})}



Concatenate \hyperlink{classoomph_1_1CRDoubleMatrix}{C\+R\+Double\+Matrix} matrices. 

The \hyperlink{classoomph_1_1Vector}{Vector} row\+\_\+distribution\+\_\+pt contains the \hyperlink{classoomph_1_1LinearAlgebraDistribution}{Linear\+Algebra\+Distribution} of each block row. The \hyperlink{classoomph_1_1Vector}{Vector} col\+\_\+distribution\+\_\+pt contains the \hyperlink{classoomph_1_1LinearAlgebraDistribution}{Linear\+Algebra\+Distribution} of each block column. The \hyperlink{classoomph_1_1DenseMatrix}{Dense\+Matrix} matrix\+\_\+pt contains pointers to the C\+R\+Double\+Matrices to concatenate. The \hyperlink{classoomph_1_1CRDoubleMatrix}{C\+R\+Double\+Matrix} result\+\_\+matrix is the result matrix.

The result matrix is a permutation of the sub matrices such that the data stays on the same processor when the result matrix is built, there is no communication between processors. Thus the block structure of the sub matrices are N\+OT preserved in the result matrix. The rows are block-\/permuted, defined by the concatenation of the distributions in row\+\_\+distribution\+\_\+pt. Similarly, the columns are block-\/permuted, defined by the concatenation of the distributions in col\+\_\+distribution\+\_\+pt. For more details on the block-\/permutation, see \hyperlink{namespaceoomph_1_1LinearAlgebraDistributionHelpers_ad3ba423fba64e7db91e9155efa7df5d0}{Linear\+Algebra\+Distribution\+Helpers\+::concatenate}(...).

If one wishes to preserve the block structure of the sub matrices in the result matrix, consider using \hyperlink{namespaceoomph_1_1CRDoubleMatrixHelpers_aba5724bb1f89625f601045ba6ad139bf}{C\+R\+Double\+Matrix\+Helpers\+::concatenate}(...), which uses communication between processors to ensure that the block structure of the sub matrices are preserved.

The matrix manipulation functions \hyperlink{namespaceoomph_1_1CRDoubleMatrixHelpers_aba5724bb1f89625f601045ba6ad139bf}{C\+R\+Double\+Matrix\+Helpers\+::concatenate}(...) and \hyperlink{namespaceoomph_1_1CRDoubleMatrixHelpers_ab335593fd53dbb5162fd63f14db95377}{C\+R\+Double\+Matrix\+Helpers\+::concatenate\+\_\+without\+\_\+communication}(...) are analogous to the \hyperlink{classoomph_1_1Vector}{Vector} manipulation functions \hyperlink{namespaceoomph_1_1DoubleVectorHelpers_ae5259ed3ae48ad417c743de0166884f8}{Double\+Vector\+Helpers\+::concatenate}(...) and \hyperlink{namespaceoomph_1_1DoubleVectorHelpers_ac69d6979ffbf4987684c0e025d107947}{Double\+Vector\+Helpers\+::concatenate\+\_\+without\+\_\+communication}(...). Please look at the \hyperlink{classoomph_1_1DoubleVector}{Double\+Vector} functions for an illustration of the differences between concatenate(...) and concatenate\+\_\+without\+\_\+communication(...).

Distribution of the result matrix\+: If the result matrix does not have a distribution built, then it will be given a distribution built from the concatenation of the distributions from row\+\_\+distribution\+\_\+pt, see \hyperlink{namespaceoomph_1_1LinearAlgebraDistributionHelpers_ad3ba423fba64e7db91e9155efa7df5d0}{Linear\+Algebra\+Distribution\+Helpers\+::concatenate}(...) for more detail. Otherwise we use the existing distribution. If there is an existing distribution then it must be the same as the distribution from the concatenation of row distributions as described above. Why don\textquotesingle{}t we always compute the distribution \char`\"{}on the fly\char`\"{}? Because a non-\/uniform distribution requires communication. All block preconditioner distributions are concatenations of the distributions of the individual blocks. 

Definition at line 5164 of file matrices.\+cc.



References oomph\+::\+C\+R\+Double\+Matrix\+::build(), oomph\+::\+C\+R\+Double\+Matrix\+::build\+\_\+without\+\_\+copy(), oomph\+::\+Linear\+Algebra\+Distribution\+::built(), oomph\+::\+Linear\+Algebra\+Distribution\+::communicator\+\_\+pt(), oomph\+::\+Linear\+Algebra\+Distribution\+Helpers\+::concatenate(), oomph\+::\+Distributable\+Linear\+Algebra\+Object\+::distributed(), oomph\+::\+Distributable\+Linear\+Algebra\+Object\+::distribution\+\_\+pt(), i, oomph\+::\+Dense\+Matrix$<$ T $>$\+::ncol(), oomph\+::\+Dense\+Matrix$<$ T $>$\+::nrow(), and oomph\+::\+Linear\+Algebra\+Distribution\+::nrow\+\_\+local().



Referenced by oomph\+::\+Block\+Preconditioner$<$ C\+R\+Double\+Matrix $>$\+::get\+\_\+block(), and oomph\+::\+Block\+Preconditioner$<$ C\+R\+Double\+Matrix $>$\+::get\+\_\+concatenated\+\_\+block().

\mbox{\Hypertarget{namespaceoomph_1_1CRDoubleMatrixHelpers_a53d5c536ca841d3d4fae5feb78448b0a}\label{namespaceoomph_1_1CRDoubleMatrixHelpers_a53d5c536ca841d3d4fae5feb78448b0a}} 
\index{oomph\+::\+C\+R\+Double\+Matrix\+Helpers@{oomph\+::\+C\+R\+Double\+Matrix\+Helpers}!concatenate\+\_\+without\+\_\+communication@{concatenate\+\_\+without\+\_\+communication}}
\index{concatenate\+\_\+without\+\_\+communication@{concatenate\+\_\+without\+\_\+communication}!oomph\+::\+C\+R\+Double\+Matrix\+Helpers@{oomph\+::\+C\+R\+Double\+Matrix\+Helpers}}
\subsubsection{\texorpdfstring{concatenate\+\_\+without\+\_\+communication()}{concatenate\_without\_communication()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily void oomph\+::\+C\+R\+Double\+Matrix\+Helpers\+::concatenate\+\_\+without\+\_\+communication (\begin{DoxyParamCaption}\item[{const \hyperlink{classoomph_1_1Vector}{Vector}$<$ \hyperlink{classoomph_1_1LinearAlgebraDistribution}{Linear\+Algebra\+Distribution} $\ast$$>$ \&}]{block\+\_\+distribution\+\_\+pt,  }\item[{const \hyperlink{classoomph_1_1DenseMatrix}{Dense\+Matrix}$<$ \hyperlink{classoomph_1_1CRDoubleMatrix}{C\+R\+Double\+Matrix} $\ast$$>$ \&}]{matrix\+\_\+pt,  }\item[{\hyperlink{classoomph_1_1CRDoubleMatrix}{C\+R\+Double\+Matrix} \&}]{result\+\_\+matrix }\end{DoxyParamCaption})}



Concatenate \hyperlink{classoomph_1_1CRDoubleMatrix}{C\+R\+Double\+Matrix} matrices. This calls the other concatenate\+\_\+without\+\_\+communication(...) function, passing block\+\_\+distribution\+\_\+pt as both the row\+\_\+distribution\+\_\+pt and col\+\_\+distribution\+\_\+pt. This should only be called for block square matrices. 



Definition at line 5816 of file matrices.\+cc.



References oomph\+::\+Dense\+Matrix$<$ T $>$\+::ncol(), and oomph\+::\+Dense\+Matrix$<$ T $>$\+::nrow().

\mbox{\Hypertarget{namespaceoomph_1_1CRDoubleMatrixHelpers_ae3c10e59d5857457c7e34be8e9262035}\label{namespaceoomph_1_1CRDoubleMatrixHelpers_ae3c10e59d5857457c7e34be8e9262035}} 
\index{oomph\+::\+C\+R\+Double\+Matrix\+Helpers@{oomph\+::\+C\+R\+Double\+Matrix\+Helpers}!create\+\_\+uniformly\+\_\+distributed\+\_\+matrix@{create\+\_\+uniformly\+\_\+distributed\+\_\+matrix}}
\index{create\+\_\+uniformly\+\_\+distributed\+\_\+matrix@{create\+\_\+uniformly\+\_\+distributed\+\_\+matrix}!oomph\+::\+C\+R\+Double\+Matrix\+Helpers@{oomph\+::\+C\+R\+Double\+Matrix\+Helpers}}
\subsubsection{\texorpdfstring{create\+\_\+uniformly\+\_\+distributed\+\_\+matrix()}{create\_uniformly\_distributed\_matrix()}}
{\footnotesize\ttfamily void oomph\+::\+C\+R\+Double\+Matrix\+Helpers\+::create\+\_\+uniformly\+\_\+distributed\+\_\+matrix (\begin{DoxyParamCaption}\item[{const unsigned \&}]{nrow,  }\item[{const unsigned \&}]{ncol,  }\item[{const \hyperlink{classoomph_1_1OomphCommunicator}{Oomph\+Communicator} $\ast$const}]{comm\+\_\+pt,  }\item[{const \hyperlink{classoomph_1_1Vector}{Vector}$<$ double $>$ \&}]{values,  }\item[{const \hyperlink{classoomph_1_1Vector}{Vector}$<$ int $>$ \&}]{column\+\_\+indices,  }\item[{const \hyperlink{classoomph_1_1Vector}{Vector}$<$ int $>$ \&}]{row\+\_\+start,  }\item[{\hyperlink{classoomph_1_1CRDoubleMatrix}{C\+R\+Double\+Matrix} \&}]{matrix\+\_\+out }\end{DoxyParamCaption})}



Builds a uniformly distributed matrix. A locally replicated matrix is constructed then redistributed using O\+O\+M\+P\+H-\/\+L\+IB\textquotesingle{}s default uniform row distribution. This is memory intensive thus should be used for testing or small problems only. 

Builds a uniformly distributed matrix. A locally replicated matrix is constructed then redistributed using O\+O\+M\+P\+H-\/\+L\+IB\textquotesingle{}s default uniform row distribution. This is memory intensive thus should be used for testing or small problems only. The resulting matrix (mat\+\_\+out) must not have been built. 

Definition at line 3658 of file matrices.\+cc.



References oomph\+::\+C\+R\+Double\+Matrix\+::build(), oomph\+::\+C\+R\+Double\+Matrix\+::built(), and oomph\+::\+C\+R\+Double\+Matrix\+::redistribute().



Referenced by deep\+\_\+copy().

\mbox{\Hypertarget{namespaceoomph_1_1CRDoubleMatrixHelpers_a157511f700993ab8bc014f9d0d44f4c7}\label{namespaceoomph_1_1CRDoubleMatrixHelpers_a157511f700993ab8bc014f9d0d44f4c7}} 
\index{oomph\+::\+C\+R\+Double\+Matrix\+Helpers@{oomph\+::\+C\+R\+Double\+Matrix\+Helpers}!deep\+\_\+copy@{deep\+\_\+copy}}
\index{deep\+\_\+copy@{deep\+\_\+copy}!oomph\+::\+C\+R\+Double\+Matrix\+Helpers@{oomph\+::\+C\+R\+Double\+Matrix\+Helpers}}
\subsubsection{\texorpdfstring{deep\+\_\+copy()}{deep\_copy()}}
{\footnotesize\ttfamily void oomph\+::\+C\+R\+Double\+Matrix\+Helpers\+::deep\+\_\+copy (\begin{DoxyParamCaption}\item[{const \hyperlink{classoomph_1_1CRDoubleMatrix}{C\+R\+Double\+Matrix} $\ast$const}]{in\+\_\+matrix\+\_\+pt,  }\item[{\hyperlink{classoomph_1_1CRDoubleMatrix}{C\+R\+Double\+Matrix} \&}]{out\+\_\+matrix }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Create a deep copy of the matrix pointed to by in\+\_\+matrix\+\_\+pt. 



Definition at line 3244 of file matrices.\+h.



References oomph\+::\+C\+R\+Double\+Matrix\+::build(), oomph\+::\+C\+R\+Double\+Matrix\+::build\+\_\+without\+\_\+copy(), oomph\+::\+C\+R\+Double\+Matrix\+::built(), oomph\+::\+C\+R\+Double\+Matrix\+::column\+\_\+index(), oomph\+::\+Double\+Vector\+Helpers\+::concatenate(), oomph\+::\+Double\+Vector\+Helpers\+::concatenate\+\_\+without\+\_\+communication(), create\+\_\+uniformly\+\_\+distributed\+\_\+matrix(), oomph\+::\+C\+R\+Double\+Matrix\+::distributed\+\_\+matrix\+\_\+matrix\+\_\+multiply\+\_\+method(), oomph\+::\+Distributable\+Linear\+Algebra\+Object\+::distribution\+\_\+pt(), gershgorin\+\_\+eigenvalue\+\_\+estimate(), inf\+\_\+norm(), oomph\+::\+Matrix$<$ T, M\+A\+T\+R\+I\+X\+\_\+\+T\+Y\+P\+E $>$\+::ncol(), oomph\+::\+C\+R\+Double\+Matrix\+::ncol(), oomph\+::\+C\+R\+Double\+Matrix\+::nnz(), oomph\+::\+Matrix$<$ T, M\+A\+T\+R\+I\+X\+\_\+\+T\+Y\+P\+E $>$\+::nrow(), oomph\+::\+Distributable\+Linear\+Algebra\+Object\+::nrow\+\_\+local(), oomph\+::\+C\+R\+Double\+Matrix\+::row\+\_\+start(), oomph\+::\+C\+R\+Double\+Matrix\+::serial\+\_\+matrix\+\_\+matrix\+\_\+multiply\+\_\+method(), and oomph\+::\+C\+R\+Double\+Matrix\+::value().



Referenced by oomph\+::\+Double\+Multi\+Vector\+::\+Double\+Multi\+Vector(), oomph\+::\+Block\+Preconditioner$<$ C\+R\+Double\+Matrix $>$\+::get\+\_\+block(), and oomph\+::\+Block\+Preconditioner$<$ C\+R\+Double\+Matrix $>$\+::get\+\_\+dof\+\_\+level\+\_\+block().

\mbox{\Hypertarget{namespaceoomph_1_1CRDoubleMatrixHelpers_ac7abb3c0163ba84dbf12eb5a0240a59c}\label{namespaceoomph_1_1CRDoubleMatrixHelpers_ac7abb3c0163ba84dbf12eb5a0240a59c}} 
\index{oomph\+::\+C\+R\+Double\+Matrix\+Helpers@{oomph\+::\+C\+R\+Double\+Matrix\+Helpers}!gershgorin\+\_\+eigenvalue\+\_\+estimate@{gershgorin\+\_\+eigenvalue\+\_\+estimate}}
\index{gershgorin\+\_\+eigenvalue\+\_\+estimate@{gershgorin\+\_\+eigenvalue\+\_\+estimate}!oomph\+::\+C\+R\+Double\+Matrix\+Helpers@{oomph\+::\+C\+R\+Double\+Matrix\+Helpers}}
\subsubsection{\texorpdfstring{gershgorin\+\_\+eigenvalue\+\_\+estimate()}{gershgorin\_eigenvalue\_estimate()}}
{\footnotesize\ttfamily double oomph\+::\+C\+R\+Double\+Matrix\+Helpers\+::gershgorin\+\_\+eigenvalue\+\_\+estimate (\begin{DoxyParamCaption}\item[{const \hyperlink{classoomph_1_1DenseMatrix}{Dense\+Matrix}$<$ \hyperlink{classoomph_1_1CRDoubleMatrix}{C\+R\+Double\+Matrix} $\ast$$>$ \&}]{matrix\+\_\+pt }\end{DoxyParamCaption})}



Calculates the largest Gershgorin disc whilst preserving the sign. Let A be an n by n matrix, with entries aij. For $ i \in \{ 1,...,n \} $ let $ R_i = \sum_{i\neq j} |a_{ij}| $ be the sum of the absolute values of the non-\/diagonal entries in the i-\/th row. Let $ D(a_{ii},R_i) $ be the closed disc centered at $ a_{ii} $ with radius $ R_i $, such a disc is called a Gershgorin disc. 

Calculates the largest Gershgorin disc whilst preserving the sign. Let A be an n by n matrix, with entries aij. For $ i \in \{ 1,...,n \} $ let $ R_i = \sum_{i\neq j}|a_{ij}| $ be the sum of the absolute values of the non-\/diagonal entries in the i-\/th row. Let $ D(a_{ii},R_i) $ be the closed disc centered at $ a_{ii} $ with radius $ R_i $, such a disc is called a Gershgorin disc.

~\newline
 We calculate $ |D(a_{ii},R_i)|_{max} $ and multiply by the sign of the diagonal entry.

~\newline
 The \hyperlink{classoomph_1_1DenseMatrix}{Dense\+Matrix} of C\+R\+Double\+Matrices are treated as if they are one large matrix. Therefore the dimensions of the sub matrices has to \char`\"{}make sense\char`\"{}, there is a paranoid check for this.

~\newline
 We calculate $ |D(a_{ii},R_i)|_{max} $and multiply by the sign of the diagonal entry.

~\newline
 The \hyperlink{classoomph_1_1DenseMatrix}{Dense\+Matrix} of C\+R\+Double\+Matrices are treated as if they are one large matrix. Therefore the dimensions of the sub matrices has to \char`\"{}make sense\char`\"{}, there is a paranoid check for this. 

Definition at line 3975 of file matrices.\+cc.



References oomph\+::\+Dense\+Matrix$<$ T $>$\+::ncol(), oomph\+::\+Dense\+Matrix$<$ T $>$\+::nrow(), oomph\+::\+C\+R\+Double\+Matrix\+::row\+\_\+start(), oomph\+::\+Sparse\+Matrix$<$ double, C\+C\+Matrix$<$ double $>$ $>$\+::value(), and oomph\+::\+C\+R\+Double\+Matrix\+::value().



Referenced by deep\+\_\+copy().

\mbox{\Hypertarget{namespaceoomph_1_1CRDoubleMatrixHelpers_ad81583a57fba80fee50d14afdf1c86e2}\label{namespaceoomph_1_1CRDoubleMatrixHelpers_ad81583a57fba80fee50d14afdf1c86e2}} 
\index{oomph\+::\+C\+R\+Double\+Matrix\+Helpers@{oomph\+::\+C\+R\+Double\+Matrix\+Helpers}!inf\+\_\+norm@{inf\+\_\+norm}}
\index{inf\+\_\+norm@{inf\+\_\+norm}!oomph\+::\+C\+R\+Double\+Matrix\+Helpers@{oomph\+::\+C\+R\+Double\+Matrix\+Helpers}}
\subsubsection{\texorpdfstring{inf\+\_\+norm()}{inf\_norm()}}
{\footnotesize\ttfamily double oomph\+::\+C\+R\+Double\+Matrix\+Helpers\+::inf\+\_\+norm (\begin{DoxyParamCaption}\item[{const \hyperlink{classoomph_1_1DenseMatrix}{Dense\+Matrix}$<$ \hyperlink{classoomph_1_1CRDoubleMatrix}{C\+R\+Double\+Matrix} $\ast$$>$ \&}]{matrix\+\_\+pt }\end{DoxyParamCaption})}



Compute infinity (maximum) norm of sub blocks as if it was one matrix. 

Calculates the infinity (maximum) norm of a Dense\+Martrix of C\+R\+Double\+Matrices as if it was one large matrix. This avoids creating a concatenation of the sub-\/blocks just to calculate the infinity norm. 

Definition at line 3708 of file matrices.\+cc.



References oomph\+::\+Dense\+Matrix$<$ T $>$\+::ncol(), oomph\+::\+Dense\+Matrix$<$ T $>$\+::nrow(), oomph\+::\+C\+R\+Double\+Matrix\+::row\+\_\+start(), oomph\+::\+Sparse\+Matrix$<$ double, C\+C\+Matrix$<$ double $>$ $>$\+::value(), and oomph\+::\+C\+R\+Double\+Matrix\+::value().



Referenced by oomph\+::\+C\+R\+Double\+Matrix\+::built(), deep\+\_\+copy(), oomph\+::\+Pseudo\+Elastic\+Preconditioner\+::setup(), and oomph\+::\+Lagrange\+Enforced\+Flow\+Preconditioner\+::setup().

